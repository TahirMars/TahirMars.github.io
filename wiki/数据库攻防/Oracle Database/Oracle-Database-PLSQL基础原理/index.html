<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>Oracle Database PL/SQL注入漏洞原理 | Tahir&#39;s Wiki</title>
    
    
        <meta name="keywords" content="Oracle Database">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="[TOC] by Tahir 1.PL&#x2F;SQL概述PL&#x2F;SQL是一种ORACLE数据库服务器的编程语言 继承了ADA（ 阿达·洛芙莱斯）第4代语言的特点 PL&#x2F;SQL是一个可移植、高效的事务处理语言：  支持SQL 支持面向对象编程 良好的性能 效率高 可移植 与Oracle集成 高度安全  PL&#x2F;SQL的编码和运行时系统是一项技术，而不是一个独立的产品。可以把这项技术想象成一个能够编译并运行PL">
<meta property="og:type" content="article">
<meta property="og:title" content="Oracle Database PL&#x2F;SQL注入漏洞原理">
<meta property="og:url" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Tahir&#39;s Wiki">
<meta property="og:description" content="[TOC] by Tahir 1.PL&#x2F;SQL概述PL&#x2F;SQL是一种ORACLE数据库服务器的编程语言 继承了ADA（ 阿达·洛芙莱斯）第4代语言的特点 PL&#x2F;SQL是一个可移植、高效的事务处理语言：  支持SQL 支持面向对象编程 良好的性能 效率高 可移植 与Oracle集成 高度安全  PL&#x2F;SQL的编码和运行时系统是一项技术，而不是一个独立的产品。可以把这项技术想象成一个能够编译并运行PL">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E5%BC%95%E6%93%8E.gif">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%9D%83%E9%99%90.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%83.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%832.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%833.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B61.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B62.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E6%8F%90%E6%9D%83%E6%88%90%E5%8A%9F.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B3%A8%E5%85%A5%E7%82%B9%E4%BE%8B%E5%AD%90.png">
<meta property="og:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E9%98%B2%E6%8A%A4%E7%94%A8%E6%88%B7%E5%88%A4%E6%96%AD.png">
<meta property="article:published_time" content="2021-07-03T03:05:40.000Z">
<meta property="article:modified_time" content="2021-07-03T03:11:31.227Z">
<meta property="article:author" content="Tahir">
<meta property="article:tag" content="Oracle Database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E5%BC%95%E6%93%8E.gif">
    

    
        <link rel="alternate" href="/atom.xml" title="Tahir&#39;s Wiki" type="application/atom+xml">
    

    
        <link rel="icon" href="/favicon.ico">
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Tahir&#39;s Wiki</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            威胁猎捕
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cobalt Strike
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/0-Cobalt%20Strike%E9%9B%B6%E5%9F%BA%E7%A1%80/">0-Cobalt Strike零基础</a></li>  <li class="file"><a href="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%AF%87/">1-Cobalt Strike基础上篇</a></li>  <li class="file"><a href="/wiki/%E5%A8%81%E8%83%81%E7%8C%8E%E6%8D%95/Cobalt%20Strike/1-Cobalt-Strike%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%AF%87/">1-Cobalt Strike基础中篇</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            数据库攻防
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Oracle Database
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/">Oracle Database简单概述</a></li>  <li class="file active"><a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">Oracle Database PL/SQL注入漏洞原理</a></li>  <li class="file"><a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/">Oracle Database 11g Wrap加密解密分析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SQL Server
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8A%E7%AF%87/">SQL Server数据库攻防详解上篇</a></li>  <li class="file"><a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2%E8%AF%A6%E8%A7%A3%E4%B8%8B%E7%AF%87/">SQL Server数据库攻防详解下篇</a></li>  <li class="file"><a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/SQL%20Server/SQL-Server%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/">SQL Server数据库安全加固</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/hello-world/">Hello World</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-数据库攻防/Oracle Database/Oracle-Database-PLSQL基础原理" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/">数据库攻防</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle-Database/">Oracle Database</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/Oracle-Database/" rel="tag">Oracle Database</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">
            <time datetime="2021-07-03T03:05:40.000Z" itemprop="datePublished">2021-07-03</time>
        </a>
    </div>


                        
                            <i class="fa fa-bar-chart"></i>
                            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span>    
                        
                        
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/TahirMars/Wiki-site/raw/writing/source/_posts/数据库攻防/Oracle Database/Oracle-Database-PLSQL基础原理.md"> Source </a>
                            </div>
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/TahirMars/Wiki-site/edit/writing/source/_posts/数据库攻防/Oracle Database/Oracle-Database-PLSQL基础原理.md"> Edit </a>
                            </div>
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/TahirMars/Wiki-site/commits/writing/source/_posts/数据库攻防/Oracle Database/Oracle-Database-PLSQL基础原理.md"> History </a>
                            </div>
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            Oracle Database PL/SQL注入漏洞原理
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-PL-SQL%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.PL&#x2F;SQL概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-PL-SQL-%E5%9D%97%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 PL&#x2F;SQL 块结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-PL-SQL-%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 PL&#x2F;SQL 变量和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E6%B8%B8%E6%A0%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E6%B8%B8%E6%A0%87FOR%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 游标FOR循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E6%B8%B8%E6%A0%87%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 游标变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.2.5 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-PL-SQL-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 PL&#x2F;SQL 控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E7%AE%80%E5%8D%95IF%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 简单IF结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-IF-ELSE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 IF-ELSE结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E5%A4%9A%E9%87%8DIF"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 多重IF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-CASE"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 CASE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E7%AE%80%E5%8D%95%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.3.5 简单循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-WHILE%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.6.</span> <span class="toc-text">1.3.6 WHILE循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-7-FOR%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.7.</span> <span class="toc-text">1.3.7 FOR循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-8-GOTO"><span class="toc-number">1.3.8.</span> <span class="toc-text">1.3.8 GOTO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-9-NULL"><span class="toc-number">1.3.9.</span> <span class="toc-text">1.3.9 NULL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-PL-SQL-%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 PL&#x2F;SQL 子程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E7%90%86%E8%A7%A3PL-SQL%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 理解PL&#x2F;SQL过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E7%90%86%E8%A7%A3PL-SQL%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 理解PL&#x2F;SQL函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%8C%85-Package"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 包-Package</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-PL-SQL%E5%8C%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.4.1 PL&#x2F;SQL包的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E7%90%86%E8%A7%A3%E5%8C%85%E4%BD%93"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.4.2 理解包体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%8C%85%E7%89%B9%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.4.3 包特性的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-PL-SQL-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.</span> <span class="toc-text">2.PL&#x2F;SQL 注入漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Oracle-%E6%9D%83%E9%99%90"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Oracle 权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-PL-SQL-%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 PL&#x2F;SQL 注入分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-PL-SQL-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 PL&#x2F;SQL 漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-PL-SQL-DBMS-SQL%E5%8C%85"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 PL&#x2F;SQL DBMS_SQL包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-DBMS-SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 DBMS_SQL执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-DBMS-SQL%E7%89%B9%E7%82%B9"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 DBMS_SQL特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 漏洞成因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-PL-SQL-%E6%B3%A8%E5%85%A5%E9%98%B2%E6%8A%A4%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 PL&#x2F;SQL 注入防护建议</span></a></li></ol></li></ol>
                </div>
            
        
        
            <p>[TOC]</p>
<p>by Tahir</p>
<h2 id="1-PL-SQL概述"><a href="#1-PL-SQL概述" class="headerlink" title="1.PL/SQL概述"></a>1.PL/SQL概述</h2><p>PL/SQL是一种ORACLE数据库服务器的编程语言</p>
<p>继承了ADA（ 阿达·洛芙莱斯）第4代语言的特点</p>
<p>PL/SQL是一个可移植、高效的事务处理语言：</p>
<ol>
<li>支持SQL</li>
<li>支持面向对象编程</li>
<li>良好的性能</li>
<li>效率高</li>
<li>可移植</li>
<li>与Oracle集成</li>
<li>高度安全</li>
</ol>
<p>PL/SQL的编码和运行时系统是一项技术，而不是一个独立的产品。可以把这项技术想象成一个能够编译并运行PL/SQL块和子程序的引擎。这个引擎可以安装在Oracle服务器上或安装在Oracle Forms，Oracle Reports这样的开发工具中。所以，PL/SQL可以在两种环境中存在：</p>
<ol>
<li>Oracle数据库服务器</li>
<li>Oracle开发工具</li>
</ol>
<p>这两种环境是独立的。PL/SQL虽被绑定到Oracle服务器上，但在某些工具中是无法使用的。在这两种环境下，PL/SQL引擎都能接受有效的PL/SQL块或子程序。下图是PL/SQL引擎处理匿名块的过程，引擎会处理过程化语句，而把SQL语句发送给Oracle服务器端的SQL语句执行程序(SQL Statement Executor)来处理。</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E5%BC%95%E6%93%8E.gif"></p>
<h3 id="1-1-PL-SQL-块结构"><a href="#1-1-PL-SQL-块结构" class="headerlink" title="1.1 PL/SQL 块结构"></a>1.1 PL/SQL 块结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[DECLARE]</span><br><span class="line">	declaration_statements</span><br><span class="line">BEGIN</span><br><span class="line">	executable_statements</span><br><span class="line"></span><br><span class="line">[EXCEPTION]</span><br><span class="line">	exception_handing_statements</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="1-2-PL-SQL-变量和类型"><a href="#1-2-PL-SQL-变量和类型" class="headerlink" title="1.2 PL/SQL 变量和类型"></a>1.2 PL/SQL 变量和类型</h3><h4 id="1-2-1-变量声明"><a href="#1-2-1-变量声明" class="headerlink" title="1.2.1 变量声明"></a>1.2.1 变量声明</h4><p>语法：variable_name [CONSTANT] type [NOT NULL] [:=value];</p>
<p>　　variable_name: 用于定义变量名，变量名的命名要符合标识符命名规范。</p>
<p>　　type: 变量需要使用的数据类型，可以使用所有SQL类型或PL/SQL类型。用方括号 [] 括起来的是可选部分。</p>
<p>　　CONSTANT: 表示声明为一个常量，常量在定义时需要指定初始值，一旦定义其值，不能再被改变。</p>
<p>　　NOT NULL: 用于约束变量的值不能为空。</p>
<p>　　:=value: 用于为变量赋初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_empname VARCHAR2(20);     --定义员工名称变量</span><br><span class="line">　　v_deptname VARCHAR2(20);    --定义部门名称变量</span><br><span class="line">　　v_hiredate DATE NOT NULL := SYSDATE;  --定义入职日期变量</span><br><span class="line">　　v_empno INT NOT NULL DEFAULT 1111;  --变量员工编码变量</span><br><span class="line">BEGIN</span><br><span class="line">　　NULL;   --不执行任何代码</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>​        注：   :=和DEFAULT是可以互换使用的，都用来为变量赋初始值。一旦出现了NOT NULL关键字，后面必须具有赋初始值的语句。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>子类</th>
<th>说   明</th>
<th>范  围</th>
<th>ORACLE限制</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>CharacterStringRowidNchar</td>
<td>定长字符串 民族语言字符集</td>
<td>0à32767可选,确省=1</td>
<td>2000</td>
</tr>
<tr>
<td>VARCHAR2</td>
<td>Varchar, StringNVARCHAR2</td>
<td>可变字符串民族语言字符集</td>
<td>0à327674000</td>
<td>4000</td>
</tr>
<tr>
<td>BINARY_INTEGER</td>
<td></td>
<td>带符号整数,为整数计算优化性能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NUMBER(p,s)</td>
<td>Dec Double precisionIntegerIntNumericRealSmall int</td>
<td>小数, NUMBER 的子类型高精度实数整数, NUMBER 的子类型整数, NUMBER 的子类型与NUMBER等价与NUMBER等价整数, 比 integer 小</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LONG</td>
<td></td>
<td>变长字符串</td>
<td>0-&gt;2147483647</td>
<td>32,767字节</td>
</tr>
<tr>
<td>DATE</td>
<td></td>
<td>日期型</td>
<td>公元前4712年1月1日至公元后4712年12月31日</td>
<td></td>
</tr>
<tr>
<td>BOOLEAN</td>
<td></td>
<td>布尔型</td>
<td>TRUE, FALSE,NULL</td>
<td>不使用</td>
</tr>
<tr>
<td>ROWID</td>
<td></td>
<td>存放数据库行号</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UROWID</td>
<td></td>
<td>通用行标识符，字符类型</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>　如果变量在声明时没有指定初始值，默认情况下，变量被初始化为NULL值。如果未给变量赋值，就直接使用变量，将会产生意想不到的结果。</p>
<p>　　根据变量的不同类型，可以为变量直接赋常量值，也可以使用表达式来计算变量的值。</p>
<p>　　下面的代码根据薪资和加薪比例来计算员工的结果薪资值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_salary NUMBER(7,2);</span><br><span class="line">　　v_rate NUMBER(7,2) :=0.12;</span><br><span class="line">　　v_base_salary NUMBER(7,2) :=1200;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"> 　v_salary := v_base_salary*(1+v_rate); --使用表达式为变量赋值</span><br><span class="line">　　DBMS_OUTPUT.put_line(&#x27;员工的薪资值为：&#x27;||v_salary);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在为PL/SQL变量赋值时，需要注意变量的类型。下面列出了常用的变量类型的赋值方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">　　v_string VARCHAR2(200);</span><br><span class="line">　　v_hire_date DATE;</span><br><span class="line">　　v_bool BOOLEAN;  --PL/SQL布尔类型</span><br><span class="line">BEGIN</span><br><span class="line">　　v_bool:=True;  --为布尔类型赋值</span><br><span class="line">　　v_hire_date:=to_date(&#x27;2019-04-28&#x27;,&#x27;yyyy-mm-dd&#x27;); --使用函数为日期赋值</span><br><span class="line">　　v_hire_date:=SYSDATE;  --使用日期函数赋值</span><br><span class="line">　　v_hire_date:=date&#x27;2019-04-28&#x27;;  --直接赋静态日期值</span><br><span class="line">　　v_string:=&#x27;this is a string&#x27;;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-2-游标"><a href="#1-2-2-游标" class="headerlink" title="1.2.2 游标"></a>1.2.2 游标</h4><p>Oracle使用工作区(work area)来执行SQL语句，并保存处理信息。PL/SQL可以让我们使用游标来为工作区命名，并访问存储的信息。游标的类型有两种：隐式和显式。PL/SQL会为所有的SQL数据操作声明一个隐式的游标，包括只返回一条记录的查询操作。对于返回多条记录的查询，我们可以显式地声明一个游标来处理每一条记录。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT empno, ename, job</span><br><span class="line">   FROM emp</span><br><span class="line">   WHERE deptno = 20;</span><br></pre></td></tr></table></figure>

<p>由多行查询返回的行集合称为结果集(result set)。它的大小就是满足我们查询条件的行的个数。如下图所示，显式游标”指向”当前行的记录，这可以让我们的程序每次处理一条记录。</p>
<p>多行查询处理有些像文件处理。例如，一个COBOL程序打开一个文件，处理记录，然后关闭文件。同样，一个PL/SQL程序打开一个游标，处理查询出来的行，然后关闭游标。就像文件指针能标记打开文件中的当前位置一样，游标能标记出结构集的当前位置。</p>
<p>我们可以使用OPEN，FETCH和CLOSE语句来控制游标，OPEN用于打开游标并使游标指向结果集的第一行，FETCH会检索当前行的信息并把游标指移向下一行，当最后一行也被处理完后，CLOSE就会关闭游标。</p>
<h4 id="1-2-3-游标FOR循环"><a href="#1-2-3-游标FOR循环" class="headerlink" title="1.2.3 游标FOR循环"></a>1.2.3 游标FOR循环</h4><p>在大多需要使用显式游标的情况下，我们都可以用一个简单的游标FOR循环来代替OPEN，FETCH和CLOSE语句。首先，游标FOR循环会隐式地声明一个代表当前行的循环索引(loop index)变量。下一步，它会打开游标，反复从结果集中取得数据并放到循环索引的各个域(field)中。当所有行都被处理过以后，它就会关闭游标。下面的例子中，游标FOR循环隐式地声明了一个emp_rec记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT ename, sal, hiredate, deptno</span><br><span class="line">   FROM emp;</span><br><span class="line"> ...</span><br><span class="line">BEGIN</span><br><span class="line"> FOR emp_rec IN c1 LOOP</span><br><span class="line">  ...</span><br><span class="line">  salary_total  := salary_total + emp_rec.sal;</span><br><span class="line"> END LOOP;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>为了使用每一个查询到的行中的每一个字段，我们可以使用点标志(dot notation)，它的作用就像一个域选择器。</p>
<h4 id="1-2-4-游标变量"><a href="#1-2-4-游标变量" class="headerlink" title="1.2.4 游标变量"></a>1.2.4 游标变量</h4><p>游标变量的使用方式和游标类似，但更加灵活，因为它不绑定于某个特定的查询，所以可用于打开任何返回类型相兼容的查询语句。游标变量是真正的PL/SQL变量，我们可以为它赋值，把它传递给子程序。如下例，我们把游标变量作为存储过程open_cv的一个参数传进去，程序执行时，可以根据choice值的不同，灵活地打开不同的查询内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE open_cv(generic_cv IN OUT genericcurtyp, choice NUMBER) IS</span><br><span class="line">BEGIN</span><br><span class="line"> IF choice = 1 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM emp;</span><br><span class="line"> ELSIF choice = 2 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM dept;</span><br><span class="line"> ELSIF choice = 3 THEN</span><br><span class="line">  OPEN generic_cv FOR</span><br><span class="line">   SELECT *</span><br><span class="line">    FROM salgrade;</span><br><span class="line"> END IF;</span><br><span class="line"> ...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-5-属性"><a href="#1-2-5-属性" class="headerlink" title="1.2.5 属性"></a>1.2.5 属性</h4><p>PL/SQL的变量和游标都有着让我们能够直接引用它们各自的数据类型或结构的属性。数据库字段和表也有类似的属性。”%”是一个属性的指示符。</p>
<ul>
<li>%TYPE</li>
</ul>
<p>%TYPE可以提供一个变量或数据库字段的数据类型，这在声明存放数据库值的变量时是非常有用的。假设我们要声明一个存放表books中的字段my_title的字段的变量时，就可以这样使用%TYPE属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_title books.title%TYPE;</span><br></pre></td></tr></table></figure>

<p>这样声明my_title有两个优点，第一，我们不必知道title具体类型；第二，如果我们改变了数据库中对该字段的数据类型定义的话，my_title的数据类型会在运行时做出相应的改变，并不需要手动地进行维护。</p>
<ul>
<li>%ROWTYPE</li>
</ul>
<p>在PL/SQL中，记录用于将逻辑相关数据组织起来。一个记录是由许多相关域的组合。%ROWTYPE属性返回一个记录类型，其数据类型和数据表的数据结构相一致。这样的记录类型可以完全保存从数据表中查询(SELECT)或从游标/游标变量取出(FETCH)的行记录。</p>
<p>行中的字段和记录中的域对应的名称和数据类型都完全一致。下面的例子中，我们声明一个dept_rec的记录。它的域名称和数据类型与表dept中的字段名称和数据类型就完全一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  dept_rec  dept%ROWTYPE;  -- declare record variable</span><br></pre></td></tr></table></figure>

<p>我们可以使用”.”来引用记录中的域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_deptno := dept_rec.deptno;</span><br></pre></td></tr></table></figure>

<p>假设我们声明了一个用于检索雇员的名字、工资、雇用日期和职称的游标，我们就可以使用%ROWTYPE来声明一个类型相同的记录，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> CURSOR c1 IS</span><br><span class="line">  SELECT ename, sal, hiredate, job</span><br><span class="line">   FROM emp;</span><br><span class="line"></span><br><span class="line"> emp_rec  c1%ROWTYPE;  -- declare record variable that represents</span><br><span class="line">             -- a row fetched from the emp table</span><br></pre></td></tr></table></figure>

<p>当我们执行语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH c1 INTO emp_rec;</span><br></pre></td></tr></table></figure>

<p>表emp中ename字段的值就会赋给emp_rec的ename域，sal字段值赋给sal域，依此类推。</p>
<h3 id="1-3-PL-SQL-控制语句"><a href="#1-3-PL-SQL-控制语句" class="headerlink" title="1.3 PL/SQL 控制语句"></a>1.3 PL/SQL 控制语句</h3><h4 id="1-3-1-简单IF结构"><a href="#1-3-1-简单IF结构" class="headerlink" title="1.3.1 简单IF结构"></a>1.3.1 简单IF结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">    满足条件时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-IF-ELSE结构"><a href="#1-3-2-IF-ELSE结构" class="headerlink" title="1.3.2 IF-ELSE结构"></a>1.3.2 IF-ELSE结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">    满足条件时执行的语句</span><br><span class="line">ELSE</span><br><span class="line">    不满足条件时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-多重IF"><a href="#1-3-3-多重IF" class="headerlink" title="1.3.3 多重IF"></a>1.3.3 多重IF</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;布尔表达式1&gt; THEN</span><br><span class="line">    满足条件1时执行的语句</span><br><span class="line">ELSIF &lt;布尔表达式2&gt; THEN</span><br><span class="line">    满足条件2时执行的语句</span><br><span class="line">ELSIF &lt;布尔表达式3&gt; THEN</span><br><span class="line">    满足条件3时执行的语句</span><br><span class="line">ELSE</span><br><span class="line">    满足条件1、2、3均不满足时执行的语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<p>注意：ELSIF不能写成ELSEIF</p>
<h4 id="1-3-4-CASE"><a href="#1-3-4-CASE" class="headerlink" title="1.3.4 CASE"></a>1.3.4 CASE</h4><p>语法一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CASE 条件表达式</span><br><span class="line">    WHEN 条件表达式结果1 THEN </span><br><span class="line">        语句1</span><br><span class="line">    WHEN 条件表达式结果2 THEN</span><br><span class="line">        语句2</span><br><span class="line">    ......</span><br><span class="line">    WHEN 条件表达式结果n THEN</span><br><span class="line">        语句n</span><br><span class="line">  [ELSE 条件表达式结果]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<p>语法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">  WHEN 条件表达式1 THEN</span><br><span class="line">     语句1</span><br><span class="line">  WHEN 条件表达式2 THEN</span><br><span class="line">     语句2</span><br><span class="line">  ......</span><br><span class="line">  WHEN 条件表达式n THEN </span><br><span class="line">     语句n</span><br><span class="line">  [ELSE 语句]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-简单循环"><a href="#1-3-5-简单循环" class="headerlink" title="1.3.5 简单循环"></a>1.3.5 简单循环</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">    [EXIT WHEN &lt;条件语句&gt;]</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-6-WHILE循环"><a href="#1-3-6-WHILE循环" class="headerlink" title="1.3.6 WHILE循环"></a>1.3.6 WHILE循环</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE &lt;布尔表达式&gt; LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-7-FOR循环"><a href="#1-3-7-FOR循环" class="headerlink" title="1.3.7 FOR循环"></a>1.3.7 FOR循环</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;&lt;标签&gt;&gt;]</span><br><span class="line">FOR 循环计数器 IN [ REVERSE ] 下限 .. 上限 LOOP</span><br><span class="line">    循环体语句;</span><br><span class="line">END LOOP [&lt;&lt;标签&gt;&gt;];</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>使用关键字REVERSE，循环变量自动减1。跟在IN REVERSE后面的数字应是从小到大的顺序，而且必须是整数，不能是变量或表达式。</p>
<h4 id="1-3-8-GOTO"><a href="#1-3-8-GOTO" class="headerlink" title="1.3.8 GOTO"></a>1.3.8 GOTO</h4><p>GOTO语句用于跳转到指定&lt;&lt;标号&gt;&gt;去执行语句，是无条件跳转到指定的标号去的意思。</p>
<p>注意：标号是用&lt;&lt;　&gt;&gt;括起来的标识符。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOTO label;</span><br></pre></td></tr></table></figure>

<p>GOTO语句缺点是会增加程序的复杂性，降低可读性，所以Oracle建议不要使用。</p>
<h4 id="1-3-9-NULL"><a href="#1-3-9-NULL" class="headerlink" title="1.3.9 NULL"></a>1.3.9 NULL</h4><p>空语句，执行没有任何实际效果，可以使某些语句变得有意义，提高程序的可读性，保证其他语句结构的完整性和正确性，通常用于占位置。</p>
<h3 id="1-4-PL-SQL-子程序"><a href="#1-4-PL-SQL-子程序" class="headerlink" title="1.4 PL/SQL 子程序"></a>1.4 PL/SQL 子程序</h3><p>子程序就是能够接受参数并被其他程序所调用的命名PL/SQL块。PL/SQL子程序有两种类型，过程和函数。</p>
<p>一般地，过程用于执行一个操作，而函数用于计算一个结果值。</p>
<p>与未命名或匿名PL/SQL块一样，子程序也有声明部分，执行部分和一个可选的异常处理部分。声明部分包含类型、游标、常量、变量、异常和嵌套子程序的声明。这些内容都是本地的，在程序退出时会自动销毁。执行部分包含赋值语句、流程控制语句和Oracle的数据操作语句。异常处理部分包含异常处理程序。思考下面用于记入借方银行账户的debit_account过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE debit_account(acct_id INTEGER, amount REAL) IS</span><br><span class="line"> 	old_balance  REAL;</span><br><span class="line">	new_balance  REAL;</span><br><span class="line"> 	overdrawn   EXCEPTION;</span><br><span class="line">BEGIN</span><br><span class="line"> 	SELECT bal</span><br><span class="line">  		INTO old_balance</span><br><span class="line">  		FROM accts</span><br><span class="line">  	WHERE acct_no = acct_id;</span><br><span class="line">  	</span><br><span class="line">	new_balance  := old_balance - amount;</span><br><span class="line"></span><br><span class="line">     IF new_balance &lt; 0 THEN</span><br><span class="line">        RAISE overdrawn;</span><br><span class="line">     ELSE</span><br><span class="line">        UPDATE accts</span><br><span class="line">            SET bal = new_balance</span><br><span class="line">        WHERE acct_no = acct_id;</span><br><span class="line">     END IF;</span><br><span class="line">	EXCEPTION</span><br><span class="line"> 		WHEN overdrawn THEN</span><br><span class="line">  		...</span><br><span class="line">END debit_account;</span><br></pre></td></tr></table></figure>

<p>在被调用时，这个过程接受一个银行账号和借贷金额。它使用账号从accts表中查询账目结算信息。然后用借款金额计算新的账目结算。如果计算后的余额比零小，异常就会被抛出；否则，该账号相关信息就会被更新。</p>
<h4 id="1-4-1-理解PL-SQL过程"><a href="#1-4-1-理解PL-SQL过程" class="headerlink" title="1.4.1 理解PL/SQL过程"></a>1.4.1 理解PL/SQL过程</h4><p>过程是一个能执行某个特定操作的子程序。我们可以用下面的语法来编写过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[CREATE [OR REPLACE]] </span><br><span class="line">PROCEDURE procedure_name[(parameter[, parameter]...)] </span><br><span class="line">	 	[AUTHID &#123;DEFINER | CURRENT_USER&#125;] &#123;IS | AS&#125;  </span><br><span class="line">		[PRAGMA AUTONOMOUS_TRANSACTION;] </span><br><span class="line">	 	[local declarations] </span><br><span class="line">BEGIN  </span><br><span class="line">		executable statements </span><br><span class="line">[EXCEPTION  </span><br><span class="line">		exception handlers]</span><br><span class="line">END [name];</span><br></pre></td></tr></table></figure>

<p>parameter的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parameter_name [IN | OUT [NOCOPY] | IN OUT [NOCOPY]] datatype </span><br><span class="line">[&#123;:= | DEFAULT&#125; expression]</span><br></pre></td></tr></table></figure>

<p>CREATE子句能让我们创建保存在数据库中的独立过程。我们可以从SQLPlus中或是在使用动态SQL的程序中执行CREATE PROCEDURE语句。</p>
<p>AUTHID子句决定了存储过程是按所有者权限(默认)调用还是按当前用户权限执行，也能决定在没有限定修饰词的情况下，对所引用的对象是按所有者模式进行解析还是按当前用户模式进行解析。我们可以指定CURRENT_USER来覆盖掉程序的默认行为。</p>
<p>编译指示AUTONOMOUS_TRANSACTION会告诉PL/SQL编译器把过程标记为自治(独立)。自治事务能让我们把主事务挂起，执行SQL操作，提交或回滚自治事务，然后再恢复主事务。</p>
<p>我们不能对参数的数据类型进行约束，如下例中对acct_id的声明就是不合法的，因为它对CHAR类型进行了长度限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE reconcile (acct_id CHAR(5)) IS ... -- illegal</span><br></pre></td></tr></table></figure>

<p>但是，我们可以使用下面的方法间接的对字符的长度进行限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  </span><br><span class="line">	SUBTYPE Char5 IS CHAR(5);  </span><br><span class="line">	PROCEDURE reconcile (acct_id Char5) IS ...</span><br></pre></td></tr></table></figure>

<p>过程有两个部分，过程说明和过程体。说明部分由关键字PROCEDURE开头，以过程名或参数列表结尾。参数声明是可选的。没有参数的过程是不用使用圆括号的。</p>
<p>过程体由关键字IS(或AS)开头，并以END结尾，END后面可以跟上一个可选的过程名。过程体有三个部分：声明、执行和可选的异常处理。</p>
<p>声明部分包括本地声明，它处于IS和BEGIN之间。在匿名PL/SQL块使用的关键字DECLARE在这里不再需要。执行部分包括许多语句，它们被放到BEGIN和EXCEPTION(或END)之间，并且至少要有一条语句出现在过程的执行部分。NULL语句可以满足这个需求。异常处理部分包含异常处理程序，它被放在关键字EXCEPTION和END之间。</p>
<p>在下面的过程raise_salary中，我们会根据给定的金额来为雇员加薪：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE raise_salary(emp_id INTEGER, amount REAL) IS  </span><br><span class="line">	current_salary  REAL;  </span><br><span class="line">	salary_missing  EXCEPTION; </span><br><span class="line">BEGIN  </span><br><span class="line">	SELECT sal   </span><br><span class="line">		INTO current_salary   </span><br><span class="line">		FROM emp   </span><br><span class="line">	WHERE empno = emp_id;   </span><br><span class="line">	</span><br><span class="line">	IF current_salary IS NULL THEN   </span><br><span class="line">		RAISE salary_missing;  </span><br><span class="line">	ELSE   </span><br><span class="line">		UPDATE emp    </span><br><span class="line">        	SET sal = sal + amount    </span><br><span class="line">        WHERE empno = emp_id;  </span><br><span class="line">    END IF; </span><br><span class="line"></span><br><span class="line">EXCEPTION  </span><br><span class="line">	WHEN NO_DATA_FOUND THEN   </span><br><span class="line">		INSERT INTO emp_audit      </span><br><span class="line">			VALUES (emp_id, *&#x27;No such number&#x27;*);  </span><br><span class="line">		WHEN salary_missing THEN   </span><br><span class="line">			INSERT INTO emp_audit      </span><br><span class="line">				VALUES (emp_id, *&#x27;Salary is null&#x27;*); </span><br><span class="line">END raise_salary;</span><br></pre></td></tr></table></figure>

<p>在调用时，过程接受雇员编号和薪资调整金额，然后用雇员编号从emp表找出指定雇员的当前工资。如果雇员编号无法找到或是当前工资为空，异常就会被抛出，否则工资就会被更新。</p>
<p>过程可以作为一个PL/SQL语句来调用。例如，我们可以像下面这样调用raise_salary：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise_salary(emp_id, amount);</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-理解PL-SQL函数"><a href="#1-4-2-理解PL-SQL函数" class="headerlink" title="1.4.2 理解PL/SQL函数"></a>1.4.2 理解PL/SQL函数</h4><p>函数是一个能够计算结果值的子程序，函数除了有一个RETURN子句之外，其它结构跟过程类似。我们可以用下面的语法来编写(本地)函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[CREATE [OR REPLACE ] ]  </span><br><span class="line">	FUNCTION function_name [ ( parameter [ , parameter ]... ) ] RETURN datatype  </span><br><span class="line">	[ AUTHID &#123; DEFINER | CURRENT_USER &#125; ]  </span><br><span class="line">	[ PARALLEL_ENABLE  </span><br><span class="line">	[ &#123; [CLUSTER parameter BY (column_name [, column_name ]... ) ] |  </span><br><span class="line">	[ORDER parameter BY (column_name [ , column_name ]... ) ] &#125; ]  </span><br><span class="line">	[ ( PARTITION parameter BY  &#123; </span><br><span class="line">	[ &#123;RANGE | HASH &#125; (column_name [, column_name]...)] | ANY &#125;  </span><br><span class="line">	) ]  </span><br><span class="line">	]  </span><br><span class="line">	[DETERMINISTIC] [ PIPELINED [ USING implementation_type ] ]  </span><br><span class="line">	[ AGGREGATE [UPDATE VALUE] [WITH EXTERNAL CONTEXT]  </span><br><span class="line">	USING implementation_type ] &#123;IS | AS&#125;  </span><br><span class="line">	[ PRAGMA AUTONOMOUS_TRANSACTION; ]  </span><br><span class="line">	[ local declarations ] </span><br><span class="line">BEGIN  </span><br><span class="line">	executable statements </span><br><span class="line">[ EXCEPTION  </span><br><span class="line">	exception handlers ] </span><br><span class="line">END [ name ];</span><br></pre></td></tr></table></figure>

<p>函数的语法结构与过程类似，这里就不再重复。但有几个不同点还是需要注意的。</p>
<p>PARALLEL_ENABLE选项能声明一个在并发DML操作的从属会话(slave session)中被安全调用的存储函数。主(logon)会话的状态不会被从属会话所共享。每个从属会话都有它自己的状态，这是在会话开始时初始化的。函数的结果不应依赖于会话(静态)变量的状态。否则结果就可能随着会话而发生变化。</p>
<p>提示DETERMINISTIC能帮助优化程序避免冗余的函数调用。如果存储函数的调用跟前一次调用时所使用的参数相同，优化程序就直接选出前一次的计算结果值。函数结果不应该依赖于会话变量或模式对象的状态。否则结果会随着调用而发生变化。只有DETERMINISTIC函数才允许被函数索引或是参数query_rewrite_enabled为TRUE的实体化视图调用。</p>
<p>我们不能对参数或是函数返回值的类型添加约束，但可以像前面的过程那样使用间接的约束方法。</p>
<h3 id="1-5-包-Package"><a href="#1-5-包-Package" class="headerlink" title="1.5 包-Package"></a>1.5 包-Package</h3><p>PL/SQL可以让我们把逻辑相关的类型、变量、游标和子程序放在一个包内，这样更加清楚易理解。包通常有两部分组成：包说明部分和包体部分。包说明部分是应用程序的接口，它声明了类型、常量、变量、异常、游标和可以使用的子程序。包体用于实现包说明部分声明的子程序和游标。</p>
<p>下面的例子是把两个雇用相关的过程进行打包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS  -- package specification</span><br><span class="line">	PROCEDURE hire_employee(empno NUMBER, ename CHAR, ...);</span><br><span class="line"></span><br><span class="line"> 	PROCEDURE fire_employee(emp_id NUMBER);</span><br><span class="line">END emp_actions;</span><br><span class="line"></span><br><span class="line">CREATE PACKAGE BODY emp_actions AS  -- package body</span><br><span class="line"> 	PROCEDURE hire_employee(empno NUMBER, ename CHAR, ...) IS</span><br><span class="line"> BEGIN</span><br><span class="line">  	INSERT INTO emp</span><br><span class="line">    VALUES (empno, ename, ...);</span><br><span class="line"> END hire_employee;</span><br><span class="line"></span><br><span class="line"> PROCEDURE fire_employee(emp_id NUMBER) IS</span><br><span class="line"> BEGIN</span><br><span class="line">  	DELETE FROM emp</span><br><span class="line">     	WHERE empno = emp_id;</span><br><span class="line"> 	END fire_employee;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure>

<p>只有在包说明中声明的内容对应用程序是可见的，而包体中的内容是不可见，无法访问的。包被编译后会存放到数据库中，当我们首次调用包中的子程序时，整个包就会被加载到内存当中，所以，后续的调用不再涉及到磁盘的读取问题。因此，包可以提高效率改善性能。</p>
<h4 id="1-4-1-PL-SQL包的优点"><a href="#1-4-1-PL-SQL包的优点" class="headerlink" title="1.4.1 PL/SQL包的优点"></a>1.4.1 PL/SQL包的优点</h4><p>包提供了几个优点：模块化、方便应用程序设计、信息隐藏、附加功能和良好的性能。</p>
<ul>
<li>模块化</li>
</ul>
<p>包能让我们把逻辑相关的类型、常量、变量、异常和子程序等放到一个命名的PL/SQL模块中。每一个包都容易理解，包与包之间接口简单、清晰。这将有助于程序开发。</p>
<ul>
<li>轻松的程序设计</li>
</ul>
<p>设计应用程序时，我们首先要确定的是包说明中的接口信息。我们可以在没有包体的条件下编写并编译说明部分。然后引用该包的存储子程序也会被编译。在完成整个应用程序之前，我们是不需要完全实现包体部分的。</p>
<ul>
<li>信息隐藏</li>
</ul>
<p>有了包，我们就可以指定哪些类型、常量、变量、异常和子程序等是公有(可见和可访问)或私有(隐藏和不可访问)。例如，如果一个包里包含了四个子程序，其中三个是公有的一个是私有的。包就会隐藏私有子程序的实现，这样的话，如果实现内容发生改变，受到影响的只有包本身(不是我们的应用程序)。同样，对用户隐藏实现细节也能保证包的完整性。</p>
<ul>
<li>附加功能</li>
</ul>
<p>打包公有变量和游标在一个会话期会一直存在。所以，它们可以被当前环境下的所有子程序共享。并且它们允许我们跨事务来维护数据而不用把它保存在数据库中。</p>
<ul>
<li>良好的性能</li>
</ul>
<p>在我们首次调用打包子程序时，整个包就会被加载到内存中。所以，以后调用包中的相关子程序时，就不需要再次读取磁盘了。包能阻塞级联依赖，这样就能避免不必要的编译。例如，如果我们改变打包函数的实现，Oracle不需要重新编译调用子程序，因为它们并不依赖于包体。</p>
<h4 id="1-4-2-理解包体"><a href="#1-4-2-理解包体" class="headerlink" title="1.4.2 理解包体"></a>1.4.2 理解包体</h4><p>包体是对包说明的实现。也就是说包体中包含了包说明中声明的每一个游标和子程序的实现。一定要记住，包体内实现的内容只有在包说明中声明之后才能在包外引用。为了匹配包说明和包体，PL/SQL做了一个token-by-token的子程序头比较。所以，除了空白内容，头部内容必须完全一致。否则，PL/SQL就会抛出异常，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS</span><br><span class="line">	...</span><br><span class="line"> 	PROCEDURE calc_bonus(date_hired emp.hiredate%TYPE, ...);</span><br><span class="line">END emp_actions;</span><br><span class="line"></span><br><span class="line">CREATE PACKAGE BODY emp_actions AS</span><br><span class="line">	 ...</span><br><span class="line"> 	PROCEDURE calc_bonus(date_hired DATE, ...) IS</span><br><span class="line">	-- parameter declaration raises an exception because &#x27;DATE&#x27;*</span><br><span class="line"> 	-- does not match &#x27;emp.hiredate%TYPE&#x27; word for word*</span><br><span class="line">	BEGIN </span><br><span class="line">		... </span><br><span class="line">	END;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-包特性的例子"><a href="#1-4-3-包特性的例子" class="headerlink" title="1.4.3 包特性的例子"></a>1.4.3 包特性的例子</h4><p>下面是一个名为emp_actions的包。包说明声明了类型、游标、异常和子程序：</p>
<ol>
<li>类型EmpRecTyp和DeptRecTyp</li>
<li>游标desc_salary</li>
<li>异常invalid_salary</li>
<li>函数hire_employee和raise_salary</li>
<li>过程fire_empire和raise_salary</li>
</ol>
<p>在编写包之后，我们就可以开发引用它声明的类型，调用它的子程序、游标和异常的应用程序。创建包时，它就会被存放在Oracle数据库中供广泛地调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CREATE PACKAGE emp_actions AS</span><br><span class="line"> /* Declare externally visible types, cursor, exception. */</span><br><span class="line">	TYPE emprectyp IS RECORD(</span><br><span class="line">		emp_id  INT,</span><br><span class="line">  		salary  REAL</span><br><span class="line"> 	);</span><br><span class="line"></span><br><span class="line">	TYPE deptrectyp IS RECORD(</span><br><span class="line">		dept_id  INT,</span><br><span class="line">  		LOCATION  VARCHAR2</span><br><span class="line"> 	);</span><br><span class="line"></span><br><span class="line">	CURSOR desc_salary RETURN emprectyp;</span><br><span class="line"></span><br><span class="line">	invalid_salary  EXCEPTION;</span><br><span class="line"></span><br><span class="line"> 	/* Declare externally callable subprograms. */</span><br><span class="line">	FUNCTION hire_employee(</span><br><span class="line"> 		ename  VARCHAR2,</span><br><span class="line">  		job   VARCHAR2,</span><br><span class="line">  		mgr   REAL,</span><br><span class="line">  		sal   REAL,</span><br><span class="line">  		comm   REAL,</span><br><span class="line">  		deptno  REAL</span><br><span class="line">	 )</span><br><span class="line">  		RETURN INT;</span><br><span class="line"></span><br><span class="line">	PROCEDURE fire_employee(emp_id INT);</span><br><span class="line"></span><br><span class="line">	PROCEDURE raise_salary(emp_id INT, grade INT, amount REAL);</span><br><span class="line"></span><br><span class="line">	FUNCTION nth_highest_salary(n INT)</span><br><span class="line">		RETURN emprectyp;</span><br><span class="line">END emp_actions;</span><br></pre></td></tr></table></figure>



<h2 id="2-PL-SQL-注入漏洞"><a href="#2-PL-SQL-注入漏洞" class="headerlink" title="2.PL/SQL 注入漏洞"></a>2.PL/SQL 注入漏洞</h2><h3 id="2-1-Oracle-权限"><a href="#2-1-Oracle-权限" class="headerlink" title="2.1 Oracle 权限"></a>2.1 Oracle 权限</h3><p>在创建用户之前，可以登录系统管理员权限去创建一个用户（因为系统管理员有这个权限），下面是三种用户分类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys；   //系统管理员，拥有最高权限</span><br><span class="line">system；//本地管理员，次高权限</span><br><span class="line">scott； //普通用户，密码默认为tiger,默认未解锁</span><br></pre></td></tr></table></figure>

<p>在登陆的时候，可以选择下面三种登录方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba；  //登陆sys帐户</span><br><span class="line">sqlplus sys as sysdba；//同上</span><br><span class="line">sqlplus scott/tiger；  //登陆普通用户scott</span><br></pre></td></tr></table></figure>

<p>可以参考Oracle安全标签机制（OLS-BLP模型）</p>
<ol>
<li>定义者权限（默认情况下）</li>
</ol>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%9D%83%E9%99%90.png"></p>
<ol start="2">
<li>调用者权限（AUTHID RURRENT_USER）</li>
</ol>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90.png"></p>
<h3 id="2-2-PL-SQL-注入分类"><a href="#2-2-PL-SQL-注入分类" class="headerlink" title="2.2 PL/SQL 注入分类"></a>2.2 PL/SQL 注入分类</h3><table>
<thead>
<tr>
<th>用户权限</th>
<th>具体权限</th>
<th>漏洞数</th>
<th>影响广度</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>高</td>
<td>EXECUTE ANT PROCEDURE</td>
<td>多</td>
<td>大</td>
<td>降低用户权限、升级补丁、取消 public权限</td>
</tr>
<tr>
<td>高</td>
<td>CREATE ANY TRIGGER</td>
<td>少</td>
<td>大</td>
<td>降低用户权限、升级补丁、取消 public权限</td>
</tr>
<tr>
<td>高</td>
<td>CREATE ANY VIEW</td>
<td>少</td>
<td>大</td>
<td>降低用户权限、升级补丁、取消 public权限</td>
</tr>
<tr>
<td>中</td>
<td>CREATE functions</td>
<td>少</td>
<td>大</td>
<td>降低用户权限、升级补丁、取消 public权限</td>
</tr>
<tr>
<td>中</td>
<td>CREATE procedure</td>
<td>少</td>
<td>大</td>
<td>降低用户权限、升级补丁、取消 public权限</td>
</tr>
<tr>
<td>低</td>
<td>CREATE connection-注入匿名</td>
<td>少</td>
<td>大</td>
<td>升级补丁、取消 public权限</td>
</tr>
<tr>
<td>低</td>
<td>CREATE connection-snarf攻击</td>
<td>极少</td>
<td>大</td>
<td>注意关闭游标</td>
</tr>
<tr>
<td>低</td>
<td>CREATE connection-利用java</td>
<td>极少</td>
<td>小</td>
<td>删除Java、取消 public权限</td>
</tr>
</tbody></table>
<h3 id="2-3-PL-SQL-漏洞利用"><a href="#2-3-PL-SQL-漏洞利用" class="headerlink" title="2.3 PL/SQL 漏洞利用"></a>2.3 PL/SQL 漏洞利用</h3><p>定义者权限和调用者权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT DBA TO USER</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT PASSWORD FROM SYS.USER$ WHERE NAME=&#x27;SYS&#x27;;</span><br></pre></td></tr></table></figure>

<p>用调用者权限创建一个函数——————————-&gt;用带有public权限的SYS函数调用黑客创建的函数</p>
<p>标准SQL注入提权思路例子：</p>
<p>1.用低权限用户写一个调用者权限的函数get_dba，内容是低权限用户无法执行的提权操作，并设置运行时编译。</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%83.png"></p>
<p>2.将get_dba函数放入public，使得高权限用户可以防问；社会工程学诱骗，sys用户执行get_dba函数，成功提取。</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%832.png"></p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/PLSQL%E6%8F%90%E6%9D%833.png"></p>
<h3 id="2-4-PL-SQL-DBMS-SQL包"><a href="#2-4-PL-SQL-DBMS-SQL包" class="headerlink" title="2.4 PL/SQL DBMS_SQL包"></a>2.4 PL/SQL DBMS_SQL包</h3><h4 id="2-4-1-DBMS-SQL执行流程"><a href="#2-4-1-DBMS-SQL执行流程" class="headerlink" title="2.4.1 DBMS_SQL执行流程"></a>2.4.1 DBMS_SQL执行流程</h4><p>通常运用DBMS_SQL包一般分为如下几步：</p>
<ol>
<li><p>open cursor：打开cursor</p>
</li>
<li><p>parse cursor：解析你要执行的SQL语句，生成任务计划</p>
</li>
<li><p>bind variable：如果要执行的SQL语句中包含变量，在此就需要绑定变量</p>
</li>
<li><p>execute：执行SQL语句</p>
</li>
<li><p>close cursor：在执行后关闭此cursor.</p>
</li>
</ol>
<p>如果你还需要返回执行SQL的结果集，还需要使用define_column,define_array等方法，具体可以看如下流程图：</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h4 id="2-4-2-DBMS-SQL特点"><a href="#2-4-2-DBMS-SQL特点" class="headerlink" title="2.4.2 DBMS_SQL特点"></a>2.4.2 DBMS_SQL特点</h4><ul>
<li><p><strong>一定条件下可执行任意语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBMS_SQL_PARSE(C IN INTEGER, STATUMENT IN VARCHAR2, LANGUAGE_FLAG IN INTEGER) IS</span><br></pre></td></tr></table></figure></li>
<li><p><strong>包是PUBLIC属性，只要能连接到数据库就能调用</strong></p>
</li>
<li><p><strong>调用者权限</strong></p>
</li>
</ul>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E8%B0%83%E7%94%A8%E8%80%85%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E.png"></p>
<p>想办法绕过调用者权限</p>
<p>1.高权限用户sys，定义一个名为A的public属性的具有定义者权限的过程，并调用了DBMS_SQL.PARSE接口，此接口存在一个参数能传入一个动态字符串并执行sql。</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B61.png"></p>
<p>2.低权限soctt用户执行public属性的A过程，虽然报错但是执行成功。</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%AA%81%E7%A0%B4DBMS_SQL%E7%9A%84%E9%99%90%E5%88%B62.png"></p>
<p>3.提权成功。</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E6%8F%90%E6%9D%83%E6%88%90%E5%8A%9F.png"></p>
<h4 id="2-4-3-漏洞成因"><a href="#2-4-3-漏洞成因" class="headerlink" title="2.4.3 漏洞成因"></a>2.4.3 漏洞成因</h4><p>危险的定义者权限</p>
<p>危险的public执行权限</p>
<p>禁止执行任意SQL语句</p>
<p>加强用户的身份识别</p>
<p>例子：在9i中ctxsys是DBA账户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctxsys.driload.validate_stmt(&#x27;grant dba to public&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/DBMS_SQL%E6%B3%A8%E5%85%A5%E7%82%B9%E4%BE%8B%E5%AD%90.png"></p>
<p>10g后把这个包的创建者ctxsys权限从DBA中移除了</p>
<h3 id="2-5-PL-SQL-注入防护建议"><a href="#2-5-PL-SQL-注入防护建议" class="headerlink" title="2.5 PL/SQL 注入防护建议"></a>2.5 PL/SQL 注入防护建议</h3><p>DBMS_SQL.PARSE()最后调用ICD_PARSE，未传入了USERID</p>
<p>DBMS_SQL.PARSE_AS_USER()最后调用ICD_PARSE，传入了USERID</p>
<p><img src="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-PLSQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E9%98%B2%E6%8A%A4%E7%94%A8%E6%88%B7%E5%88%A4%E6%96%AD.png"></p>
<p>所以建议使用DBMS_SQL.PARSE_AS_USER()</p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database-11g-Wrap%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    Oracle Database 11g Wrap加密解密分析
                
            </div>
        </a>
    
    
        <a href="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E9%98%B2/Oracle%20Database/Oracle-Database%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">Oracle Database简单概述</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            Tahir &copy; 2021 
            <a rel="external nofollow noopener noreferrer" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            
                <br>
                <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span></span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span></span>
            
        </div>
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>